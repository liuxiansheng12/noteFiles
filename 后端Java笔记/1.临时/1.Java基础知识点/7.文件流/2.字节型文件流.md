##### 流的介绍
1. 流按照方向(功能)来区分，in(读取)	out(写入)
2. 操作的目标来区分
   1. 文件流  数组流  字符串流  数据流  对象流  网络流。。。。

##### 容器
1. 变量，只能存一份
2. 数组，存储好多个，数据类型统一
3. 集合，存储好多个，存储后个数还能改变，泛型---数据类型统一
4. 如上三个都是Java中的类型(对象-->内存)
   1. 都存储在内存中  程序执行完毕  虚拟机停止的时候  内存空间就回收啦
   2. 数据都是临时性存储的


5. 文件，存储好多信息
   1. 文件是存储在硬盘上的--->永久性保存
   2. 数据虽然是安全了
   3. 文件毕竟不在内存中，需要通过IO操作文件，JDBC



##### 创建一个字节型输入流（低级流）
1. 进行读文件
2. 通过构造方法 `FileInputStream`，创建一个字符型输入流
   1. 包   java.io
   2. 了解一下继承关系    InputStream类  字节型输入流的父类
3. 有两种方式可以创建出字符型输入流
   1. 调用一个带File类型的构造方法
      1. `File f = new File(路径);`	
	  2. `FileInputStream fi = new FileInputStream(f);`	
   2. 调用一个带String类型的构造方法
      2. `FileInputStream fi = new FileInputStream(路径);`	
4. 常用的方法
   1. `int code = fi.read();`，每次从流管道中读取一个字节，返回字节的code码
      1. 读英文还行，读中文只能读取一半
   2. `int count = fi.read( arr )`  每次从流管道中读取若干个字节，存入数组内，返回有效元素个数
      1. arr为 `byte[]` 类型的数组，比如: `byte[] arr = new byte[]{'a', 'b'}`
   3. `int count = fi.available();`， 返回流管道中还有多少缓存的字节数
   4. `fi.skip(long n)`，跳过几个字节，读取(使用上面的方法)
	  1. 可以配合多线程使用--->利用几个线程同时读取文件
	  2. 比如：10000字节，5个小人同时读取
	  3. 1-2000   2001-4000   4001-6000   6001-8000   8001-10000
5. 操作完成后，必须要关闭流
   1. `fi.close()`，将流管道关闭---必须要做，最好放在finally里，注意代码的健壮性，判断严谨
	



##### 创建一个字节型输出流（低级流）
1. 创建一个字节型输出流，把数据写进行文件中
2. 通过类 `FileOutputStream`，将数据写入文件中
   1. 包， java.io
   2. 继承OutputStream  所有字节型输出流的父类
3. 创建一个字节型输出流，两种方式
   1. 调用一个带File类型的构造方法
      1. `File f = new File(路径);`	
	  2. `FileOutputStream fo = new FileOutputStream(f);`	
   2. 调用一个带String类型的构造方法
      2. `FileOutputStream fo = new FileOutputStream(路径);`	
4. 常用方法
   1. `fo.write(int code);`，将传入的数字转换成对应的字节，写入文件中
   2. `fo.write(byte[])`，将数组中的全部字节写入文件，getByte()
   3. `fo.flush();`，将管道内的字节推入(刷新)文件，写入后(上一个方法)，该方法可以写也可以不写，通常写
   4. `fo.close();`，注意在finally中关闭，关闭流这是必须要做的事情



##### 复制文件的原理
1. 读多少个数据，写多少个数据，从一个文件中读取，写入另一个新的文件中
2. 为了提高效率，通常使用 `char[]`类型的数组，进行读写，通常定义长度为 `1024`。
3. 最后读取的时候，需要判断长度是否够 `1024`，如果不够，数组有空余，这样写文件的时候，写入的全是空格。与复制的不同
   1. 所以需要数组，进行去空
4. **字节型输入输出流，操作文本元素，有一个很大的问题**。
   1. 字节型输入输出流，操作的是字节，而中文是两个字节，这样就有可能出现读一半，写一半的现象
   2. 比如，读12个字节，刚好第十二个是一个中文，则中文的实际字节为 `12、13`
   3. 这样，就会造成读一半的问题，写的时候，也是写的一半，这样的话，中文展示就会出现问题
   4. **所以，后面引入了字符型输入输出流，但是只能操作文本文件，其他的用不了，用于处理中文的问题**
			















