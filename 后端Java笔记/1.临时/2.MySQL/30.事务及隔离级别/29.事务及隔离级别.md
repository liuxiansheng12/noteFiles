
#### 数据库操作的流程
1. 开启一个事务
   1. 每一次执行的一条sql语句之前
   2. mysql数据库都会默认的开启
		
2. 执行操作
   1. insert  update  delete
   2. select
   3. 可能不止一条语句
   
3. 事务的处理
   1. 提交/回滚/保存还原点
   2. mysql数据库会默认的执行提交事务





#### 事务其实就是操作数据库的过程
1. 正常情况下，通过指令操作表的数据，比如增删该查，mysql都会自定开启一个事务
2. **然后才是操作表(这里的操作，只是操作虚拟的表，相当于缓存)**，此时底层的数据库还没有变化
3. 当操作完成后，会立即进行提交(此时才真正的更改数据库)

4. 如果手动开启一个事务，在通过指令操作表的数据(增删改查)，操作的是缓存，底层的数据库并没有改变
   1. 如果是手动开启的事务，并不会自动进行提交，而是需要手动提交
5. 手动开启事物的指令: `begin;` 或者 `start transaction;`
6. 提交的指令：`commit;`
   1. 在提交之前，所有操作表的过程，操作的都是缓存
   2. 提交后，才会真正的对表进行修改，并且事务结束，结束后
   3. 如果没有手动开启，就会自动开启事务，自动开启的是可以进行自动提交（操作一次，自动提交一次）
7. 回滚的指令: `rollback;`
   1. 手动开启事务后，进行操作，无论操作多少下，进行什么操作，都是操作的缓存
   2. 如果，执行了回滚，则之前所有的操作，都将消失，数据库还是之前的状态
   3. 并且，执行回滚后，当前手动开启的事务也会结束
   4. 如果没有手动开启，就会自动开启事务，自动开启的是可以进行自动提交（操作一次，自动提交一次）
   5. 如果执行了提交（无论是手动的，还是自动的），都是不能进行回滚的。



#### 查看事务状态
1. 共有两个指令，可以查询状态
   1. 查询所有: `show variables like '%commit%';`
   2. 只查询`autocommit`: `show variables like 'autocommit';`
2. 如果 `autocommit` 为 `on`，表示会自动提交
3. 设置自动提交关闭: `set autocommit = off;`
		
		  



#### 事务的四大特性(ACID)
1. A:Atomicity---->原子性
   1. 一个事务中的所有操作是一个整体，不可再分
   2. 事务中的所有操作要么都成功，要么都失败
      1. 比如一次添加多个数据，如果有一个失败，其他的也添加不进行去
2. C:Consistency--->一致性
   1. **一个用户操作了数据，提交以后**，需要注意是提交后，如果手动开启的事务，需要手动提交
   2. 另一个用户看到的数据与之前用户看到的效果是一致
   3. **如果没有提交，两个用户在`隔离性`的作用下，可能获取的数据是不同的**

3. I:Isolation---->隔离性----->(事务隔离级别)，比较重要
   1. 指的是多个用户并发访问数据库时
   2. 一个用户操作数据库，另一个用户不能有所干扰
   3. 多个用户之间的数据事务操作要互相隔离


4. D:Durability--->持久性(保存到本地，就持久化了)
   1. 指的是一个用户操作数据的事务一旦被提交(缓存-->文件)
   2. 他对数据库底层真实的改变是永久性的，不可返回






#### 隔离级别针对的是，同时操作数据库的过程，与事务有关

1. 经过上面的事务说明，以及事务过程中发生的事情
2. 操作表，其实操作的是缓存，如果没有手动开启事务还好。操作完，会立即进行提交，可以看成直接操作数据库
3. **如果，是手动开启的事务**，操作的都是缓存数据库，真实的并没有发生变化，要想改变真实的数据库，需要进行手动提交
4. **如果此时，有另一个指令，也访问了数据库，就会出现一些问题**
5. 会带来数据的安全隐患
   1. **脏读**
      1. 一个人读到了另外一个人还没有提交的数据(手动设置事务，操作的是缓存，还没有提交)
	  2. 比如: A、B在操作同一张表格
	  3. A修改了数据，还没有提交，B读取到了(特殊的隔离级别下，才能读取到，其他的级别，获取的就是底层数据表的结构)
	  4. A不提交了，回滚回来，B刚刚读取到的那些数据就是无用的----这就是脏数据(更改级别，可以避免这种情况)
   2. **不可重复读**
	  1. A、B在操作同一个表格
	  2. A先读取了一些数据，读完之后B此时将数据做了修改/删除（已经提交）
	  3. A再按照之前的条件重新读一遍，与第一次读取的不一致，这就是重复度
	  4. 可以通过更改级别，避免这种情况
	     1. 在一个事务下(手动开启的事务)，只要事务还没有结束(没有手动提交或者回滚)，以后在获取数据，获取的就是第一次读取的
		 2. 哪怕另一个人，对数据库作为修改/删除（**只有修改和删除，其他操作还是有影响的**），哪怕是已经提交，也没有影响
		 3. 如果进行了提交(当前用户)，则下次在读，就是当前表格中的内容(修改后的)
		 4. 这个过程，被成为 **可重复读**，发生在同一个事务下。
	3. **幻读(虚读)**
	   1. A、B在操作同一个表格
	   2. A先读取了一些数据，读完之后B此时将数据做了新增
	   3. A再按照之前的条件重新读一遍，与第一次读取的不一致
	   
6. 具体的级别分类，以及可以解决的问题
   1. `Serializable` ，最高，可以避免所有出现的问题，性能很慢
   2. `Repeatable Read`，避免脏读，不可重复读，幻读有可能出现，但是几率比较小
   3. `Read Committed`，避免脏读
   4. `Read UnCommitted`，所有效果均无法保证，也就是这个级别可以读取到其他用户操作mysql的缓存中的内容

7. MySQL数据库提供默认隔离级别，`Repeatable Read`


8. 修改数据库中的隔离级别
   1. 通过指令: `set session transaction isolation level 级别;`
   2. 如果不放心可以查看：`select @@tx_isolation;`

9. **级别，作用于整个用户操作的过程，并不是作用于某个表，关闭后消失**








