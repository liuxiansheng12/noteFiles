<script src='/笔记/see/index.js'></script>
[toc]





#### 新增数据
- 属于DML阶段

- 新增数据的流程
  - 要先进入该表，所在的子数据库，才能往表中添加数据（或者使用xxx.表名）
  - 比如（具体指令）：`insert into test.表名 (列名,列名,列名) values(值,值,值);`
    - 如果，该列为非必填的，本次添加可以省略，即不向该列中添加数据
    - 如果是必填的，则必须要添加数据
    - 添加一次就是一条数据，如果没有某一列没有添加数据，则获取该条数据的时候，该列对应为空
  - 如果想要新增的记录是全部表格的列，可以省略表名后面的括号内容
    - 比如（具体指令）：`insert into test.表名 values(值,值,值);`
    - 但要求values后面值的值，个数及类型，都必须与表格中列的`顺序、类型、个数一致`，否则添加有误
  - 同一条insert语句新增多个记录(**一次添加多条数据，相当于多个insert连用的效果**)
    - 具体的操作指令(每个列都添加数据): `insert into 表名 values(值,值,值),(值,值,值),(值,值,值);`
    - 具体的操作指令(选择性添加(只有非必填的可以省略)): `insert into 表名 (列名,列名,列名) values(值,值,值),(值,值,值),(值,值,值);`

.
- 注意点：如果存放的是字符串，使用单引号，不能用双引号
  - 比如: `insert into test (max) values ('a')`
- 存放时间类型的数据，必须要遵循对应的格式
  - 比如data类型: 格式为 `xxxx-xx-xx`，所以存放数据的时候，必须是 `2020-10-30` 
    - 这种格式，获取的时候也是这种格式
  - 时间格式，可以使用字符串的方式存放，底层会自动转换，但是格式必须保持一致
    - 比如: `insert into text (time) values ('202-03-21')`；底层会自动转换成 `data` 类型




#### 修改数据
- 修改对应列，所有的数据(整个表这一列全部进行修改)
  - 修改一列：`update 表名 set 列名=值;`
  - 修改多列：`update 表名 set 列名=值,列名=值;`

- 根据条件，修改符合条件的数据（筛选，利用where关键字）
  - 修改多列：`update 表名 set 列名=值,列名=值 where 列名=值;`
  - 比如：`update 表名 set a=1,b=2 where c=3;`
    - 修改，列名为 `c`，对应值为 `3`的所有的数据（条）中的 `a` 和 `b` ，换成指定的数据





#### 删除数据
- 删除表中的所有数据
  - `delete from test.表名;`

- 根据条件删除某些符合条件的数据（筛选，利用where关键字）
  - 具体指令： `delete from 表名 where 列名 = 数据;`
  - 比如： `delete from test where c = 123;`
    - 删除列名为 `c`，对应值为 `123`的所有的数据

- 注意点
  - 表中要是没有id（主键），删除的时候可能报错，无法删除



#### 对某一列累加求和
- 注意：只能对 `数字列` 求和，如果是字符串，需要先转换成 数字

- 示范sql
   ```sql
   -- 数字
   select sum(列名) from 表名
   -- 字符串转换成数字
   select sum(cast (列名 as int)) from 表名
   ```



#### 查询一列或者多列的所有数据（多行数据）
- 进入表所在的子数据库：`use 工程名;`
   - 也可以不执行这一步，直接使用 `工程名.表名` 操作表

- 示范sql
   ```sql
   select 列名,列名,列名 from 表名
   
   select * from 表名
   ```
- 注意点：`select * from 表名`，这种方式查询没有上面的效率高，但是方便
  - 因为上面的方式直接指定了对应的列名，而这种方式还需要先去表中查看有那些字段
  - 所以影响了一定的效率，但是问题不大，但是尽量使用上面的方式





#### 条件筛选-简单筛选
- 示范sql
  ```sql
  select 列名,列名,列名 from 表名 where 列名 = 条件一;
  ```
- 比如
  ```sql
  select name,age from demo1 where name = '张三';
  ```
  - 查询name为张三的所有数据

- 多条件查询
  - and：且
  - or：或
  - 并且：and的优先级比or高
  - 比如
     ```sql
     select name,age from demo1 where name = '张三' and age = 32;
     ```
     - 查询name为张三 并且 age为32的所有数据
- 如果 or 需要在一块查，可以使用 ()，进行包裹
  - 比如
     ```sql
     select name,age from demo1 where name = '张三' and (age = 32 or age 24);
     ```
     - 查询 name=张三 并且 age=32或者age=24 的所有数据




#### 条件筛选-运用函数in（包含-or的简化）
- `in()`：满足查询子集中的某一个即可，
  - `in` 后面的 `()` 内，可以是常量固定值
  - 也可以是通过另一条sql语句查询出来的结果，但是只能是固定的一列（因为多条固定的一列，就相当于数组）

- 示范代码
  ```sql
  select name,age from test.demo1 where name in('王五', '测试1');
  select name,age from test.demo1 where name in( select name from demo2 );
  ```
  - 第一条就相当于：`select name,age from test.demo1 where name = '王五' or name = '测试1'`
    - 所以说：in 相当于 or 的简写



#### 条件筛选-运用函数any和some（运算符or的简化）
- any和some的用法相同，只是名称不同而已
- any和some后面的 `()` 内， 只允许写sql语句查询出内容，不能直接写固定的内容
  - 也是只能查固定的一列

- any和some需要和运算符进行配合使用
- 示范代码
  ```sql
  select * from demo1 where age > any( select age from demo2 )
  select * from demo1 where age < any( select age from demo2 )
  select * from demo1 where age = any( select age from demo2 )
  ```
  - 假设 `select age from demo2` 查出来的是 20、30
  - 则第一条sql的意思就：`select * from demo1 where age > 20 or age > 30`
  - 则第三条sql的意思就：`select * from demo1 where age = 20 or age = 30`
    - 会发现，这条sql，完全可以用 in 进行替换



#### 条件筛选-运用函数all（运算符and的简化）
- all后面的 `()` 内， 只允许写sql语句查询出内容，不能直接写固定的内容
  - 也是只能查固定的一列

- all需要和运算符进行配合使用
- 示范代码
  ```sql
  select * from demo1 where age > all( select age from demo2 )
  select * from demo1 where age < all( select age from demo2 )
  select * from demo1 where age = all( select age from demo2 )
  ```
  - 假设 `select age from demo2` 查出来的是 20、30
  - 则第一条sql的意思就：`select * from demo1 where age > 20 and age > 30`
  - 则第三条sql的意思就：`select * from demo1 where age = 20 and age = 30`
- 意思是所有的条件都要满足才可以






#### 条件筛选-取反not（获取排除符合条件的所有数据）
- 运用 not

- 比如
  ```sql
  select name,age from test.demo1 where not name = '王五';
  select name,age from test.demo1 where not (name = '王五' or age = 32);
  select name,age from test.demo1 where not name = '王五' or age = 32;
  select name,age from test.demo1 where not name in('王五', '测试1');
  ```
  - 第一条：获取所有 排除name为王五 的所有数据
    - 相当于：`select name,age from test.demo1 where name != '王五';`
  - 第二条：获取所有 排除name为王五或者age=32 的所有数据

- not多个条件，后面的条件需要用 () 进行包裹
  - 如果不进行包裹，则会按照顺序依旧进行判断（比如第四条），即
    - not name = '王五' 是一组
    - or age = 32 是一组


- 甚至可以利用函数，比如第四条

- 意思就是：某条数据满足某个条件，本来不加not，是要获取这些满足条件的数据的，但是加了 not，获取的就是那些被条件排除的数据



#### 条件筛选-not的优先级
- not的优先级最高，如果查询条件中有not，则先进行not处理


- 比如
  ```sql
  select * from demo where age = 20 and not name = '张三' or xing = 'nan';
  ```
  - 有 not，所以先 not，然后在处理 and，最后在处理or



#### 条件筛选-使用算术运算符
- 条件判断，就是使用比较运算符进行判断
  - 即： `>` `<` `>=` `<=` `=` `!=`
  - 比如
    ```sql
    select a,b from test where c = 123;
    select a,b from test where c >= 123;
    ```
  - 只要，`c` 符合 后面的条件，该条数据的 `a` 和 `b` 就会被处理(获取数据)

- 条件判断，也可以先使用算术运算符，先进行运算，然后在使用比较运算符进行判断
  - `+`、`-`、`*`、`/`
  - 使用运算完的结果进行比较，符合条件的数据才进行处理
    - 比如：
      ```sql
      select a,b from test where c + 5 = 123;
      ```
    - 只要，`c + 5` 符合 后面的条件，该条数据的 `a` 和 `b` 就会被处理(获取数据)




#### 条件筛选-逻辑运算介绍
- 可以按照 or 划分条件筛选（ `()`的不考虑 ），符合的就获取
- 比如: 
  ```sql
  select * from demo where (age = 30 or age = 46 or age = 40) and xing = 'zhong' or age = 24 and xing = 'nv' or age = 30 or age = 40 and xing = 'nan';
  ```
- 不考虑`（）`，and先进行处理，所以，`or` 共划分出了4个筛选条件，只要这四个有一个满足,该条数据就能被筛选出来
  - 第一个筛选条件： `(age = 30 or age = 46 or age = 40) and xing = 'zhong'`
    - or 先筛选完( `()`改变了筛选顺序，把or提高了 )，然后从筛选出的数据中，在进行 `and` 的筛选
  - 第二个筛选条件：`age = 24 and xing = 'nv'`，符合的也能筛选出
  - 第三个筛选条件：`age = 30'`，符合的也能筛选出
  - 第四个筛选条件：`age = 40 and xing = 'nan'`，符合的也能筛选出

.
- not，可以放在任意判断的前面，表示非，比如: 
  ```sql
  select * from demo where not xing = 'nan';
  select * from demo where not (age = 23 and xing = 'nan');
  ```
  - `not` 的优先级，比 `and` 和 `or` 都要高，所以要想对联合筛选取非，需要加上括号



#### 条件筛选-范围筛选（大于小于，between and）
- 范围筛选：比如 `30 ～ 50` 之间，除了借助 `>`、`<` 和 `and` 外，还可以使用 `between and`
- 比如：
  ```sql
  select * from demo where age between 30 and 50;
  ```
  - 需要注意：**取得是闭区间，相当于 `>=` 和 `<=`**




#### 条件筛选-数据库底层做的处理（效率优化）
1. 解析SQL（敲入的命令）
2. 从表格中全部数据都读取出来、放在数据库缓存
3. 将所有数据，做一个遍历循环，每一次拿到一个元素(一行记录)，进行条件判断
   1.  假设我们的表格有7条记录
   2. 如果只写一个where条件
   3. 执行7次循环就可以比较出来啦
   4. 如果有and连接不止一个条件
      1. 先按照第一个条件先筛选
	  2. 比如: 7次循环，5条满足 `> 95`
	  3. 把第一次筛选出的数据，在按照第二个条件再筛选
	  4. 5次循环，2条满足
   5. 如果有 or 连接，就从剩下的在筛选一次。
4. 如果以后在语句中使用了and
   - 尽量将条件苛刻的写在前面，提高执行效率
   - 条件苛刻的一次就把不符合的数据排除了，省的前面的条件宽松，一条数据要循环判断多遍，然后到达条件苛刻的才被干掉








#### 列计算得到新的列
- 多列数据通过计算合成一个新的列

- 比如
  - 可以使用 as 给计算列起一个别名
  ```sql
  select a, b+c from test;
  select a, b+c as d from test;
  ```
  - 最终获取的数据，共两列，一列是`a`，一列是`b列和c列`相加得到的值（每一条数据都进行计算）
  - 如果计算过程中，有一个没有数据，为 `NULL`（比如说 `b` = `NULL`），则计算完也为 `NULL`





#### 条件筛选-模糊查询(只适用与字符串)
- 借助于 `like`

.
- `%`的使用与含义
  - `%`：用来代替0-n个字符
  - 示范代码
    ```sql
    select * from demo where name like 'abc%';
    select * from demo where name like '%abc%';
    ```
    - 第一条Sql：以什么开头，后面随意
    - 第二条Sql：前面随意，中间固定（是什么），后面随意

.
- `_`的使用与含义
  - `_`：用来代替1个字符(有且只有一个)
  - 示范代码
    ```sql
    select * from demo where name like '_abc%';
    select * from demo where name like 'abc_';
    select * from demo where name like '%abc_%';
    select * from demo where name like '_%abc%'
    ```
    - 第一条Sql：前面有且只有一个(随意)，中间固定(是什么)，后面随意
    - 第二条Sql：前面固定(是什么)，后面有且只有一个(随意)
    - 第三条Sql：前面随意，中间固定(是什么)，后面最少有一个(随意)
    - 第四条Sql：前面最少有一个(随意)，中间固定(是什么)，后面(随意)
  - 还有很多组合情况

.
- 可以与逻辑运算符连用
  ```sql
  select * from demo where age = 20 and name like '%a%' or xing = 'nan';
  select * from demo where age = 20 and not name like '_a%' or xing = 'nan';
  ```
  - 第二条：有一个`not`, 由于not优先级高，所以先非，然后在`and`筛选一次，剩下的用`or`在筛选一次





#### 排序-升序
- 通过 `order by 列名 asc` 进行排序
- 对已经查出来的表中的列进行排序
  - 比如
    ```sql
    select name as ns from test.demo1 order by ns asc;
    ```
- 如果展示的列没有排序的列，则找那些没有展示的列进行排序
  - 比如
    ```sql
    select name as ns from test.demo1 order by age asc;
    ```
    - 没有展示 age，但是 from 查询出来的内容，其实有age这一列（只不过没有展示，但是依旧可以使用这一列进行排序）

.
- 带筛选条件的排序（排序要放在where的后面）
  - 比如
    ```sql
    select * from where age = 20 order by 列名 asc
    ```


#### 排序-降序
- 通过 `order by 列名 desc` 进行排序
- 对已经查出来的表中的列进行排序
  - 比如
    ```sql
    select name as ns from test.demo1 order by ns desc;
    ```
- 如果展示的列没有排序的列，则找那些没有展示的列进行排序
  - 比如
    ```sql
    select name as ns from test.demo1 order by age desc;
    ```
    - 没有展示 age，但是 from 查询出来的内容，其实有age这一列（只不过没有展示，但是依旧可以使用这一列进行排序）

.
- 带筛选条件的排序（排序要放在where的后面）
  - 比如
    ```sql
    select * from where age = 20 order by 列名 desc
    ```



#### 排序-多列排序
- 作用：排序过程中遇到了相同的数据，可以根据其他的列在进行排序
  - 比如：都叫张三，但是想让age大的排在前面，这样就需要使用多列排序了

- 示范代码
  ```sql
  select * from where age = 20 order by 列名 desc, 列名 asc, 列名 desc
  ```
  - by后面挨个拼就行了



#### 分页查询	
- 查询指令，`limit a, b;`
  - a为偏移量，b为要获取的数据量
  - 比如: `select * from demo limit 10, 6;`	
    - 表示从第十条数据开始获取，包括第十条，总共获取六条，如果不够六条，有几条获取几条

- 分页查询，必须放在Sql的最后
  - 查询结果已经固定，然后才在里面取出对应的数据，进行返回




#### 查询去重
- 通过 `distinct` 实现去重的效果，对已经查询出的数据进行去重
- 比如
  ```sql
  select distinct name from demo1;
  select distinct name, age from demo1;
  ```
  - 第一条是对name进行去重，并且只展示name列
  - 第二条是对name和age进行去重（两个相同才进行去重），并且只展示name 和 age列

- 注意：不能写成 `select age, distinct name  from demo1;`
  - 原因：看下面的比如（age 和 去重后的 name，数据量不一致）
  - **也就是说，distinct 无法实现展示多列，但是只根据一列进行去重**
  - 比如
    - name=张三,age=30、name=张三,age=40
    - name相同，就认为重复数据，两条去掉一条，但是查询结果还想展示 age，这样是实现不了的
      - 因为：age不同，如果去掉，可能会造成数据的丢失，所以sql不允许这样去重
      - 只能根据 name 和 age 共同去重





#### 分组查询
- 分组：按照某一列进行分组（相同的为一组），一组为一条数据
- 由于分完组，一组只展示成一行数据，但是这一组可能对应多条数据，这样要展示的内容就有要求了
  - **一种是分组条件**（分组条件，每组的所有数据的这一列都相同，所以展示成一列不存在数据丢失的问题）
    - 要展示其他的内容(列)就不行了，因为每组的多条数据，这个列可能不相同，但是分组只能展示一条，展示那个内容都不合适
      - 比如展示A，B就丢了、展示B，A就丢了
      - 要是真展示了，就造成了数据的丢失（不准确性）
    - **Sql查询，展示的内容，不能产生异议，否则报错**
      - 比如：展示A，有可能还有B结果，但是B展示不出来，这就造成了异议
  - **一种是分组函数**
    - 因为分组函数，就是一个函数运算，每组的多条数据运算完，一定是这个结果，所以不存在异议，结果是唯一的，所以可以展示出来
      - 不可能这次 1 + 1 运算完 = 2，下一次查询就变成 3 了

.
- 分组函数
  - count()
  - max()    
  - min()
  - avg()
  - sum()


- 示范代码
  ```sql
  select name from test.demo1 group by name;
  select name,age from test.demo1 group by name,age;
  select name,sum(age) from test.demo1 group by name;
  ```
  - 第一条：对name分组
  - 第二条：对name和age分组（两个相同的才认为是一组）
  - 第三条：对name分组，并且对每一组的age进行求和

- 分组的用法有很多，比如分组求和，以及下面介绍的行列转换
  



#### 分组与筛选配合使用
- 先筛选，后分组（把筛选好的数据，在进行分组）
  - 筛选条件没有要求，正常筛选
  - 示范sql
    ```sql
    select 分组条件 from demo where xing = 'nan' group by 分组条件;
    select 分组函数 from demo where xing = 'nan' group by 分组条件;
    select min(age) from demo where xing = 'nan' group by name;
    ```
 
- 先分组，后筛选（先分好组，在进行筛选）
  - 筛选条件，只能为分组条件或者运算函数。
  - 筛选不能使用 `where` ，原因就是 `where` 的优先级比分组高，放在后面使用会报错
  - **使用 `having` ，`having`关键字的使用与where类似，但是优先级比分组低**
  - 示范sql
    ```sql
    select age from demo group by age having age = 30;
    ```
- 先筛选，在分组，在筛选
- 先筛选，在分组，在筛选，在排序







#### 函数-使用条件判断
- 示范sql
  ```sql
  select name,min(if(age = 18, age, 0)) from test.demo1 group by name;
  ```
- 函数：每条数据都会传入，然后运算后得到最后的值。
  - 数据传入的时候：可以使用条件判断 `if(age = 18, age, 0)`
  - 意思是：当 age = 18 的时候，注入第二个参数（age），不满足注入的是0





#### 行列转换操作
- 其实利用的是分组功能，然后实现特殊的业务

- 比如下面一个表

  | xu   | num  | yue       |
  |------|-------|-----------|
  | A    |  100 | 一月份    |
  | B    | 1000 | 一月份    |
  | C    |   10 | 一月份    |
  | A    |  200 | 二月份    |
  | B    | 2000 | 二月份    |
  | C    |   20 | 二月份    |
  | A    |  300 | 三月份    |
  | B    | 3000 | 三月份    |
  | C    |   30 | 三月份    |

- 想要变成  
  - 展示三条数据，A、B、C各一条。一二三月份为列，展示成如下样子
    | 列名   | 一月份    | 二月份    | 三月份    |
    |--------|-----------|-----------|-----------|
    | A      |       100 |       200 |       300 |
    | B      |      1000 |      2000 |      3000 |
    | C      |        10 |        20 |        30 |

  - 分析：
    - 既然展示A、B、C三条数据，说明是对xu这一列进行分组查询
    - 分完组，就需要确定展示的列了
      - 由于一月只展示一月，所以把二三月过滤掉就可以了（条件判断），二三月展示同理

- 实现sql
  ```sql
  select
      xu as '列名',
      max(if(yue = '一月份', num, 0)) as '一月份', 
      max(if(yue = '二月份', num, 0)) as '二月份', 
      max(if(yue = '三月份', num, 0)) as '三月份'   
  from lan group by xu;
  ```






#### 多表联合查询-sql嵌套
- 首先sql嵌套：可以实现一个表的查询条件，由另一个表进行提供
  - 比如：另一个表提供的查询条件，只有一个值，可以直接配合where使用
    ```sql
    select * from demo1 where name = ( select name from demo2 where age = 20 );
    ```
    - 假设：`select name from demo2 where age = 20`查出来的 name为 张三
    - 则上面的sql，就相当于 `select * from demo1 where name = '张三'`
  - 比如：另一个表提供的查询条件，有多个值（一列），就需要借助函数了，比如（in）
    ```sql
    select * from demo1 where age in( select age from demo2 where name = '张三' );
    ```
    - 假设：`elect age from demo2 where name = '张三'`查出来的 age为 20、30
    - 则上面的sql，就相当于 `select * from demo1 where age in(20, 30)`

- 其次from查出来的内容，可以作为一个表，再次进行sql分析
  - 比如：
    ```sql
    select * from ( select * from 表名 ) abc where age > 20
    ```
    - `select * from 表名`，查询出的结果是一个表，然后在使用sql对该表进行进一步筛选
    - 需要注意的是，必须对表起一个别名，否则报错，这里为 `abc`(不用写as)




#### 多表联合查询-union和union all
- union 和 union all 查询出来的样式是一样的
- 使用示范代码
  ```sql
  select name,age from test.demo1 union select bj,bzr from test.demo2;
  select name,age from test.demo1 union all select bj,bzr from test.demo2;
  ```
  - 分析：union 和 union all 两侧都是一个完成的 select 查询语句
  - 作用：把两次查询出来的结果拼在一块，并且是上下拼接
    - 比如：select name,age from test.demo1 查询出来的结果如下
      | name | age |
      |------|-----|
      | 张三 |  20 |
      | 李四 |  32 |
    - 比如：select bj,bzr from test.demo2 查询出来的结果如下
      | bj | bzr |
      |------|-----|
      | 一班 |  呵呵 |
      | 二班 |  哈哈 |
    - 使用 union 和 union all 合并后的样子（上下合并）
      | name | age |
      |------|-----|
      | 张三 |  20 |
      | 李四 |  32 |
      | 一班 |  呵呵 |
      | 二班 |  哈哈 |
  - 所以：哪个 select 在前面，就使用哪个select对应的列名，后面的直接怼到下面
  - **由于是直接拼在下面，所以多个select展示的列个数需要相同，名字无所谓，反正以第一个为准**
    - 不能一个两列，一个三列。这样拼接的时候就对应不上，于是sql报错


.
- union和union all的区别
  - `union`合并后做去重复的处理，性能比较慢(每次都要进行比较，看看是否有重复，有就去掉)
    - 拼接后，如果两行或者多行数据完全相同，则后面的去掉，进行去重处理
  -  `union all` 将两个查询的字节直接做合并，不会进行去重，性能比较快





#### 多表联合查询-广义笛卡尔积概念
- 得到的是一个，横向拼接的表
  - 把两个表的列横行拼接在一起
  - 拼接的方式：
    - 第一个表的列，依次与第二个表的列拼接在一块
    - 然后每一列在依次与后面的列拼接在一块
  - 最终数据的量为：表一的数据量 * 表二的数据量 * 表三的数据量，如果还有表，以此类推

- 拼接示范（有三个表）
  - 表一
    | name   | age  | xingBie | banJi     |
    | ------ | -----| -------| ----------|
    | 张三   |   18 | 男      | 高二*二班     |
    | 李四   |   20 | 男      | 高二*二班     |
    | 王五  |   18 | 女      | 高一*一班     |
    | 马六  |   26 | 男      | 高一*一班     |
  - 表二
    | name          | banzhuren |
    | ------------ | --------- |
    | 高二*二班     | 测试1     |
    | 高一*一班     | 测试2   |

  - 表三
    | dds  |
    | -----|
    | abc  |
    | ddd  |
  - 联合查询拼接后的表（前面的依次与后面的进行拼接）
    | name   | age  | xingBie | banJi     | name    | banzhuren | dds  |
    | ------ | -----| -------| ----------| -----| -------| ----------|
    | 张三   |   18 | 男      | 高二*二班     |  高二*二班   | 测试1    |  abc    |
    | 张三   |   18 | 男      | 高二*二班     |  高二*二班   | 测试1    |  ddd    |
    | 张三   |   18 | 男      | 高二*二班     |  高一*一班     | 测试2    |  abc    |
    | 张三   |   18 | 男      | 高二*二班     |  高一*一班     | 测试2    |  ddd    |
    | 李四   |   20 | 男      | 高二*二班     |  高二*二班   | 测试1    |  abc    |
    | 李四   |   20 | 男      | 高二*二班     |  高二*二班   | 测试1    |  ddd    |
    | 李四   |   20 | 男      | 高二*二班     |  高一*一班     | 测试2    |  abc    |
    | 李四   |   20 | 男      | 高二*二班     |  高一*一班    | 测试2    |  ddd    |
    | 王五  |   18 | 女      | 高一*一班     |   高二*二班   | 测试1    |  abc    |
    | 王五  |   18 | 女      | 高一*一班     |   高二*二班   | 测试1    |  ddd    |
    | 王五  |   18 | 女      | 高一*一班     |   高一*一班     | 测试2    |  abc    |
    | 王五  |   18 | 女      | 高一*一班     |   高一*一班    | 测试2    |  ddd    |
    | 马六  |   26 | 男      | 高一*一班     |   高二*二班   | 测试1    |  abc    |
    | 马六  |   26 | 男      | 高一*一班     |  高二*二班   | 测试1    |  ddd    |
    | 马六  |   26 | 男      | 高一*一班     |     高一*一班     | 测试2    |  abc    |
    | 马六  |   26 | 男      | 高一*一班     |   高一*一班    | 测试2    |  ddd    |
  - 共有16条数据 4 * 2 * 2；
    

#### 多表联合查询-广义笛卡尔积实现
- 具体的拼接指令
  ```sql
  select * from 表1, 表2, 表3
  ```

- 从上面实例中可以看出，拼接后的表是非常庞大的，并且有些数据并没有关联关系，所以在查询的时候就不需要这些多余的数据，需要给它过滤掉（条件筛选，where的使用）
  - 实现示范
    ```sql
    select * from 表1, 表2, 表3 where 表1.banJi = 表二.name and 表3.dds = 'abc'
    ```
    - 经过上面查询where的限制，最终 表1.banJi != 表二.name 和 表3.dds != 'abc' 的数据都会被过滤掉，只保留符合条件的数据
    - 也就是上例中的 4 和 5 列必须相同，不同的去掉，最后一列必须是 abc 不是的去掉


- 如果两个表中有相同的列，在取值的时候，就需要带上表名了，否则sql不知道取那个就会报错，比如
  ```sql
  select demo1.name, demo1.age, demo2.bj from test.demo1, test.demo2;
  ```

- 条件必须都满足，才不会被过滤掉，其他的一概干掉。




#### 多表联合查询-内链接查询
- 查询结果与：广义笛卡尔积查询结果一样，所有条件都满足才会查询出来，不符合的全部过滤掉

- 示范
  ```sql
  select * from demo1 inner join demo2 on demo1.bj = demo2.bj inner join demo3 on demo2.bj = demo3.bj;
  ```
  - 假设，demo1、demo2、demo3的表结构是如下
    - demo1

      | id | name | bj | age |
      | -- | ---|  --- | --- | 
      | 32 | 张三 | 一班 | 23 | 
      | 33 | 李四 | 二班 | 26 | 
      | 34 | 王五 | 一班 | 29 | 
      | 35 | 马六 | 三班 | 33 | 
    - demo2

      | id | bj | bzr | age |
      | -- | -- | -- | --- |
      | 1 | 一班 | 李老师 | 38 |
      | 2 | 二班 | 张老师 | 42 |
      | 3 | 一班 | 王老师 | 28 |
    - demo3

      | id | bj | cs |
      | -- | -- | -- |
      | 1 | 一班 | c1 |
      | 2 | 三班 | c2 |
      | 3 | 八班 | c3 |
    - 查询后的表格展示

      | id | name | bj | age | id | bj | bzr | age | id | bj | cs |
      | -- | ---|  --- | --- | -- | -- | -- | --- | -- | -- | --- |
      | 32 | 张三 | 一班 | 23 | 1 | 一班 | 李老师 | 38 | 1 | 一班 | c1 |
      | 32 | 张三 | 一班 | 23 | 3 | 一班 | 王老师 | 28 | 1 | 一班 | c1 |
      | 34 | 王五 | 一班 | 29 | 1 | 一班 | 李老师 | 38 | 1 | 一班 | c1 |
      | 34 | 王五 | 一班 | 29 | 3 | 一班 | 王老师 | 28 | 1 | 一班 | c1 |
    - 分析：只有四条数据，两个条件都符合

- 联合查询，可以操作同一张表，如果操作同一张表，表必须起一个别名，否则会有冲突的问题







#### 多表联合查询-外链接查询
- 核心：以一个表为基准，根据条件匹配相同的数据
- 总结：基准表的数据必须全部显示出来，没有匹配到的数据，就全是 null
  - 先根据基础表条件，开始查询分析
- 上面两种多表联合查询比较常用（因为，大多数查询不需要null）

- 比如（简单使用）
  ```sql
  select * from 表一 left/right [outer] join 表二 on 条件
  select * from demo1 left [outer] join demo2 on demo1.bj = demo2.bj
  ```
  - left/right 的作用就是表示，以那个表为基准（左边的还是右边的）
  - outer 可以忽略
  - 第二条sql（实现）：使用的是left，所以以demo1为基础表
  - 假设，demo1、demo2的表结构是如下
    - demo1

      | id | name | bj | age |
      | -- | ---|  --- | --- | 
      | 32 | 张三 | 一班 | 23 | 
      | 33 | 李四 | 二班 | 26 | 
      | 34 | 王五 | 一班 | 29 | 
      | 35 | 马六 | 三班 | 33 | 
    - demo2

      | id | bj | bzr | age |
      | -- | -- | -- | --- |
      | 1 | 一班 | 李老师 | 38 |
      | 2 | 二班 | 张老师 | 42 |
      | 3 | 一班 | 王老师 | 28 |
    - 查询后的表格展示

      | id | name | bj | age | id | bj | bzr | age |
      | -- | ---|  --- | --- | -- | -- | -- | --- |
      | 32 | 张三 | 一班 | 23 | 1 | 一班 | 李老师 | 38 |
      | 32 | 张三 | 一班 | 23 | 3 | 一班 | 王老师 | 28 |
      | 33 | 李四 | 二班 | 26 | 2 | 二班 | 张老师 | 42 |
      | 34 | 王五 | 一班 | 29 | 1 | 一班 | 李老师 | 38 |
      | 34 | 王五 | 一班 | 29 | 3 | 一班 | 王老师 | 28 |
      | 35 | 马六 | 三班 | 33 | null | null | null | null |
    - 分析：demo1为基础，条件为 `demo1.bj = demo2.bj`
      - demo1第一条，与 demo2 的三条数据拼接，形成三条数据，但是只有两条符合条件，所以查出来两条
      - demo1第二条，与 demo2 的三条数据拼接，形成三条数据，但是只有一条符合条件，所以查出来一条
      - demo1第三条，与 demo2 的三条数据拼接，形成三条数据，但是只有两条符合条件，所以查出来两条
      - demo1第四条，与 demo2 的三条数据拼接，形成三条数据，但是没有一条符合条件，但是根据外连接查询的特点
        - 基础表数据，必须显示，所有后面没有对应的数据，就全是null

.
- 比如（复杂使用，三个表）
  ```sql
  select * from demo1 left join demo2 on demo1.bj = demo2.bj right join demo3 on demo1.bj = demo3.bj;
  ```
  - 假设，demo1、demo2、demo3的表结构是如下
    - demo1

      | id | name | bj | age |
      | -- | ---|  --- | --- | 
      | 32 | 张三 | 一班 | 23 | 
      | 33 | 李四 | 二班 | 26 | 
      | 34 | 王五 | 一班 | 29 | 
      | 35 | 马六 | 三班 | 33 | 
    - demo2

      | id | bj | bzr | age |
      | -- | -- | -- | --- |
      | 1 | 一班 | 李老师 | 38 |
      | 2 | 二班 | 张老师 | 42 |
      | 3 | 一班 | 王老师 | 28 |
    - demo3

      | id | bj | cs |
      | -- | -- | -- |
      | 1 | 一班 | c1 |
      | 2 | 三班 | c2 |
      | 3 | 八班 | c3 |
    - 查询后的表格展示

      | id | name | bj | age | id | bj | bzr | age | id | bj | cs |
      | -- | ---|  --- | --- | -- | -- | -- | --- | -- | -- | --- |
      | 32 | 张三 | 一班 | 23 | 1 | 一班 | 李老师 | 38 | 1 | 一班 | c1 |
      | 32 | 张三 | 一班 | 23 | 3 | 一班 | 王老师 | 28 | 1 | 一班 | c1 |
      | 34 | 王五 | 一班 | 29 | 1 | 一班 | 李老师 | 38 | 1 | 一班 | c1 |
      | 34 | 王五 | 一班 | 29 | 3 | 一班 | 王老师 | 28 | 1 | 一班 | c1 |
      | 35 | 马六 | 三班 | 33 | null | null | null | null | 2 | 三班 | c2 |
      | null | null | null | null | null | null | null | null | 3 | 八班 | c3 |
    - 分析：demo3为基础（最后是right），条件为 `demo1.bj = demo3.bj 和 demo1.bj = demo2.bj`
      - demo3第一条，根据基础表条件 demo1.bj = demo3.bj
        - 先找到 demo1 中有两条数据与之匹配，但是 demo1 又与 demo2 进行匹配，找到 demo2 中的两条数据
        - 所以最终，查出来的对应数据是 1 * 2 * 2;
      - demo3第二条，根据基础表条件 demo1.bj = demo3.bj
        - 先找到 demo1 中有一条数据与之匹配，但是 demo1 又与 demo2 进行匹配，找到 demo2 中的0条数据
        - 然后demo2的内容，就全为 null（没有匹配数据）
      - demo3第三条，根据基础表条件 demo1.bj = demo3.bj
        - 先找到 demo1 中有 0 条数据与之匹配，挂掉之后，其他的表不用看了，全是null（因为0条数据，其他表也没有对应数据）
- 分析：demo3为基础（最后是right），如果条件为 `demo2.bj = demo3.bj 和 demo1.bj = demo2.bj`，查询结果又不一样
  - demo3第一条，根据基础表条件 demo2.bj = demo3.bj
    - 先找到 demo2 中有两条数据与之匹配，但是 demo2 又与 demo1 进行匹配，找到 demo1 中的两条数据
    - 所以最终，查出来的对应数据是 1 * 2 * 2;
    - 这个没变
  - demo3第二条，根据基础表条件 demo2.bj = demo3.bj
    - 先找到 demo2 中有 0 条数据与之匹配，挂掉之后，其他的表不用看了，全是null（因为0条数据，其他表也没有对应数据）
    - 然后就全是 null，和上面的实例产生了区别
  - demo3第三条，根据基础表条件 demo2.bj = demo3.bj
    - 先找到 demo2 中有 0 条数据与之匹配，挂掉之后，其他的表不用看了，全是null（因为0条数据，其他表也没有对应数据）
- 上例总结（不是查询本质，只是分析查询结果）
  - 先根据基础表找条件，进行分析，有相关的数据，在找其他的表，没有相关的数据，就全是null了
  










#### 子账号-创建用户
- 指令为: `create user '用户名'@'IP' identified by '密码';`
  - `IP`，就是可以访问该用户的ip，如果写 `*` 则所有的都可以，本机通常设置成 `localhost`
- 比如: 
  ```sql
  create user 'zzt'@'localhost' identified by '123456';
  ```
  - 这样，就创建好了一个用户
  - 在连接数据库的时候，账号密码就可以使用 zzt-123456，进行登陆了



#### 子账号-给子账号设置权限
- 如果，没有设置权限，则新创建的用户的权限默认为是，`Usage`，即只允许登陆，不允许查询和设置，也就是啥都干不了
- 可以通过 `show grants for '用户名'@'IP';` 这条指令，查询某个用户的权限 

.
- 设置用户的权限
  - `grant 权限 on 数据库名.表 to '用户名'@'IP';`
    - `数据库名.表`，表示，某个数据库下的某个表，把 `设置的权限` 赋予 `指定的用户`
    - 比如： `all`，这个权限非常大，啥都能干(创建，查询，修改，添加，删除)，相当于 `root` 的权限
    -  `*` 表示所有数据库，或者所有表格
    - 比如
      ```sql
      grant all on *.* to 'zzt'@'localhost';
      flush privileges;
      ```
      - 这就相当于root的权限了，啥都能干
- 赋予权限之后最好做一个刷新，指令为 `flush privileges;`


#### 子账号-权限分类
1. 数据库/数据表/数据列权限：
	- `Create`：允许建立新的数据库或数据表
	- `Alter`：允许修改已存在的数据表(例如增加/删除列)
	- `Drop`：允许删除数据表或数据库
	- `Insert`：允许增加表的记录（新增数据）
	- `Delete`：允许删除表的记录（删除数据）
	- `Update`：允许修改表中已存在的记录（修改数据）
	- `Select`：允许显示/搜索表的记录（查询）
	- `References`：允许创建外键
	- `Index`：允许建立或删除索引
	- `Create View`：允许创建视图
	- `Create Routine`：允许创建存储过程和包
	- `Execute`：允许执行存储过程和包
	- `Trigger`：允许操作触发器
	- `Create User`：允许更改、创建、删除、重命名用户和收回所有权限


- 全局管理MySQL用户权限：
	- `Grant Option`：允许向其他用户授予或移除权限
	- `Show View`：允许执行SHOW CREATE VIEW语句
	- `Show Databases`：允许账户执行SHOW DATABASE语句来查看数据库
	- `Lock Table`：允许执行LOCK TABLES语句来锁定表
	- `File`：允许在MySQL服务器上读写文件
	- `Process`：允许显示或杀死属于其它用户的服务线程
	- `Reload`：允许重载访问控制表，刷新日志等
	- `ShutDown`：允许关闭MySQL服务

        
- 特别的权限：
	- `All`：允许做任何事(和root一样)
	- `Usage`：只允许登录，其它什么也不允许做



#### 子账号-回收子账号的权限
- 具体指令，`revoke 权限 on 数据库名.表名 from '用户名'@'IP';`
  - 其实，并不是真正的回收了，而是，又变成了`Usage`，啥都不能干，只能登陆
- 如果想要修改权限，只需要通过上面的方法，重新设置一个权限，就可以覆盖之前设置的权限。



#### 子账号-修改用户的密码
1. 具体的指令，`update user set authentication_string = password('123') where user = 'zzt';`
2. 其实，所有的用户信息，都存在一个 `mysql`数据库下的一个 `user` 表中，修改密码，就是修改这个表中，对应账号的密码数据
   1. 密码是 `authentication_string` 这一个列中存放的数据，账号名，是 `user` 这一个列中存放的数据
   2. 所以，上面修改密码的原理，就是，通过 `user = 'zzt'`，对应的`authentication_string`
   3. 修改他的值，就相当于修改了密码
   4. `authentication_string`，中存放的都是加密后的密码，所以需要借助一个password函数，对密码进行加密，然后才能存入
3. 并且修改密码的时候，需要进入到 mysql 这个数据库下，通过 `use mysql;` 进入
   1. 原因：修改密码，修改的是这个数据库下的 `user` 表格中的数据，所以需要进入这个数据库，才能操作这个表格
   2. **或者，通过 `mysql.user` 的方式，也能操作这个表，这样就可以，不用进入 mysql 的下面了**
4. **`mysql.user`，这个表中常用的字段**
   1. 这个表的字段量是非常大的，如果在查询的时候，都进行展示，是看不清的，所以通常只查看几个关键的字段
   2. 常用的有 `user列  host列  authentication_string列`
   3. 有的可能，还有 `password列`，这个列，存放的也是密码，但是在新版的数据库中，这个字段删除了


#### 子账号-删除用户
1. 具体指令: `drop user '用户名'@'IP';`
2. 比如: `drop user 'zzt'@'localhost';`







#### 设计范式
- 优缺点
  - 设计范式，可以处理表数据的冗余
  - 设计范式的优点是，修改删除数据方便
    - 一次修改，影响全局
  - 设计范式的缺点是，查询数据，浪费性能
    - 联合查询，浪费性能

.
- 设计范式的底层思想（共有数据的提取，然后依靠外键进行关联）
  - 找一个表中，各个数据之间的关系，把相关的数据，提取到另一个表中。
  - 表与表之间，通过外健建立联系，通过联合查询的方式，查询数据
    - 联合查询是浪费性能的，所以设计范式不利于查询
  - 由于，设计范式，是把有关系的数据，进行了提取，然后用外健建立联系
    - 相当于，把数据进行了提取，然后给出对应的索引(外健)
    - 这样，在修改数据的时候，直接修改提取出的数据，就可以，然后其他表通过外健获取数据，获取的都是修改后的数据
    - 这样的话，可能修改一次，就能实现效果
    - 尤其是，多表公用一个关系，进行提取后，修改起来更加方便，只修改一次，不用每个表都修改一次，其他的表都从该表中获取数据

.
- 范式的三阶段
  - 1NF
    - 要求数据保证原子性
    - 每一个表格的没一个列都是不可分割  (行列交叉点的单元格内只存储一个数据)
   3. 每一个表格必须有主键约束  (快速查询某一行记录)
  - 2NF
    - 在满足第一范式的前提下
    - 不允许出现部分依赖性 (非主键列不能受到主键列或主键的一部分影响)	
  - 3NF
    - 在满足前两个范式的前提下
    - 不允许出现传递依赖性 (非主键列不能受到非主键列或非主键的一部分影响)

.
- 比如，有这样一个表，按照范式进行提取

  | 学生ID   | 姓名   | 性别   | 年龄   | 班级         | 班主任    | 班主任职称      | 薪资   |
  | -------- | ---- | ----- |  -------- |  -------- |  -------- |  -------- |  -------- |
  |  2015001 | 张三   | 男     | 18     | 高二二班     | 王老师    | 副教授          | 10000  |
  |  2015002 | 李四   | 男     | 20     | 高二一班     | 李老师    | 高级教师        | 8000   |
  |  2015003 | 王五   | 女     | 17     | 高二三班     | 刘老师    | 教授            | 12000  |
  |  2015004 | 马六   | 女     | 18     | 高三三班     | 王老师    | 副教授          | 10000  |
  - 提取
    - 学生一表
    - 班级-老师一表
    - 职称-薪资一表
    - 然后在起一个中间表，用来这关联三个表
  - 这样的话，修改一次副教授的薪资，与他关联的数据都发生了变化，如果没有分表，则就需要修改两条数据了




#### 事务和隔离级别
- 数据库操作的流程
  1. 开启一个事务
    1. 每一次执行的一条sql语句之前
    2. mysql数据库都会默认的开启
      
  2. 执行操作
    1. insert  update  delete
    2. select
    3. 可能不止一条语句
    
  3. 事务的处理
    1. 提交/回滚/保存还原点
    2. mysql数据库会默认的执行提交事务

.
- 事务其实就是操作数据库的过程
  1. 正常情况下，通过指令操作表的数据，比如增删该查，mysql都会自定开启一个事务
  2. **然后才是操作表(这里的操作，只是操作虚拟的表，相当于缓存)**，此时底层的数据库还没有变化
  3. 当操作完成后，会立即进行提交(此时才真正的更改数据库)

  4. 如果手动开启一个事务，在通过指令操作表的数据(增删改查)，操作的是缓存，底层的数据库并没有改变
    1. 如果是手动开启的事务，并不会自动进行提交，而是需要手动提交
  5. 手动开启事物的指令: `begin;` 或者 `start transaction;`
  6. 提交的指令：`commit;`
    1. 在提交之前，所有操作表的过程，操作的都是缓存
    2. 提交后，才会真正的对表进行修改，并且事务结束，结束后
    3. 如果没有手动开启，就会自动开启事务，自动开启的是可以进行自动提交（操作一次，自动提交一次）
  7. 回滚的指令: `rollback;`
    1. 手动开启事务后，进行操作，无论操作多少下，进行什么操作，都是操作的缓存
    2. 如果，执行了回滚，则之前所有的操作，都将消失，数据库还是之前的状态
    3. 并且，执行回滚后，当前手动开启的事务也会结束
    4. 如果没有手动开启，就会自动开启事务，自动开启的是可以进行自动提交（操作一次，自动提交一次）
    5. 如果执行了提交（无论是手动的，还是自动的），都是不能进行回滚的。

.
- 查看事务状态
  1. 共有两个指令，可以查询状态
    1. 查询所有: `show variables like '%commit%';`
    2. 只查询`autocommit`: `show variables like 'autocommit';`
  2. 如果 `autocommit` 为 `on`，表示会自动提交
  3. 设置自动提交关闭: `set autocommit = off;`
		 
.
- 事务的四大特性(ACID)
  1. A:Atomicity---->原子性
    1. 一个事务中的所有操作是一个整体，不可再分
    2. 事务中的所有操作要么都成功，要么都失败
        1. 比如一次添加多个数据，如果有一个失败，其他的也添加不进行去
  2. C:Consistency--->一致性
    1. **一个用户操作了数据，提交以后**，需要注意是提交后，如果手动开启的事务，需要手动提交
    2. 另一个用户看到的数据与之前用户看到的效果是一致
    3. **如果没有提交，两个用户在`隔离性`的作用下，可能获取的数据是不同的**

  3. I:Isolation---->隔离性----->(事务隔离级别)，比较重要
    1. 指的是多个用户并发访问数据库时
    2. 一个用户操作数据库，另一个用户不能有所干扰
    3. 多个用户之间的数据事务操作要互相隔离


  4. D:Durability--->持久性(保存到本地，就持久化了)
    1. 指的是一个用户操作数据的事务一旦被提交(缓存-->文件)
    2. 他对数据库底层真实的改变是永久性的，不可返回

.
- 隔离级别针对的是，同时操作数据库的过程，与事务有关
  1. 经过上面的事务说明，以及事务过程中发生的事情
  2. 操作表，其实操作的是缓存，如果没有手动开启事务还好。操作完，会立即进行提交，可以看成直接操作数据库
  3. **如果，是手动开启的事务**，操作的都是缓存数据库，真实的并没有发生变化，要想改变真实的数据库，需要进行手动提交
  4. **如果此时，有另一个指令，也访问了数据库，就会出现一些问题**
  5. 会带来数据的安全隐患
    1. **脏读**
        1. 一个人读到了另外一个人还没有提交的数据(手动设置事务，操作的是缓存，还没有提交)
      2. 比如: A、B在操作同一张表格
      3. A修改了数据，还没有提交，B读取到了(特殊的隔离级别下，才能读取到，其他的级别，获取的就是底层数据表的结构)
      4. A不提交了，回滚回来，B刚刚读取到的那些数据就是无用的----这就是脏数据(更改级别，可以避免这种情况)
    2. **不可重复读**
      1. A、B在操作同一个表格
      2. A先读取了一些数据，读完之后B此时将数据做了修改/删除（已经提交）
      3. A再按照之前的条件重新读一遍，与第一次读取的不一致，这就是重复度
      4. 可以通过更改级别，避免这种情况
        1. 在一个事务下(手动开启的事务)，只要事务还没有结束(没有手动提交或者回滚)，以后在获取数据，获取的就是第一次读取的
      2. 哪怕另一个人，对数据库作为修改/删除（**只有修改和删除，其他操作还是有影响的**），哪怕是已经提交，也没有影响
      3. 如果进行了提交(当前用户)，则下次在读，就是当前表格中的内容(修改后的)
      4. 这个过程，被成为 **可重复读**，发生在同一个事务下。
    3. **幻读(虚读)**
      1. A、B在操作同一个表格
      2. A先读取了一些数据，读完之后B此时将数据做了新增
      3. A再按照之前的条件重新读一遍，与第一次读取的不一致
      
  6. 具体的级别分类，以及可以解决的问题
    1. `Serializable` ，最高，可以避免所有出现的问题，性能很慢
    2. `Repeatable Read`，避免脏读，不可重复读，幻读有可能出现，但是几率比较小
    3. `Read Committed`，避免脏读
    4. `Read UnCommitted`，所有效果均无法保证，也就是这个级别可以读取到其他用户操作mysql的缓存中的内容

  7. MySQL数据库提供默认隔离级别，`Repeatable Read`


  8. 修改数据库中的隔离级别
    1. 通过指令: `set session transaction isolation level 级别;`
    2. 如果不放心可以查看：`select @@tx_isolation;`

  9. 级别，作用于整个用户操作的过程，并不是作用于某个表，关闭后消失









#### MySQL函数的使用
- 函数可以放置在什么位置上
  - 查询中用来显示的部分---> `select 函数(列名) from 表格`
  - 条件筛选的后面---> `select 列名 from 表名 where age > 函数(值)`

- 函数的值，可以传入具体的值，也可以传入一个列名
  - 如果传入列名，则每次都把列名对应的数据，获取到，然后传入


.
- 按照函数功能来进行划分
  1. 比较函数
    1. `isnull(值);`，是空值(null)反1，不是空值返回0
  2. 数学函数(数值函数)
    1. abs绝对值    
    2. floor向下取整   
    3. mod(5,2)取余数    
    4. pow求次方   
    5. round()
  3. 日期和时间
    1. now();
    2. year(date);
    3. month()
    4. day
    5. week
  4. 控制流程函数(转换函数)
    1. if(条件, 值1, 值2);
        1. 如果条件为true，返回`值1`的值，否则返回`值2`的值
    2. ifnull(值, 值1);
        1. 判断值是否为 `null`，如果为`null`，则返回`值1`，如果不为`null`，返回值
  5. 字符串函数
    1. `length(str);`
        1. **获取某个字符串的长度**，如果传入的是数字，则自动转换成字符串。还可以传入列名
        2. 具体的使用指令（比如）：`select * from demo where length(name) = 3;`
          1. 只有，列 `name` 的长度为 3，该条数据才会被选中
        3. 具体的使用指令（比如）：`select * from demo where length(22) = 2;`
          1. `22`自动转化成字符串，长度为 `2`，所以条件始终成立，会读出所有的数据
        4. 具体的使用指令（比如）：`select * from demo where length('a') = 3;`
          1. 长度为 `1`，条件始终不成立，所以筛选不到数据
    2. concat()
    3. substr()
    4. instr(str,'a')
    5. replace()
    6. upper()	
    7. lower()	
    8. ltrim()
    9. rtrim()
    10. trim();
    11. lpad()
    12. rpad();
    13. reverse()		




#### 错误处理
- 出现的错误信息
  ```ts
  message from server: “Host ‘127.0.0.1’ is blocked because of many connection errors; unblock with unblock with ‘mysqladmin flush-hosts’”
  ```
- 原因
  - 同一个ip在短时间内产生太多（超过mysql数据库max_connection_errors的最大值）中断的数据库连接而导致的阻塞；

.
- 解决方法
  - 第一种方式：提高允许的max_connect_errors数量（这种方法不彻底，后期还可能导致异常出现）：
    - 进入Mysql数据库查看max_connect_errors
    ```ts
    show variables like ‘max_connect_errors’;
    ```
    - 修改max_connect_errors的数量为1000
    ```ts
    set global max_connect_errors = 1000;
    ```
    - 查看是否修改成功
    ```ts
    show variables like 'max_connect_errors';
    ```
  - 第二种方式：在数据库中进行，命令如下：flush hosts;（需要root用户的权限）
    ```ts
    mysql> flush hosts;
    ```

  - 第三种方式：使用mysqladmin flush-hosts 命令清理一下hosts文件
    - whereis mysqladmin查找mysqladmin的路径
    - 使用命令修改：
      - /usr/bin/mysqladmin flush-hosts -h192.168.1.121 -uroot -p
    - 备注：
      - 配置有master/slave主从数据库的要把主库和从库都修改一遍
