<script src='/笔记/see/index.js'></script>
[toc]



#### 对某一列累加求和
- 只能对 数字列 求和，如果是字符串，需要先转换成 数字

```sql
-- 数字
select sum(列名) from 表名
-- 字符串转换成数字
select sum(cast (列名 as int)) from 表名
```



#### 查询一列或者多列的所有数据
1. 进入表坐在的子数据库
2. `select 列名,列名,列名 from 表名`，列名就要要查询的列
3. 如果要查询所有列，可以使用上面的方式，把每一列都列举出来。或者使用 `select * from 表名`
   1. 但是这种方式效率没有上面的高，上面的方式直接指定了对应的列名，这种方式还需要先去表中查看有那些字段。
   2. 所以这种不推荐使用




#### 条件筛选
1. 通过指令： `select 列名,列名,列名 from 表名 where 列名 = 数据;`
2. 比如： `select a,b from test where c = 123;`
   1. 查询，列名为 `c`，对应值为 `123`，的所有的数据（条）中的 `a` 和 `b` 数据，其他的不管



#### 列计算得到新的列
1. 在查询的时候，获取一个列名计算完成的数据
2. 比如：`select a,b+c from test;`
   1. 最终获取的数据，共两列，一列是`a`，一列是`b和c`相加得到的值（每一条数据都进行计算）
   2. 如果计算过程中，有一个没有数据，为 `NULL`（比如说 `b` = `NULL`），则计算完也为 `NULL`
3. 获取的列名，也为 `b+c`，如果不想被别人看到这个计算过程，可以使用 `as` 起一个别名
   1. 比如：`select a,b+c as sum from test;`
   2. 这样，第二列的名称不再是 `b + c` 了，而是别名 `sum`。





#### 模糊查询(只适用与字符串)
- 借助于 `like`
- 相当于条件筛选，条件又满足一定的条件
1. `%`，用来代替0-n个字符
   1. 以什么开头，后面随意
      1. `select * from demo where name like 'abc%';`
   2. 前面随意，中间固定（是什么），后面随意
      1. `select * from demo where name like '%abc%';`
2. `_`，用来代替1个字符(有且只有一个)
   1. 前面有且只有一个(随意)，中间固定(是什么)，后面随意
      1. `select * from demo where name like '_abc%';`
   2. 前面固定(是什么)，后面有且只有一个(随意)
      1. `select * from demo where name like 'abc_';`
   3. 前面随意，中间固定(是什么)，后面最少有一个(随意)
      1. `select * from demo where name like '%abc_%';`
   4. 前面最少有一个(随意)，中间固定(是什么)，后面(随意)
      1. `select * from demo where name like '_%abc%';`
   5. 还有很多组合情况
3. 可以与逻辑运算符连用
   1. 比如: `select * from demo where age = 20 and name like '%a%' or xing = 'nan';`
      1. 有一个 `or` ，所以，有两种筛选情况
   2. 比如: `select * from demo where age = 20 and not name like '_a%' or xing = 'nan';`
      1. 有一个 `not`, 先非，在 `and` ，筛选一次
      2. 剩下的，用 `or` 在筛选一次




#### 排序介绍
- 排序，是针对已经查询出来的数据，利用某一列或者某几列进行排序
- 所以只要查出来数据，形成了列，就能进行排序



#### 升序
1. 通过 `order by 列名 asc`
2. `asc`可以省略不写，如果不写，作为默认值存在
3. 具体的操作指令：`select * from order by 列名 asc`;
4. 带筛选条件的排序: `select * from where age = 20 order by 列名 asc`;


#### 降序
1. 通过 `order by 列名 desc`，在获取的时候，就会对，指定的 `列` 进行降序排序
3. 具体的操作指令：`select * from order by 列名 desc`;
4. 带筛选条件的排序: `select * from where age = 20 order by 列名 desc`;


#### 多级排序
处理在排序过程中，遇到了相同的数据
1. 比如：对 `a` 进行升序排序的过程中，有多条的数据的 `a` 都等于 10;
2. 可以通过定义多个排序方式，处理这种情况
   1. 当第一个排序时相同，则使用第二个在排，当第二个相同的时候，在使用第三个排，依此类推
3. 具体的指令：`select * from where age = 20 order by 列名 desc, 列名 asc, 列名 desc`;
   1. 比如: `select * from where age = 20 order by age desc, name asc, chengJi desc`;



#### 分页查询	
1. 查询指令，`limit a, b;`
2. a为偏移量，b为要获取的数据量
3. 比如: `select * from demo limit 10, 6;`	
   1. 表示从第十条数据开始获取，包括第十条，总共获取六条，如果不够六条，有几条获取几条

- 对查询数据，进行分页获取
  - **放在sql命令的最后，也就是后面不能存在其他指令**
  - 如果存在排序，就是对排完序的数据，进行分页查询
    - 排序数据，也是一个表结构



#### 查询去重
1. 通过 `distinct` 实现去重的效果，对已经查询出的数据进行去重
2. 具体的指令，`select distinct 列名 from 表名`，获取指定的列，并进行去重
3. 具体的指令，`select distinct 列名,列名 from 表名`，获取指定的列，并进行去重
   1. 两个列相同的情况下才进行去重
4. **注意: 不可以这样写: `select 列名, distinct 列名 from 表名`**
   1. 一个列进行了去重，一个没有，就会出现两个列的数据个数，出现差异。mySQl是无法处理的
   2. 所以这样写，是会报错的




#### 特殊指令
1. `in ()`，满足查询子集中的某一个即可，**进行等号（=）比较**
   1. `in` 后面的 `()` 内，可以是常量固定值
   2. 也可以是通过另一条sql语句查询出来的结果 
   3. `in()`、`not in();`



2. `any、some、all` 后面的 `()` 内， **只允许写sql语句，也就是只能通过嵌套来获取子集**
   1. **这三个可以进行比较筛选，与in不同，in做的是 `=` 号筛选**

3. `any ()` 的用法
   1. 具体的指令：`select * from demo1 where age > any ( select age from demo2 )`
   2. 如果：() 中的 sql的查询结果为 `3, 4, 5`
   3. `age > any (3, 4, 5)`(不能直接写3, 4, 5，必须写sql语句)。就相当于 `arg > 3 or arg>4 or arg>5`
   4. **满足其中一个就可以**
   5. **如果做 `=` 筛选，就相当于 `in`**
      1. 比如: `age = any( select age from demo2 )` 相当于 `age in( select age from demo2 )`

4. `some` 的用法与，`any`完全相同，只不过名称不同。


5. `all ()` 的用法
   1. **与any相反，必须全部满足才可以，相当于and**
   2. 还是，比如: `select * from demo1 where age > all ( select age from demo2 )`
   3. 如果：() 中的 sql的查询结果为 `3, 4, 5`
   4. `age > all (3, 4, 5)`(不能直接写3, 4, 5，必须写sql语句)。就相当于 `arg > 3 and arg>4 and arg>5`
      1. 必须全部满足
   



#### 行列转换查询
- 行列转换并不是真正的行列转换，并且发生在查询的过程中
1. 就是把一个列的数据，整合一下，作为查询到的，所展示的列。
2. 对数据库中存放的表没有影响，并且展示的信息，是通过命令实现的(人为的)，并不是旋转得到的
3. 比如: 
```java
+------+------+-----------+
| xu   | num  | yue       |
+------+------+-----------+
| A    |  100 | 一月份    |
| B    | 1000 | 一月份    |
| C    |   10 | 一月份    |
| A    |  200 | 二月份    |
| B    | 2000 | 二月份    |
| C    |   20 | 二月份    |
| A    |  300 | 三月份    |
| B    | 3000 | 三月份    |
| C    |   30 | 三月份    |
+------+------+-----------+

// 想要变成如下形式，可以发现，每一列的名字变成了月份(也就是行)，而月份在表中，是列，这就是所谓的行列互换
+--------+-----------+-----------+-----------+
| 列名   | 一月份    | 二月份    | 三月份    |
+--------+-----------+-----------+-----------+
| A      |       100 |       200 |       300 |
| B      |      1000 |      2000 |      3000 |
| C      |        10 |        20 |        30 |
+--------+-----------+-----------+-----------+

// 通过分析不难发现，他的展示效果，是 a b c，相当于，根据 xu，进行了分组处理
// 而列名，是可以通过命令，起别名的。
```

4. 实现上述效果的具体命令(行列互换功能的实现)
```java
select
    xu as '列名',
    max(if(yue = '一月份', num, 0)) as '一月份', 
    max(if(yue = '二月份', num, 0)) as '二月份', 
    max(if(yue = '三月份', num, 0)) as '三月份'   
from lan group by xu;
// 随便用那个函数都可以，不一定非得max，但是if是必须的

// 对 xu，这个字段进行了分组，这样就分成了三组
A  一月份 -> 100    二月份 -> 200     三月份 -> 300
B  一月份 -> 1000   二月份 -> 2000    三月份 -> 3000
C  一月份 -> 10     二月份 -> 20      三月份 -> 30
// 而分组，只能显示分组函数，和分组条件
// 比如：max(if(yue = '一月份', num, 0)) as '一月份', 
// 会把每一组的数据，都传入，然后经过判断，就筛除了一月份的，显示出来，然后给列起了一个别名
// 二月份，三月份的原理相同
```

5. **经过上面的代码分析，所谓的行列转换，只不过是一个障眼法，是我们处理好每一列要展示的数据，然后给列起了一个别名**
   1. 如果起的是，之前一个列中的信息，则表现的就是行列互换，如果起成别的名字，就没有行列互换的效果
   2. 但是每一行展示的数据是不变的



#### 筛选介绍
1. 除了新增没有，改、查、删都可以使用条件筛选
2. 其实条件筛选，就是进行条件的判断，条件判断，就需要有进行判断的数据，符合的进行操作，不符合的忽略
3. 表中，只用字段是数据，**所以，筛选就是根据字段实现的**
4. 原理，取某些字段的值，进行条件判断，如果符合(为true)，则该条数据才会被处理(改、查、删)
5. **条件判断，就是使用比较运算符进行判断**
   1. 即： `>` `<` `>=` `<=` `=` `!=`
   2. 比如：`select a,b from test where c = 123;`
   3. 比如：`select a,b from test where c >= 123;`
   4. 只要，`c` 符合 后面的条件，该条数据的 `a` 和 `b` 就会被处理(获取数据)
6. **条件判断，也可以先使用算术运算符，先进行运算，然后在使用比较运算符进行判断**
   1. `+`、`-`、`*`、`/`
   2. 使用运算完的结果进行比较，符合条件的数据才进行处理
   3. 比如：`select a,b from test where c + 5 = 123;`/usr/local/mysql/bin/mysql -u root -p
   4. 只要，`c + 5` 符合 后面的条件，该条数据的 `a` 和 `b` 就会被处理(获取数据)
7. **也可以使用逻辑运算符**，`and`(与) `or`(或) `not`(非)
   1. 比如：`select a,b from test where c = 123 and d >= 123;`
      1. 只要，`c`和 `d` 符合，后面的条件，该条数据的 `a` 和 `b` 就会被处理(获取数据)
   2. **如果，`and`和`or`同时出现，`and`优先级别更高，`and`会先进行处理**
      1. 也就是，会先处理and，两侧的筛选条件，把符合的筛选出来
      2. 然后，在从头开始，筛选 or 符合的
      3. 比如: select * from demo where (age = 30 or age = 46 or age = 40) and xing = 'zhong';
   3. **也可以使用括号，进行优先筛选 （具体看，逻辑运算的详解 ）**
6. **其实，底层也是先获取所有数据，然后进行循环判断，符合的才能用**




#### 逻辑运算介绍
1. 可以按照 or 划分条件筛选（ `()`的不考虑 ），符合的就获取
2. 比如: `select * from demo where (age = 30 or age = 46 or age = 40) and xing = 'zhong' or age = 24 and xing = 'nv' or age = 30 or age = 40 and xing = 'nan';`
3. 不考虑`（）`，and先进行处理，所以，`or` 共划分出了，**4个筛选条件**，只要这四个有一个满足，该条数据就能被筛选出来
   1. 第一个筛选条件： `(age = 30 or age = 46 or age = 40) and xing = 'zhong'`
      1. or 先 筛选完( `()`改变了筛选顺序，把or提高了 )，然后从筛选出的数据中，在进行 `and` 的筛选
   2. 第二个筛选条件：`age = 24 and xing = 'nv'`，符合的也能筛选出
   3. 第三个筛选条件：`age = 30'`，符合的也能筛选出
   4. 第四个筛选条件：`age = 40 and xing = 'nan'`，符合的也能筛选出
4. not，可以放在任意判断的前面，表示非
   1. 比如: `select * from demo where not xing = 'nan';`
   2. 比如: `select * from demo where not (age = 23 and xing = 'nan');`
      1. `not` 的优先级，比 `and` 和 `or` 都要高，所以**要想对联合筛选取非，需要加上括号**





#### 其他筛选指令介绍
1. 范围筛选，比如 `30 ～ 50` 之间，除了借助 `>`、`<` 和 `and` 外，还可以使用 `between and`
   1. 具体的指令为：`select * from demo where age between 30 and 50;`
      1. **取得是闭区间，相当于 `>=` 和 `<=`**
   2. 也可以使用逻辑运算符
      1. 比如: `select * from demo where name = 'a' and age between 30 and 50 or xing = 'nan';`
         1. 有一个 `or` ，所以，有两种筛选情况
      2. 比如: `select * from demo where name = 'a' and not age between 30 and 50 or xing = 'nan';`
         1. 有一个 `not`, 先非，在 `and` ，筛选一次
         2. 剩下的，用 `or` 在筛选一次
2. 条件满足一个就可以（只能做等号判断），借助于 `in(值1, 值2, ···)`，相当于 `or`
   1. 具体的指令为：`select * from demo where age in(20, 30);`
      1. 相当于 `age = 20 or age = 30`; 进行的是等号判断，符合就保留。
   2. 也可以使用逻辑运算符
      1. 比如: `select * from demo where name = 'a' and name in('liu', 'wang') or xing = 'nan';`
         1. 有一个 `or` ，所以，有两种筛选情况
      2. 比如: `select * from demo where name = 'a' and not name in('liu', 'wang') or xing = 'nan';`
         1. 有一个 `not`, 先非，在 `and` ，筛选一次
         2. 剩下的，用 `or` 在筛选一次




#### 筛选，数据库底层做的处理
1. 解析SQL（敲入的命令）
2. 从表格中全部数据都读取出来、放在数据库缓存
3. 将所有数据，做一个遍历循环，每一次拿到一个元素(一行记录)，进行条件判断
   1.  假设我们的表格有7条记录
   2. 如果只写一个where条件
   3. 执行7次循环就可以比较出来啦
   4. 如果有and连接不止一个条件
      1. 先按照第一个条件先筛选
	  2. 比如: 7次循环，5条满足 `> 95`
	  3. 把第一次筛选出的数据，在按照第二个条件再筛选
	  4. 5次循环，2条满足
   5. 如果有 or 连接，就从剩下的在筛选一次。
4. 如果以后再语句中使用了and
   1. 尽量将条件苛刻的写在前面，提高执行效率


