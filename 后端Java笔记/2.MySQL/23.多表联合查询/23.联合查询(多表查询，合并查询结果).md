

#### 联合查询，又被称为广义笛卡尔积联合查询
1. 得到的是一个，横向拼接的表
   1. 把两个表的列横行拼接在一起
   2. 列的值比较特殊，**第一个表的列，依次与第二个表的列拼接在一块，然后每一列在以此与后面的列拼接在一块**
   3. 最终数据的量为， **表一的数据量 * 表二的数据量 * 表三的数据量**，如果还有表，以此类推
2. 拼接的事例
```java
// 表a
+--------+------+---------+---------------+
| name   | age  | xingBie | banJi         |
+--------+------+---------+---------------+
| 张三   |   18 | 男      | 高二*二班     |
| 李四   |   20 | 男      | 高二*二班     |
| 丽丽   |   18 | 女      | 高一*一班     |
| 王武   |   26 | 男      | 高一*一班     |
+--------+------+---------+---------------+
// 表b
+---------------+-----------+
| name          | banzhuren |
+---------------+-----------+
| 高二*二班     | 杨卿      |
| 高一*一班     | 欣广悦    |
+---------------+-----------+
// 表c
+------+
| dds  |
+------+
| abc  |
| ddd  |
+------+


// 拼接后的表
+--------+------+---------+---------------+---------------+-----------+------+
| name   | age  | xingBie | banJi         | name          | banzhuren | dds  |
+--------+------+---------+---------------+---------------+-----------+------+
| 张三   |   18 | 男      | 高二*二班     | 高二*二班     | 杨卿      | abc  |
| 张三   |   18 | 男      | 高二*二班     | 高一*一班     | 欣广悦    | abc  |
| 张三   |   18 | 男      | 高二*二班     | 高二*二班     | 杨卿      | ddd  |
| 张三   |   18 | 男      | 高二*二班     | 高一*一班     | 欣广悦    | ddd  |
| 李四   |   20 | 男      | 高二*二班     | 高二*二班     | 杨卿      | abc  |
| 李四   |   20 | 男      | 高二*二班     | 高一*一班     | 欣广悦    | abc  |
| 李四   |   20 | 男      | 高二*二班     | 高二*二班     | 杨卿      | ddd  |
| 李四   |   20 | 男      | 高二*二班     | 高一*一班     | 欣广悦    | ddd  |
| 丽丽   |   18 | 女      | 高一*一班     | 高二*二班     | 杨卿      | abc  |
| 丽丽   |   18 | 女      | 高一*一班     | 高一*一班     | 欣广悦    | abc  |
| 丽丽   |   18 | 女      | 高一*一班     | 高二*二班     | 杨卿      | ddd  |
| 丽丽   |   18 | 女      | 高一*一班     | 高一*一班     | 欣广悦    | ddd  |
| 王武   |   26 | 男      | 高一*一班     | 高二*二班     | 杨卿      | abc  |
| 王武   |   26 | 男      | 高一*一班     | 高一*一班     | 欣广悦    | abc  |
| 王武   |   26 | 男      | 高一*一班     | 高二*二班     | 杨卿      | ddd  |
| 王武   |   26 | 男      | 高一*一班     | 高一*一班     | 欣广悦    | ddd  |
+--------+------+---------+---------------+---------------+-----------+------+
// 有16条数据 4 * 2 * 2；
```


3. **具体的拼接指令**: `select * from 表1, 表2, 表3`

4. **拼接后的筛选，把没有关系的数据给去掉**，可以直接使用where进行处理，也可以使用嵌套的方式进行处理
   1. 比如，`a表` 有一个班级列，合并后，只保存班级相同的合并，其他不满足条件的去掉
   2. 也就是 `a.banJi` 和 `b.name`  需要一样
      1. 这样，该条信息，后面的信息，才是 `a表`，需要的,对应的 `b表` 中的信息，其他的信息并没有对应关系，合并后没用，就需要滤掉
   3. 具体的筛选指令: `select * from demo, ban where demo.banJi = ban.name;`
      1. 这样，`demo.banJi` 和 `ban.name`相同的才能合并，其他的，不符合条件的，就会被滤掉
      2. 如果合并后的列名，**有冲突**(比如，有两个name)，要想使用具体的name，条件或者读取，就需要加上对应的表名
         1. 类似对象属性的操作方式
      3. **如果没有冲突，是可以省略的**
         1. 比如：`demo.banJi`，合并后只有一个 `banJi`
         2. 使用时(条件或者读取)就可以省略 `demo` ，直接写 `banJi`
      4. **表是可以起别名的**，比如一个表的名称过长，使用 `.xxx` 的方式操作该表下的列过于麻烦，就可以起一个简单的别名
         1. 比如: `select * from demo a, ban b where a.banJi = b.name;`
         2. 直接把别名，写在对应表的后面就可以，不用加 `as`，实现效果与上面的一样(具体的筛选指令)
   4. **这种筛选的过程，又可以称为等值查询**


#### 外链接查询
1. `select * from 表一 left/right [outer] join 表二 on 条件`，必须写条件;
2. 如果多个表，比如三个，命令的写法是
   1. `select * from 表一 left/right [outer] join 表二 on 条件 left/right [outer] join 表三 on 条件`
3. `outer`，可写，可不写
4. 两张表格，表一和表二， 取决于谁的数据在左边显示
   1. 表一表格先出现，表一左边显示
   2. 表二表格后出现，表二右边显示
5. `left`和`right`来控制以哪一个表格的数据(前面的还是后面的)作为基准
   1. **作为基准的表格数据必须全部显示出来**
   2. 非基准的表格按照on条件与之拼接，符合的就拼接
   3. 若找到条件拼接，则正常显示，若找不到满足条件的则 **用null**，进行拼接(另一个表格的列值，全为null，然后与之拼接)
   4. 根据这一特性，查询的结果，有可能与 `select where`，有所不同，可能会多几个（原因是会拼接null）
      1. 而`select where`，只要没有找到符合项，当前的行也舍弃掉，不会拼接 null，这样就产生了 数量上的差异

6. 比如，以三表联合查询为例
   1. 三表数据
    ```java
    // demo
    +--------+------+---------+---------------+
    | name   | age  | xingBie | banJi         |
    +--------+------+---------+---------------+
    | 张三   |   18 | 男      | 高二*二班     |
    | 李四   |   20 | 男      | 高二*二班     |
    | 丽丽   |   18 | 女      | 高一*一班     |
    | 王武   |   26 | 男      | 高一*一班     |
    +--------+------+---------+---------------+

    // ban
    +---------------+-----------+
    | name          | banzhuren |
    +---------------+-----------+
    | 高二*二班     | 杨卿      |
    | 高一*一班     | 欣广悦    |
    +---------------+-----------+

    // lanXi
    +---------------+
    | dds           |
    +---------------+
    | abc           |
    | ddd           |
    | 高二*二班     |
    | 王武          |
    +---------------+
    ```
   2. 执行命令: `select * from demo left  join ban on demo.banJi = ban.name right join lianXi on demo.name = lianXi.dds;` 查询结果为

    ```java
    // 只有，王武可以匹配成功，张三、李四、丽丽都匹配失败，但是命令中设置的是 right，所以 以lianXi为基本
    // abc、ddd、高二*二班都匹配失败了，自动填入null，就构成了下面的表
    +--------+------+---------+---------------+---------------+-----------+---------------+
    | name   | age  | xingBie | banJi         | name          | banzhuren | dds           |
    +--------+------+---------+---------------+---------------+-----------+---------------+
    | 王武   |   26 | 男      | 高一*一班     | 高一*一班     | 欣广悦    | 王武          |
    | NULL   | NULL | NULL    | NULL          | NULL          | NULL      | abc           |
    | NULL   | NULL | NULL    | NULL          | NULL          | NULL      | ddd           |
    | NULL   | NULL | NULL    | NULL          | NULL          | NULL      | 高二*二班     |
    +--------+------+---------+---------------+---------------+-----------+---------------+
    ```


   3. 执行命令: `select * from demo left  join ban on demo.banJi = ban.name right join lianXi on demo.name = lianXi.dds or ban.name = lianXi.dds;` 查询结果为
   ```java
   // 王武可以，还有高二*二班又筛出了，两个张三，李四
   // 但是，命令是 right ，以 linXi为基础，筛到了两个，还有两个没有找到的，填null
    +--------+------+---------+---------------+---------------+-----------+---------------+
    | name   | age  | xingBie | banJi         | name          | banzhuren | dds           |
    +--------+------+---------+---------------+---------------+-----------+---------------+
    | 张三   |   18 | 男      | 高二*二班     | 高二*二班     | 杨卿      | 高二*二班     |
    | 李四   |   20 | 男      | 高二*二班     | 高二*二班     | 杨卿      | 高二*二班     |
    | 王武   |   26 | 男      | 高一*一班     | 高一*一班     | 欣广悦    | 王武          |
    | NULL   | NULL | NULL    | NULL          | NULL          | NULL      | abc           |
    | NULL   | NULL | NULL    | NULL          | NULL          | NULL      | ddd           |
    +--------+------+---------+---------------+---------------+-----------+---------------+
   ```


#### 内链接查询(查询结果与 select where 完全一致，也不会拼接null)，通常使用这个进行联合查询
1. `select * from 表1 inner join 表2 on 条件`，条件必须写
2. 多个表格，`select * from 表1 inner join 表2 on 条件 inner join 表3 on 条件;`
3. 可以查看外链接查询的事例，作用一样，只不过自动填充null，是没有的，该条信息会直接删除



#### 联合查询，可以操作同一张表，如果操作同一张表，表必须起一个别名，否则会有冲突的问题



#### 联合查询，除了有联系的表(外健约束)可以使用，查询联合的数据，没有关系的表也可以使用，进行联合查询数据