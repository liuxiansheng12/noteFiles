

#### 一对多的关系
1. 就是普通的外健约束
2. 当前表的一条数据，只对应，对应表的一条数据
   1. 由于，与外健建立联系的列，受唯一的约束，所以，与外键中的某一条信息，建立联系的只有一条数据，此为一
3. 由于外健不唯一，所以对应表中的数据，对应当前表的多条数据，此为多
   1. 由于，外健信息，没有唯一的约束，可以重复，所以，从另外一张表中与外健建立联系的列中的某一条数据，可以对应查询到多个外健信息，此为多。
4. 就这这样构成了一对多的关系
5. 比如
```java
// a表                                         b表
————————————————————————————————————————      —————————————————————
|  name    ｜  age   | c(外健 -> b.aa)  |     ｜  aa    ｜   ss     ｜
———————————————————————————————————————-      —————————————————————
|  '王一'   |   2    |        1         |     ｜  1     ｜  '一班'  ｜
|  '刘二'   |   5    |        3         |     ｜  2     ｜  '二班'  ｜
|  '张三'   |   8    |        1         |     ｜  3     ｜  '三班'  ｜
|  '李四'   |   10   |        2         |     ｜  4     ｜  '四班'  ｜
————————————————————————————————————————      ————————————————————— 
```
6. 通过，b表的1(唯一性，只有一份)，通过外健c，可以找到 a 表的 王一、张三 这两条数据，这样就构成了一对多


#### 多对多的关系
1. 一张表中，有多个外健，与另一个表的一个列建立联系
2. 当前表的一条数据，由于存在多个外健，所以可以对应，对应表的多条数据
   1. 通过这张表的外健，可以查询到对应表的多条数据，此为多
3. 由于外健不唯一，所以对应表中的数据，对应当前表的多条数据，此为多
4. 就这样构成了多对多的关系
5. 比如
```java
// a表                                                          b表
——————————————————————————————————————————————————————————      —————————————————————
|  name    ｜  age   | c(外健 -> b.aa)  | d(外健 -> b.aa)  |     ｜  aa    ｜   ss    ｜
———————————————————————————————————————-——————————————————      —————————————————————
|  '王一'   |   2    |        1         |        2        |     ｜  1     ｜  '一班'  ｜
|  '刘二'   |   5    |        3         |        3        |     ｜  2     ｜  '二班'  ｜
|  '张三'   |   8    |        1         |        3        |     ｜  3     ｜  '三班'  ｜
|  '李四'   |   10   |        2         |        1        |     ｜  4     ｜  '四班'  ｜
——————————————————————————————————————————————————————————      ————————————————————— 
```
6. `b表` 中的 `1` 通过外健，可以从 `a表` 中找到多条对应的数据
7. `a表`，通过外健，可以找到一条 `b表` 中的数据，但是多个外健组合，就可以从 `b表` 中，找到多条对应的数据，构成了多对多
   1. **所以多对多，就是多个一对多组合形成的**


8. **中间表**
   1. 两个表没有直接的联系，通过中间表建立联系，**可以优化多对多的表格结构**
   2. 多对多，就是通过多个外健实现的，但是一个表中，有多个外健，除了建立联系外并没有什么用
   3. 如果外健一多，这样表的列就过于臃肿。这样，就可以设置一个中间表，把外健的功能全部放在中间表中
   4. **中间表的结构**
      1. 只有两列，两列都是外健，一列与表a建立联系，一列与表b建立联系
      2. **把 `a表` 中，与 `b表` 有联系的，一条一条的放在中间表中**
      3. 比如，上面的表，使用中间表进行优化: 
      ```java
      —————————————————————————————————————————
      |  a(外健 -> a.name)  |  b(外健 -> b.aa) ｜
      —————————————————————————————————————————
      |       '王一'        |        1         |
      |       '王一'        |        2         |
      |       '张三'        |        1         |
      |       '张三'        |        3         |
      —————————————————————————————————————————
      // 王一 与 b表 中的两条数据都有联系，存两个
      // 张三 与 b表 中的两条数据都有联系，存两个
      ```
      4. 这样也能实现多对多的表关系
        1. 比如 `a表` 中的 `王一`，可以在 `中间表` 中，找到 `1、2`，然后通过 `中间表`，找到 `b表` 中的两条数据
        2. 比如 `b表` 中的 `1`，可以在 `中间表` 中，找到 `王一，张三`，然后通过 `中间表`，找到 `a表` 中的两条数据
        3. 实现了多对多的联系
        4. 并且 `a表` 中，也没有过多的外健，结构更加完美。只不过找关系时，需要借助 `中间表` 的辅助
   5. **中间表，设置主键的方式，可以新增主键列，也可以使用原来的两列作为主键约束**




##### 一对一的关系
1. 就是一对多，然后给外健设置一个唯一约束
2. 这样当前表的一条数据，只能对应对应表的一条数据，对应表的一条数据也只能对应当前表的一条数据。构成了一对一的关系
3. 比如
```java
// a表                                                          b表
—————————————————————————————————————————————      —————————————————————
|  name    ｜  age   | c(外健 -> b.aa)(唯一)  |     ｜  aa    ｜   ss    ｜
———————————————————————————————————————-—————      —————————————————————
|  '王一'   |   2    |           1           |     ｜  1     ｜  '一班'  ｜
|  '刘二'   |   5    |           3           |     ｜  2     ｜  '二班'  ｜
|  '张三'   |   8    |           4           |     ｜  3     ｜  '三班'  ｜
|  '李四'   |   10   |           2           |     ｜  4     ｜  '四班'  ｜
—————————————————————————————————————————————      ————————————————————— 
```
4. `b表` 中的 `1` 通过外健，可以从 `a表` 中找到一条数据(唯一性约束)
5. `a表` 通过外健，可以从 `b表` 中找到一条数据(唯一性约束)，这就构成了 一对一的关系