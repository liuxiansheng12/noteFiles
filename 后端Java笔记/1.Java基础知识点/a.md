# 课程说明

**<font size="6">大家好，我是渡一java讲师  董明晨(dmc)</font>**

带小白入门

基础知识温故知新

录播课的补充

**更多更详细的内容**：https://ke.qq.com/course/375599?taid=5636315647687471

​                                  https://ke.qq.com/course/4125523?tuin=c734c58e&taid=12354993122112339 

**数据结构算法内容：**https://ke.qq.com/course/3062841?taid=10551093971827769



# =======数据类型=======

# 2021-06-09

## 1 java是什么？

​	java是计算机编程语言 ， 可以与计算机交互， 让计算机知道我们要做什么 
​		C , C++ , go ...

​	如何交互： 编写java代码 -- 程序

## 2 如何写java程序

创建.java文件-》编写java代码

```java
public class Test1{	
	public static void main(String[] args){	
		//用java编程语言告诉计算机，帮我们输出一句话
		System.out.println("hello everyone !!!");	
	}
}
```





## 4 变量

是一个容器，用来临时存放数据，可以在后面使用。
java中如果需要一个变量，就要有一个变量
这个变量从无到有的过程：变量定义

变量类型 变量名 ;

变量名： 方便我们记住这个变量，使用变量
	java命名规范 ： 只能是数字，字母，_，$  ；数字不能开头； 不能是关键字；区分大小写；
	规约： 见名知意
		money , age , name
变量类型：
	体现这个变量中都可以存储什么形式的数据。
		10 , 字母 

## 5 java数据类型

有2种
		1） 基本数据类型
			   整形数字	byte , short , int ,long
			  浮点型数字  float , double
			  字符型	char
			  布尔型  boolean
		2)  引用数据类型
			 数组，类，接口

int num = 10 ;

**4个整形类型，区别在于可以存储的数字范围不同**
**byte 类型的变量 只能存储 -128 至 127 这256个数字**
**这个范围是如何计算出来的呢？**

变量中的数据是存储在计算机当中

### 1） 计算机只能存储0,1两种数字 (二进制)

​		逢二进一   1 , 10 , 11 , 100
 					     1	 2    3    4

​	我们在生活当中更习惯的是10进制，如何使用二进制表示

​		涉及二进制与十进制的转换

​		十进制 --> 二进制  除2 反向取余
​			13/2	6		1
​			6/2		3		0
​			3/2		1		1
​			1/2		0		1 --> 1101 (原码)

​	二进制 --> 十进制
​		1101 一千一百零一
​		1 * 1000 + 1 * 100 + 0 * 10 + 1 

​	    1 * 10^3 + 1 * 10^2 + 0 * 10^1 +1 * 10^0

​	    1 * 2^3 + 1 * 2^2 +0 * 2^2 +1 * 2^0 = 8+4+0+1 = 13

### 2） 计算机处理二进制时使用的二进制补码



# 2021-06-11

要使用变量，就需要先有变量

定义变量 ： 类型 名称 ；

​	数字形式数据

​	符号形式数据

整形数字类型 ： 1 ,2 , 3 , 4 , 5

一共有4种整形类型,表示存储不同数字范围的数据

byte b ;

short s ;

int i ;

long l;



## 1 byte类型变量存储数字的范围

要想了解byte存储数字的范围，需要先了解二进制,那什么是二进制？

## 2 什么是二进制

如同十进制， 逢十进一， 借一当十

​						逢二进一，借一当二

二进制数： 1(2) -- 1(10)

​					10(2) -- 2(10)

​					11 --- 3

​					100 -- 4

​					......

为什么要了解二进制 ?

## 3 计算机存储和计算数据时时，就是以二进制的形式处理的

### 1）十进制与二进制的转换

十进制 --》 二进制   除2反向取模  

​		10 /2 = 5...0

​		5/2 =    2...1

​		2/2=     1...0

​		1/2=     0....1  = 1010

二进制 --》十进制   *2相加

​		1010 = 1 * 2<sup>3</sup> + 0 * 2<sup>2</sup> + 1 * 2<sup>1</sup> + 0 * 2<sup>0</sup>

### 2）二进制的正负表示

最高位表示符号位 ， 0 正 ， 1 负  （假设8位）

+10    ->   0000 1010

-10    ->   1000  1010

### 3）计算机存储和计算二进制时，使用的是二进制补码

需要先了解什么原码 ， 反码， 补码

**十进制通过转换规则，转换成二进制数就称为 原码**



**补码 ： 与原码互补 ， 原码 与 补码 相加 各位均为0，整体进1**

 * 正数的原码和补码相同

 * 关于补码的计算只针对负数

   -10 --》 1 1010 + ? = 1  10000 

   ​			  ? = 10000 - 01010 = 00110 = 1 0110（补）

   ![image-20210611143715490](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210611143715490.png)

   1 0110补码 -1 = 10101 = 1 1010按位取反

   负数原码的符号位不变，其余位数取反（反码） 再+1 = 补码

   -12   = 1 1100(原码) = 1 0011 + 1 = 10100(补码)

**反码：负数原码的符号位不变，其余位数取反**

​	正数的原码与反码相同，也与补码相同



**原码在进行减法计算时比较麻烦**

​			5 - 7 = 5 +(-7) = 2 

​			0000 0101 + 1000 0111

​			最终的计算结果和绝对值最大的那个的数的符号相等  1

​			大数-小数 0111 - 0101 = 1000 0010 = -2

​			(-)7-5

**反码在计算减法时,比较简单，可以将符号也参与运算**

​		5-7

​		0000 0101 + 1000 0111

​		0000 0101(反) + 1111 1000(反) = 1111 1101(反) -> 1000 0010 = -2

​		

​		5-5 = 5+(-5)

​		0000 0101 + 1000 0101

​		0000 0101 + 1111 1010 = 1111 1111 （反） = 1000 0000 = -0

​		如果使用反码计算， 0就会有2种表示 +0 ， -0

**补码计算减法 ，比较简单，符号位可以直接参与运算**

​	5-7 = 5+（-7）

​	0000 0101 + 1000 0111

​	0000 0101(反) + 1111 1000(反)

​	0000 0101(补) + 1111 1001(补) = 1111 1110(补) -1 = 1111 1101(反) = 1000 0010 = -2 



​	5-5 = 5+(-5)

​	0000 0101 + 1000 0101

​	0000 0101 + 1111 1010 

​	0000 0101 + 1111 1011(补) = 1111 1112 = 0000 0000(补) = 0



## 4 byte基于二进制存储范围的计算

byte的存储范围需要通过二进制计算获得

byte 占1个字节  8bit位  可以有8个二进制数

​	计算机只能存储0,1

​	存储的每一位数字称为bit位 1111 1111

​	计算的最小存储表示单元是字节，1字节=8bit

所谓byte存储范围，就是看看8bit的二进制数都可以表示的范围

​	0 111 1111	127

​	1 111 1111(补) - 》1 111 1110 -> 1000 0001(原码) = -1

​	1 000 0001 = -127

​	-127 ~ 127 中间  

​	1000 0000没有对应的原码，人为规定原码是 -128

byte存储范围 -128 ~ 127



## 5 补充：整形的存储范围

byte 1字节 8bit

short 2字节 16bit

int	4字节	32bit

long 8字节	64bit



浮点型

## 6 float 4字节 32bit  如何使用二进制表示浮点数的呢（待续）



# 2021-06-17

java的基本数据类型中

有4个整形数字类型

有2个浮点数字类型

​	float  单精度			3.14f					4个字节   32bit    > int

​	double 双精度		3.14d  3.14

## 1 小数的二进制表示

13.625

整数部分13转换成二进制

13/2 = 6 - 1

6/2 =   3 - 0

3/2 =   1 - 1

1/2 =   0 -1

13 ——》 1101

小数部分0.625转换成二进制

0.625 * 2 = 1.25 -- 1

0.25 * 2 = 0.5 --     0

0.5* 2 = 1.0 ---      1

0.0*2 = 0----		 0

0.625 ——》 0.101



13.625 ——》 1101.101



二进制整数部分

1	2	4	8	16	32	.....

2<sup>0</sup> 2<sup>1</sup>

二进制小数部分

0.5	0.25	0.125 ...

2<sup>-1</sup>     2<sup>-2</sup>

1/2   1/4        1/8

注意：十进制小数部分只有是0.5 , 0.25 , 0.125 ... 这一系列有规律的小数组合才能完全转换成二进制小数

​	       否则会出现精度误差



0.4 * 2 = 0.8 	0

0.8*2 = 1.6		1

0.6*2 = 1.2		1

0.2*2=0.4		0

0.4*2=0.8		0



0.4 ~ 0.0110011  -> 0.4



## 2 float的二进制存储(IEEE754)

使用科学记数法表示浮点数

13.22  

1.322 *10<sup>1</sup>

0.1322 * 10<sup>2</sup>

132.2 * 10<sup>-1</sup>



13.625 --> 1101.101

要求整数位必须1 ： 正规数

1.101101 * 2<sup>3</sup>



float的存储由3部分组成

正负号占1位    0 正， 1 负

指数位 float占8位  存储的是2的幂指数    二进制的形式存储3->0000 0011 + 127 -> 1000 0010

​	占8位  0-255

​	表示2的次幂

​	指数有正负之分  2<sup>2</sup> , 2<sup>-2</sup>

​	用8位计算的结果 减去 偏移量 127 (2<sup>7</sup>-1)

​		真正的指数 + 127 = 指数位表示 （阶码）

​		阶码 - 127 = 真正的指数

​		指数的真值范围  -127 ~  128

尾数位  float占23位  存储小数部分  101101



0 	1000 0010	1011 0100 0000 0000 0000 000

0

1000 0010  -> 130 - 127 = 3

1011 0100 0000 0000 0000 000



1 * 1.10110100 * 2<sup>3</sup>

1101.101 -> 13.625



## 3 float取值范围(最大)

Float.MAX_VALUE -> 3.4028235E38 -> 3.4028235 * 10<sup>38</sup>



符号位	0

指数位	-127 ~ 128   

​	指数位都为0 -127  或 指数位都为1 表示非规范数

​	对于规范的浮点数，取不到 0和255的  真值取不到-127 和 128

​	最终真值的表示 -126 ~ 127 -》阶码表示 1111 1110

尾数位 1111 1111 1111 1111 1111 111



1.1111 1111 1111 1111 1111 1110 * 2<sup>127</sup>

0x1.f f f f f e * 2<sup>127</sup>

0x1.f f f f f e p+127



# 2021-06-18

java数据类型

​	基本数据类型

​		整形		 byte , short , int , long

​		浮点型	float , double

​		字符型   char

​		布尔型   boolean  true（1） / false（0）

​	引用数据类型



## 1 字符型的表示

使用单引号包含一个符号    'a' 	'b' 	','	'1' 	'2'	

## 2 包含多个符号的字符

理论上，一个字符只能包含一个符号 

但有一些特殊情况，也允许一个字符包含多个符号，最终表示的是一个符号。

### 1） 转义符号

```txt
'\r'	回车		\	转义符号		将光标移动会本行起始位置

'\n'    换行						   换到下一行

‘\t’    缩进， 字符串补充为8位，补足的补空格

‘\’  语法错误		'\\' 表示\
```

### 2） unicode表示(中文)

'\u4e00' ~ '\u9fa5'

## 3 字符编码

字符表现出来的是一个符号 (也有一些字符没有符号表现)

最终在计算里存储的都是0,1二进制

这些符号在存储的时候，都是什么样的(二进制)数

### 1）ascii码

用1字节记录符号对应的数字

​	1 byte = 8bit 表示的范围 0-255

ascii规定首位始终为0 ~ 127  这128个符号对应的数字

​	0-31 和 127 控制符号  32-126

​	'a'  ---> 97

​	'A' ---> 65

​	'0' ---> 48

### 2）ISO-8859-1

单字节编码  1byte=8bit	0-255

兼容ascii

使用了128以后的数字

补充：别名 latin1

### 3） GB2312

使用2个字节存储汉字 ， 大约存储6700+

每个字节存储时只用大于127的位置

### 4） Unicode和UTF-8

unicode 万国码 ， 几乎制定了所有国家文字符号对应的数字表示

utf-8 制定具体的存储方式

可变长度的字符编码

首位为0时，就表示ascii码那些符号，1个字节表示1个符号

首位为1时，表示要由多个字节组成这个符号  （中文需要3个字节）

1110 xxxx  表示有3个字节组成符号

1100 xxxx 表示有2个字节组成符号

1110 xxxx

10xx xxxx

10xx xxxx



# =======**运算符**=======

# 2021-06-24

## 1 数据类型转换

java的基本数据类型有8种

除了boolean以外，其他7种数据类型之间是可以相互转换。

所谓的类型转换，就是将某种类型空间中的数据 移动到 另一个类型空间中

1） 小空间中的数据 移动到 大空间中  一切如常  称为 **自动转换**

2） 大空间中的数据，移动到小空间中 可能会空间不足， 导致数据失真，导致精度丢失 ， 依然移动  称为**强制转换**

​	   注意： 强制转换时，需要使用(byte)指定要转换的类型

​		short s = 384 ;

​		byte b = (byte)s ;

​		不写强转，就会报错

注意： short 和 char 都是2字节 16bit 空间， 互相转换时也需要强转

​		     short表示数字，有正负之分   -2<sup>15</sup> ~ 2<sup>15</sup> - 1

​			 char表示符号，没有正负 	    0 ~ 2<sup>16</sup> - 1



数据在对应的空间中存储的好好的，为什么要移动(转换) ? 什么时候可能需要移动？

一般在运算时可能需要类型转换

## 2 运算符

### 0) java内存区域

和变量相关的运算，都需要在jvm内存中完成

数据存储在变量中，变量存储jvm内存中‘

变量存储在jvm的哪里呢？ 在jvm存储时又有什么样的特点呢？

![01.png](images/01.png)

**注意**： 目前我们定义的所有变量，都存储在栈空间中

### 1） 赋值运算符

```txt
= += -= *= /= %= ...
```

* #### = 赋值

  * 将数值直接存入当前变量，数值能装下就装，不能装下，可以强制装。

    byte b = 10 ;

    byte b = (byte)200 ;

  * 将另一个变量中的数据取出，并存入当前变量空间。根据取值变量的类型判断是否需要强转

    int i = 10 ;

    byte b = 10 ;

    byte b1 = b ;	//1. 从变量b中取出数值 ， 2 将数值存入b1变量

    byte b2 = (byte)i ;   

* #### +=  变量自身+上一个数值

  1. 先将数值装入变量空间，

  2. 再从变量空间中计算

  3. 在赋值时，可以不考虑类型转换问题

     ​	byte b = 10 ;

     ​	b += 10 ;

     ​	结果： b == 20

### 2） 算数运算符

```txt
+ - * / % ++ --
```

* #### / 相除取商

  5/2  商2余1	---》 2

  5.2/2 = 2.6

* #### % 相除取模(余)

  5%2 = 1

  5.2%2 = 1.2

* #### 带符号的除法

  ​	-8除以5  = 商-1 余-3  = 商-2 余 2

  ​	-8除以-5 = 商1 与-3   = 商2 与 2

  总结： 

  ​	符号不同 按大商计算

  ​	符号相同 按小商计算

* #### 变量数据运算时，会从变量中取出数据，在一个临时的int或更大的类型变量空间中计算

```java
//案例1
int i = 0 ;
i = i++ ;
System.out.println(i); // 0  所谓的前++ 和 后++ 在将数据从变量中取出的前后，至于数据取出后要做什么 和++无关

//案例2
byte b = 1 ;
b = b + 1 ;
System.out.println(b); //  编译报错，b=b+b时需要类型转换  b = (byte)(b+b) ;

//案例3
int i = 10 ;
double d = 3.14 ;
int j = i + d ;
System.out.println(j); // 编译报错 j = i+d是需要类型转换 需要从double转换成int  i+d是在double高类型空间中计算 
```

**注意：**非变量的运算， 是在编译期间运算的，不是在jvm中运算。就不需要考虑临时空间问题

​	byte b = (3 + 4) ;

​	可以使用javap 查看字节码   javap -c Test.class

![02.png](images/02.png)

3） 位运算符

4） 比较运算符  > < >=

5） 逻辑运算		& &&

6） 条件运算符    ? :

# 2021-06-25

## 1 运算符

### 3） 位运算

```txt
& 	| 	~  ^	<<	>>	>>>
```

位运算只针对于数字的二进制表示，需要将十进制转换成二进制分析



1. ####  '&'	按位与

   两个二进制数，相同位置，同时为1计算结果为1 ， 否则计算结果为0

   9 & 5	--》 	1001 & 101 --》 1001 & 0101 --》 0001 --》 1

2. #### '|'      按位或

   两个二进制数，相同位置，同时为0计算结果为0，否则计算结果为1

   9 | 5 --》 1001 | 0101 --》 1101 --》13

3. #### '~'      按位取反

   一个二进制数，每一个位置的数字 1变0 ， 0变1

   ~9 --》  ~0000 1001 --》 1111 0110(补) --》1111 0101(反) --> 1 000 1010(原) --> -10

   总结： 正数按位取反 = 相反数-1

4. #### '^'       按位异或

   两个二进制数，相同位置，数字相同结算结果为0 ， 数字不同计算结果为1

   9 ^ 5 --》 1001 ^ 0101 --》1100 --》 12

5. #### '<<'      向左移动

   一个二进制数，整体向左移动n位，低位补0

   5<<2 --》 101 << 2 --》 101 00 --》 20

   -5<<2 --》 1000 0101(原码)  --》1111 1010(反) --》 1111 1011(补) <<2  -> [11]  1110 1100(补) --》 1110 1011(反码) --》

   1 001 0100(原码) -》-20

   总结： 数字每左移1位相当于 * 2 

6. #### '>>'      带符号向右移动

   一个二进制数，整体向右移动n位，高位补0，最高位依然为原来的符号位数字

   -5 >> 1 --》1111 1011(补) >> 1 --> 1111 1101(补) --》 1111 1100(反) --》 1000 0011（原） -》 -3

   总结： 每向右移动1位，相当于/2

7. #### '>>>'      无符号向右移动

   一个二进制数，整体向右移动n位，高位补0

   -5 >>> 1 --》1111 1011(补) >>> 1 --》0111 1101(补码) --》 64+32+16+8+4+1 = 125 = -128 - 3 = -128 -1 - 2 = 127 - 2 = 125

   总结：

   ​	正数向右移动  相当于/2

   ​	负数向右移动 相当于 最小值 + /2

​	总结： 正数的 >> , >>> 结果一致

8. #### 练习一

![03.png](images/03.png)



# 2021-07-01

## 1 运算符

### 4） 比较运算

又称关系运算

用来比较两个数据，比较的结果只有2种，成立 和 不成立

所以比较结果是一个boolean类型结果， true表示比较成立，false表示比较不成立

```txt
==	!=	>	< 	>= 	<=	instanceof
<>	===(全等)	 !== （java不支持）

!= 不相等
instanceof  比较对象是否属于某一种类型  多态特性
```

**注意：**

int num = ? ;

10<num<20	错误。 java不是不支持这种计算方式，而是在计算式，类型不匹配无法计算

num1<num2<num3  --> (num1<num2) < num3 --> true < num3

num1 == num2 == num3 	错

true == true == false

num1 + num2 +num3  ;	√

num1 = num2 = num3 ;    √

### 5） 逻辑运算

对一组可以产生boolean结果的计算公式，进行再一次逻辑计算。

逻辑运算符只能计算布尔值，结果依然是一个布尔值

```txt
!(非运算符)  只对一个boolean计算式取反。 boolean计算式计算结果为true，通过!非运算，结果变成false
&(逻辑与运算) 对两个boolean计算式再次计算，如果两个boolean计算式的结果都为true，&逻辑运算的结果也是true，否则为false
	true & true --> true		true & false --> false
|(逻辑或运算) 对两个boolean计算式再次计算，如果两个boolean计算式的结果都为false，|逻辑运算的结果也是false，否则为true
```

总结： 逻辑运算时之关系运算式的结果是不是boolean，并不关心这个布尔的由来

​		boolean f = true ;  int i = 30 ;

​		!( i < 20)  	!(f)		!(f=true)	!(f==true)	  ! ( "".eqauls(s)  )

​										! ( i = 30 )	×

注意： '&' , '|' 需要对两个boolean结果进行再次的逻辑运算。 运算时会先算左边，再算右边。

​		   有时计算左边时，就可以得知最终的计算结果了。但右侧依然需要计算一次。

​		   很明显这样的计算不是最优秀

​		  所以又提供了2个短路运算符 '&&'  '||'    如果符号左侧的计算结果就以经可以确定最终的计算结果

​		  符号右侧就不再参与计算了

​			int i = 3 ; int j=1 ;

​			boolean f = i-- == j++ & i-- < j++ ;		--> false

​			boolean f = i-- == j++ && i-- < j++ ;	 -->false

​			System.out.println(i+','+j);

			1. 首选要计算 符号左侧   i-- == j++		2.  ++,-- 符号的优先级 大于 == ，所以会先计算 -- 和 ++		3. 因为都是后-- ， 后++ ，从内存图中可知， 会先从变量中取出数值 i -> 3 , j->1 , 之后再++，--  所以 i-- => i = 2 , j++=> j=2		4. 用++，--前从变量中取出的 3 和 1进行==比较 结果是false		5. 如果是 && 右侧不计算 ，此时 i=2 , j=2		6. 如果是 & 右侧依然需要计算        			1.  i ->  2 , j -> 2        			2. i-- => i=1 , j++ => j= 3

### 6） 条件运算

三元运算，三目运算

一目运算，二目运算，三目运算

! true    +3	-3	i++

3 + 2    

xx ? xxx : xxx

boolean ? 计算式值1 : 计算式值2 ;

有两个值，不确定是谁。可以通过一个boolean结果确定。

条件运算的最终结果，一定是一个值，一定是两个值中的1个，

值 true? System.out.println(1) : System.out.println(2);



根据?前的boolean结果决定?后的值

如果true，整个条件运算结果就是值1，false就是值2



### 7) 运算符的优先级和结合性

![21070101](images/21070101.png)

**运算符混合使用时，通过优先级确定执行过程**

​	i + j++

​	true || false && false		--> true 

**优先级相同的运算符混合使用时，通过结合性确定执行过程**

​	a = b = 0 		--> 		a = ( b = 0 ) ;

​	false ? false : true ? 20 : 30		--> ?

(true ? false : true ) ? 20 : 30	-> 30			错

true ? false  : (true ? 20 : 30 )   -> false		对



# =====控制结构=====

# 2021-07-02

## 1 if 结构

### 1） 单分支

if 结构会根据一个boolean类型的结果进行判断，判断接下来的功能代码是否执行。

​	true 执行紧邻的功能

​	false 不执行紧邻的功能

![](images/21070202.png)

**语法：**

```txt
if (boolean结果)
	代码/代码段
```



```txt
if(score > 425)
	System.out.println("恭喜你通过四级");
----
if(score > 425)
{
	System.out.println("恭喜你");
	System.out.println("你通过四级啦")
}

if(false)
	语句1
	语句2

```

**注意： if判断成立 （boolean==true) 就会执行紧邻的代码**

​		     {}代码段对于if而言，也属于一个完整的内容

**注意： 现在我们比较流行阿里巴巴编码规范**

​		    建议我们if 后面跟有{}

​			idea中安装编码规范

**笔试题：**

![](images/21070201.png)

### 2） 双分支

if - else

![](images/21070203.png)

**语法：**

```txt
if( boolean 结果)
	单行代码/代码段
else
	单行代码/代码段
	
boolean 结果为true ， 就执行if紧邻功能
boolean 结果为false ，就执行else紧邻的功能
```

* 注意： if结构在判断时，只关系是不是一个boolean结果，以及结果是什么。至于结果是怎么来的并不关心

```txt
if(  i > 10 )
首先会先执行/计算 i>10 --> 一定会计算出一个boolean结果
if根据计算的结果
	true
	false

if( true )
if( f = true )
if( f == true)

int i = 3 ; 
未来会学一个知识内容：volatile  关键字 ： 有一作用，阻止指令重排
```

### **3） 多分支**

if - else if - else if - else

![](images/21070204.png)

**语法：**

```txt
if(boolean)	代码1else	if(boolean)		代码2	else		if(boolean)			代码3		else			代码4--------------------if(boolean){}else if(boolean){}else if(boolean){}else
```

注意： 实际上，并不是真的多分支。而是双分支的一个逐层嵌套

# 2021-07-08

## 2 switch多分支结构

### 语法

```txt
switch(待判断的值){	case 值1 : 语句 ;break ;	case 值2 : 语句 ;break ;	case 值3 : 语句 ;break ;	case 值4 : 语句 ;break ;	case 值5 : 语句 ;break ;	default : 语句; break ;}------
```

```java
int b = 6 ;switch(b){    case 1 : System.out.println(1);break ;    case 2 : System.out.println(2);break ;    case 3 : System.out.println(3);break ;    default : System.out.println("default");break ;}
```

switch结构会用“待比较的值” 与 每一个case选项值做**等值**比较。 找到对应的选项，并执行后面的代码。如果没有找到对应选项，就会执行default后面的代码。 最终会退出switch

![21070801](images/21070801.png)

switch只能支持等值比较判断

if可以支持各种判断，适合的场景更多一些。

### 特点

**1）switch 带判断的值类型只能是以下几种**

​	byte , short , char , int   其实就支持int

​	jdk1.5之后 也支持 Byte , Short , Character,Integer 包装类

​	jdk1.5之后 支持枚举类型

​	jdk1.7之后 支持String类型

**2） case选项值不能重复**

**3） case选项值必须是常量值 。 不能是变量**

```java
		final int x = 3 ;        switch(b){            default :                System.out.println("default");break ;            case 1 :                System.out.println(1);break ;            case x :                System.out.println(3);break ;            case 2 :                System.out.println(2);break ;        }
```

**4）case选项值可以没有顺序**
**5） default表示其他选项情况**

​	    default 不一定要放到选项的最后

​		default 不是必须要有
**6）break关键字作用**

​	  switch通过等值比较，找到对应的case选项，并执行后面的功能代码。

​	  代码执行完毕后，会检查是否存在break关键字

​	  如果有break关键字，就会退出switch

​	 如果没有break关键字，就会继续执行当前选项后面的选项内容

​	 称为 switch穿透

```java
//打印一下指定月份的天数int mouth = 3 ;switch(mouth){    case 1 :case 3 :case 5 : case 7 :case 8 :case 10 :case 12 :        System.out.println(31);break ;    case 2 :        System.out.println(28);break ;    case 4 :case 6 :case 9 :case 11 :        System.out.println(30);break ;}
```

**7） case选项后面执行的本身就是代码段，可以不使用{}**

```java
switch(1){    case 1:                System.out.println(1);        System.out.println(2);        System.out.println(3);            case 2:}
```

注意： 如果case后面跟有多行代码（代码段），又没有使用{}，要注意多个case代码段不能重复定义变量

​	        如果存在这样的需求，只需要使用{}包含即可

```java
//打印一下指定月份的天数int mouth = 3 ;switch(mouth){    case 1 :case 3 :case 5 : case 7 :case 8 :case 10 :case 12 : {        int day = 31;        System.out.println(day);        break;    }    case 2 : {        int day = 28;        System.out.println(28);        break;    }    case 4 :case 6 :case 9 :case 11 : {        int day = 30;        System.out.println(30);        break;    }    default:break ;}
```



# 2021-07-09

循环：一件事反复的做

无限循环

有限循环，循环结束需要一定的判断条件，判断成立，循环继续，判断失败，判断终止。循环条件也需要随着循环发生

## 3 while循环结构

### 语法

```txt
while(boolean结果)	单行代码/{代码段}	boolean结果为true时，执行循环体中代码boolean结果为false时，退出循环boolean结果始终为true，就是无限循环。
```

![21070901](images/21070901.png)

### 分析

1） 循环进行/终止条件（条件变量的初始化）

2） 循环条件的改变

3） 循环体：具体的操作

```java
/*
            任务： 打印99乘法表
            结果不能一下打印出来
            需要一行一行的打印
            需要循环

            1. 循环进行/结束条件
               打印完第9行就结束
               打印的行数row<=9
               int row = 1 ;//  记录要打印的行号
            2. 循环条件的改变
               每打印完一行，就会准备打印下一行
               行号就需要增加
               row++ ;
            3. 循环体
               每次循环要做什么？
                 打印一行乘法表
               打印哪行乘法表？
                 打印row表现的一行
         */
//表示要打印的行号
int row = 1 ;
while(row<=9){
    //打印当前这行(row)乘法表
    /*
                新任务： 打印row=5表示这行的乘法表
                通过简单分析，发现不能/不适合直接打印
                最好使用循环
                1. 循环进行/结束条件
                   打印完最后一个单元格
                   cell <= row
                   int cell = 1 ;
                2. 循环条件改变
                   打印完一个单元格
                   准备打印下一个
                   cell++
                3. 循环体
                   打印当前这个单元格
             */
    int cell = 1 ;
    while(cell <= row){
        //打印当前单元的乘法表
        /*
                    新任务： 打印当前单元的乘法表
                    通过分析，认为不要循环，直接打印呗
                    行号：row
                    单元号：cell
                 */
        System.out.printf("%d*%d=%d\t",cell,row,cell*row);
        cell++ ;
    }

    System.out.println();//换新行
    //假设打印完成
    row++;
}
```

## 4 do-while循环结构

### 语法

```txt
do{
	代码段
}while(boolean结果)
	
```

![21070902](images/21070902.png)

### 特点

从功能上，所有的循环都可以互相转换

只不过有些场景，更适合指定的循环

**一般那种试探性的逻辑场景更适合do-while** : 猜数字

先猜一次

while{

​	再猜一次

}

-----

do{

​	猜一次

}while()

### while 和 do-while区别

```txt
while分解while判断{	操作}while判断{	操作}while判断{	操作}------------do-while分解{	操作	continue ;	...}while判断{	操作}while判断{	操作}while判断{	操作}
```

综上分析：

1） do-while至少会执行一次，while有可能一次都不执行

2） 假设循环条件起初是成立的，经过n次变化后，到时判断是失败

​		i. 如果在循环体中改变条件，如果经过n次条件改变，导致判断失败，就意味着循环体执行了n次

​			此时 while 和do-while 循环次数一样，判断次数不一样

​			{ i++ }

​		ii. 如果在判断的同时改变条件,如果经过n次条件改变，导致判断失败,就意味着判断执行了n次

​			此时do-while永远比while多执行一次

​		   while( i++ <= 3)

```java
int i1 = 1 ;while(i1++<=3){    System.out.println("dmc is good");    //i1++;}System.out.println("-------------------");int i2 = 1 ;do{    System.out.println("zzt is good");    //i2++;}while(i2++<=3);
```



# 2021-07-15

## 5 for循环结构

### 语法

for( 语句1 ; 语句2  ; 语句3 )

​	代码/代码段

![](images/21071501.png)

**1） 语句1特点：**

可以没有语句

可以是其他正常语句 （定义变量，变量赋值，调用方法）

可以写多个语句，使用逗号隔开

**2）语句2特点：**

可以没有语句，表示无限循环

如果有语句，只能是单条语句

要求语句必行返回一个boolean结果，for结构根据这个boolean结果决定是否执行循环体

​	true ，执行循环体

​    false， 不执行循环体

**3） 语句3特点**

与语句1基本相同，就一个不同点，不能定义变量

**注意： for循环底层就是while循环**

![](images/21071502.png)

### 练习

```java
public static void main(String[] args) {    int i = 0;    for( foo('A')  ; foo('B') & i<2; foo('C'),i++  ){        foo('D');    }    //A. 编译错误    //C. ABDCBDCB}public static boolean foo(char c){    System.out.print(c);    return true ;}
```



# 2021-07-16

正常情况下，从循环开始，随着循环条件的改变，循环会自然结束

在某些特殊的情况下，也可能需要在循环的过程中提前结束循环(手动结束循环)

**例如：查找**

## 6 break

break关键字可以在switch和循环结构中使用。

在switch中使用break关键字，可以结束整个switch结构体，可以防止switch穿透

在循环中使用break关键，可以结束整个循环体。

![](images/21071601.png)

```java
//找一个大于30，是7的倍数，还要含7
for(int i=1;i<100;i++){    
    if(i>30 && i%7==0 && (i%10==7 || i/10==7) ){        
        System.out.println(i);        
        break ;    
    }    
    continue ; //继续找
}
```



## 7 continue

只能在循环体中使用。结束当前这次循环，跳过剩余代码，直接进入下一次循环判断

![](images/21071602.png)

continue关键字的使用不是必然，可以使用if-else代替

合理的使用continue关键字可以明确代码逻辑，还可以简化编码

```java
int i=0,s=0;
do{    
    //i==6 i==7    
    if(i%2==0){        
        i++; 
        //i==7        
        continue ;    
    }    
    i++; //i==8    s+=i; 2,4,6,8
}while(i<7)System.out.println(s);

//A. 16
//B. 12
//C. 28
//D. 20
```

## 8 循环命名

假设在循环中嵌套了一个switch

当前switch某一个条件成立时，就想要结束循环

使用【name:】语法，为循环命名，使用break和continue关键字时，可以配合这个名字，指定控制的是哪个循环

```java
a:while(true){    
    switch(1){        
        case 1: break  ; //我们希望这个break可以结束循环。可惜的是break只会结束switch结构体(就近原则)        
        case 2: break a;        
        case 3: continue a;    
    }
}
public user findUser(){    
    a:for(一层一层的找){        
        b:for(每层一屋一屋的找){            
            c:for(每屋中一个一个人找){                
                找到了，可以结束                   
                    break a;                
                //return user ; 结束方法，自然也就结束了所有的循环            
            }        
        }    
    }
}
```

**扩展： 结构体也可以命名**

```java
a:{
    int i=0 ;
    int j =0 ;
    b:{
        int m = 0 ;
        int n = 0 ;
        if(m == 0 && n== 0){
            break a ;
        }
        System.out.println(m);
        System.out.println(n);
    }
    System.out.println(i);
    System.out.println(j);
}

System.out.println("--------------------");
```

# =======数组=======

# 2021-07-22

## 1 数组特点

数组本身是一个容器，可以存储一组数据

* 变量是一个容器，可以存储一个数据
* 数组是一个容器，可以存储一组数据
  * 数据并不是直接存储在数组中，而是存储在数组中的变量里了
  * 所以数组中放的是变量，变量中存储着数据
  * 数组中存储的是一组类型相同且连续的变量
    * 所谓的连续就是一个挨一个，也就是说每一个变量都有一个具体的位置，这个位置称为：下标（从0开始）
    * 注意：连续的是变量，而不是变量的值。(hash)
  * 所以数组中的变量，没有名字，可以通过下标找到对应的变量，就可以使用变量存取数据了
  * 数组中的每一个变量称为元素（属性，下标变量）

## 2 数组的创建(定义)

**new int[5]**

使用new关键字 表示要创建一个容器

[]表示创建的是一个数组

[5]表示创建的数组中有5个变量 ， 数组最多可以存储5个数据，数组的容量，数组的长度

int表示数组中创建的变量都是int类型的。



**关于数组创建时的内存特点**

程序中所有的内容(数据)都会存储在jvm内存中

jvm中有不同的位置存储不同特点的数据

大体分为：  堆内存，栈内存，本地方法栈，元数据区，程序计数器，

* **使用new关键字，就会在堆内存中开辟块空间**

* **堆内存会为这块空间提供一个地址(内存地址-数字)**
* **堆内存中定义的变量，会赋予一个默认值（整形：0，浮点型：0.0 ， 字符：空符号 ， 布尔：false)**
  * 之前我们定义的变量都是在(主)方法中定义，方法定义的变量会在方法栈中开辟空间。
  * 不会有默认值，使用前必须赋值。

**数组的引用**

数组存储在堆空间中，不能随时携带着数组空间

每次想使用数组中的变量时都需要找到数组

根据数组的内存地址找到

要想根据地址找到数组，就需要先记住这个地址

定义一个变量，存储数组的地址（引用）

int[] nums = new int[5] ;

![](images/21072201.png)

## 3 数组的使用

所谓的使用数组，就是使用数组中的变量

变量的使用就2种

* 取值 ： 除赋值以外的操作全是取值
* 赋值 ： 变量后面跟有=号就是赋值

从数组中获取变量

* 要找到变量，就需要找到变量在数组中的位置
* 要想找到数组中的位置，就要找到数组的位置
* 数组的位置一般会在创建数组时，存储在一个临时变量中 (nums)
  * nums是一个变量 ，因为没有写=，表示取值，取出了数组的地址(找到了数组)
  * nums[0] 在数组中找到0位置的变量
  * nums[0]本质是变量 相当于之前定义的 num
    * num = 10 ;									nums[0] = 10 ;
    * System.out.println(num);          System.out.println(nums[0]);

# 2021-07-23

## 4 数组的初始化

```java
int[] nums = new int[]{10,20,30,40};int[] nums = {10,20,30,40} ;
```

**注意： 如果{10,20,30,40}这样的初始化形式的，必须在定义变量的同时初始化**

```java
int[] nums ;nums = new int[]{1,2,3,4,5} ;//--------------int[] nums ;nums = {10,20,30,40};
```

**注意： 动态初始化**

```java
int[] nums = new int[5];nums[0] = 10 ;nums[1] = 20 ;...
```

## 5 引用数据类型

java的数据类型有2种

基本数据类型。   数值可以直接存入变量  int i = 10 ;

引用数据类型。  需要使用new关键在（堆区）创建数据空间，这个空间比较大，不能直接装入变量，就将空间的内存地址(引用)存入变量

​	以后通过变量就可以获得这个地址，在jvm内部会自动的找到那块空间，并使用空间中变量

​	数组可以理解成一个数据

## 6 基于数组的插入和删除

```java
int[] nums = new int[5000];
nums[0] = 10 ;
nums[1] = 20 ;
nums[2] = 30 ;

//将2位置的数据向后移动一下到3位置
//2位置后面可能还有数据
//需要循环依次移动
//1.循环进行/终止条件，完成所有需要移动的元素的移动 从后向前
int position = nums.length-2; //第一个移动的位置,应该是最后一个数据，第一个为0的前一个数据
while(position >= 2){
    nums[position+1] = nums[position];
    position--;
}

nums[2] = 40 ;


for(int i=0;i<=nums.length-1;i++){
    System.out.print(nums[i]+" ");
}
```

```java
int[] nums = new int[]{10,20,30,40,50,60};
//向删除位置为0的20这个元素

int position = 2 ;//第一个开始移动的位置

while(position<=nums.length-1){
    //将当前位置的元素，向前移动
    nums[position-1]=nums[position];
    position++;
}
nums[ nums.length-1 ] = 0 ; //相当于空出来


for(int i=0;i<=nums.length-1 ;i++){
    //5 , 01234
    //6 , 012345
    if(nums[i] == 0){
        //一个空位置，不需要输出，后面也一定都是空位置了，就可以提前结束输出操作了
        break ;
    }
    System.out.print(nums[i]+" ");
}
```

## 7 数组的扩容

数组中存储着一些变量

数组一旦创建，长度，容量，变量的个数就不能再改变了。

如果想多存储一些数据，创建新的，更长的数组

还需要将原数组中的数据复制到新数组中。

```java
//循环向数组中添加数字，直到输入<=0的数字位置// 1<<2 100->4
int[] nums = new int[1<<2] ;
Scanner input = new Scanner(System.in) ;
//准备存储数据的位置，从0开始存储
int position = 0 ;
while(true){    
    int num = input.nextInt() ;    
    if(num <= 0){        
        System.out.println("输入结束");        
        break ;    
    }    
    //这是一个正常的数字，需要存入数组    
    //数组中一定的多余的位置么    
    if(position == nums.length){        
        //数组中最后一个位置被上一次使用了        
        //证明这次没有位置了        
        //扩容        
        int[] new_nums = new int[ nums.length + 1 ];        
        for(int i=0;i<=nums.length-1;i++){            
            new_nums[i] = nums[i];        
        }        
        nums = new_nums ;    
    }    
    nums[position] = num ;    
    position++;
}

for(int i=0;i<=nums.length-1 ;i++){    
    //5 , 01234    
    //6 , 012345    
    if(nums[i] == 0){        
        //一个空位置，不需要输出，后面也一定都是空位置了，就可以提前结束输出操作了        
        break ;    
    }    
    System.out.print(nums[i]+" ");
}
```

# 2021-07-29

## 8 冒泡排序

> {3,6,1,7,9,2}  -> {1,2,3,6,7,9}
>
> 要进行n轮比较，每轮比较过后，都会找到一个当前最小/大的数字，移动到后面
>
> 在每一轮比较中，又需要进行m次相邻的两两比较，将小元素移动到前面，大元素移动到后面
>
> 3	6	1	7	9	2
>
> 第一轮比较：
>
> 第1次比较： 3和6比 ，不需要进行交换 	3	6	1	7	9	2
>
> 第2次比较： 6和1比 ， 需要交换				3    1   6    7 	9	2
>
> 第3次比较： 6和7比，  不需要交换			3    1   6    7 	9	2
>
> 第4次比较： 7和9比，不需要交换		      3    1   6    7 	9	2
>
> 第5次比较： 9和2比，   需要交换			   3    1   6    7 	2	**9**
>
> 第二轮比较：
>
> 第1次比较： 3和1比， 需要交换				1	3	6	7	2	9
>
> 第2次比较： 3和6比， 不需要交换			1	3	6	7	2	9
>
> 第3次比较： 6和7比， 不需要交换			1	3	6	7	2	9
>
> 第4次比较： 7和2比， 需要交换			    1	3	6	2	**7**	**9**
>
> 第三轮比较：												1	3	2	**6**	**7**	**9**
>
> 第四轮比较：												1	2	**3**	**6**	**7**	**9**
>
> 第五轮比较												    1	**2**	**3**	**6**	**7**	**9**

```java
public static void main(String[] args) {
    //        int[] nums = new int[]{3,6,1,7,9,2} ;
    int[] nums = {3,6,1,7,9,2};

    //冒泡排序(循环)
    //进行n轮比较，每次找到一个最大的，放置在最后
    int count1 = 1 ;//记录比较的轮数
    while( count1 <=nums.length-1 ){

        //每轮做什么事？--》要进行m次两两比较（交换）
        //现在是第count1轮，比较几次？  1,5   2,4   3,3   count1,length-count1
        int count2 = 1 ;//每轮比较的次数
        while(count2 <= nums.length-count1){
            //两两元素比较+交换
            //第1次比较的是第1个和第2个元素--> 0 1
            //第2次比较的是第2个和第3个元素--> 1 2
            //count2比较的是count2 和  count2+1 --> count2-1 , count2
            if(nums[count2-1] > nums[count2]){
                //大在前，小在后，需要交换
                int temp = nums[count2-1] ;
                nums[count2-1] = nums[count2] ;
                nums[count2] = temp;
            }

            //进行下一次比较
            count2++;
        }

        //每一轮比较完就进行下一次
        count1++ ;
    }


    System.out.println( Arrays.toString(nums) );

}
```

> 1,2,3,4,5,7,6
>
> 1,2,3,4,5,6,7
>
> 有些数列，进行少数交换后，就可以达到有序状态
>
> 如果一直比较排序，会降低效率
>
> 考虑提前结束比较过程
>
> 程序如何得知数列已经有序了呢？
>
> 进行下一次比较时，如果没有发生交换，就表示已经有序了

```java
public static void main(String[] args) {
//        int[] nums = new int[]{3,6,1,7,9,2} ;
    int[] nums = {1,2,3,4,5,7,6};

    //冒泡排序(循环)
    //进行n轮比较，每次找到一个最大的，放置在最后
    int count1 = 1 ;//记录比较的轮数
    while( count1 <=nums.length-1 ){

        //每轮做什么事？--》要进行m次两两比较（交换）
        //现在是第count1轮，比较几次？  1,5   2,4   3,3   count1,length-count1
        int count2 = 1 ;//每轮比较的次数
        boolean f = false ;//假设本轮不会交换
        while(count2 <= nums.length-count1){
            //两两元素比较+交换
            //第1次比较的是第1个和第2个元素--> 0 1
            //第2次比较的是第2个和第3个元素--> 1 2
            //count2比较的是count2 和  count2+1 --> count2-1 , count2
            if(nums[count2-1] > nums[count2]){
                //大在前，小在后，需要交换
                int temp = nums[count2-1] ;
                nums[count2-1] = nums[count2] ;
                nums[count2] = temp;
                f = true ;//发生了交换
            }else{
                //前面的数比后面的小 或 前面的数和后面的数相等
                //比交换
            }

            //进行下一次比较
            count2++;
        }
        if(f == false){
            //本轮没有发生交换，因为已经有序了，就不需要后续的比较了
            break ;
        }

        //每一轮比较完就进行下一次
        count1++ ;
        System.out.println( Arrays.toString(nums) );
    }
}
```

* 注意： 即使提前结束，也至少要多遍历一次。

**时间复杂度：**O(n<sup>2</sup>)      , 最优O(n) 

**空间复杂度：**O(1)

**稳定排序：** 数列中有相等的数字，通过排序不会改变其位置  5**7**76 56**7**7



# 2021-08-05

## 9 插入排序

也称为直接插入排序

将一个新的数字插入到已经排好序的序列中，行成一个长度增1的有序序列

以此类推，对所有的数据都进行插入操作，就可以最终形成一个完整的有序序列，过程——插入排序

> **利用辅助空间**

<img src="images/21080501.png" style="zoom:50%;" />

```java
public static void main(String[] args) {

    int[] array1 = {6,3,5,2,7,4};
    int[] array2 = new int[ array1.length ];

    //将无序数列中的数字一个接一个的插入到有序数列中，完成插入排序
    for(int i=0;i<array1.length;i++){
        if(i==0){
            //第一个位置的元素直接插入
            array2[0] = array1[0];
        }else{
            int temp =array1[i] ; //待插入的数字
            //array1[i]位置的元素本应该插入到array2[i]
            //但不能直接插入
            //需要和前面的元素依次比较
            //  找到前面的元素小于当前待插入的这个元素
            //  已经比较到了0位置，前面已经没有元素。
            // j 表示每次要比较的那个数的位置
            for(int j=i-1;j>=0;j--){
                if(temp < array2[j]){
                    //将j位置的元素向后移动
                    array2[j+1] = array2[j] ;
                    //temp就应该放到j位置了么？
                    //也不一定，还需要继续和前一个位置比较j-1
                    if(j==0){
                        //已经比较到第1个位置了，还么没有找到比temp小的元素，temp就是最小的元素
                        array2[0] = temp;
                        break ;
                    }
                    continue ;
                }else{
                    //前面的数列比当前待插入的数列小
                    //证明当前这个位置就是待插入的位置
                    array2[j+1] = temp;
                    break ;
                }
            }
        }
    }
    System.out.println( Arrays.toString(array2) );
}
```

> **不利用额外的辅助空间**

<img src="images/21080502.png" style="zoom:50%;" />

```java
public static void main(String[] args) {

    int[] array = {6,3,5,2,7,4};
    System.out.println( Arrays.toString(array) );

    for(int i=1;i<array.length;i++){
        //j 表示此次要比的那个数的位置 ，这个j位置的数字和谁比，j-1
        for(int j=i;j>0&&array[j] < array[j-1];j--){
            //前面的数比后面的数大，需要交换
            int temp = array[j] ;
            array[j] = array[j-1] ;
            array[j-1] = temp  ;
            // 在不定义临时变量的情况下，实现两个数字的交换
        }
    }
    
    System.out.println( Arrays.toString(array) );
}
```

**分析：**

**时间复杂度：**O(n<sup>2</sup>)    最优O(n) ， 最差， 平均

**空间复杂度：**O(1)

**稳定排序：**  有2个相同数字，排序后，位置是否发生变化。 No：稳定。 Yes：不稳定 



# 2021-08-06

## 10 线性查找

也称为顺序查找

对一个连续存储的数列，进行一个从头至尾的遍历查找过程

不要求数列的有序

```java
public static void main(String[] args) {
    //             0 1 2 3 4
    int[] array = {3,1,5,9,7} ;

    Scanner input =new Scanner(System.in);
    System.out.print("请输入您要查找的数字：");
    int num = input.nextInt() ;

    boolean f = false ;
    int i = 0 ;
    for(;i<=array.length-1;i++){
        if(array[i] == num){
            //找到了
            System.out.println("找了这个数字，在第【"+i+"】个位置");
            break ;
        }else{
            //不表示没找到，表示当前这个数字不是要找到的数字，继续找
            continue ;
        }
    }

    if(i == array.length){
        //越界了，还没有找到，证明没找到
        System.out.println("没有找到这个数字："+num);
    }

}
```

分析：

**时间复杂度：**O(n)

## 11 二分查找

又称为折半查找

前提要求： 要求查找的数列必须是有序的。

```txt
 0 1 2 3 4 5   6  7
{1,3,5,7,9,10,18,20}
int num = 16 ;   //线性查找需要遍历所有的元素8次后，发现不存在
第1次 找中间位置：
	left = 0 ;
	right = 7 ;
	mid = (left + right) / 2 = 3
	array[3] == 7 < 16
	继续在右侧找
第2次 找中间位置
	left = mid + 1 = 4 ;
	right = 7 ;
	mid = (7+4)/2 = 5
	array[5] = 10 < 16
	继续在右侧找
第3次 找中间位置
	left = mid + 1 = 6 ;
	right = 7 ;
	mid = 7+6 / 2 = 6
	array[6] =  18 > 16
	继续在左侧找
第4次 找中间位置
	left = 6 ;
	right = mid - 1 = 5 ;
	right < left 没有找到
	---------------------------------
0 1 2 3 4 5   6  7
{1,3,5,7,9,10,18,20}
int num = 1 ;   
第1次 找中间位置
	left = 0 ;
	right = 7 ;
	mid = 7+0 / 2 = 3
	array[3] = 5 > 1
	继续向左找
第2次	找中间位置
	left = 0 ;
	right = mid - 1  = 2 ;
	mid = 2+0/2 = 1 ;
	array[1] = 3 > 1
	继续向左找
第3次 找中间位置
	left = 0;
	right = mid - 1 = 0 ;
	mid = 0 ;
	array[0] = 1 == 1 找到了
```

```java
public static void main(String[] args) {

    //             0 1 2 3 4 5  6  7
    int[] array = {1,3,5,7,9,10,18,20} ;
    Scanner input =new Scanner(System.in);
    System.out.print("请输入您要查找的数字：");
    int num = input.nextInt() ; //16

    int left = 0 ;
    int right = array.length-1 ;

    //一直找
    int count = 0 ;//记录查找的次数
    while(true){
        System.out.println("第【"+(++count)+"】次查找");
        if(left > right){
            //表示没有找到
            System.out.println("没有找到【"+num+"】这个数字");
            break ;
        }
        int mid = (left + right) >> 1 ;
        int temp  ;

        if((temp = array[mid]) == num){
            System.out.println("在【"+mid+"】位置找到了这个数字");
            break ;
        }

        //没有找到，而且还可以继续找
        if(temp > num){
            //中间的数字比要找的大，应该继续在左找
            right = mid - 1 ;
            continue;
        }
        //需要继续向右找
        left = mid + 1 ;
    }
}
```

分析：

**时间复杂度：** O(log<sub>2</sub>n)

1 	n

2     n/2

3    n/4

k   n(1/2)<sup>k</sup> = 1  == >  n = 2<sup>k</sup> === >   k = log<sub>2</sub>n



# 2021-08-12

## 12 多维数组

### 1) 从维度空间理解

![](images/21081201.png)

### 2) 从jvm内存理解

java中实际上是没有多维数组的概念

只有数组中的数组

所谓的数组中的数组，就是有一个（一维）数组，数组空间中存储的数据的类型比较特别，又是一个数组

![](images/21081202.png)

多维数组学习的重点在于

* 每一维度表示的数据含义 —— 业务逻辑

* 了解这种含义的数据的类型如何表示 —— 语法

### 3) 语法

> **如何表示多维**

```txt
一个[]表示一个维度
[]
[][]
[][][]

学校 包含一堆 学年  String[][][]表示一组学年，也就是一个学校
学年 包含一堆 班级  String[][]表示一组班级，也就是一个学年
班级 包含一堆 学生  String[]表示一组学生，也就是一个班级
学生 包含	 名字  String 表是一个学生的名字
```

> 创建多维数组

```java
//创建数组的时候，必须要指定数组的初始容量
//创建一个数组准备来存储一个学校的信息，学校包含4个学年
//哪4个暂时不知道
new String[4][][] ;
```

**注意：**

数组数据属于引用类型的数据

* 所谓的引用类型的数据，就是这个数据比较庞大，不能直接存储在变量中
* 需要在堆区使用new关键字开辟空间，分配一个地址，将地址存储在变量中
* 未来通过变量，就能得到地址，通过地址就能找到数组空间，在空间中就可以操作相应的数据

引用类型的数据在堆区会被分配一个默认值：null 表示还没有地址

基本类型的数据在堆区会被分配一个默认值：0 （0 ， 0.0 ， false)

> 多维数组的赋值和取值

```java
//存储学校的信息
String[][][] 学校 = new String[4][][];
//现在我确定第一个学年是大一
//创建一个数组存储学年的信息
//数组是几个维度，需要由逻辑分析获得
String[] 学年 = new String[10][] ;
//这个学年就是学校的第一个学年
//这就是之前的一维数组的操作
学校[0] = 学年 ;
//现在确定第一个班级
//创建一个数组存储班级的信息,包含20个学生
String[] 班级 = new String[20];
//这个班级是学年的第一个班级
学年[0] = 班级;
//最终从学校中获得这个班级
//学校中第一个学年的第一个班级
System.out.println( 学校[0][0] ) ;
```

> 二维空间矩阵的赋值

```java
//创建一个4行3列的数字矩阵
//初始情况下矩阵中的值都是0
int[][] matrix = new int[4][3];
//创建一个4行3列的数字矩阵
//带有初始值
int[][] matrix = new int[][]{ {1,1,1} , {2,2,2} , {3,3,3} , {4,4,4} }
```



# 2021-08-13

## 13 关于数组涉及的异常问题

### 1） 空指针异常

java的数据类型分为2类

* 基本类型
  * 基本类型的值，可以直接存储并使用。
  * int i = 10 ;
* 引用类型
  * 数组，类，接口
  * 引用类型的数据，比较庞大，不能直接使用。
  * 引用类型的数据需要使用new关键创建而成，并且会分配一个内存地址
  * 我们可以通过这地址，找到这个数据并使用。



在使用引用类型的数据时，可能会产生空指针异常

有时这个地址不存在，以null形式表现

非要使用地址背后的那个数据，就会出现空指针异常



在多维数组使用中，更容易出现空指针异常

```java
int[][] array = new int[4][] ;array[0][0] = 10 ;// java.lang.NullPointerException 
```

### 2） 数组下标越界

假设一个数组，有10容量

数组内部有10个变量可以用来存储

这10个变量没有名字，有下标

下标是从0-9

当使用的下标不在0-9范围内，就称为越界。

int[] array = new int[5] ;

array[-1] = 10 ;

array[5] = 10 ;

```java
int[] array = new int[4];
array[-1] = 10 ;
//java.lang.ArrayIndexOutOfBoundsException: -1
```

## 14 蛇形矩阵的实现

```java
/*
	为一个二维数组赋值
	希望这个值在数组中存储时有一定的顺序
	1	2	3	4
				
	12	13	14	5
				
	11	16	15	6
				
	10	9	8	7
	
	---------------------------
	
	1	2	3	4
	
	8	7	6	5
	
	9	10	11	12
	
	16	15	14	13
	
	--------------------------
	
	1	2	6	7
	
	3	5	8	13
	
	4	9	12	14
	
	10	11	15	16
*/
```

```java
public static void main(String[] args) {
    /*
            1	2	3	4

            12	13	14	5

            11	16	15	6

            10	9	8	7
    */
    final int UP = 0 ; //上
    final int RIGHT = 1 ;//右
    final int DOWN = 2 ;//下
    final int LEFT = 3 ;//左


    System.out.println("请输入矩阵的大小：");
    Scanner input = new Scanner(System.in) ;
    int size = input.nextInt() ; //5

    int[][] matrix = new int[size][size];
    matrix[0][0] = 1 ;
    //记录每个数应该放置的位置（行列下标）
    int l = 0 ;
    int c = 1 ;
    //记录蛇形的方向
    int dir = RIGHT ;

    for(int i=2;i<=size*size;i++){
        matrix[l][c] = i ;
        //考虑下一个数字的位置，与盘的方向有关
        switch (dir){
            case UP:
                if(l == 0 || matrix[l-1][c]!=0){
                    dir=RIGHT;
                    c++;
                }else{
                    l--;
                }
                break ;
            case RIGHT:
                if(c == matrix.length-1 || matrix[l][c+1] != 0){
                    //现在这个位置，已经是这一行的最后一个位置
                    //或者这个位置的下一个位置已经有值了
                    //都需要改变方向
                    l++;
                    dir = DOWN;
                }else{
                    //可以继续向右盘，行不变，列++；
                    c++;
                }
                break ;
            case DOWN:
                if(l==matrix.length-1 || matrix[l+1][c] != 0){
                    //已经是最后一行，或下一行有数据，都需要改变方向
                    dir=LEFT;
                    c-- ;
                }else{
                    l++;
                }
                break ;
            case LEFT:
                if(c==0 || matrix[l][c-1]!=0){
                    dir = UP ;
                    l-- ;
                }else{
                    c-- ;
                }
                break ;
        }
    }



    for(l=0;l<matrix.length;l++){
        for(c=0;c<matrix.length;c++){
            System.out.print(matrix[l][c]+"\t");
        }
        System.out.println();
        System.out.println();
    }

}
```

```java
/**
 * 蛇形数组（二维数组）
 * 1	2	6	7
 *
 * 3	5	8	13
 *
 * 4	9	12	14
 *
 * 10	11	15	16
 */
public static void main(String[] args){
    int[][] nums = new int[4][4] ;

    final int r = 0 ; //右
    final int d = 1 ; //下
    final int ld = 2 ;//左下
    final int ru = 3 ;//右上
    int i = 0 ;
    int j = 0 ;
    int dir = r ; //初始方向
    nums[i][j] = 1 ;//初始第一个数

    //循环，根据方向找到每一个数存放的位置
    for(int num=2;num<=16;num++){
        if(dir == r){
            //方向向右，j++ ;
            j++ ;
            //考虑接下来的方向
            if(i==0){
                //最上面向右，接下来就是左下
                dir = ld ;
            }
            if(i == nums.length-1){
                //最下面向右，接下来就是右上
                dir = ru ;
            }
        }else if(dir == ld){
            i++ ;
            j-- ;
            //考虑接下来的方向
            if(j==0){
                //到了左边界
                if(i==nums.length-1){
                    //到了最下面（最下角），向右
                    dir = r ;
                }else{
                    //向下
                    dir = d ;
                }
            }else if(i==nums.length-1){
                //到了下边界
                dir = r ;
            }
        }else if(dir ==d ){
            i++ ;
            //考虑接下来的方向
            if(j==0){
                //左边界向下，右上
                dir = ru ;
            }else if(j==nums.length-1){
                //有边界向下，左下
                dir = ld ;
            }
        }else if(dir == ru){
            i-- ;
            j++ ;
            //考虑接下来的方向
            if(i==0){
                //上边界
                if(j==nums.length-1){
                    //右上角，向下
                    dir = d ;
                }else{
                    //没在右上角，向右
                    dir = r ;
                }
            }else if(j==nums.length-1){
                //向下
                dir = d ;
            }
        }

        nums[i][j] = num ;
    }



    for(i=0;i<nums.length;i++){
        for(j=0;j<nums[i].length;j++){
            System.out.print(nums[i][j]+"\t");
        }
        System.out.println();
        System.out.println();
    }
}
```



# =======方法=======

# 2021-08-19

## 1 方法概念

遇见方法时，不要纠结方法怎么写，先关心什么是方法，什么时候写方法，再关心如何写方法，怎么用方法。

> **从业务逻辑角度理解方法**

方法一个功能，一个行为，一个动作，一个操作。

有时也成为一个函数。

> **从代码设计角度理解方法**

对于一些复杂的代码，如果希望重复使用这些代码，做到随时任意的使用，就可以将这些复杂的，需要重复使用的代码编写在一个方法中。

## 2 方法结构

方法主要分为2个部分

* **方法体** ： 用{}包含一段功能代码
* **方法声明** : 为方法设置一些规范，方法使用者找到方法，并使用方法
  *  **方法名** ： 方法的名称，可以通过名称来找到方法，并使用方法。见名知意即可——add
  *  **参数列表**：本质就是定义变量 ， 与普通变量不同，用来存储方法的使用者在使用方法时传递的数据的——需要知道计算哪个数的加法。
     * 从方法使用者的角度： 我让你这个方法帮我做一些功能是，我需要给你传递一些什么数据
     * 从被使用者的角度： 如果有人使用我这个方法做一些事情，我是否需要别人给我传递一些数据
     * 参数列表可以定义多个变量，使用逗号给开，定义变量时不能赋处置。
  *  **返回类型**：方法在执行功能时，可能会产生一些结果，并需要返回给使用者——返回两个数相加的结果
     * 如果确实有结果需要返回，返回类型即为返回结果的类型——计算2个整形的加法，返回类型 int
     * 如果没有结果需要返回，此时的返回类型为void （也要有返回类型）
     * 在方法体中，使用 **return 100** 返回具体的结果
  *  **注意：有没有参数 和 有没有返回 无关**
  *  **访问权限**： 暂时固定 public。 谁能用，谁不用这个方法，在面相对中有4种权限，后面讲。
  *  **修饰符**： 暂时固定static 。 还有abstract，final ， native等。后面都会重点讲
  *  **异常声明**： 暂时无 。 异常表示不正常情况，表示一些问题。异常声明告诉使用者这个方法在执行功能时可能会存在一些不正常的情况，使用者可以考虑不用，或做好遇见问题的准备。
* 案例

```java
访问权限 修饰符  返回类型 方法名(参数列表)throws 异常声明
{
    方法体
}

//----------------------------------------------------------------

public static int add(int num1 , int num2)throws Exeption
{
    int sum = num1 + num2 ;
    return sum ;
}
```

## 3 方法的使用

### 1） 基本调用

方法名+()表示使用方法，调用方法

```java
public static void main(String[] args) {
    
    
    int say ;

    System.out.println("1");
    System.out.println("2");

    //我需要使用一个方法
    say();

    System.out.println("3");
    System.out.println("4");

}

public static void say(){
    System.out.println("hello everyone !!!");
}
```

* main方法调用add方法时，main方法代码会暂停，开始执行add方法，add方法执行完毕后，就需执行main方法后面的代码

### 2） 调用并传参

方法名+(具体的值)

```java
public static void main(String[] args) {
	
    //计算两个数的和，这是一个操作，可以写一个独立的方法
    //在这个调用过程实现了2个变量赋值的过程 num1 = 10 , num2 = 20 ;
    //add(10,20);
    
    //定义变量，使用变量
    //变量的使用只有2种， 存和取
    //变量后面有=就叫存，其余都叫取
    int num1 = 10 ;
    int num2 = 20 ;
    
    add(num1,num2) ; 
}

public static void add(int num1,int num2)
{
    System.out.println(num1 + num2);
}
```

* **实参与形参**
  * 实参：调用方法时，使用者传递的具体数据。
  * 形参：定义方法时，参数类表中定义的变量，用来接收存储方法调用时传递的具体数据的。

### 3） 调用并获得返回值

```java
public static void main(String[] args) {

    //计算两个数的和，这是一个操作，可以写一个独立的方法
    //在这个调用过程实现了2个变量赋值的过程 num1 = 10 , num2 = 20 ;
    int sum = add(10,20)
    System.out.println(sum);
}

public static int add(int num1,int num2)
{
   int sum = num1 + num2 ;
   //返回的是？ 是sum变量么？ 返回的是sum变量中的值，因为sum没有=号，表示取值
   return sum ; // return 30 ;
}
```

* 在方法有返回值的情况下，将调用方法的这段代码理解成一个数值 	add(10,20) --> 30

* 接下来要考虑就是如何使用这个数值30

  System.out.println(30);		--> System.out.println( add(10,20) );

  int num = 30 ;		--> 	int num = add(10,20);

  if( i < 30){}			--> 	if(i < add(10,20) ){}

  test(30) ;			--> 	a( test( add(10,20) ) ) ;

# 2021-08-20

## 4 方法运行时的内存特点

### 1） java程序运行过程

<img src="images/21082001.png" style="zoom:80%;" />

### 2） jvm内存结构

<img src="images/21082002.png" style="zoom:80%;" />

### 3） 方法内存特点

<img src="images/21082003.png" style="zoom:80%;" />

> 栈帧的结构

<img src="images/21082004.png" style="zoom:80%;" />

> **实操**

```java
/**
 * 在jvm运行Test2程序时，会自动调用main方法
 * jvm会根据main方法代码得到其运行所需要的一些信息
 *      1+2个变量 args,i,j
 *      先在栈区产生栈帧
 *          就会在局部变量表中产生3个变量槽
 * 产生一个10，存入变量i
 * 产生一个20，存储变量j
 * 从变量区i中读取10  加入操作数栈
 * 从变量区j中读取20  加入操作数栈
 * 调用add方法
 */
public static void main(String[] args) {
    int i = 10;
    int j = 20 ;
    add(i,j);		//行号21
}

/**
 * 随着main方法调用add方法
 * add方法运行所需要栈帧空间，被压入虚拟机栈
 * 此时这个add方法执行
 *      在add方法的返回地址中，存储行号21
 * 根据add源码发现
 *      这个方法运行需要3个参数 num1,num2,sum
 *      在局部变量表中产生3个变量槽
 * 从变量区num1 中取出数值 加入操作数栈
 * 从变量区num2 中取出数值，加入操作数栈
 * 计算加法
 * 将结果存入变量区sum，这个结果从操作数移出（弹栈）
 * 从变量区sum中取出数值，加入操作数栈
 * return 返回操作数栈中的数据
 */
public static int add(int num1,int num2){
    int sum = num1 + num2 ;
    return sum;

}
```

```text
 在cmd中找到上述Test2.class文件
 javap -v Test2.class 查看
 
 public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1	locals=3 表示需要3个变量槽
         0: bipush        10		10装入操作数栈
         2: istore_1				10存入变量表中的i
         3: bipush        20		20装入操作数栈
         5: istore_2				20存入变量表中的j
         6: iload_1					从变量表的i中取出数值，加入操作数栈
         7: iload_2					从变量表的j中取出数值，加入操作数栈
         8: invokestatic  #2        调动add方法     // Method add:(II)I
        11: pop
        12: return

public static int add(int, int);
    descriptor: (II)I
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=2
         0: iload_0				从变量表的num1中取出数值，加入操作数栈
         1: iload_1				从变量表的num2中取出数值，加入操作数栈
         2: iadd				加法
         3: istore_2			将结果存入变量表中的sum
         4: iload_2				从变量表的sum中取出数值，加入操作数栈
         5: ireturn				返回操作数栈中的数值
```

# 2021-08-26

## 5 值传递与址传递

### 1） java的数据类型

java数据一共有2种类型

* 基本类型

  * 数据可以直接使用。 存储，比较，打印，传递
  * int i = 10 ;

* 引用类型

  * 数组和类（对象）

  * 引用类型的数据，必须使用new关键字创建产生

  * 会在jvm堆空间产生内容，同时会为其分配一个地址（地址本身可能是一个数字10）

  * 我们在使用引用类型的数据时，其实直接使用的是这个地址。 存储，比较，打印，传递

  * 利用一些语法，间接的使用真正引用类型的数据

    int[] array = new int{1,2,3,4};

* **总结：**

  ​	int  i = 10 ;  这里面的10 就表示一个数字值（10）

  ​	int[] array = new int[]{};    new产生的空间被分配的地址也可能是一个10

  ​		此时array变量中存储的也是10. 这个10表示的是一个地址，引用

### 2） 值传递

无论是哪种传递，表示都是在方法调用时，传递参数

所谓的值传递，就是传参时传递是基本类型的值

```java
public static void t1(int num){
    num = 20 ;
}

public static void main(String[] args){
    int i = 10 ;
    t1(i) ; // int num = 10 ;
}
```

主方法调用t1方法传递了一个基本类型的数据（值）

在t1方法中将主方法传递值存储在了变量中

当t1方法改变变量中存储的数据时

主方法中变量存储的数据不会发生变化

### 3） 地址传递

所谓的地址传递，就是在方法调用传参数时，传递是一个堆空间的地址

传递时以数字的形式传递

```java
 public static void main(String[] args){    
     int[] array = new int[]{1,2,3};    
     System.out.println(array[0]); //1    
     t1(array);    
     System.out.println(array[0]); //20
 }
 public static void t1(int[] array2){   
     array[0] = 20 ;
 }
```

主方法调用t1方法时，传递的是一个堆空间的地址

这个地址的表现性形式可能依然是一个数字，但表示含义发生了变化

在t1方法中，我们同通过这个地址就可以找到堆空间

通过间接语法 array[0] , obj.uname 操作堆空间数据 （赋值，取值）

主方法中再次通过这个地址，找到堆空间，其中的数据就是之前t1变化后的数据了

**总结：**

方法调用时，如果传递的是值， 被调用的方法中改变了变量的值，原方法变量中不会发生变化

方法调用时，如果传递的是地址，被调用的方法中通过地址改变了堆空间中的数据，原方法中再次操作堆空间数据时就是改变后的。

<img src="images/21082601.png" style="zoom:80%;" />

### 4） 地址传递扩展

在主方法调用t1方法时，传递了一个数组的地址（址传递）

在t1方法中使用变量存储这个地址

在t1方法中，改变了变量中存储的地址，并操作了地址指向的堆空间数据

此时主方法中再通过地址找到堆空间时，数据是否发生了变化？

```java
public static void main(String[] args){
    int[] array = new int[]{1,2,3};
    System.out.println(array[0]) ;//1
    t1(array);
    System.out.println(array[0]); //?
}

public static void t1(int[] array2){
    //array2[0] = 20 ;
    array2 = new int[]{1,2,3};
    array2[0] = 20 ;
}
```

**总结：**

值传递，调用方法中改变数据，原方法中的数据不发生变化

地址传递，调用方法中改变了地址中的内容，原方法中地址内容也发生变化（同一个地址）

地址传递，调用方法中改变了地址，原方法中地址内容不发生变化。

<img src="images/21082602.png" style="zoom:80%;" />

```java
public static void main(String[] args){
    //对象
    StringBuidler s1 = new StringBuilder("dmc");
    System.out.println(s1); // ? dmc is good
    
    String s2 = new String("dmc") ;
    t2(s2); //地址传递
    System.out.println(s2); // ? dmc
}

public void t1(StringBuilder str){
    str.append(" is good") ;
}

public vodi t2(String str){
    str += " is good" ; //  String内容不可变，如果发现变了，那一定是产生了新对象  
    					//  str = new String("dmc is good")
    System.out.println( str ); //dmc is good
}
```

# 2021-08-27

## 6 方法重载

### 1） 概念

（在一个类中）两个方法的名称相同，参数列表不同，执行不同的操作（方法体不同），与访问权限，修饰符，返回类型，异常声明无关

参数列表不同体现在参数的**个数**和**类型**不同

### 2）编写

```java
public static void sum(int num1,int num2) {}
public static void sum(int num1,int num2,int num3){}
public static void sum(double num1,double num2) {}
```

### 3）调用

* 编码时，只需要根据需求，传递指定数量和类型的参数即可。
  * sum(10,20)
  * sum(10,20,30)
* 编译时，就会自动匹配对应的方法。（如果没有匹配就会报错）

<img src="images/21082701.png" style="zoom:80%;" />

**总结：**

* 使用方法重载，可以让方法调用者，有更多的精力去关注业务需求，而不需要关注每一个业务所对应方法
* 方法的重载和重载方法的使用，一般都是2个人操作的。
  * 编写者考虑更多的情况，提供多个功能类似的方法
  * 为了方便使用这调用，将这些方法重载。
  * 调用者只需要根据需求调用方法，传递相关的参数即可。具体调用哪一个，编译时自动匹配。

### 4） 扩展

```java
public static void sum(int num1,int num2) {}
public static void sum(int num1,int num2,int num3){}
public static void sum(double num1,double num2) {}

public static void main(String[] args){
    sum(10 , 3.14 ) ;// 能成功么？能  调用的是哪一个方法呢？sum3   double num1 = 10 ; ?
}
```

**总结：**

* 调用重载方法时，如果类型没有直接匹配的
* 就会自动(向上)转换类型，匹配方法

```java
public static void t1(short num){}
public static void t1(long num){}

public static void main(String[] args){
    byte b = 127 ;
    t1(b) ;// 调用了谁呢？
}
```

**总结：**

* 当调用重载方法时，如果没有类型直接匹配的方法，但转型以后有的多个匹配的方法，
* 会调用类型最近的那个方法。

```java
public static void t1(double num1,float num2){}
public static void t1(float num1,double num2){}

public static void main(String[] args){
    t1(10,20) ;// 报错   类型不明确
    t1(10,20d);//只能保留一个不明确的类型
}
```

# 2021-09-02

## 7 可变参数

### 1） 概念

参数分为 实参 和 形参 

可变数是jdk1.5新特性

形参： 可变参数就是**一个**特殊的参数

实参： 参数传递时，可以为可变参数传递**0或多个**实际的参数值

适用于参数类型确定，参数个数不确定。 可变参数当做数组来处理。

### 2） 应用

> **定义可变参数（形参）**

```java
//只有1个参数
public static void sum(int... nums){}
```

> **为可变参数传值（实参）**

```java
public static void main(String[] args){
    sum();
    sum(10);
    sum(10,20);
    //传递了1个（数组）参数
    sum( new int[]{1,2,3} ) ;
}
```

> **使用可变参数**

无论方法调用者是否传递了参数，传递几个参数，传递了什么类型的参数（int , int[])

在当前方法中，可变参数都当做数组使用

如果调用者没有传递参数，可变参数也依然是数组，只不过数组.length=0

```java
public static void sum(int... nums){
    //int[] nums ;
    System.out.println(nums.length);
}
```

**总结：**

* 一个方法的参数列表中可变参数必须是参数列表中最后一个参数

  `public static void sum(int num1,int num2,int...nums){}`

  在调用方法传参时，必须保证传递前两个参数，从第三个开始可以任意。（0,1,多,数组）

  `public static void sum(int...nums, int num1,int num2){}` **错**

  非可变参数（普通参数） 必须是一对一匹配，一个形参对应一个实参

  如果可变参数在前，传递的2个参数怎么确定是可变参数的值，还是后面固定参数的值。

* 一个方法的参数列表中只能有1个可变参数

  `public static void sum(int...nums1 , int...nums2)` **错**

  在调用方法传递参数时，如果传递了3个参数，怎么分配？

* 在为可变参数传递参数时，可以传递0个参数，1个对应类型的参数，多个对象类型的参数，1个对应类型的数组参数

* 可变参数在方法中，当成数组来使用。无论调用者如何传递的参数。

### 3） 重载中的应用

有可变参数的方法一样可以重载

```java
//(1)
public static void sum(int num1,int num2){}
//(2)
public static void sum(int num1,int...nums){}

public static void main(String[] args){
    sum(10,20);		// (1)
    sum(10,20,30);  // (2)
}
```

* 在调用（含有可变参数的）重载方法时
* 会优先参数类型和个数完全匹配的方法

```java
//(1)
public static void sum(int num1,int num2,int...nums){}
//(2)
public static void sum(int...nums){}

public static void main(String[] args){
    sum(10,20);		// 报错
    sum( new int[]{10,20} ); //(2)
    sum(10, new int[]{10});	 //(1)
}
```

```java
//(1)
public static void sum(int num1,int num2,int...nums){}
//(2)
public static void sum(int...nums){}

public static void main(String[] args){
    sum(10,20);       		  // 报错
    sum( new int[]{10,20} );  //(2)
    sum(10,20,new int[]{});   //(1)
}
```

* 如果重载的两个方法都含有可变参数
* 在传递参数时，必须为可变参数指定对应的数组参数值。

# 2021-09-03

## 8 方法递归

### 1） 特点

所谓的方法递归，就是方法直接或间接的调用自己

```java
public static void main(String[] args){
    a();
}

public static void a(){
    //coding...
    a();
    //coding...
}
```

```java
public static void a(){
	b();    
}

public static void b(){
    //coding...
    a();
}
```

### 2） 栈内存溢出

方法在执行时，会被压入虚拟机栈（栈空间），形成一个栈帧

方法递归时，上一次调用的方法还没有执行完毕，就又重新调用一次当前方法

所以方法就会不停的压栈，没有弹栈过程。

如果没有控制方法递归调用的终止条件，就不不停的压栈，最终就会出现栈内存溢出。

<img src="images/21090301.png" style="zoom:80%;" />

### 3） 递归与循环

都是一个操作一遍一遍的执行

* 循环是做完一遍，再做下一遍
* 递归是操作做到一半，就开始执行下一次操作
  * 虽然当前的方法还没有执行完毕（没有弹栈，局部变量没有被回收）
  * 但从功能而言，这个方法的功能已经执行完毕了
  * 从这个角度分析，此时循环和递归是可以转换的。
* 但还有一种递归情况，不太适合与循环互换
  * 当前方法的功能要想执行完毕，需要依赖于下一次方法的执行结果。
  * 这种情况也就意味着，如果下一次功能没有执行完毕，这一次功能就无法执行完毕。

**总结：** 绝大多数的递归情况都可以得出如下分析结果，反之如果分析出如下的结果，可以考虑使用递归。

* **要想完成a这件事，就需要先完成b那件事，a和b是一样的事**。

> **案例1： 计算1-100的和**

```java
//非递归
public static void main(String[] args) {
    int result = sum(100);
    System.out.println(result);
}

//计算1-top的和
public static int sum(int top){
    //存储累加的结果
    int sum = 0 ;
    //每次累加的数值
    int num = 1 ;
    while(num<=top){
        sum += num ;
        num++ ;
    }
    return sum ;
}
```

```java
//递归
public static void main(String[] args) {
    int result = sum(100);
    System.out.println(result);
}

//计算1-top的和
public static int sum(int top){
    //思考 。。。。
    //1-top的和我可能不太会计算
    if(top == 1){
        //1+2+3+4 = 10
        return 1 ;
    }

    //如果有人帮我算出1-99的和，我只需要在这个基础上+100 不就是1-100的和了么
    int result = sum(top-1) + top ; // 1-top
    return result ;
}
```

> **案例2： 汉诺塔**

![](images/21090302.png)

```java
static long time = 0 ;
public static void main(String[] args) {
	//move(3,'A','B','C'); 
    move(60,'A','B','C');
    System.out.println(time/(60*60*24*365));
}

//将指定数量的圆盘，从from柱子经过temp柱子移动到to柱子
public static void move(int count,char from,char temp,char to){
    time++ ;
    //有人让我将count个圆盘，从from经过temp移动到to去
    //这个有点难，我不一定会
    //如果只有1个圆盘，我就会
    if(count == 1){
        //System.out.printf("将【%d】号圆盘，从【%c】放到【%c】\n",count,from,to);
    }else{
        //我就不太会
        //如果有人能将count-1个圆盘移走
        move(count-1,from,to,temp);
        //我只移动最后那一个圆盘
        //System.out.printf("将【%d】号圆盘，从【%c】放到【%c】\n",count,from,to);
        //这个人再将刚刚移走的那count-1个圆盘在一回来
        move(count-1,temp,from,to);
    }
}
```

> **案例3： 文件夹删除与复制**

要删除文件夹a

如果文件夹a中有内容，就需要先删除a中的内容

a中有文件和文件夹

文件噶一下就删除

文件夹的删除（递归）

# 2021-09-09

## 9 归并排序

* 归并排序就是将2个有序数列合并成1个有序数列

* 所以如果要对一个数列进行归并排序，需要将其分成2个数列
  * 分治思想
* 这2个数列要求有顺序，才可以归并
* 所以需要对这个2个数列先进行排序——**递归**
  * 一开始有一组乱序数列
  * 将其一分为2  两个数列
  * 这2个数列也是乱序的
  * 要想归并，就需要对2个数列分别进行排序

<img src="images/21090901.png" style="zoom:80%;" />

<img src="images/21090902.png" style="zoom:80%;" />

```java
public static void main(String[] args) {
    int[] nums = {6,8,3,9,1,4,14,5} ;
    System.out.println( Arrays.toString(nums) );
    sort(nums);
    System.out.println( Arrays.toString(nums) );
}


public static void sort(int[] nums){
    //要使用归并排序
    //先拆分成2个子数列
    if(nums.length <2){
        //不需要拆分，也不需要排序
        return ;
    }

    //需要拆分
    /*
        长度/2就是中间位置
        长度是10 下标范围0-9  中间位置10/2=5   左侧0-4 长度5 右侧5-9 长度5=10-5
        长度是11 下标范围0-10 中文件位置11/2=5 左侧0-4 长度5 右侧5-10 长度6=11-5
     */
    //中间位置的下标（指针）
    int mid = nums.length>>1 ;
    int[] left = new int[mid] ;
    int[] right = new int[nums.length-mid];
    System.arraycopy(nums,0,left,0,left.length);
    System.arraycopy(nums,mid,right,0,right.length);

    //是不是就可以归并了？
    //不可以
    //归并的前提是2个子数组都必须有序
    //归并前要先对2个自数字排序
    //如何对left排序呢
    //发现好像有一个排序算法，他应该能排序
    sort(left);
    sort(right);

    //此时left和right就都有序了
    //对left和right进行合并
    //还需要一个大数组，恰好就可以用nums
    merge(left,right,nums);
}

public static void merge(int[] left , int[] right , int[] target){
    //左数列指针
    int l = 0 ;
    //右数列指针
    int r = 0;

    for(int i=0;i<target.length;i++){
        //每次都要想target中放一个元素
        //只不过这个元素是left的还是right的需要比较
        if(l==left.length){
            //l越界，说明left元素已经都进入target
            //只需要放置right
            target[i] = right[r++];
            continue ;
        }
        if(r==right.length){
            //r越界，说明right元素已经都装进target
            //只需要放置left
            target[i] = left[l++] ;
            continue ;
        }

        if(left[l] <= right[r]){
            //左边的小
            //将左边的元素放置到target中
            target[i] = left[l++] ;
        }else{
            //右边的小
            //将右边的元素放置到target中
            target[i] = right[r++] ;
        }

    }
}
```

**总结：**

* 时间复杂度  O(nlogn)
* 空间复杂度  O(nlogn)
* 稳定性   稳定排序

**优化：**

* 一种优化方式：不拆成一个一个子数组，利用下标标记子数组范围，最终合并在一个新的数组中

  此时空间复杂度 O(n)

* 另一种优化方式：不拆成一个一个子数组，利用下标标记子数组范围，最终在当前数组中进行数据交互

  此时空间复杂度 O(1)

# 2021-09-10

## 10 快速排序

* 将一个数列中的每一个数字快速的找到其应该存在的位置
* 以数列中的一个数字为基准
* 将比其小的数字都放在左侧
* 将比其大的数字都放在右侧
* 最终空出来的那个位置就是当前数字应该在的位置。
  * 此时当前这个基数放置到位置就是排序后的位置
  * 其他的数字依然没有顺序
  * 但是有一个特点，大的都在右侧，小的都在左侧
* 如果有人能将基数左侧的数列排序，将右侧的数列排序
* 整个数列就都有顺序了
* 我们可以继续使用快速排序方式——**递归。**

<img src="images/21091001.png" style="zoom:80%;" />

```java
public static void main(String[] args) {
    int[] nums = {6,8,3,9,1,4,14,5} ;
    System.out.println(Arrays.toString( nums )  );

    sort(nums,0,nums.length-1);

    System.out.println(Arrays.toString( nums )  );
}

public static void sort(int[]nums,int start,int end){
    if(start >= end){
        return ;
    }
    //使用快速排序
    //找到第一个数，排序后的位置
    int base = nums[start] ;
    int low = start ;
    int heigh = end ;
    //引动指针，以base为基准，将小的数靠左放，大的数靠右放，先从高位找小的数
    while(low < heigh){
        //按照现在的逻辑，先从高位找
        if(nums[heigh] < base){
            //就将当前nums[heigh]数放置到左侧空位置
            nums[low] = nums[heigh] ;
            low++;
            //break,continue
        }else{
            //当前高位的这个数比基数大
            heigh-- ;
            continue ;
        }

        while(low<heigh) {
            //在高位找到了比base小的数，并已经放置到了左侧的空位置
            //应该从低位找大的数据
            if (nums[low] > base) {
                nums[heigh] = nums[low];
                //将低位数放置到高位置，低位有空位置，准备从高位找小的数据
                heigh--;
                break ;
            } else {
                //当前低位的这个数比基数小，继续向上找
                low++;
                continue;
            }
        }

    }
    //循环结束， low==heigh
    nums[low] = base ;
    sort(nums,start,low-1);
    sort(nums,low+1,end);
}
```

**总结：**

* 时间复杂度：O(nlogn)
* 空间复杂度：排序过程中利用的辅助空间
  * 快速排序没有利用辅助空间，内部排序，空间复杂度应该是O(1)
  * 因为快速排序会使用递归，递归会占用栈空间 O(logn)    最差O(n) 完全逆序
* 不是稳定排序

# =======面向对象=======

# 2021-09-16

## 1 面向过程 和 面向对象

* 面向过程：更关注的是一个业务的执行过程，在这个过程中，都需要实现哪些功能，就按照需求编写哪些函数
* 面向对象：也需要关注一个业务的执行过程，只不过会在此基础上，还要关注业务过程中每一个功能的执行者是谁。

## 2 面向对象的概念

* 万物皆对象
* 案例：素拍黄瓜
  * 面向过程： 买黄瓜-洗黄瓜-拍黄瓜-拌黄瓜
  * 面向对象：谁买黄瓜，从谁那里买黄瓜，谁洗黄瓜，用什么洗黄瓜。谁拍黄瓜，用什么拍。。。
  * 问：我拍黄瓜，用刀拍。 这个黄瓜到底是谁拍的呢？
* 这里又会涉及到另外的一个很重要的问题，对象之间的关系，我和刀之间存在一种 依赖关系
* 总结：
  * 简单来说，所谓的面向对象就是在面向过程的基础上，为过程中的每一个操作指定一个具体的执行者（对象）
  * 要想更好的实现面向对象的编程，要从一下3方面入手： OOA,OOD,OOP
* 通过上述分析，要进行面向对象的编程，在了解业务过程的基础上，需要先产生对象
  * 对象怎么来的？	创建**对象**
  * 怎么创建对象呢？ 使用 new关键字 + 指定对象特点的**模板**
  * 这个模板又是什么呢？  就是一个**class**类， 类模板中存储在和某一类对象所具有的功能(方法)和特征(属性)
    * 秘书 ： 就是一个概念，是一群**具体的秘书人**的一个统称
    * 秘书需要具备一定的特征： 人，年龄，性别，身高，学历，专业，外貌
    * 秘书有什么业务能力，沟通能力，服务能力，编码能力
* 这个类为什么会包括这些特征和方法呢？主要是从以往的经验中和未来的需求中，抽取出与此次应用相关的一些特征和功能，这个(脑海)抽取的过程——**抽象**

## 3 定义类

```java
//我想去旅游，去哪：去铁岭
//我怎么去铁岭：开车去，坐火车去，坐飞机去，腿去
//我们选择开车去
//如果要开车去，需要先有一辆车，车是个什么东西：对象
//创建汽车对象
//要想创建汽车对象
//先有一个汽车的模板
//写一个汽车了
class Car{
    //类模板中需要包含汽车的一些特征（变量）和功能（方法）
    //所谓的特征 就是变量，  特征其实就是一个信息，了解对象特征就是获得对象的信息，要获得信息就需要先存储信息，用一个变量存储信息
    //所谓的功能 就是方法
    
    //作为汽车我们都有哪些关心的特征呢   汽车品牌，颜色，价格，size(长，宽，高)，排量。。。
    String name ;
    String color ;
    double price ;
    int height ;
    int width ;
    int length ;
    int autoSpeed ;
    
    //作为汽车我们都有哪些关心功能呢 自动驾驶 。。。
    public void run(){}
    
    public void autoRun(){
        if(autoSpeed == 0){
            System.out.println("不具备自动驾驶功能");
        }else{
            System.out.println("时速【"+autoSpeed+"】在自动假设");
        }
    }
    
    public void stop(){}
    
}
```

* 模板不是对象
* 会根据模板创建对象，返之，创建出来的对象符合模板表现的特点
* 可以根据模板创建多个对象
* 不同的对象，有相同的特征，比如都有颜色特征，但细节不同。
* 不同的对象，有相同的功能，比如都能自动驾驶，但细节不同，30，80
* 扩展： 对象的方法中，可以使用对象的变量
  * 原来我们的变量都是在方法中定义的，称为**局部变量**。只能在当前方法中使用，换一个方法就不能用了
  * 现在类中的变量相当于方法外的变量，称为**成员变量**，是类对象一部分，一个成员。可以被类中的所有方法使用。 不能称为全局变量
  * 类中的方法称为**成员方法**
* 注意：**暂时类模板中定义的方法不能使用static关键字**

## 4 创建对象

```java
Car car = new Car();
```

* 至此，按照需求，我们就完成了一个对象的创建
* 并且将这个对象存储在了变量中
* 未来我们就可以通过变量找到我的对象，就可以使用对象了

## 5 使用对象

* 从编码而言，所谓的使用对象，其实就是使用对象中的变量和方法

* 原来是如何使用变量和方法

```java
int age ; 
age = 18 ;	//存
System.out.println( age ); //取

public void sum(int num1,int num2){}
sum(10,20); //调用方法
```

* 现在又了对象之后，我们要如何使用对象的变量和方法呢

```java
car.color = "red" ;
System.out.println( car.color );

car.autoRun();
```

# 2021-09-17

## 6 对象创建及调用过程

* 本节课内容不需要大家掌握（有一定难度）

### 1） 类加载

* 我们根据需求编写的类并不存在于jvm中，存在于磁盘的文件里

* 但new关键字创建对象的过程是在jvm中执行，并且还要参照class模板

* 就需要在jvm中也有类信息

* jvm会在创建对象时，根据需求，将.class文件中的类信息（模板）加载到jvm中——**类加载**

  * 类加载是在创建对象时发生，不是在运行程序时就发生的。

  <img src="images/21091701.png" style="zoom:80%;" />

### 2） 创建对象

* jvm一旦看到了new关键字，就会在堆空间开辟一块区域，准备用来存储对象的内容，同时为这块区域分配一个地址（内存地址）
  * 划分空间的时候，这个空间的大小就已经确定了
  * 根据加载的类模板，就可以知道对象空间大小
* jvm会根据new关键字后面的 类的构造器( Car() ) 找到对应的模板
* 会根据模板创建对象
  * 所谓的创建对象，就格式根据类模板中设置的对象状态
  * 在刚刚划分的jvm内存中，开辟子空间存储状态变量及值
    * 在刚刚创建这个变量空间时，jvm统一为变量赋予一个默认值 0

* 至此对象创建完成，我们要了解2点：
  * **第一：**从内存而言，对象创建完成。从应用而言，还没有完成，**还需要初始化**(执行构造器代码)。通过初始化为刚刚划分的变量空间赋予了我们代码指定的值
  * **第二：**我们划分的对象空间中只有变量存储，没有方法存储
* 对象创建完成后，为了后面使用的对象，将对象（的地址）赋值给一个变量。未来可以通过这个变量获得对象的地址，从而找到这个对象，从而可以使用对象的内容（变量）

![](images/21091702.png)

### 3） 调用对象的方法

* 根据上面的对象的内存图，在堆中划分空间中，存在对象的变量
* 所以`car.name`可以获得变量的值，可以从图中清楚可知
* 但图中没有存储方法内容
* 那`car.run()`如何调用的呢？
  * 随着jvm加载class文件内容
  * class模板中的方法也会存储在方法区
  * 创建对象时，方法不会出现在堆空间中
  * 调用方法时
    * 首先会根据car变量中地址找到对象空间
    * 根据对象空间，可以找到对应的类模板
    * 在根据car.后面指定的方法run()，就可以找到类模板中run方法的内容
    * 在字节码中，run方法就是一组执行指令。
    * 所以所谓的调用方法，就是在jvm栈中创建一个栈帧，在栈帧中按照run方法的执行指令执行操作
* 综上总结： 
  * 我们可以根据class模板创建多个对象。每个对象的空间中都会装有变量来存放对应的状态值
  * 当调用对象的方法时，都是最终找到类模板中的方法指令，在栈帧中执行
  * 那有一个问题： **既然不同对象的方法执行，都来自同一个方法指令，在方法执行时如何区分到底是哪一个对象在执行方法，如果方法中使用了对象的变量，如何确定使用的是哪个对象的变量呢？**

```java
public class Car {
    String name = "bmw" ;
    String color ="red";
    double price = 300000;
    public void run(){
        System.out.println(name+"嗷嗷开");
    }
    public void run(int speed){}

    public void stop(){}
}
```

```java
public static void main(String[] args) {
    //按照需求，我需要使用一个汽车对象的内容
    //所以就需要先创建一个汽车对象
    //要想创建对象，就要先设计一个class模板

    Car car = new Car();
    //我知道有一个变量叫name ，如何获得name的值
    //现在的问题是，这个变量name不是一个独立变量，他是对象的变量
    //怎么使用对象的变量呢

    Car car2 = new Car();
    car2.name = "benz";
    car.run();
    car2.run();

}
```

# 2021-09-23

## 7 构造器

### 1） 概念

* 构造器又称为构造方法，构造函数
* 是在创建对象的时候调用的一个特殊的方法
  * new Car()

### 2） 语法

1. 方法名必须和类名相同  

   普通方法的名字也可以与类名相同。

2. 没有返回类型  （没有返回类型  != 没有返回值）

   void sum(){}	 普通方法 

   Car(){}				构造方法

3. 不允许使用static（，final，abstract等）关键字修饰

4. 其余都与普通方法一致 （访问修饰符，参数列表，异常声明）

5. 只能在new关键字后面被调用

```java
class Car{
    String cname = "benz" ;
    
    public Car(){
        //jdbc 从数据库获取数据，redis,...
        cname = "bmw" ;
        System.out.println(1);
    }
    
    public void Car(){
        System.out.println(2);
    }
     
}

Car car = new Car(10,20,30);
car.Car(10,20,30);
```

### 3） 作用

* 为成员变量初始化
* 用来设计一些创建对象时的初始操作

### 4） 构造方法与普通方法的使用

* 普通方法直接调用

  ```java
  public static void sum(int num1,int num2){
  	
  }
  
  sum(10,20);
  ```

* 构造方法通过new关键字调用

  ```java
  new Car();
  ```

### 5） 构造方法重载

* 与普通方法一样，构造方法也可以存在重载

  * 方法重载：多个方法的名称相同，参数列表不同，执行不同的操作，与其他内容无关

    ​					参数列表不同体现在参数的个数和类型不同，顺序不同 

* 在使用new关键字创建对象时，调用构造器，通过传递不同的参数，指定调用不同的构造器

```java
public static void sum(int num1,int num2){}
public static void sum(int num1,int num2,int num3){}
sum(10,20);
sum(10,20,30);

class Car{
    String cname ;
    
    public Car(){
        
    }
    
    public Car(String cname1){
        cname = cname1 ;
    }
    
}
new Car();
new Car("bmw");
```

### 6） 构造器之间的调用

* 首先普通方法可以调用重载方法

  ```java
  public static void sum(int num1,int num2){
     sum(num1,num2,0);
  }
  public static void sum(int num1,int num2,int num3){
      (num1 + num2 + num3) * 0.8;
  }
  
  sum(10,20);
  sum(10,20,30);
  ```

* 构造方法也可以调用重载方法

  ```java
  class Car{
      String cname ;
      String color ;
      
      public Car(){
         // Car("大众","black"); //不能够调用到重载构造器，语法没有错误，会调用普通方法
          this("大众","black")
      }
      
      public Car(String cname1){
         // new Car(cname1,"white");//语法没有错误，而且重载方法确实可以被执行，但不属于重载调用
         this(cname1,"white"); 
      }
      
      public Car(String cname1 , String color){
          cname = cname1 ;
          color = color1 ;
      }
      
      public void Car(String cname1,String color){}
      
  }
  Car()
  new Car("bmw","粉色") ;
  new Car("benz") ;
  new Car() ;
  ```

* **注意：**

  * 构造器之间的调用，不能直接使用构造器的名字，因为那样调用的实际上是普通方法
  * 构造器之间的调用，也不能使用new关键字.
    * 虽然在结果上好像是可以，因为另外要调用的那个构造方法确实执行了
    * 但是底层机制却不同
    * 因为使用new关键字，是可以调用构造方法，但同时也会产生对象
    * 我们要使用无参构造器创建一个对象，结果创建对象时又使用了有参构造器创建了一个新对象
    * 会出现2个对象， 不符合需求
    * 我们创建的对象依然是通过无参构造器创建的。
  * 构造器之间的调用必须使用this关键字表示
    * 在构造器中 this(...) 表示调用重载的构造器 （最终只会创建一次对象）
    * 我们使用了无参构造器创建对象，无参构造器最终调用了有参构造器来创建这个对象。



# 2021-09-24

## 8 this关键字

* this关键字可以在类对象的方法中使用，可以理解成一个内置的变量

* 变量存储的是当前对象的引用，表示当前对象。

* 可以通过this访问当前对象的成员（成员变量-属性，成员方法）

  * 默认情况下，在方法中不是this也可以使用当前对象的属性和方法

* 从上面的内容可知，某些情况下，使用this和不使用this都可以访问当前对象的内容（属性，方法）

* 那什么情况下，必须使用this呢

  1. **当方法中要使用的成员变量和局部变量同名时，必须使用this指定哪一个是成员变量**

     ```java
     String name ;
     public Car(String name){
         //默认按就近原则使用变量
         this.name = name ;
     }
     
     Car car = new Car();
     car.name ;  this.name ;
     car.t1();   this.t1();
     
     ```

  2. **在某一个构造方法中调用重载的构造方法时，必须使用this关键字实现调用**

     ```java
     class Car{
         public Car(){
             //Car("bmw","red");
             //new Car("bmw","red");
             this("bmw","red");
         }
         
         public Car(String name){
             // Car(name,"red");
             this(name,"red");
         }
         
         public Car(String name,String color){
              System.out.println(name,color);
         }
         
         public void Car(String name,String color){}
     }
     ```

* **对象的创建过程及this特点**

<img src="images/21092401.png" style="zoom:80%;" />

## 9 构造器底层初始化过程

* 构造器的一个主要作用就是为成员变量初始化

* 成员变量的初始化赋值会分为3次

  1. 使用new关键字在堆中开辟空间，并根据后面调用的构造器，找到方法区中的类模板，类模板中有变量信息，就可以根据变量的信息在刚刚开辟的对象空间中，划分出两个区域准备存储变量的值。同时为这2个区域赋予类型的默认值（String-null， int-0）

  2. 通过new关键字最终开辟对象空间后，就要准备调用构造器执行初始化操作。 此时构造器中执行的初始化代码并不仅仅是编写时写的，而且定义属性变量时，如果指定了初始值，这个初始值的赋值过程也会被加入到构造方法中

     ```java
     class Car{
         String name="bmw" ;
        
         public Car(String name){
             this.name = name ;
         }
         
     }
     
     Car car = new Car("benz") ;
     car.name ; // bmw? benz?
     
     //在javac编译时，会将name="bmw"这个赋值代码也加入到构造器中
     public Car(String name){
         name="bmw";
         //--------------------
         this.name = name ;
     }
     ```

  3. 最后会执行构造器中我们编码时体现的赋值操作。最终完成成员变量的初始化。

```text
{
  java.lang.String name;				//类模板中有一个变量信息
    descriptor: Ljava/lang/String;
    flags:

  java.lang.String color;				//类模板中有一个变量信息
    descriptor: Ljava/lang/String;
    flags:

  public com.test.Car();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: ldc           #2                  // String bmw
         7: putfield      #3                  // Field name:Ljava/lang/String;
        10: aload_0
        11: ldc           #4                  // String red
        13: putfield      #5                  // Field color:Ljava/lang/String;
        16: return
      LineNumberTable:
        line 21: 0
        line 18: 4
        line 19: 10
        line 21: 16
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      17     0  this   Lcom/test/Car;

  public com.test.Car(java.lang.String);
    descriptor: (Ljava/lang/String;)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         
         // this.name="bmw" 定义变量时指定的初始值赋值
         4: aload_0   this
         5: ldc           #2                  // String bmw
         7: putfield      #3                  // Field name:Ljava/lang/String;
        
        //  color="red"  定义变量时指定的初始值赋值
        10: aload_0
        11: ldc           #4                  // String red
        13: putfield      #5                  // Field color:Ljava/lang/String;
        
        // 构造器中自定义的代码  this.name=name 
        16: aload_0		this
        17: aload_1     临时变量name的值
        18: putfield      #3                  // Field name:Ljava/lang/String;
        
        // 构造器中自定义的代码  System.out.println("----------------");
        21: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;
        24: ldc           #7                  // String -----------------
        26: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        29: return
      
      LineNumberTable:
        line 23: 0
        line 18: 4
        line 19: 10
        line 25: 16
        line 26: 21
        line 27: 29
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      30     0  this   Lcom/test/Car;
            0      30     1  name   Ljava/lang/String;


```

# 2021-09-30

## 10 方法调用执行过程详解

### 1） 方法内部执行过程

* 方法被调用时，会在栈空间产生一个栈帧，栈帧存储方法执行过程中的一些信息

![](images/21093001.png)

<img src="images/21093002.png" style="zoom:80%;" />

### 2） 对象方法的调用

* this关键字是对象方法内置的一个变量，存储的就是对象的地址
* 对象属性的定义是在创建对象时就产生了空间。但对象属性的复制，是在创建对象空间后，在执行构造器时才进行的属性赋值。定义属性同时的初始化赋值int a1=10 ,在javac编译时，会被调整至构造器。

<img src="images/21093003.png" style="zoom:80%;" />

* 对象方法的代用

```java
class A{
    int a1 = 10 ;
    int a2 = this.a1 ;

    public A(){
        System.out.println("-----------------");
    }

    //对象方法
    public void t1(){
        System.out.println(this.a1 + this.a2 );
    }

    public static void main(String[] args) {
        /*
            1. 主方法中new关键在堆空间创建了一个对象
            2. 方法中定义了一个a变量，存储在主方法栈帧的局部变量表中
            3. 将创建变量的地址赋值给了a变量 （a变量存储的就是地址）
            4. 调用a.t1()
                表示要用a这个变量中的内容
                要用就需要从局部变量表压入操作数栈
                根据t1方法图纸，再次产生了t1方法的栈帧。
                这个t1方法图纸不属于某一个对象
                执行方法时，怎么知道执行的是哪个对象的t1方法呢
                主方法在调用t1方法时，会将刚刚a变量中的地址传递给t1方法
                t1方法会有一个默认的参数(第一个参数），就是this，存储的就是当前的对象地址
         */
        A a = new A();
        A a2 = new A();

    }
}
```

![](images/21093004.png)

<img src="images/21093005.png" style="zoom:80%;" />

# 2021-10-08

## 11 static关键字

### 1） 修饰成员变量

* **成员变量与局部变量**

  * 类中定义的变量称为成员变量，成员属性
  * 方法中定义的变量称为局部变量

  ```java
  class A{
      //成员变量
      int num ;
      
      //静态成员变量，静态变量
      static int num2 ;
      
      public void t1(){
          //局部变量
          int num ;
      }
      
      public void t2(){
          System.out.println(num2);
      }
      
      public void t3(){
          num2 = 20 ;
      }
      
      //静态方法
      public static void t4(){
          
      }
  }
  ```

* **类属性和对象属性** （类成员和对象成员， 类属性和实例属性）

  * 没有使用static关键字修饰的属性 称为对象属性（实例属性）。**对象属性必须创建对象后，通过对象才能调用**，**并且每个对象都有独立的对象属性**

    ```java
    A a1 = new A();
    a1.num = 10 ;
    
    A a2 = new A();
    System.out.println(a2.num); // 打印 0 , a1的num对a2的num没有影响，各自玩各自的
    ```

  * 使用static关键字修饰的属性 称为类属性。 不需要创建对象，**可以直接使用类名调用**。无论创建了多少个对象，静态属性只有一份，**所有对象都可以共享这一份属性**

    ```java
    A.num2 = 10 ;
    
    A a1= new A();
    A a2 = new A();
    a1.t3();
    a2.t2(); // 打印 20  a1调用t3方法时为num2变量赋值，对a2对象调用t2方法时产生了影响，用的是同一个属性
    ```

* 总结： 未来如何选择普通属性还是静态属性呢？

  * 一般我们的思考方向就是  这个属性数据时对象独享还是对象共享。

### 2） 修饰成员方法

* 使用static关键字修饰的方法 就称为 静态方法，也叫类方法。 **不需要创建对象，可以直接使用类名调用**

  `A.t4();`

* 没有static关键字修饰的方法 称为 普通方法，也叫对象方法，实例方法。必须创建对象，才能调用

  `A a = new A()`

  `a.t1();`

* 与属性不同，无论是静态方法还是普通方法，在内存中都只有一份存储空间（ 类加载的时候）

* **我们如何思考是使用静态方法还是使用普通方法呢？**

  1. 只有普通方法才能使用对象的属性(和this关键字)。有些功能(方法)的实现与对象的属性数据息息相关

     例如一个Person有各自的一些信息（年龄，性别，姓名）

     person还有一个功能（方法）自我介绍。介绍的一定是当前对象自己的属性信息，这就要求这个方法必须能调用对象的属性，所以应该是一个对象方法。

  2. 如果功能方法实现的过程中不需要使用对象独有的属性，理论上普通方法和静态方法都可以。那普通方法还需要创建对象才能用，而静态方法可以类名直接调用，更简单。（工具类中的方法静态的多—Math）

* **为什么只有对象方法才能使用对象的属性，而静态方法为什么就不能呢？**

  * 简单理解：静态方法又称类方法，属于类，有类不一定有对象（有对象就一定有类）。 而this关键字表示的是对象的地址，没有对象，哪来的地址。对象属性的前提也要先有对象。

  * 底层理解：

    * 调用对象的属性和方法时，都会将对象的地址压栈（栈帧——操作数栈）。 对象地址是哪里来的呢？

      ```java
      class A{
      
          int num1 ;
      
          public  void t1(){
              System.out.println(num1);
          }
          
          public static void t2(){}
      }
      ```

      ```text
      javap -v A.class
      
      public void t1();
          descriptor: ()V
          flags: ACC_PUBLIC
          Code:
            stack=2, locals=1, args_size=1//这个方法获得了一个参数就是默认的this 就是下标为0的参数
               0: getstatic     #2                 //获得System.out 
               3: aload_0					         //将对象地址压入操作数栈顶				
               4: getfield      #3                  // 获得刚刚压入栈顶对象的num1属性
               7: invokevirtual #4             //调用out.println()     
              10: return
      ```
    
      
    
    * 一定有一个地方使用new关键字创建了对象（一般是主方法），就会产生一个地址。调用对象的方法时，就会产生一个栈帧(jvm栈里），并按照t1方法指定的代码逻辑(方法区)，准备执行方法。同时会将当前这个a中的地址作为参数默认传递给t1方法，t1方法中使用一个默认的this来接收这个参数。this就表示默认传递的第1个（0）参数，aload_0就相当于加载地址
    
      ```java
      public static void main(String[] args) {
          //产生一个地址，并将地址存入a变量
          A a = new A();
          //调用了a对象的方法
          //从编码上看是调用t1方法，没有传递参数。但在jvm底层，会将a变量中的地址传递给t1方法
          //t1会有一个默认的形参this，用来接收这个地址
          a.t1();
      }
      ```
    
    * 如果使用的是静态方法，直接通过类名调用，此时就不会传递对象地址，静态方法中也不需要提供一个默认的形参(this)
    
       ```text
       javap -v A.class
       
       public static void t2();
          descriptor: ()V
          flags: ACC_PUBLIC, ACC_STATIC
          Code:
            stack=0, locals=0, args_size=0	//没有参数  静态方法不接收对象地址
               0: return
       ```
       
       
    
    <img src="images/21100801.png" style="zoom:80%;" />

# 2021-10-09

### 3） 修饰代码段

* 定义类时，除了可以定义属性和方法外，也可以定义代码段

  ```java
  class A{
      int num ;
      
      public void t1(){}
      
      {}
      
      static int num2 ;
      static{}
      public static void t2(){}
  }
  ```

* 使用static关键字修饰的代码段就称为静态代码段

* 代码段有什么作用呢？

  * 普通代码段我们一般很少用
  * 静态代码段偶尔会遇见，类加载时执行且仅执行一次。 比如：读取配置文件

* 类和对象的初始化

  * 要想更好的了解代码段作用和特点，我们先需要了解2个初始化方法

  * **对象的初始化方法**

    * 从编码而言，对象的初始化方法就是构造方法

    * 但实际上，我们创建对象时，会通过new关键调用构造器方法，在编译后会变成如下效果

      `new A()` -->编译成字节码后就变成了 --> `A + init()`

      jvm执行时，遇见new关键字就会在堆区中开辟存储空间，并分配内存地址

      jvm会根据类名，找到对应的类信息，并根据类信息在刚刚开辟存储空间中划分属性变量的存储区域

      jvm才会调用init()初始化方法，为属性赋值

  * **类初始化方法**

    * 在编译时，会为类也生成一个初始化方法 `clinit()`，前提是我们设置了静态属性
    * 在类加载完毕后，jvm会自动的调用这个初始化方法

    <img src="images/21100901.png" style="zoom:80%;" />

  * 在javac编译时，会将代码段中的代码编译到各自初始化方法中。

    * 如果初始化方法中本身就有代码（构造器）

    * 代码段中的代码会编译到初始化方法本身代码的上面。

      <img src="images/21100902.png" style="zoom:80%;" />

    * 因为我们可以编写构造方法，所以写代码段和写构造方法相同，一般就不写代码段了
    * 但我们不能写静态初始化方法，所以如果有想在静态初始化方法中执行的代码，就只能写在静态代码段中了。

## 12 类和对象的初始化过程

### 1） **类初始化过程**

1. 类加载： 将class文件内容加载到jvm内存空间，并为这一堆二进制内容创建一个对应的Class对象

2. 链接：

   * 验证 ： 验证字节码是不是符合要求。

     **idea查看class文件二进制插件： binED**

   * 准备： 会根据类模板为静态变量划分存储空间 （存储一个默认值0,false,null）

   * 解析

3. 初始化： 调用类的初始化方法`clinit()` 在初始化方法会实现声明变量时赋值

### 2） **对象初始化过程**

new A()

1. 根据new关键字，jvm会在堆区开辟存储空间并分配内存地址
2. 根据new指定的类，找到类模板，根据类模板中属性的定义，会在刚刚开辟的存储空间中为属性分配存储区域，并赋予默认值（0,null)
3. 执行初始化方法（普通代码段中的代码 和 构造方法中的代码），一般会为属性赋值

* 类的生命周期

  类加载 -- 验证 -- 准备 -- 解析 -- 初始化 -- 通过类创建对象（1,2,3） -- 卸载
  
  <img src="images/21100903.png" style="zoom:80%;" />

# 2021-10-14

## 13 继承

### 1） 基本特点

1. **两个类之间，使用extends关键字实现继承**

   ```java
   class A{
      int num ;
       
       public void t1(){}
   }
   
   class B extends A{
       String name ;
       
       public void t2(){
           
       }
   }
   
   B b = new B();
   b.num = 10 ;
   b.t1();
   ```

   * 上述代码我们称为  `B类 继承了 A类`，也可以称为  `B类 扩展自 A类`
   * A类称为：父类，基类，超类
   * B类称为：子类，衍生类，派生类

2. **通过继承，子类可以自动拥有父类的属性和方法**

   * 例如在父类中定义了属性和方法，在子类中什么都没有定义，就可以通过子类对象使用属性和方法，这些属性和方法就是从父类继承过来的。
   * 子类不能继承父类的构造方法 （可以调用父类的构造方法）
   * 子类可以继承父类的所有成员（属性，方法，公有，私有），但不能访问私有成员。

3. **子类可以在父类的基础上在扩展自己的属性和方法**

4. **继承具有传递性和不可以逆性**

   `C extends B extends A` : 

   * B中有A的成员，C中也有A的成员——传递性
   * C中可以有B的成员，但B中不能有C的成员

5. **java只支持单继承**

   C extends A

   C extends B  错误

   ----

   C extends A

   B extends A

6. **继承的意义： 代码复用，结构设计，多态控制**

### 2） 对象的构建

1. 子父类是相对而言的，不是绝对的。我们在介绍B类的时候，可以顺道说一下的他的父类A。但是在介绍A的时候有，就是独立的一个A。

2. 所以当我们创建一个A对象和一个B对象的时候，记住，两者没有关系

   ```java
   A a = new A();
   
   B b = new B();
   ```

3. **创建子类对象的内存过程：**

   new B() -->  B + init()

   1. 根据new关键字，在堆区开辟一块内存空间

   2. 根据构造器所指定的类路径找到对应的模板，找到模板后就能知道有哪些属性了

   3. 由于现在B继承了A，所以找到B的模板后，不能马上处理B的属性，需要根据继承找到父类A的模板

   4. 然后先处理A的属性，会在刚刚开辟的内存空间中，分配区域存储父类A的属性

   5. 再根据B类的模板，处理B的属性，在刚刚开辟的内存空间中，分配区域存储子类B的属性

   6. 再调用子类的B的初始化方法init()

   7. 只不过在编译时，会在子类初始化方法的第一行增加一个调用父类初始化方法的指令

      new -> A属性处理->B属性处理->ainit->binit

      <img src="images/21101401.png" style="zoom:80%;" />

   * 总结：

     在具有子父关系的情况下，创建子类对象时，在内存中只会产生一个对象，是没有独立的父类对象

     但也存在父类信息的存储空间（子类对象空间中）

4. 可以使用工具类**ClassLayout**查看一下对象的内存结构（查看对象大小）

   * 需要额外引入jol.jar

     ![](images/21101402.png)

# 2021-10-15

### 3） 重写

* 这里所说的重写使我们在编码上将父类的属性和方法在子类中再写一遍。从java的知识内容上并没有属性重写的概念。

  ```java
  class A{
      int num ;
      public void t1(){
          System.out.println("---------------");
      }
  }
  
  class B extends A{
      int num ;
      
      public void t1(){
          System.out.println("===============")
      }
  }
  ```

* **属性重写（隐藏）**

  * 就是在子类中写一个与父类属性同名的属性。类型无所谓

  * 重写后，原来的属性依然存在在子类对象的内存中，只不过不能直接访问了，相当于隐藏起来

  * 如何重新使用被隐藏的属性呢？

    * 在对象内部可以使用super关键访问
    * 在对象的外部，可以利用上转型访问

    ![](images/21101501.png)

* **方法重写（覆盖）**

  * 简答来说，就是在子类中写一个与父类方法结构相同的方法

  * 更全面点说，方法重写不一定要和父类的方法结构完全一样，具体的概念如下：

    在子父类关系中，子类的方法名称，参数列表与父类方法相同，就称为方法的重写

    ​	同时子类方法的访问权限要大于父类方法的访问权限

    ​	子类方法声明的异常类型和数量要小于父类方法声明的异常类型和个数

    ​	子类方法的返回类型 要小于 父类方法的返回类型

  * 注意：**static静态方法不存在重写**

    * 情况一，从编码上似乎是实现了一个static方法的重写，但实际上并不符合重写的特点。**没有错**

      ```java
      class A{
          public static void t1(){}
      }
      
      class B extends A{
          public static void t1(){}
      }
      ```

    * 情况二，从编码上用非静态方法 重写 静态方法 （反之），**此时会报错**

      ```java
      class A{
          public void t1(){}
      }
      
      class B extends A{
          public static void t1(){}
      }
      ```

      

  * **方法的重写被称为方法的覆盖**

    1. 类加载时，字节码（类信息）的内容会被加载的jvm中（方法区，元空间）

    2. 会根据二进制内容产生一个类模板对象Class，用我们更熟悉的结构来表示二进制内容

       读取二进制内容时，就可以知道二进制内容表示的类信息中都表示了什么名字呀，什么属性呀，什么方法呀

    3. 当解析到方法时，就会将其存储在一个特定的方法空间中，并未每一个方法分配一个对应存储地址
    4. 当加载子类时，理论上也是上面的一套操作，只不过在生成子类方法存储空间时，会先将父类方法的存储空间复制一份（继承），在根据二进制内容，处理子类的方法信息
    5. 每获得一个子类的方法信息时，就会与方法空间中父类继承的方法信息比较，如果没有重复，就增加一个新的方法信息(t3)
    6. 如果发现这个方法在从父类继承的方法信息中已经存在，就会将这个方法替换之前的方法。所以同一个地址m1，方法的已经不再是从父类继承的方法了，而是子类自己的方法
    7. 同时我们发现，在子类的方法空间中已经没有这个从父类继承的方法了，不是隐藏，而是覆盖
    8. 但我们要知道，在整个jvm框架中，父类的方法依然存在，所以可以通过super关键字方法父类的方法

  ![](images/21101502.png) 

# 2021-10-21

## 14 super关键字

### 1） super前置了解

```java
class A{
    int no ;
    
    public void t1(){}
}

class B extends A{
    int age ;
    
    public void t2(){
        
    }
    
}

new B();
```

![](images/21102101.png)

* 综上分析
* 正常情况下，不需要super关键字，就可以调用父类属性和方法
* 但是在某些情况下，我们无法通过对象调用父类的属性和方法
* 这个时候我们就需要使用super关键字。
* 在属性重写 和 方法重写时，就不能再通过子类对象来访问父类的属性和方法了

### 2） super关键字的作用

* **在子类的方法中，可以使用super关键字调用父类的属性和方法**

  * 在没有重写的情况下，是否使用super意义不大。（什么情况下必须使用super关键字）
  * `super.no`
  * `super.t1()`

* **在子类构造器中，使用super关键字调用父类的构造器。**

  * 在创建子类对象时，会先处理父类的属性信息

  * 所以也需要先执行父类的初始化方法

  * 但是在编码时我们只体现了对子类构造器的调用 `new B()`

  * 在编译时，编译器自动处理，会在子类构造器的首行调用父类的无参构造器

    * 注意：从方法调用顺序上，是先调用子类的构造器，在子类构造器又调用了父类的构造器

      ​		   从执行顺序上，是先执行父类构造器中的代码，再执行子类构造器中的代码。

  * 如果父类中存在重载构造器

    ```java
    public A(){}
    
    public A(int no){}
    ```

  * 默认情况下，编译器编译时默认调用的是父类无参的构造器

  * 问题来了，如果想要调用父类的有参构造器怎么办

  * 此时必须使用super关键字，并且在子类构造器首行使用。

### 3） 考题

```java
class A{
    int no = 10 ;
    
    public A(int no){}
    //此时编译器不会生成无参构造器
    
}

class B extends A{
    int no = 20 ;
    //子类没有写构造器
    //编译器会自动生成一个无参构造器 
    //在无参构造器会默认调用父类无参构造器
    //但父类没有，所以会出现编译错误 答案C
}

A b = new B();
System.out.println(b.no);

//输出什么?
A. 10
B. 20
C. 编译错误
D. 运行错误   
```

# 2021-10-22

## 15 多态

### 1） 多态特点

* java是一种面向对象的编程语言

* 面向对象有三个特征：封装，继承，多态

* 多态就是事物（对象），行为（方法）的多种表现形态

  * 老师 ， 英语老师，语文老师，体育老师

  * 在程序中如何体现多态呢

    1. 继承				英语老师，语文老师都是老师，都具有老师的一些行为和特征

    2. 方法重写        不同状态的老师具体的行为是不一样

    3. 上转型            英语老师，语文老师都是老师的不同形态，所以英语老师应该也算是一个老师

       ​						通过上转型就可以将英语老师当老师来用。

### 2） 上转型

* 在子父类关系的基础上

* 将子类对象的引用（地址）赋值给父类型变量，这个过程就称为：上转型

  ```java
  class A{}
  class B extends A{}
  
  A a = new B();
  
      
  public void t1(B b){
      A a = b ;
  }
  
  t1(new B());
  ```

  ![](images/21102201.png)

* 特点：
  * 上转型也就是将子类对象当成父类型对象使用。
  * 以为用的是父类型的对象，其实是子类型的对象
  * 所以调用属性和方法时，依然会在子类的内存空间中寻找要调用的内容
  * 如果调用的方法存在重写，以为调用的是父类型的方法，其实调用的是子类的方法。
  * 如果调用的属性存在重写，以为调用的是父类型的属性，其实调用的是父类型的属性。
* 简单总结一下上转型特点
  * 在具有属性和方法重写的情况下
  * 调用的方法是子类重写之后的方法
  * 调用的属性依然是父类隐藏的属性

### 3） 下转型

* 在上转型的基础上，将这个装入了父类型变量的中的子类对象地址，再赋值给子类变量

  ```java
  A a = new B();
  B b = (B)a ;
  ```

* 下转型的前提一定先做了上转型。

* 下转型编码时会存在这样的三种情况：

  1. =左右两侧的类型不存在子父关系，此时下转型会编译错误

     String s = (String)10 ;

  2. =左右两侧类型存在子父关系，但父类型变量中的地址其本质不是指定的子类型对象，此时会抛出类型转换异常

     ```java
     class A{}
     class B extends A{}
     class C extends A{}
     
     A a = new B();
     C c = (C)a ;
     ```

  3. =左右两侧类型存在子父关系，并且父类型变量中存储的地址的本质就是指定的子类型，正常转型。

# 2021-10-28

## 16 final关键字

* 可以修饰变量，方法，类

### 1） 修饰变量

* 称为常量(变量)，存储的值不能被改变

  * 常量：  常量值( =10  ,  =new Car() )  , 常量变量
  * 值不能被改变：
    * 变量中的内容不能发生更换
    * 如果变量是一个引用类型，变量中存储对象的地址（引用）
    * 此时常量的特点是不能更换另外一个对象的地址。但这个对象的内容可以更换。

* 变量包括：成员变量，局部变量，参数变量

  * final修饰成员变量时，必须在对象构建完成前，完成唯一的一次赋值

    ```java
    class A{
        final int i = 10 ;
        
        final int j ;
        {
            j = 20 ;
        }
        
        final int k ;
        public A(){
            k = 10 ;
        }
        
        /* 不允许
        final int m ;
        public void setM(int m){
            this.m = m ;
        }
        */
        
        public void t1(){
            System.out.println(i);
        }
    }
    
    ```

  * final修饰局部变量时，只要保证第一次使用前完成唯一的一次赋值即可。

    ```java
    public void t1(){
        final int i=20 ;
        final int j ;
        //2000 years later
        j=30;
        System.out.println(j);
    }
    ```

  * final修饰参数变量时，在方法调用时就已经完成了唯一的一次赋值。

    ```java
    public void t1(final int i,final int j){}
    ```

* **常量变量的使用在编译时的优化**

  * 在定义常量变量的同时就为其初始化赋值

  * 编译时，会对当前常量变量的引用部分的代码直接替换成常量值

    <img src="images/21102801.png" style="zoom:80%;" />

* **静态常量——对静态初始化影响**

  * 定义静态常量变量的同时就为其初始化赋值

    `static final int i = 10`

  * 当调用这个静态常量时，不会触发静态初始化。 因为会将常量的调用直接替换成常量值

  * 静态初始化：

    * 类加载的时候，会分为3个阶段  加载，链接，初始化

      * 加载，就是将字节码读取jvm上
      * 链接——验证， 验证字节码的结构是否正确
      * 链接——准备，根据类中的static属性定义，开辟静态属性的存储空间，并没有按照代码赋值。赋予了一个默认值（0，null）
      * 链接——解析

      * 初始化，就是根据类代码，为刚刚开辟的静态属性空间赋予指定的值，同时执行静态代码段

  * 什么情况下可以触发静态初始化

    1. 创建对象时
    2. 访问静态成员是时。 调用静态属性，调用静态方法
    3. 反射时

  * 反之，有些常见的情况并不会触发静态初始化

    1. 使用类定义变量
    2. 使用类定义泛型的时候
    3. 调用静态常量时

### 2） 修饰方法

* 称为最终方法，不能被重写

  ![](images/21102802.png)

### 3） 修饰类

* 称为最终类，不能被继承 （太监类）

* final修饰的类中，定义final修饰方法没有意义，但不报错。

  <img src="images/21102803.png" style="zoom:80%;" />

# 2021-10-29

## 17 抽象类

```java
class A{
    
}

abstract class A{
    public A(){}
    int i ;
    public void t1(){}
    
    public abstract void t2();
}
```

### 1） 什么是抽象类

* 使用**abstract**关键字修饰的类

### 2） 抽象类特点

* 本质也是一个类，也可以有属性，方法，构造器。从这点来看，与普通类相同
* 但是不能被实例化 （new 对象）

### 3） 抽象类作用

* 抽象类中可以定义抽象方法。 普通类不能定义抽象方法
* 当我们根据逻辑分析，需要定义抽象方法的时候，就需要先定义抽象类了。
* 所以要了解抽象类，就需要先了解抽象方法。
* **强调：只能在抽象类中定义抽象方法，但反之抽象类中不一定必须定义抽象方法（意义不大，不报错）**

### 4） 什么是抽象方法

* 由**abstract**关键字修饰的方法，且没有方法体

### 5） 抽象的特点

* 不能被直接调用
* 必须被子类继承重写
  * 所有抽象，就是不具体，不确定
  * 抽象方法没有方法体，只提供了方法的基本结构（名称，参数，返回类型）。没有具体的内容，也就是说具体的实现是不确定
  * 具体的实现需要有子类继承通过重写来确定。子类重写时，内容有子类具体决定。但重写的方法结构必须与抽象方法相同。

### 6） 抽象方法的意义

* 制定规则，提供API
* 如何理解规则，在什么场景中需要定义规则呢？
  * A想帮B，C，D做一件事
  * 这件事中有一部分功能A自己就知道怎么做
  * 但还有一部分功能A不知道怎么，需要B来告诉A怎么做
  * 也就是说由B来提供具体的实现，让A来参照这个具体的实现来执行（调用这个功能方法）
  * 那如何保证B提供的功能，A就可以执行呢
  * 这时候就需要提供一个规则（这个规则是谁提供的？A）
  * 然后B按照这个规则提供对应的功能方法（具体的实现）
  * A就可以按照这个规则执行这个具体的实现了。
  * 在程序中，这个规则体现在功能方法的名称，参数，返回类型上。
  * 也就是说，这个规则体现在方法的结构上。 B按照规则提供一个具体的功能，也就是写一个和规则结构一样的方法。
  * B按照这个方法结构（规则）定义了一个具体的方法。A就可以按照这个规则结构，调用这个方法。

7） 补充：

* 抽象类的意义就在于定义抽象方法，被子类继承重写。
* 如果抽象类中没有定义抽象方法，或者没有被子类继承，这个抽象没有意义的，但不报错。



* 接口，抽象类的使用也是多态的体现。未来抽象类会有许多子类，就相当于有不同的实现。
* 更建议从规则的角度理解抽象。

## 18 接口

```java
interface A{
    public static final int i = 20 ;
    int j = 20 ;
    
    public abstract void t1();
    void t2();
    
}

class B implements A{
    public void t1(){}
    
    public void t2(){}
}
```



### 1） 什么是接口

* 使用**interface**关键字 代替 class关键字定义的类就称为接口（类）

### 2） 接口的作用

* 接口是一个特殊的抽象类
* 特殊在哪？ 完全用来制定规则的
  * 接口中的所有方法都必须是抽象方法
    * 就可以省略**public abstract**关键字了
  * 接口中的所有属性都必须是公共的静态的常量属性
    * 公共的：public  谁都可以用
    * 静态的：static **接口也不会产生对象**，可以类名.属性的方法调用。
    * 常量：   final，规则不能被改变，属性中值也不能被改变。
    * 可以省略 **public static final**
  * 接口中不能有构造方法
    * 构造器的作用就是为成员属性初始化
    * 接口中都是静态常量，不需要在构造器中初始化

### 3） 接口的使用

* 子类 需要使用 **implements** 关键字  实现（继承）接口
* 子类（实现类）需要重写所有的抽象方法，否则子类需要是一个抽象类。

### 4） 接口的一些特点

* 接口与接口之间，可以继承，并且可以多继承，使用逗号隔开

  ```java
  interface A1{
      void t1();
  }
  interface A2{
      void t1();
  }
  interface A extends A1,A2{}
  
  class B implements A1,A2{
      public void t1(){}
  }
  
  class C extends B implements A{}
  ```

  * 继承的也都是抽象方法（规则），不具体的，不会产生二义性

* 子类实现接口时，也可以实现多个接口，使用逗号隔开

  * 如果2接口中有相同的规则，子类只需要重写一个即可。

* 子类既可以继承父类，也可以同时实现接口。先继承，再实现

### 5） 面向接口编程

* 也称为面向抽象编程  （抽象：抽象类，接口）
* 更在意的是使用了实现了哪些功能规则对象，而不显具体的对象
* 本身也是一种多态的表现。

# 2021-11-04

## 19 类之间的关系

* java是一种面向对象的编程语言
* 所谓的面向对象：生活中万物皆对象，所见皆对象
* 生活中对象（车，手机，电脑，人），我们都可以说会用java代码来体现
* java中要想有一个对象，就需要先有一个类。 类是对象的抽象，模板。 对象是类的实例
* 生活中对象之间是存在一定关系的
* java中的类也可以表示生活中的对象关系



* 更好了解类之间关系，可以设计更合理的程序结构，可以体现不同的耦合性强弱
  * 内聚性 ： 一个对象独立完成功能的能力
  * 耦合性 ： 多个对象完成功能的配合能力
  * 程序的设计目标：高内聚，低耦合



* java中类之间的关系可以分为以下6种：

### 1）继承关系

* **也称为“泛化关系”，也称为“is-a”关系，有时也称为“like-a”关系**

* 实现

  * 类与类的继承

  * 接口与接口之间的继承

    ```java
    class A{}
    
    // B is a A
    class B extends A{}
    ```

* 耦合特点

  * 耦合度最高的一种关系
  * 当A类的某些属性和方法发生改变时，会立刻对子类B产生影响。

* UML建模

  * 使用“实线空心三角”表示

  <img src="images/21110401.png" style="zoom:50%;" />

### 2）实现关系

* 也属于泛化关系，也算是“is-a”关系
  * 如果在程序结构分析时，想要实现A**是一个**B这种特点。A需要继承B或实现B
  * 自定义一个类，希望他**是一个**线程对象
  * 自定义一个类，希望他**是一个**Servlet对象

* 实现

  * 子类 实现 接口

    ```java
    interface E{}
    
    class D implements E{}
    ```

* 耦合特点
  
  * 与之前的继承关系相同
* UML建模
  
  * 使用“虚线空心三角”表示

![](images/21110402.png)

### 3）关联关系

* **又称为“包含关系”，也称为“has-a”关系**

* 实现

  * 类A中定义B类型的属性或集合属性

  ```java
  class B{}
  
  class A{
      B b ;
  
      List<B> bs ;
  }
  ```

* 耦合特点

  * 比之前的继承关系和实现关系，耦合度要弱一些

  * 当B类中的属性和方法发生一些变化时，不一定会对类A产生影响

    

  * 关联关系中不仅体现了有关系

  * 还体现了关系数量

    * 1对1	（单向关联）

    * 1对多   （单向关联）

    * 多对多  （双向关联）

    * 多对1    （双向关联）

      ```java
      //1对1   一个A关联一个B
      class A{
          B b 
      }
      class B{}
      //-------------------------------
      //1对多  一个A关联多个B
      class A{
          List<B> bs; 
      }
      class B{}
      
      
      //-------------------------------
      //多对1     多个A关联一个B
      class A{
          B b ;
      }
      class B{
          List<A> a ;
      }
      
      //-------------------------------
      //多对多     多个A关联一个B
      class A{
          List<B> bs ;
      }
      class B{
          List<A> a ;
      }
      ```

* UML建模

  * 使用“实线”表示双向关联
  * 使用“实线箭头”表示单向关联

  <img src="images/21110403.png" style="zoom: 80%;" />

### 4）聚合关系

* 也是关联关系的一种。更关注的是关联的强弱程度

* 实现：

  * 同关联关系

* 特点

  * 逻辑上，A类包含了BCD等类型的属性，表示A是由BCD组成的
  * 但A和BCD有没有那么强的耦合度
  * A和BCD的生命周期不同
  * 并且BCD可以独立存在并使用。
  * 例如：  车和轮子 ， 灯架和灯泡

* UML建模

  * 使用”实线空心菱形“表示
  * “菱形”放置在包含那一端(A)

  <img src="images/21110404.png" style="zoom:50%;" />

### 5） 组合关系

* 也是关联关系的一种，更关注关联关系的强弱
* 实现
  * 同关联关系
* 特点
  * A是由BCD组成的
  * 并且BCD完全属于A
  * 生命周期相同（有A就有BCD，A没了BCD就没有了）
  * BCD不能独立使用
  * 例如： 人 和 四肢 眼睛，嘴
* UML建模
  * 使用“实线实心菱形”

<img src="images/21110405.png" style="zoom:50%;" />

### 6）依赖关系

* **也称为“use-a"关系**

* 实现

  * A类中的方法通过参数获得一个B类型对象
  * 也就是只有调用A的这个方法时，才需要传递一个B对象，才会使用B对象

  ```java
  class A{
      public void t1(B b){
          b.t2();
      }
  }
  
  class B{
      public void t2(){}
  }
  ```

* 耦合特点
  * 比之前的那些关系，更弱一些。属于弱耦合，松耦合
  * 只有在执行A的方法时，才会和B产生耦合
  * 所以可以利用依赖关系，对两个类进行解耦
  * 比较推荐使用依赖关系设计程序，例如策略模式
  * 例如： 歌手和麦克风， 司机和汽车， 屠夫和猪和屠刀

* UML建模

  * 使用“虚线箭头”表示

  <img src="images/21110406.png" style="zoom:50%;" />

# 2021-11-5

## 20 封装

* 封装可以从**广义**和狭义两个角度理解
  * 广义：功能封装
    * 在开发中，将一些常用的功能代码抽取出来，形成一个独立的方法，类，工具，框架
    * 未来再需要使用这些功能代码，只需要调用上述的封装内容即可。
    * 比如：ArrayBox，LinkedBox，ORM封装，MVC封装，浏览器服务器封装
  * 狭义：语法封装。 也可以从2个角度理解
    1. 将抽取出来的属性和行为行成一个整体，这个过程就称为封装。形成的这个整体就是**类**
       * 回忆：抽象
       * 也就是我们每写一个类就是在封装
    2. 信息隐藏
       * 利用**访问权限修饰符**，将一些属性信息隐藏起来
       * 不允许其他外部类直接访问使用
       * 可以提供间接访问的API方法
       * 从而提高了信息的安全性

## 21 包

### 1） 作用特点

* 特点：

  * 就如同文件夹一样，可以包裹一组类或接口

* 作用：

  * 解决同名冲突问题
  * 使得程序结构更加清晰（将功能相同，目的相同的类或接口放置同一个包中）

* 内部特征：

  * 包在编码时，表现出来的效果就是文件夹。需要一个包，就创建一个文件夹（不用idea理解）

    * 就如同需要一个类，就先创建一个java文件一样

  * 编译时，文件名会作为类名的前缀，与类名组成一个完整的带路径的名字：类全名

    * 类文件： f:/z/myProject/test/Test1.java

    * 类全名： test.Test1
    * 在文件系统中，文件夹和内容之间使用/分割。在java中，包和内容之间使用.分割

* 包的声明：
  * 包对应的就是文件夹。 在java中如果需要有一个包，就在系统中创建一个文件夹

  * 文件夹不一定都是包

  * 在定义类时，需要在类的首行使用**`package`**关键字来声明当前类所属的包

    * 声明的这个包名，对应的就是文件夹的名字
    * 这个时候，在编译时，才会认为对应的文件夹是一个包。
    * 注意：此时要求包路径必须和文件夹路径匹配

    ```text
    f:
    	z	
    		myproject
    			test
    				Test1.java
    			io
    				user
    					UserIO.java
                data
                util
    ```

    ```java
    //Test1被放置在了test包中，Test1.java文件所在的文件夹就是一个包
    package test ;
    class Test1{}
    
    //----------------------
    //此时包声明是不正确的，因为包路径和对应的文件夹路径不匹配
    //package io.user ;
    package io ;
    class UserIO{}
    
    ```

    <img src="images/21110501.png" style="zoom:50%;" />


### 2） 导包

* 我们现在可能会根结构设计需求，将不同类，放置在不同的包中，分别管理
* 在使用时，可能a包中的类需要用到b包中类，如何访问呢？

1. **可以使用类全名，直接访问**

   ```java
   package com.test1 ;
   class A{} //-----> class com.test1.A
   
   package com.test2 ;
   class B{
       com.test1.A a ;
   }
   ```

2. 可以使用**`import`**关键字 在 package和class中间引入要使用的类

   > a **引入指定的类**

   ```java
   package com.test1 ;
   class A{}
   
   package com.test2 ;
   import com.test1.A ;
   class B{
       A a ;
   }
   ```

   > **b 通配符引入指定包中所有的类**

   * 注意： 在使用通配符导入包中所有类时，可能会与另外一个包中导入的类有同名冲突

     ​			此时不会报错，但使用时必须使用类全名

   ```java
   package com.test1 ;
   class A{}
   class B{}
   
   package com.test3 ;
   class A{}
   class B{}
   
   
   package com.test2 ;
   //import com.test1.A ;
   import com.test1.* ;
   import com.test3.* ;
   class C{
       com.test1.A a ;
       com.test3.B b ;
   }
   ```

### 3） 静态导入

* 可以导入另外一个类中的所有静态成员（属性、方法）。可以直接访问，不在需要使用类名访问
* 一般不推荐，无法区分使用的是引入的成员，还是自己成员。

```java
package com.test1 ;
class A{
    public static int num  ;
    public static void t1(){}
}

package com.test2 ;
import com.test1.A ;
class B{
    public static void main(String[] args){
        A.num = 20 ;
        A.t1() ;
    }
}

package com.test3 ;
import static com.test1.A.num ;
import static com.test1.A.* ;
class C{
    public static void main(String[] args){
        num = 20 ;
        t1() ;
    }   
}
```

# 2021-11-12

## 22 访问权限修饰符

* 要想更好的了解访问权限，需要先了解一个知识内容：**包**



* 访问权限分为 类的访问权限，成员访问权限

### 1） 类的访问权限

* 类的访问权限有2种修饰 ， **公共的**，**默认的**

* **公共的**

  * 定义类，使用**public**关键字修饰
  * 任何包中的类都可以引用公共的类
  * public修饰的类，类的名字必须和.java文件名相同

  ```java
  public class A{}
  ```

* **默认的**

  * 不需要任何权限修饰符修饰
  * 只能被本包中的其他类访问，其他包中的类不能访问（也不能导入）
  * 默认类的名字 与 .java文件名字无关  （可以一样，也可以不一样）
  * 一个.java文件中可以多个默认的类

  ```java
  class A{}
  
  class B{}
  
  class C{}
  ```

### 2） 类成员访问权限

* 类的成员包括： 成员属性，成员方法，构造方法，内部类 （代码块，静态代码块）

* 类的成员有4种访问权限： 公共的，保护的，默认的，私有的

* **公共的**

  * 使用public关键字修饰

    `public int i = 10 ;`

  * 在可以访问类的前提下，任何类都可以访问这个成员

* **保护的**

  * 使用protected关键字修饰

    `protected int i = 10 ;`

  * 在可以访问类的前提下，可以本包中的类访问，可以被其他包中的子类继承访问

    * 外包的类如果不是子类，不能访问
    * 外包的类即使是子类，但不是通过继承，也不能访问

    ```java
    public class E extends C {
    
        //外包的子类可以通过继承，直接使用父类的公共权限和保护权限的成员。
        public void e(){
            System.out.println(super.i1);
            System.out.println(super.i2);
    
            //System.out.println(super.i3);
            //System.out.println(super.i4);
        }
    
        public void e2(){
            C c = new C();
            System.out.println(c.i1);
    
            //System.out.println(c.i2);
            //System.out.println(c.i3);
            //System.out.println(c.i4);
        }
    }
    ```

* **默认的**

  * 不需要任何修饰符

    `int i =10 ;`

  * 在可以访问类的前提下，只有本包中的类可以访问

* **私有的**

  * 使用private关键字修饰

    `private int i = 10 ;`

  * 只可以被本类中的方法访问，其他任何类都无法访问

|           | 本类 | 本包类 | 外包子类 | 外包非子类 |
| --------- | ---- | ------ | -------- | ---------- |
| public    | √    | √      | √        | √          |
| protected | √    | √      | √        |            |
| 默认      | √    | √      |          |            |
| private   | √    |        |          |            |

* 注意： 
  * 开发中，一般情况下，都是属性私有，方法共有
  * 但不绝对。

# 2021-11-18

## 23 内部类

* 所谓的内部类，就是在一个内部定义的类。在哪个内部呢？ 有2个

### 1） 类内部

* 在类的内部再定义一个类，与类的属性和方法同级别

* 称为 **成员内部类**

  ```java
  class A{
  
      {}
  
      public A(){}
  
      //成员属性
      private int i = 10 ;
  
      //成员方法
      public void t1(){}
  
      //成员内部类
      class B{
          int j = 20 ;
          int i = 30 ;
          public void t2(){
              System.out.println(i); // 30
              System.out.println(A.this.i); // 10
          }
      }
      
      
      static class B2{}
  
  }
  ```

* 成员内部类的特点

  * 内部类可以随意的使用外部类的所有成员（包括私有的）
  * 外部类不能直接使用内部类的成员。
  * 其他类要想使用内部类，必须先创建外部类对象，然后再产生内部类对象

* 成员内部类的使用

  * 与成员属性和方法一样。 要使用都需要先创建外部对象。

  * **定义语法**：

    `A.B b ;`

  * **创建语法**：

    ```java
    A.B b = new A().new B() ;
    
    A a = new A();
    A.B b = a.new B();
    ```

* 注意：

  * 当内部类中定义类与外部类同名的成员时（属性和方法）

  * 可以用如下的语法继续调用外部类的成员。

    `A.this.i`

* 总结：

  * 类成员特点 + 类特点 + 内部类特殊语法
  * 类成员有4种访问权限，所以内部类也有4种访问权限
  * 类成员可以是static修饰，所以内部类也可以用static修饰

* 扩展：静态成员内部类

  * 类的成员可以使用static关键字修饰

  * 所以成员内部类也可以使用static关键字修饰

  * static关键字修饰的特点就是不需要创建外部类对象，可以通过外部类直接访问

  * 所以此时创建内部类对象的语法如下：

    `A.B2 b2 = new A.B2();`

### 2） 方法内部

* 在一个方法中定义类

* 称为 **局部内部类**

* 特点： 局部 ， 类 ， 内部

* 只能在方法内部使用内部类来创建对象。

  ```java
  class A{
      private int i = 10 ;
  
      public void t1(){
  
          {
              //局部变量
              int m = 100;
  
              class B {
                  int j = 20;
  
                  public void t2() {
                      System.out.println(i);
                  }
              }
  
              B b = new B();
          }
  
  
          // new B(); //无法使用B来创建对象，因为作用域
      }
  
  
  }
  ```
  
* **补充：**

  * 在局部内部类中，如果要使用所在方法的变量，这个变量必须是final修饰的常量
  * 在jdk1.7之后，被局部内部类使用的变量，隐式的被设置为final。不能修改

### 3） 内部类总结

* 普通类，所有的类都可以访问
* 成员内部类，只有在类的内部才可以访问
* 局部内部类，只有在类的方法中才能方法
* 我们发现上述3种情况，对类的使用范围越来越窄
* 简单理解就是： 
  * 当有一个类需要给所有类来使用的时候，就定义为一个普通类
  * 如果有一个类，只在当前这个类中有效，就可以定义为一个内部类
    * 比如： 链表结构中节点对象 ， hash结构中的节点对象，树结构节点对象
  * 如果只有需要在调用方法时，才用到的类，就可以定义为一个局部内部类。
    * 这种情况一般都使用匿名内部类

# 2021-11-25

### 4） 匿名内部类

* 就是在某一个行需要定义类的时候，不指定名字。直接定义。

  * 如果这个类没有名字，未来怎么使用呢

  * 未来无法使用，只能在定义这一瞬间（这一行）直接使用，创建对象

* 匿名内部类的定义与创建语法

  * 匿名内部类必须有一个上下文推断 （接口或父类）

  ```java
  public class Test {
  
      public static void main(String[] args) {
          A a = new A(){
  
              int i = 10 ;
              String s = "20" ;
  
              private void t1(){}
  
              private void t2(){}
              
              public void tt(){
                  t1();
                  t2();
              }
          };
  
      }
  
  }
  
  interface A{
      public void tt();
  }
  
  class B implements A{
      int i = 10 ;
      String s = "20" ;
  
      private void t1(){}
  
      private void t2(){}
  
      public void tt(){
          t1();
          t2();
      }
  }
  ```

  * 现在有一个接口A

  * 按照我们的业务功能分析，需要在主方法中创建一个符合A条件对象

    * 所谓符合A条件，实现A的接口

  * 我们完全可以按照以往的设计手段，自顶一个类B，实现接口A

  * 然后区创建B对象即可。

    `A a = new B();`

  * 但我们进一步分析设计发现

  * 我们需要的这个符合A条件的类对象，只需要在主方法的那一行创建一次，以后都不需要再使用创建了

  * 所以结合我们的分析特点以及我们了解的匿名内部类的特点

  * 我们觉得此处使用匿名内部类更合适

  * 所以我们就是用匿名内部了---> 匿名内部类怎么用？

## 24 lambda表达式

### 1） 基本应用

* 是jdk1.8的新特性。

* 是一个语法糖，简化匿名内部类的语法。

* 但不是所有的匿名内部都可以简化，有一定的条件

* 如果这个匿名内部类中有且只有一个方法，就可以使用lambda了

  ```java
  public class Test {
  
      static class B2 implements A{
          @Override
          public void sum(int num1, int num2) {
  
          }
      }
  
      static int i ;
       int j ;
  
      public static void main(String[] args) {
          class B3 implements A{
  
              @Override
              public void sum(int num1, int num2) {
  
              }
          }
  
          A a2 = new B1();
  
          A a = new A(){
              @Override
              public void sum(int num1, int num2) {
  
              }
          };
  
          /*
          	Lambda表达式
          	省去了实现接口，重写方法的部分
          	因为按照“实现接口”的特点
          	地球人都知道应该重写方法
          	而且也知道重写方法特点，就是写一个和接口一样的方法
          	但其中也有一些部分是不确定的，比如：参数名，方法体
          	所以lambda就是把地球人都知道的部分省略，
          	保留不确定的2部分需要程序员自己编写（参数名，方法体）
          	两者之间使用->分割
          	就是lambda表达式了
          */
          A a1 = (int x, int y)->{};
  
  
      }
  
      public static void t1(){}
  
      public static void t2(){}
  }
  
  interface  A{
      public void sum(int num1 , int num2);
  
  }
  
  class B1 implements A{
  
      @Override
      public void sum(int num1, int num2) {
  
      }
  }
  ```

### 2） lambda参数部分

```java
public class Test {
    public static void main(String[] args) {
        A a1 = new A(){
           public void t1(int i, int j){
               System.out.println("----------");
           }
        };
        A a2 = new A(){
            public void t1(int a, int b){
                System.out.println("==========");
            }
        };
        //省略参数类型
        A a3 = (a , b)->{System.out.println("+++++++++++++++");};
        
        //省略参数圆括号（）  只能是1个参数
        B b1 = x->{System.out.println("@@@@@@@@@@@@@@@@@@@");};

        //省略了方法体花括号{}  只能是一行代码
        B b2 = x->System.out.println("#####################");
        
        C c1 = (x)->{return x*x ;}
        
        //省略return 和 {}
        C c2 = x->x*x;
    }
}

interface A{
    public void t1(int x , int y ) ;
}

interface B{
    public void t2(int x) ;
}

interface C{
    public int t3(int x);
}
```



* 由匿名内部类 变成 lambda表达式，就保留参数和方法体两部分了

1.  可以省略参数类型

```java
A a2 = new A(){
            public void t1(int a, int b){
                System.out.println("==========");
            }
        };
        A a3 = (a , b)->{
            System.out.println("+++++++++++++++");
        };
```

2. 如果只有1个参数，还可以省略()

```java
 B b1 = x->{};
```

### 3）lambda方法体部分

1. 如果方法体中只写了一行代码，可以省略{}

   ` B b2 = x->System.out.println("#####################");`

2. 如果方法体中只有1行代码，并且是返回值代码，可以省略return 和 {}

   `C c2 = x->x*x;`

### 4） 方法引用

#### a 对象方法引用

```java
public class Test {
    public static void main(String[] args) {
        //因为业务需求，需要一个B对象。
        B b = new B();

        //因为业务需求，需要一个A对象。而A是一个接口，所以产生的一定义A的实现类对象
        //所以可以使用匿名内部类，或者lambda
        A a1 = new A(){
            @Override
            public void t1(int i) {
                b.t2(i);
            }
        };

        
        A a2 = (i)->{b.t2(i);};

        /*
            1. 当前匿名内部类中的方法只有一行代码
            2. 这行代码调用了另外一个对象的方法
            3. 当前匿名内部类的方法和调用的另一个对象方法有相同的方法结构(返回类型和参数列表相同）
            总结：在这种情况下，就可以使用对象方法引用,语法如下
         */
        //需要一个实现A接口的匿名内部类对象，该对象方法中执行的代码就是b对象的t2方法
        //按照方法引用的特点，要求匿名内部类对象的方法和b对象的方法有相同的方法结构
        //所以 如果b对象的t2方法有参数，匿名内部类的方法也一定有参数，所以我们调用时就会传递参数
        //     我们给匿名内部类方法传递的参数，最终就会传递给b对象的t2方法
        A a3 = b::t2;
    }
}

interface A{
    public void t1(int i);
}
class A1 implements A{

    @Override
    public void t1(int i) {
        new A1().t1(10);
    }
}

class B{
    public void t2(int i){
        System.out.println("------------");
    }
}
```

* **扩展：关于super和this的对象方法引用**

```java
interface A{
    public void t1(int i) ;
}

class B{
    public void t2(int x){
        System.out.println(x);
    }

    public void t3(){}
}

class C extends B{
    public void t3(){
        super.t2(10);
        this.t2(20);
        //因为业务需求，需要一个A对象
        A a1 = new A(){
            @Override
            public void t1(int i) {
                //调用了C的父类t2方法
                C.super.t2(i);
            }
        };

        A a2 = i->C.super.t2(i);

        A a3 = super::t2 ;

        A a4 = this::t2 ;

    }
}
```

#### b 类方法引用（static）

```java
public class Test {
    public static void main(String[] args) {
        //根据需求，需要创建一个A对象

        A a1 = new A(){
            @Override
            public void t1(int x) {
                B.t2(x);
            }
        };

        A a2 = x->B.t2(x);

        A a3 = B::t2;
    }
}

interface A{
    public void t1(int x);
}

class B{
    public static void t2(int i){
        System.out.println(i);
    }
}
```

#### c 构造方法引用

```java
public class Test {
    public static void main(String[] args) {

        //按照需求，需要创建一个B对象

        B b1 = new B(){
            @Override
            public A t1(int i1,int i2,int i3) {
                return new A1(i1,i2,i3);
            }
        };


        B b2 = (i1,i2,i3)->new A1(i1,i2,i3);
        /**
         * 如上分析
         * 此时如果调用匿名内部类对象的t1方法，就相当于调用了A1的构造方法
         * 此时就可以使用构造方法引用
         */
        B b3 = A1::new;
        b3.t1(10,20,30);

    }
}

interface A{}

class A1 implements A{
    public A1(int x , int y , int z){}
}

interface  B{
    public A t1(int i1,int i2,int i3);
}
```

# ======面向对象进阶======

# 2021-12-02

## 1 Object类

### 1） java.lang包

* Object类是由jdk提供的
* 在java.lang包中
* java.lang包中的类在我们的程序中使用时，不需要import导入，可以直接使用
  * 常用的 : Object , String，System
* 除此以外，jdk还提供了许多的类，放在了不同的包中，如果要使用，就必须import导入
  * java.util.Scanner
  * java.util
  * java.io
  * java.net
  * java.sql

### 2） Object是公共父类

* Object是所有类的公共父类

* 所有的类最终都继承自Object

  `class A{}` === `class A extends Object{}`

  `class B extends A{}`

  * 所有的都有继承关系，底层处理时，就需要针对于有继承和没继承提供两套处理机制。
  * Object类中提供了许多具有通用特性的方法，不同的类对象也可以进行相同的处理机制

### 3）Object方法

> toString() 方法

* 用一个字符串，来简单介绍一下当前的类对象
* Object.toString提供了一套所有类对象相同的自我介绍：类型 + @ +hash地址
* 可以通过重写来自定义自我介绍内容
* 注意：
  * 在使用对象时，如果没有调用对象的任何方法，默认会调用其toString方法（打印）



> equals() 和 hashCode() 方法

* equals 官方给出的作用是用来比较两个对象是否相等的。

* 还可以使用==来实现相等的比较

* 问： equals 和 == 的区别

  * equals 只能比较（引用类型的）对象，比较的是地址，判断两个对象的地址是否相等

  * == 既可以比较（引用类型的）对象，也可以比较基本类型的数字
* 比较对象时，与equals相同，比较的是地址
  
    * 比较数字时，就是值的比较。
    
* 注意：
  
  * 看了Object的源码后，我们发现equals中也是使用==比较对象
  
  * 有时候我们对两个对象的比较，更关心的是内容，所以可以通过重写equals来自定义比较规则
      * 但此时我们更需要的是内容的比较规则，也可以不用重写equals，可以自定义一个新的比较方法
      * 如果是完成我们自己需要的内容比较规则，可以重写equals，也可以自定义比较方法
      * 不是必须重写equals的
      * equals的存在以及equals的重写都要依赖于对hashcode方法的理解。
  
* **hashCode方法** 是一个native本地方法，是由C/C++实现的方法

  * 调用hashCode时，可以获得一个hash值 （不是地址）

  * 这个hash值的作用主要是针对于hash存储结构提供服务的

  * 存数据和找（取）数据时，这个位置不是连续的，而是通过一个hash对这个hash进行计算，算出那个位置。 相同的hash值通过hash算法，可以算出相同的位置

    

  * hashCode不一定是唯一的，是有可能重复的（几率比较小）

  * 除此以外，即使hashcode不重复，但往哈市结构存储时，有可能存储在相同位置

  * 此时就会产生 “哈希碰撞”  两个对象利用hashcode算在了同一个位置

  * 碰撞后，一般都会使用链表进行串联

  * 所以，当产生碰撞时， 需要判断到底是一个新数据导致碰撞，还是一个旧数据重复处理

  * 就需要对数据进行一个相等比较

    * 如果这个hash结构是一个通用的，公用存储结构。就要用大家都知道的比较方法（equals）
    * 如果这个hash结构是自定义的，那就随意了。

* 所以，当两个对象使用equals方法比较后结果相等，我们认为这个就应该是2个一样的对象

* 这个两个对象就应该有相同的hashCode值。

* 所以 equals的重写一般都会伴随着hash的重写。



* hashCode码不是初始化时产生，属于懒加载机制，第一次调用hashcode时才会自产生hashcode值。

  * 可以使用ClassLayout 展示一下对象存储结构（包含hashcode码），需要jol.jar

    <img src="images/21120201.png" style="zoom:50%;" />

  ```java
  public static void main(String[] args) {
      A a = new A();
  
      String s = ClassLayout.parseInstance(a).toPrintable();
      System.out.println(s);
  
      System.out.println("==========================================");
      System.out.println( a.hashCode() );
      System.out.println("==========================================");
  
      s = ClassLayout.parseInstance(a).toPrintable();
      System.out.println(s);
  }
  ```

  <img src="images/21120202.png" style="zoom:50%;" />

# 2021-12-03

## 2 Object之克隆方法

### 1） 什么克隆

* 所谓的克隆，就是内容的复制。 一般指的都是对象内容的复制。

  * 如果一个变量中存储的是一个基本类型的数值，所谓复制就是赋值给另一个变量。

    ```java
    int a = 10 ;
    int b = a ;
    ```

  * 如果一个变量中存储的是一个（引用类型）对象数据，如果再按照上述的方式，就无法实现复制了

    如果依然使用上面的方式，会怎样呢？

    ```java
    class A{
        int num ;
    }
    
    //创建了一个对象
    //对对象做了一些处理
    //接下来相对处理后的对象内容进行一个复制。 希望复制后的对象num也是10
    A a1 = new A();
    a.num = 10 ;
    
    A a2 = a1 ;
    ```

    * 上述代码完成的“复制”

    * 其实a1 和 a2 是同一个对象。 所谓复制，一定是产生了一个新的内容（对象）

      `a1 == a2`	true

    * 因为a1和a2对象，所以对a1修改也会对a2产生影响。

      `a1.num=20`

      `System.out.println(a2.num);`  20

    * 所以上述方法不能完成复制

  * 既然复制需要产生一个新对象，那直接new一个对象行不行？

    * 不可以
    * 虽然new可以产生一个新对象，但这个新对象中的数据都是默认值 num=0
    * 而我们希望的复制，内容都是一样的  num=10

  * 这个时候我们就可以使用Object提供clone这个方法，来实现对象的克隆

    * 又可以产生一个新对象
    * 又可以保留最新的数据内容

### 2） 克隆实现

* clone是Object类的方法，Object又是所有类的爹

* 所以，所有的类对象都拥有克隆的方法，都可以克隆（复制）

* 但通过源码发现，clone这个方法是一个protected修饰的方法

* 只有子类对象自己可以使用，其他对象不能使用

  * 对象自己可以克隆自己
  * 但其他对象不能主动的克隆当前对象

* 如果要允许其他对象来克隆当前对象，需要当前对象重写clone方法，并设置public访问权限（封装特性）

* 默认情况下，克隆会抛出异常 `CloneNotSupportedException`

* 需要被克隆类对象，实现允许克隆的接口`Cloneable`

  ```java
  public class Test {
      public static void main(String[] args) throws CloneNotSupportedException {
          A a1 = new A();
          a1.num = 10 ;
  
          A a2 = (A) a1.clone();
  
          System.out.println(a1 == a2); //false
          System.out.println(a2.num); //10 和 a1相同
  
          a1.num = 5 ;
          System.out.println(a2.num); //10 没有变化
      }
  }
  class A implements Cloneable{
      int num ;
  
      @Override
      public Object clone() throws CloneNotSupportedException {
          return super.clone();
      }
  }
  ```

### 3） 浅克隆和深克隆

* 无论是浅克隆还是深克隆，使用的都是上述的clone方法
* 深浅克隆主要是针对于在对象复制时，如果对象中还包含了子对象，这个子对象的是否克隆
  * 如果克隆的对象与原对象 包含同一个子对象，就称为浅克隆
  * 如果克隆的对象与原对象 包含了不同的子对象，也就是说子对象也被克隆，就称为深克隆

> 浅克隆设计

```java
package com.test3;

public class Test {
    public static void main(String[] args) throws CloneNotSupportedException {
        B b1 = new B();
        b1.name = "dmc" ;
        b1.a = new A();
        b1.a.num = 10 ;

        System.out.println(b1);

        // 相对b1做一个克隆
        B b2 = (B) b1.clone();

        System.out.println(b2); //b2和b1相同，证明克隆成功

        b1.name="zzt";
        System.out.println(b2); //b1.name修改，b2.name不变，证明确实克隆了一个新对象

        b1.a.num=20;
        System.out.println(b2);//b1.a.num修改，b2.a.num也发生变化，证明包含子对象没有被克隆
    }
}

class A{
    int num ;

    @Override
    public String toString() {
        return "i am a A , my.num="+num ;
    }
}


class B implements Cloneable{
    String name ;
    A a ;

    public String toString(){
        return "i am  "+name+" , i have a A : " + a.toString() ;
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

> 深克隆设计

```java
class A implements Cloneable{
    int num ;

    @Override
    public String toString() {
        return "i am a A , my.num="+num ;
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}


class B implements Cloneable{
    String name ;
    A a ;

    public String toString(){
        return "i am  "+name+" , i have a A : " + a.toString() ;
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        //所谓的深克隆，就是在克隆B的时候，将包含的子对象a也一起克隆
        //需要克隆A对象

        //这是一个浅克隆，内部包含的a还没有克隆呢
        B b = (B) super.clone();
        //需要对b内部包含的a也做一个克隆
        if(this.a != null){
            A a = (A) this.a.clone();
            b.a = a;
        }
        return b ;
    }
}
```

* 思考：

  * 所谓的深克隆，就是在克隆外部对象时，将包含的子对象也一同克隆

  * 如果包含的子对象比较多，甚至子对象还包含了子对象

    ```text
    A{
    	B{
    		B1{}
    		B2{}
    	}
    	C{
    		C1{}
    		C2{}
    	}
    }
    
    ```

  * 此时如果继续使用clone方法来实现克隆复制的话，就会比较麻烦

  * 我们有一种更适合克隆方式：序列化（后面要讲的IO有关系）


# 2021-12-16

## 4 异常机制

* java语言的特性：
  1. 跨平台特性
  2. 面向对象特性
  3. 简单性
  4. 健壮性 （垃圾回收机制，异常处理机制）

### 1） 什么异常

* 程序在运行时出现的问题，就称为异常或错误
  * 程序再非运行时出现的问题，称为编译错误，一般都是语法错误。
* 理论上来讲，出现问题，直接解决就可以了
* 但在一些封装应用或底层实现中，无法确定对问题的具体处理机制
  * 现在是我们的程序中，使用了别人提供的工具类（jdk一些类）
  * 我们再使用别人提供的工具类时，由于我们传递的一些信息有问题，导致在人家的工具类执行时出现了问题
  * 出现问题的地方在别人提供的工具类代码中。但出现问题的原因，是我们传递信息有问题
  * 那次是，如果在别人提供的工具类中给出相应问题的解决方案，那就不一定符合使用者的需求。
* 就会将出现的问题做一个总结（形成一个错误信息对象-异常对象），使用**throw**关键字，将这个对象抛给使用者。

### 2） 异常分类

* 异常本身就是程序运行时出现的一些问题
* 根据这个问题的严重程度，将问题分为2类
  1. Exception 异常 。 问题不是很严重，可以稍微处理，继续执行
     1. 非运行时异常，受检异常，受控异常 ，编译时异常:   必须在编码时，指定相应的处理手段。
        * 逻辑上，这类问题需要重视
     2. 运行时异常，非受检异常，非受控异常：在编码时，可以不用指定相应的处理手段
        	* 逻辑上，这类问题一般不太容易出现。
           	* 一旦出现，要想处理，还需要再编码时，指定处理手段
  2. Error 错误。  问题比较严重，无法轻松处理，即使利用异常处理机制让程序继续运行，但也不会太持久。因为没有解决根本问题

### 3） 异常处理

* 程序运行时，一般在底层代码中或他人提供的工具类代码中，出现了逻辑问题

* 但又不能确定如何处理

* 所以将出现的问题做了一个描述，做了一个总结，创建了一个异常对象

  * 异常对象不是问题，只是问题的描述。

* 将其使用throw关键字抛给调用者，让调用者自己根据出现的问题提供处理手段

* 调用者处

  * 如果是一个运行时异常，可以先不用处理。
    * 不提前准备处理手段，不代表不会出错。
    * 一旦出错，本次执行就会终止。
    * 为了下次执行，如果再出现这样问题，程序不终止，要么修改源码，要么还需要提前准备处理手段
  * 如果非运行时异常，必须提前准备好处理手段

* 异常的处理手段有两种

  1. **try-catch-finally 自行处理**

     * try代码块，包裹可能产生异常的代码。一旦产生异常，就会被下面的catch块捕获
     * catch代码块，用来捕获异常，并提供相应处理手段，紧接着程序可以继续执行。
       * 由于try中可能会产生不同种类的异常
       * 所以try的后面可以跟有多个catch指定对应异常
       * 异常之前，也可能存在子父关系，catch在捕获异常时，要确保子类在上，父类在下
     * finally代码块，可以直接跟在try的后面（没有catch），也可以跟在catch后面
       * 表示try和catch处理的统一出口，无论执行了try还是catch，finally都会执行
       * 一般用来作为管道关闭，对象的释放

     ```java
     public static void main(String[] args)throws NullPointerException {
     
             //创建对象，用来读取文件内容
             try {
                 new FileInputStream("d:/z/1.txt");
                 String s =null ;
                 s.toString() ;
             } catch (FileNotFoundException e) {
                 //写一些对文件路径错误问题的处理手段
             } catch(NullPointerException e){
                 //写一些对空指针问题的处理手段
             } catch(Exception e){
     
             }finally{
     
             }
     
             try{
     
             }finally{
     
             }
     
         }
     ```

  2. **throws 继续向外声明，让上一级调用者处理。**

  * 如果最终都没有人处理（没有try-catch）。就会抛给虚拟机，虚拟机终止

# 2021-12-17

### 	4） 异常处理详解

* try,catch,finally的组合

  try-catch-catch-finally

  try-finally

  > **a. 如果try或catch中使用return关键字，那么finally中代码还会执行么？**
  >
  > 答案： 会执行

  ```java
  public static int t2(){
      String s = "zzt";
      try {
          System.out.println(s.toString());
          return 1;
      }catch(NullPointerException e){
          s = "dmc";
          System.out.println("空指针问题");
          return 2 ;
      }finally{
          System.out.println("end");
      }
  }
  ```

  > **b.如果try-catch-finally中都有return关键字，最终返回的try-catch中的值，还是finally中的值呢？**
  >
  > 答案： 最终返回的是finally中的值

  ```java
  public static int t3(){
      String s = "zzt";
      try {
          System.out.println(s.toString());
          return 1;
      }catch(NullPointerException e){
          s = "dmc";
          System.out.println("空指针问题");
          return 2 ;
      }finally{
          System.out.println("end");
          return 3 ;
      }
  }
  ```

  > **c. 在try-catch-finally组合中，如果catch中再次出现异常，finally会不会执行？**
  >
  > 答案：依然会执行finally代码
  >
  > ​	       其实throw 抛出异常，就如同return关键字一样，都可以结束方法，并返回数据
  >
  > ​			return 返回正常的数据，调用者使用变量存储
  >
  > ​		    throw 返回的是异常信息，调用者使用try-catch处理

  ```java
  public static void t1(){
      String s = null; //1-store0
      try {
          System.out.println(s.toString());
          System.out.println("end");
      }catch(ArrayIndexOutOfBoundsException e){ //e-2-store1
          System.out.println("越界问题");
          System.out.println("end");
          
      }catch(NullPointerException e){ //e-2-store1
          s = "dmc";
          System.out.println("空指针问题");
          throw new RuntimeException("new exception");
          return i;
      }finally{
          System.out.println("end");
      }
  
  }
  ```

  

  > **d. 在try-catch-finally的组合中，为什么会上述的情况呢？**

  * 在编译时，会将根据try-catch-finally的组合，将代码编译成n条分支

    ​	try-finally return   分支，将try和finally中的代码合二为一

    ​	catch-finally 分支  将catch和finally中的代码合二为一

    ​	catch-[catch]-finally 隐藏分支，编码时没有体现。但编译时，有可能在一个catch中再产生catch，也需要执行finally

  * 如果try-catch-finally中都有return

    finally中的返回值会覆盖调用try-catch中的返回值，最终返回的是finally中的值。

    ```java
    public static void t1(){
        String s = "zzt";
        try {
            System.out.println(s.toString());
            System.out.println("end");
        }catch(ArrayIndexOutOfBoundsException e){
            System.out.println("越界问题");
            System.out.println("end");
        }catch(NullPointerException e){
            s = "dmc";
            System.out.println("空指针问题");
        }finally{
            System.out.println("end");
        }
    
        System.out.println(s.toString());
        System.out.println("------------------------");
    }
    ```

    **javap -c Test1  命令查看反汇编指令**

    ```txt
    public static void t1();
        Code:
           0: ldc           #5                  // String zzt
           2: astore_0							//存入局部变量表的0位置变量中  s="zzt"
           3: getstatic     #3                  //  java/lang/System.out:Ljava/io/PrintStream;  3-10 System.out.print(s.toString());
           6: aload_0							//装载之前0位置的zzt对象,装到操作数栈
           7: invokevirtual #6                  // Method java/lang/String.toString:()Ljava/la
    ng/String;
          10: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/l
    ang/String;)V
          13: getstatic     #3                  // Field  java/lang/System.out:Ljava/io/PrintStream;  13-21 finally中代码
          16: ldc           #8                  // String end
          18: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/l
    ang/String;)V
          21: goto          78
          24: astore_1							//上面没有执行21，存储异常了（异常对象）
          25: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintSt
    ream;
          28: ldc           #10                 // String 越界问题
          30: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/l
    ang/String;)V
          33: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;   33-41  finally代码
          36: ldc           #8                  // String end
          38: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/l
    ang/String;)V
          41: goto          78
          44: astore_1							//41没有执行，证明没有月结问题，是空指针问题
          45: ldc           #12                 // String dmc
          47: astore_0
          48: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintSt
    ream;
          51: ldc           #13                 // String 空指针问题
          53: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/l
    ang/String;)V
          56: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintSt
    ream;
          59: ldc           #8                  // String end
          61: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/l
    ang/String;)V
          64: goto          78
          67: astore_2							//64没有执行，此时产生了对象，存储在了第三个变量，存储的是catch中再次出现的异常，没有处理代码
          68: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintSt
    ream;
          71: ldc           #8                  // String end
          73: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/l
    ang/String;)V
          76: aload_2
          77: athrow
          78: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintSt
    ream;
          81: aload_0
          82: invokevirtual #6                  // Method java/lang/String.toString:()Ljava/la
    ng/String;
          85: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/l
    ang/String;)V
          88: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintSt
    ream;
          91: ldc           #14                 // String ------------------------
          93: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/l
    ang/String;)V
          96: return
    
    ```

    > **e. 如果try中出现了额error，catch还能处理么？**
    >
    > 答案：可以处理，没意义。解决不了根本问题

    ```java
     public static void t4(int i){
         System.out.println(i);
         try {
             t4(i + 1);
         }catch (StackOverflowError e){
             System.out.println(" error end !!!");
         }
     }
    ```

    > **f. 如果catch中用throw抛出了异常，finally中有return 返回值。调用者最终拿到的是返回值还是异常呢？**
    >
    > 答案： 获得finally中的内容
    >
    > ​			如果finally中是返回值，调用者就获得返回值
    >
    > ​			如果finally中是异常，调用者就获得异常

    ```java
    main(){
        int num = t5();
        System.out.println(num);
    }
    
    public static int t5(){
        String s = null;
        try {
            System.out.println(s.toString());
            return 1; //一行代码做了2件事，1个是将1装入操作数栈顶，2个是return结束方法，并返回栈顶数据（有就返回，没有就拉到）
        }catch(NullPointerException e){
            s = "dmc";
            System.out.println("空指针问题");
            throw new RuntimeException("new exception"); //return value ;;
        }finally{
            System.out.println("end");
            return 2;
        }
    }
    ```

# 2021-12-23

### 5） 自定义异常

* 异常处理机制是一系列的异常相关处理操作
* 异常就是程序运行时出现的问题。
* 出现问题后，不能马上处理，需要交给使用者来处理
* 这就需要将问题进行总结：就是创建一个异常对象 —— 就是对问题的一种描述



* 异常对象：

  * jdk为我们提供一些常见的问题描述：  空指针，数组下标越界，文件没有找到

    * NullPointerException ， ArrayIndexOutOfBoundsException , FileNotFoundException

  * 还有更多业务中产生的问题，需要我们自己去进行描述，就需要自定义异常（类）了。

    

* 自定义异常

  * 自定义一个(异常)类
  * 继承具体的异常父类
    * Throwable :   
      * 异常类最终会产生一个异常对象，这个异常对象和普通对象的区别是什么？
      * 异常对象可以使用throw关键字抛出
      * 所以所有的异常对象，都是可以被抛出的，都是Throwable的子类
    * Error 和 Exception
      * 所有的问题描述对象，因为继承自Throwable，所以可以被throw关键字抛出
      * 这些问题，可以根据严重性，分为Error 和 Exception
      * Error 和 Exception 都是 Throwable子类
    * 注意：  Throwable，Exception这些异常对象，抛出后，都需要调用者提前处理
    * 注意：  Error 一般认为是和jvm相关比较严重的问题，出现后建议关闭程序，调试代码。 所以不需要try-catch处理，处理了也没有意义。
    * Exception 和 RuntimeException
      * 继承Exception ，当问题对象抛出时，必须提前接受编码的检查，进行异常提前处理准备
      * 继承RuntimeException，当问题对象抛出时，不是必须做检查，就可以不用提前的异常处理准备
      * 无论继承那个父类，最终的问题都是在运行时产生的

* Throwable api

  ```java
   public static void main(String[] args) {
  
          Scanner input = new Scanner(System.in) ;
  
          int age = input.nextInt();
  
          if(age <= 0 || age >=150){
              //年龄越界，但我们处理，需要将其总结(产生对象)，抛给别人处理
  
              throw new AgeOutOfBoundsException(age+"") ;
          }
  
      }
  ```

  

  ```java
  /**
   * 准备自定义一个异常类
   * 其对对象用来描述输入的年龄超出范围(1-150)
   *      未来如果输入的年龄超出范围，就可以创建该异常对象并抛出
   *      未来如果捕获了这个异常对象，就表示输入的年龄超出的范围
   *
   *
   * 我们希望这个类"是一个"异常类
   * 我们给他起名字叫Exception 这个类就是一个异常类了么？
   * 是一个  is-a  关系  可以通过继承父类或实现接口方式  体现。
   */
  class AgeOutOfBoundsException extends Exception {
      public AgeOutOfBoundsException(String msg){
          super(msg);
      }
  
      public AgeOutOfBoundsException(){
          super();
      }
  }
  ```

  

  * 所有的异常对象，都是Throwable的子类

    1. 创建异常对象时，为异常对象提供更具体的异常信息

       `throw new AgeOutOfBoundsException(age+"") ;`

    2. 异常是在某一个方法中产生的。

       * 如果没有立刻进行try-catch处理，就会自动的向上抛给调用者
       * 如果所有的调用者都没有try-catch处理，就会抛给jvm，jvm的处理手段就是现实错误，停止程序
       * throwable中有一个printStackTrace() 打印这个异常经过的栈过程，可以分析异常产生的位置

    3. 异常产生的原因可能是因为另一个异常

       * 每一个异常对象，都可以作为另一个异常对象的产生原因
       * 可以在创建异常对象时，传递上一个异常原因
       * 可以利用getCause()获得当前问题的原因
       * 这些一系列异常原因称为： 异常链

    ```java
    public class Test2 {
        public static void main(String[] args) {
            try {
                a();
            } catch (Throwable a) {
                a.printStackTrace();
            }
        }
    
        public static void a() throws Throwable {
            try {
                b();
            } catch (Throwable b) {
                throw new Throwable("a出了问题",b);
            }
        }
    
        public static void b() throws Throwable {
            try {
                c();
            } catch (Throwable c) {
                throw new Throwable("b出现了问题",c);
            }
        }
    
        public static void c() throws Throwable {
            try {
                d();
            } catch (Throwable d) {
                throw new Throwable("c出了问题",d);
            }
        }
    
        public static void d() throws Throwable {
            Scanner input = new Scanner(System.in) ;
    
            int age = input.nextInt();
    
            if(age <= 0 || age >=150){
                //年龄越界，但我们处理，需要将其总结(产生对象)，抛给别人处理
    
                throw new Throwable("d出了问题");
            }
            System.out.println(age);
    
        }
    }
    ```

# 2021-12-24

## 5 泛型

### 1） 什么泛型：

* 参数化类型 ： 在编写内容时，有些类型不确定，需要在这些内容被使用时，以类似于参数的形式传递(指定)具体的类型。
  * 方法参数：方法在执行时，需要一些数据，但这些数据在编码时不确定，就可以定义参数。使用者在调用方法就是传递具体的数值了。
* 如果类型不确定， 我们可以使用Object来表示呀，Object是所有类的爹，Object可以表示任何类型。
* 为什么还要使用泛型呢？

### 2） 泛型的作用

* 使用泛型可以在编译时进行类型检查，提高安全性。
* 使用泛型，可以有效的减少或避免强制类型转换的代码
* 通过泛型的使用，能更好的提高程序员的综合设计能力。

### 3） 泛型的使用（定义）

* 在编写一些内容时，有些内容的类型不确定，就可以考虑使用泛型了(1.5+)。 也可以使用Object（1.5-)

* 在编写哪些内容时，可能出现类型不确定呢？  2种

  1. **编写类和接口内容的时候**

     * 在编写类的时候，如果类中有些内容的类型不确定。 类中哪些内容的类型不确定？类中哪些内容会有类型

       * 属性类型
       * 参数类型
       * 返回类型

     * 就可以暂时定义泛型来代替那些不确定的类型

       * 在定义类时，在类名的后面使用`<T>` 定义泛型。 表示这个类中有些内容的类型不确定。但这些内容的类型是相同的，暂时使用T来代替

       * <>中的T是任意的，也不一定是一个字母。

         ```java
         class A<T>{
             T a1 ;
         
             public void a2(T x){
         
             }
         
             public T a3(){
                 return null ;
             }
         }
         ```

       * 注意：也可以定义多个泛型

         * 上面的例子是，有3个内容类型不确定，但能确定是3个内容是同一个类型。是一个类型不确定

         * 也有可能3个内容，会有3种类型，都不确定，就都是用泛型来代替，所以需要3个泛型

         * 多个泛型只需要使用逗号隔开 `<T1,T2,T3>`

           ```java
           class A<T1,T2,T3>{
               
               T1 a1 ;
           
               public void a2(T2 x){
           
               }
           
               public T3 a3(){
                   return null ;
               }
           }
           ```

           

  2. **单独编写方法内容的时候**

     * 方法定义泛型时，和类无关。 

     * 在编写方法时， 方法的返回类型，参数类型，局部变量类型有可能不确定，需要在方法被使用（调用）时确定，此时就可以使用方法泛型

     * 在返回类型前，使用`<T>`来定义泛型，**表示这个方法中有些内容的类型不确定，但这些内容的类型都相同，暂时用T代替**

       ```java
       public static <T> T t1(T x){
           T y ;
           
       }
       ```

     * 方法中的泛型同样可以定义多个

### 4） 泛型指定（传递）

1. **类和接口指定泛型**

   * 在使用类和接口时指定泛型

     * 使用类定义变量时

       `A<String> a;`

       现在使用A类型来定义变量，使用A时发现，A中有一个类型不确定，需要现在使用时指定，指定为String

     * 使用类同名的构造器创建对象时

       `new A<String>()`

2. **方法指定泛型**

   * 在使用方法时，来指定泛型。

   * 所谓的使用方法就是调用方法

     * 通过传递的参数的类型来确定
     * 通过接受返回值的变量的类型来确定

     ```java
     public static void main(String[] args) {    
     	String a = A.t1("dmc");    
     	String b = A.t2();
     }
     ```

### 5） 泛型的一些扩展（特殊）

* **泛型只能传递引用类型，不能传递基本类型**
  * 我们知道java的数据类型，分2类 （基本类型，引用类型）
  * 如果要传递基本类型，可以使用其包装类。



* **泛型定义时，可以指定边界**

  * 泛型本身的含义，就是类中有一些内容类型不确定，暂时定义一些泛型来代替。

  * 但在某些情况下，虽然具体不确定，但这个类型能确定一些东西，从而可以缩小检查范围。

    * 能确定这个类型，是某一个类型的父类
      * **这种情况不存在  `<T super A>`**
      * 从含义上，似乎表达的是 “T表示A或A的父类”   
      * 但实际上，这个泛型也可以包含A的所有方法
      * 但A的父类不一定有和A一样的方法。 但A的子类一定有和A一样的方法。
    * 能确定这个类型，是某一个类型的子类

    ```java
    class A extends AA2{}
    
    class A1 extends A{}
    
    class A2 extends A{}
    
    class A3 extends A{}
    
    class B <T extends A> {
        T a ;
    }
    ```

    * B中有些内容的类型不确定，定义个泛型，暂时用T来代替。 但这个泛型能明确一点，未来一定是A或A的子类类型

  

* **泛型指定时，使用通配符【?】**

  * 所谓的通配符，就是可以匹配多个

  * 但泛型指定时，不是应该指定具体的类型，为什么还要统配呢？

    

  * 使用统配有一个前提，就是存在一个明确泛型的对象

    * 注意： A1 extends A

      ​            A a= new A1();   可以   上转型

      ​			X<A> a = new X<A1>()

  * 再定义一个类型变量，准备接收上面的变量值时

    * 如果新定义变量中的泛型 和 已定义变量中的泛型不一致，就会出现编译错误

    * 即使连个变量的泛型存在子父关系也不可以

      ```java
      public class Test5 {
          public static void main(String[] args) {
              A<B1> a1 = new A();
      
              A<B2> a2 = new A();
      
              A<B3> a3 = new A();
      
      
              t1(a1 ); //报错
              t1(a2 ); //报错
              t1(a3 ); //报错
          }
      
          public static void t1(A<B> a){
      
          }
      }
      
      class A<T extends B>{
          T a ;
      }
      
      class B{}
      
      class B1 extends B{}
      
      class B2 extends B{}
      
      class B3 extends B{}
      ```

    * 此时就可以使用通配符 ? 

      `public static void t1(A<?> a){}`

    * 注意： ?也表示一个具体类型，就是所有类型

    * 注意： 同样，这个所有类型的范围也可以调整

      `public static void t1(A<? extends B> a){}`

      * 不能对a进行赋值操作，可以取值  （能取不能存）
      * 不能存，是因为不确定是B的哪一个子类
      * 能取，是因为无论哪个子类都可以使用父类B表示（上转型）

      <img src="images/21122401.png" style="zoom:50%;" />

      ``public static void t1(A<? super B> a){}`

      * 表示泛型一定是B的父类
      * 此时就可以为a.a = new B(). 
      * 因为无论是哪个父类，B都可以上转型存储
      * 不能直接取值，需要强转，还可能报错

    * 这里就体现了泛型的一个原则： PECS

```java
Node curr = head.next ; 
Node newLink = new Node();
Node last = newLink.next() ;
while(curr != null){
    if(last == null){
        last = curr ;
        curr = curr.next ;
    }else{
        last.next = curr ;
        curr = curr.next ;
        last = last.next ;
    }
}
```

# 2021-12-30

## 6 数据结构概述

* 如何可以更好的学习和掌握面向对象相关的知识内容
* 如何强化面向对象的编程思想
* 可以在封装过程中来进行强化
* 接下来我们就准备封装各种容器

### 1） 容器

* 所谓的容器就是可以用来装载多个数据
  * 变量本身也是一个容器，但只能装载一个数据
  * 我们封装的容器是用来装载多个数据的
* 在之前的学习内容，数组和对象可以装载多个数据，为什么还要封装容器呢
* 这需要先来了解一下数据结构

### 2） 数据结构

* 计算机存储和组织（管理）数据的一个中方式
* 随着不同的需求，选择不同的数据结构（数据处理方式），可以提高程序存储和运行的效率。
* 数据结构有不同分体，大体上可以分为以下这两类
  1. **线性存储结构**
  2. **非线性存储结构**

### 3） 线性存储结构

* 在逻辑上，存储的数据是一个接一个

* 也有更细致的划分

  1. **顺序表 ：**

     * 线性存储结构中的一种
     * 不仅数据在逻辑上是挨着的，在物理也是挨着的。
     * 优点：
       * 数据随机查找时会非常的方便，会很快
       * 每一个位置都会有一个索引
     * 缺点就是： 
       * 为了确保物理上的连续性
       * 每次存入新数据都需要其他数据的位置移动。
       * 每次移除数据也需要其他数据的位置移动。
     * 可以使用数组来实现顺序表的存储结构。

  2. **链表**

     * 存储的数据只在逻辑上连续。物理上不连续的。
     * 利用所谓的指针，由前一个数据指向下一个数据
     * 数据在物理位置没有要求
     * 优点
       * 在添加和移除元素的时候，不需要考虑其物理位置，也就是不需要移动位置
       * 只需要断开一些指针，重新连接即可
     * 缺点：
       * 因为物理位置不连续
       * 所以要想找到某一个元素，必须从头捋
     * 可以使用 指针（数组下标） + 对象 来实现，也可以使用 指针（对象引用） + 对象 来实现
       * java中没有指针这个概念，这里面我们说的指针一般指的数组的下标或对象引用。

     <img src="images/21123001.png" style="zoom:50%;" />

  3. **栈**

     * 特殊的线性结构
     * 相比于之前的顺序表和链表，更多的是在逻辑上增加了一些需求
     * 要求数据存取只有一个口。 数据的存取特点是先进后出，也可以说后进先出
     * 如何实现： 利用顺序表或链表都可以实现。

     <img src="images/21123002.png" style="zoom:50%;" />

  4. **队列**

     * 特殊的线性结构
     * 在逻辑上增加了需求
     * 存取数据有2个口，存有一个入口，取有一个出口。 数据的存取特点是先进先出
     * 如何实现： 顺序表和链表都可以实现。  

### 4） 非线性结构

* 逻辑上数据不是一个挨一个。   有可能是一个挨多个，或多个挨一个，或多个挨多个

  1. **树**
     * 有一个根元素，可以挨着多个子元素。 
     * 根据逻辑画出来的效果是一棵倒置的树
     * 用什么技术实现？ 
       * 指针+对象
       * 数组

  2. **hash表**

     * 又称为散列表

     * 内部也是有一定的规律

     * 存储数据时，需要额外提供一个键  

       ​	 dmc--董明晨 ， zzt--郑中拓 ， zs--张三

     * 存储结构利用一些算法（hash算法），通过键，快速计算出其"幸运"位置，并存储

     * 这这个位置前后不一定有数据，所以数据不是连续的

     * 查找数据时，通过这个键，依然可以快速的找到其存储的位置。

     * hash表的存取特点就是单一数据的快存，快取

     * 注意： hash表存储数据时可能会产生一个问题——哈希碰撞

       ​	有可能两个数据的键，通过hash算法，算出了同一个位置。 表示碰撞。

       ​	但毕竟是2个不同的数据，需要都存起来

       ​	hash表存储时，还需要考虑碰撞后的存储方式

     * 可以采用：  数组 + 链表的方式实现， 也可以  数组 + 数组的方式实现 ， 数组 +红黑树的方式

     ![](images/21123003.png
     )

  3. **堆**

     * 是树的一种特殊实现

  4. **图**

### 5） 总结

* 综上可知，不同的数据结构有不同的特点
* 我们可能会在不同的存储场景中，需要不同的存储结构
* 这些数据结构是概念上的
* 如果我们想按照某种结构实现数据的存取
* 这个存取操作需要我们自己编码实现
  * 其中最简单的就是顺序表，可以用我们学过的数组来实现
  * 但为了确保顺序代表存储特点，插入和删除后的数据移动需要我们自己利用数组来实现
  * 当数据不足时，数组空间的扩容已经数据数据的复制，需要我们自己去实现
* 相比之下，链表，哈希表，树这些结构的代码实现，要远比数组实现顺序表更复杂
* 难道我们每次需要用到这些数据结构，需要去把对应的功能代码写一边么？
* 肯定不是
* 所以我们需要对其进行封装
  * 假如：封装一个容器，其内部使用顺序表存储。 
  * 假如：封装一个容器，其内部使用链表存储。
* 所以接下来我就开始准备封装这些内存储结构不同的容器了！！

# 2022-01-06

## 7 数组结构的容器封装

### 1） 封装目的

1. 对之前面向对象知识的综合运行

2. 首先我们了解了存储数据，有不同的数据存储结构。选择合适的存储结构可以提高我们的运行和存储效率

   所以我们应该知道，对数据结构的选择是有意义。

   假设现在有一个存储环境，需要顺序结构存储

    * 特点：
      	* 存储的数据连续
         	* 有下标，利用下标可以快速检索数据
   * 缺点：
     * 为了确保连续性，每次插入数据 和 删除数据都需要移动数据

   我们可以使用数组来实现顺序结构的存储

   但问题出现了。  每次需要顺序结构存储时，都使用数组。

   但每次插入删除数据，都需要移动剩余数据。

   当数组存储的数据满时，需要自己实现数组的扩容。

   这个时候，我们就考虑可以对数组顺序结构存储实现封装。

### 2） 封装设计

#### 基本结构

```java
/**
 * ArrayBox对象是一个容器
 * 可以存储多个数据
 * 对外提供了存储数据的方法（api）  ，未来如果有数据需要存放，就可以创建ArrayBox对象，通过方法实现存取。
 * 在容器底层，使用顺序结构来存储数据（array）
 *      new ArrayBox().add()
 */
public class ArrayBox<E> {

    /**
     * 一个数组，来存储使用者向容器中存放的数据
     *      使用者将数据存入容器
     *      容器将数据存入数组
     *      容器为什么要将数据存入数组呢？ 因为通过我们的人为定义，让这个容器内部实现顺序表存储
     */
    private Object[] elements  ;
    
}
```



#### 构造器

* 提供3个构造器
  1. 默认构造器，创建默认长度的数组
  2. 指定长度的构造器，创建指定长度的数组
  3. 指定初始内容的构造器，创建与初始内容长度相同的数组
     * 注意：不能直接使用初始化的数组，需要创建新数组，防止外部通过引用修改容器内部的数据。

```java
/**
 * ArrayBox对象是一个容器
 * 可以存储多个数据
 * 对外提供了存储数据的方法（api）  ，未来如果有数据需要存放，就可以创建ArrayBox对象，通过方法实现存取。
 * 在容器底层，使用顺序结构来存储数据（array）
 *      new ArrayBox().add()
 */
public class ArrayBox<E> {

    /**
     * 一个数组，来存储使用者向容器中存放的数据
     *      使用者将数据存入容器
     *      容器将数据存入数组
     *      容器为什么要将数据存入数组呢？ 因为通过我们的人为定义，让这个容器内部实现顺序表存储
     */
    private Object[] elements  ;
    private static final int DEFAULT_LENGTH = 10 ;

    /**
     * 创建容器，自定义容器长度
     * @param length
     */
    public ArrayBox(int length){
        elements = new Object[length];
    }

    /**
     * 创建一个默认容器
     */
    public ArrayBox(){
        //如果使用者使用了默认构造器创建容器对象，表示使用者不确定会装多少数据，也不确定什么时候开始装数据
        //我们可以有两种处理手段
        //1. 给一个默认长度的数组
        //2. 先不创建数组，第一次使用的时候再创建
        elements = new Object[DEFAULT_LENGTH] ;
    }

    /**
     * 创建一个容器，并传递初始数据
     */
    public ArrayBox(E[] elements){
        //this.elements = Arrays.copyOf(elements,elements.length) ;
        //this.elements = arrayCopyOf(elements) ;
        this.elements = elements.clone() ;

    }

    private Object[] arrayCopyOf(E[] elements){
        ArrayList list ;
        Object[] newElements = new Object[ elements.length ];
        for(int i=0;i<elements.length;i++){
            newElements[i] = elements[i] ;
        }
        return newElements;
    }

}
```

#### 添加方法（add）

* 人为规定，新输入插入到数组的最后一个空位置
* 由于我们封装的容器是基于顺序表，所以数据存放是连续的
* 只要我们知道最后一个数据的存储位置
  * 所以我们可以定义一个成员变量last，记录最后一个数据存储的位置。
* 是不是就可以知道新数据的存储位置 （last+1)
* 注意：这里有一个问题，需要考虑容量问题。
  * 检查一下，看看还有没有足够的剩余空间来存储此次的数据。
    * 有，就拉倒
    * 没有，就扩容
  * 现在我们实现的是add方法，用来添加一个数据
  * 未来我们还有addAll方法，可以添加一组数据
  * 所以我们在检测剩余空间时，要考虑多种情况。
    * add方法根据自己实际添加的数量，给出对数组的期望容量
    * 再比较期望容量和实际容量的关系，绝对是否扩容

```java
/**
     * 检测容量，充足就结束。不充足就扩容
     * 保证检测之后，容量一定充足。
     * @param expect 希望数组的容量
*/
private void checkCapacity(int expect){
    if(expect <= this.elements.length){
        //希望容量，比实际的容量小，足够
    }else{
        //不够，扩容
        //什么是扩容
        //  就是创建一个长度更大的数组，将原来的数组中的数据，写入到新数组中
        //  扩容之后，长度也可能不够
        //      原数组长度5,存储了3个元素（空2个），现在使用者利用addAll添加了20个
        //      希望的空间是多少20+3 > 5--> 10 < 23
        int length = this.elements.length<<1 ;
        if(length < expect){
            //我准备扩容的长度 依然小于期望的长度。 就按期望长度扩容
            length = expect;
        }
        Object[] newElements = new Object[ length ] ; //*2
        for(int i=0;i<this.elements.length;i++){
            newElements[i] = this.elements[i] ;
        }

        this.elements = newElements ;

    }
}
```

```java
/**
        向容器的末尾插入一个数据
        @param e  要存储的元素
*/
public void add(E e){
    //数据e需要存储到内部数组的下一个空位置   最后一个数据存储的位置 + 1
    //一定存在空位置么？不一定，有可能已经存储满了。
    //需要先检测一下容量. 此次容量检测，希望容量是当前容量+1 。 当前容量是多少 ,要找到存储了多少数据。
    //我们并不知道存储了多少数据，只知道存储的最后一个数据的位置是last ， 一共存储了last + 1个元素
    checkCapacity((last+1) + 1);

    this.elements[last + 1] = e ;
    last++ ;
}
```

# 2022-01-13

#### 插入方法（add)

* 本身也是添加元素，所以需要考虑容量问题
* 但添加之前，需要先考虑其插入位置是否合法，所以需要先检查位置

```java

private void checkPosition(int index){
    if(index >= 0 && index <= last+1){
        //位置是可以
    }else{
        //这个位置是有问题，越界。
        //问题出现在容器内部，但产生问题的原因，不怪我的容器，因为是传入的位置有问题
        //问题在容器的使用者。 这个问题容器能帮处理么？ 不应该。
        //容器应该吧问题抛给使用者，让使用者处理。
        //怎么把问题抛给使用者?  throw 抛出异常
        throw new BoxIndexOutOfBoundException("Size:"+(last+1)+",Index:"+index) ;

    }
}
```



```java
/**
     * 向容器中的指定位置插入一个数据。 此位置及其后面的数据，需要移动。为了确保连续性
     * @param e         要插入的元素
     * @param index     要插入的位置
*/
public void add(E e , int index){
    //需要先验证一下，插入的位置是否正确
    checkPosition(index);

    //程序可以执行到该行代码，表示上面的方法没有出现异常。位置可以插入
    //位置没有问题，还需要检查一下，容量是否够用。
    //last+1 现在存储元素的数量
    checkCapacity((last+1)+1);

    //此时就一定有足够的空间（要么原来空间就够，要么原来空间不够，扩容之后就够了）
    if(index == last+1){
        //插入到最后一个位置，就不需要移动其余的数据了
        elements[++last] = e ;
    }else{
        //数据插入之前，需要将原来的那些数据（从index往后的数据），依次向后移动

        /*
                1. 原数组，要复制的数据
                2. 原数组复制起始位置
                3. 目标数据，要复制到哪个数组中
                4. 目标数组的起始位置
                5. 复制的长度
             */
        System.arraycopy(elements,index,elements,index+1 ,(last-index+1));

        elements[index] = e ;
        last++ ;
    }

}
```

* **扩展： System.arraycopy方法的使用**

  ```java
  /*
      1. 原数组，要复制的数据
      2. 原数组复制起始位置
      3. 目标数据，要复制到哪个数组中
      4. 目标数组的起始位置
      5. 复制的长度
  */
  System.arraycopy(elements,index,elements,index+1 ,(last-index+1));
  ```

  <img src="images/22011301.png" style="zoom:50%;" />

# 2022-01-14

#### 获得方法（get）

* 因为ArrayBox内部是一个顺序存储结构
* 么一个元素都有存放下标位置
* 所以可以利用这个下标，快速的找到并获取对应的元素。
  * 注意： 获取数据时 和 插入数据时，对位置的检查是一样的。 插入时允许最后一个空位置。

```java
/**
     * 获取指定位置的数据
     * @param index
     * @return
*/
public E get(int index){
    //在获取元素之前，需要检查一下索引位置是否正确
    this.checkPositionForGet(index);
    return (E) elements[index];
}

/**
     * 为了获取数据提供的检查方法
     * @param  index [0,last]
*/
private void checkPositionForGet(int index){
    if(index < 0 || index>last){
        //超出了范围，无法获取数据。这是一个问题
        throw new BoxIndexOutOfBoundException("Size:"+(last+1)+", Index:"+index) ;
    }
}
```

#### 获得容器容量方法（size）

```java
/**
     * 获得容器存储数据的数量。
     * @return
*/
public int size(){
    return last + 1 ;
}
```

#### 删除方法（remove）

* 所谓的删除就是将数组位置设置成默认值。（null）

```java
/**
     * 移除指定位置的数据。并将这个数据返回。
     *      移除之后，为了确保连续性，需要移动
     * @param index
     *
     * @return E 此次删除的那个位置的元素
*/
public E remove(int index){
    //需要根据位置，删除元素
    //再此之前，需要确保这个位置是正确的，需要检测。
    checkPositionForGet(index);

    E e = (E) elements[index];

    //将index后面的数据依次向前一个位置复制
    System.arraycopy(elements,index+1,elements,index,last-index);

    elements[last--] = null ;
    return e ;
}
```

# 2022-01-20

## 8 链表结构的容器封装

### 1） 链表结构特点

* 数组结构，存储的多个数据之间是物理上连续的，所以每一个数据有存储的位置，可以通过位置（下标）快速访问。但在插入删除时，为了确保数据的物理连续，需要移动数据，从而拉低性能。
* 链表结构，可以存储多个数据，多个数据在物理位置上是非连续的，逻辑上是连续。
  * 因为物理上不连续，所以在插入删除时，就不需要移动数据位置，速快较快，O(1)
  * 反之，在查询数据时，效率较低。每次查询都需要从头开始数。O(n)
* 链表结构是通过一个一个节点实现数据存储的。
* 每一个节点，既存储当前的元素，又存储关联的节点地址（指针）
  * 关联下一个节点 （单向链表）
  * 关联上一个和下一个节点（双向链表）

### 2） 链表结构的设计

* 链表是由一个一个的节点连接而成

* 每一个节点 要存储元素，还要存储下一个节点指针（地址）

  * 一个节点要存储好多信息
  * 在java中用什么结构可以存储好多信息呢？ **对象**

  ```java
  /**
   * 表示链表中的一个节点
   * 按需，存储字符串
  */
  static class Node{
      String element ;
      //下一个节点的地址（指针）
      Node next ;
  
      public Node(String element, Node next) {
          this.element = element;
          this.next = next;
      }
  }
  ```

* java中如何存储链表

  * 对于数组结构而言，我们可以在堆内存中创建一个数组空间，这数组空间就是一组物理连续的变量空间

    在使用时，我们只需要定义一个变量，存储数组地址，未来就可以找到整个数组空间，就可以找到空间中的数据

    ```java
    //nums变量中就相当于存储着数组
    int[] nums = new int[] ;
    ```

    

  * 对于链表结构而言，是由一个一个的节点组成，每一个节点都是一个对象，都有一个存储空间。我们使用链表时，只需要定义一个变量，存储链表中第一个节点的地址即可 （头结点），这样就可以通过头结点，依次找到后续节点。
  
    ```java
    public static void main(String[] args) {
        //现在有一个存储场景，需要使用链表结构存储。
        //所以我们准备创建一个链表。
        //java中只有数组的语法，没有链表的语法。
        //所以链表需要我们自己根据链表的结构特点，手动设计。
        //数据存储在链表中，有几个数据，就需要有几个节点
        Node node1 = new Node("dmc",null) ;
    
        Node node2 = new Node("zzt",null) ;
    
        Node node3 = new Node("andy",null) ;
    
        //指定逻辑存储顺序
        node1.next = node2 ;
        node2.next = node3 ;
    
        //定义一个变量存储头节点，未来根据头节点就可以获得整个链表内容
        Node head = node1 ;
    
        //有一个新节点，如何放置在链表的最后呢?
        Node newNode = new Node("ella",null);
    }
    ```

# 2022-01-21

### 3）链表结构应用

#### a 链表遍历

* 从头到尾，将所有的节点依次遍历

```java
//先来遍历显示链表内容
if(head == null){
    //链表中没有节点，没有数据
}else{
    //链表中有节点，我们就要一个一个遍历，直到最后一个。 next==null
    Node curr = head ;

    do{
        System.out.println(curr.element);
        curr = curr.next ;
    }while(curr != null);
}
```

#### b 链表添加

* 追加到结尾

```java
{
    //准备向链表的末尾增加一个数据  ella
    //数据在链表中的存储一定是节点的形式
    Node newNode = new Node("ella", null);
    //只需要找到最后一个节点，将其next=newNode
    //在链表中，从head开始找，哪一个节点的next==null就是尾节点
    Node curr = head;
    while (true) {
        if (curr.next == null) {
            //curr就是尾节点
            break;
        } else {
            curr = curr.next;
        }
    }
    //循环结束后，curr存储的就是尾节点
    curr.next = newNode;
}
```

#### c 链表插入

<img src="images/22012101.png" style="zoom:50%;" />

```java
{
    //要插入一条记录 语晴， 插入在dmc和zzt之间，也就是让语晴作为第二个节点（下标1）
    //dmc 原来指向zzt，现在指向语晴， 语晴指向zzt
    Node newNode = new Node("语晴", null);

    Node curr = head ;
    while(true){
        if(curr == null){
            break ;
        }else if(curr.element.equals("dmc")){
            break ;
        }else{
            curr = curr.next ;
            continue ; //继续找下一个
        }
    }
    //要么找到了，要么没有
    if(curr != null){
        //找到了dmc ， dmc的下一个变成语晴,语晴的下一个变成dmc原来的下一个(zzt)
        Node old_next = curr.next ;
        curr.next = newNode ;
        newNode.next = old_next ;
    }
}
```

# 2022-01-27

### 4） 链表容器封装设计

* 自定义一个容器类

* 内部准备使用链表结构实现数据的存储

  ```java
  public class LinkedBox<E> {
  
      private static class Node<T>{
         T element ;
         Node next ;
         Node prev ;
  
         public Node(T element , Node prev , Node next){
             this.element = element ;
             this.prev = prev ;
             this.next = next ;
         }
      }
  
      //该变量，本身存储的是链表的头节点
      //从链表的结构特点可知，获得了头节点，就可以获得整个链表。
      private Node head ;
  
      //该变量，本身出的是链表的尾节点
      private Node last ;
  
  	//api .....
  }
  ```

  

* 外部只需要提供简单的api调用即可。

  ```java
  /**
   * 是一个容器，外部使用者可以利用容器存储多个元素
   * 对外我们提供相应api，使用者只需要调用对应api就可以完成数据的存取操作
   * 对内，我们在容器中准备使用链表结构实现数据的存储
   *      链表结构存储数据，逻辑上有序
   */
  public class LinkedBox<E> {
      private static class Node<T>{}
      private Node head ;
      private Node last ;
  
      /**
       * 允许外部使用者，向容器中存入元素
       * @param e
       */
      public void add(E e){
          //内部需要将元素存入链表结构
      }
  
  
      /**
       * 允许外部的使用者，从容器中获得元素
       * @return
       */
      public E get(int index){
          //内部需要从链表结构中获取元素。
          return null ;
      }
  
  }
  ```

* 测试类只需要通过api使用容器，就相当于使用链表

  ```java
  public static void main(String[] args) {
          //我们想要使用链表结构存储数据
          //自己设计链表，太麻烦了
          //想使用一个别人设计好的链表结构。
  
          LinkedBox<String> box = new LinkedBox<>() ;
          box.add("dmc");
          box.add("zzt");
          box.add("语晴");
  }
  ```

#### a 添加元素方法（add）

```java
/**
     * 允许外部使用者，向容器中存入元素
     * @param e
*/
public void add(E e){
    //内部需要将元素存入链表结构
    //元素必须组装成节点，才可以加入链表
    Node<E> newNode = new Node(e,null,null);

    //新节点一定是存储在末尾
    if(head == null){
        //没有头节点。 也就是没有尾节点
        head = newNode ;
    }

    if(last != null){
        //有尾节点，新节点就是原来尾节点的下一个节点，原来的尾节点，就是新节点的上一个节点。
        last.next = newNode ;
        newNode.prev = last ;
    }
    last = newNode ;

}
```

# 2022-01-28

#### b 获取元素方法（get）

* 链表中存储的元素是逻辑有序的

* 所以可以通过逻辑位置来获取指定的元素

  ```java
  /**
       * 允许外部的使用者，从容器中获得元素
       * @return
  */
  public E get(int index){
      //内部需要从链表结构中获取元素。
      return null ;
  }
  ```

* 但需要先判断位置是否正确（越界）

  ```java
  int size = 0 ;
  
  public void add(E e){
      //....
      size ++ ;
  }
  
  private void checkPosition(int index){
      if(index >=0 && index < size){
          return ;
      }
      //position位置有问题  Size:5,Index:5
      throw new BoxIndexOutOfBoundException("Size:"+size+",Index:"+index) ;
  }
  ```

* 查找元素是，因为是双向链表，可以从头找，也可以从尾找

* 为了提供查找的性能，判断元素所处的位置（前一半，后一半）

  ```java
  public E get(int index){
      //内部需要从链表结构中获取指定位置的元素。
      //需要从头 或 从尾 数到指定的位置。
      //  在找之前需要先做一件什么事？先检查位置是否正确
      checkPosition(index);
  
      //代码执行至此，证明上面位置检测是成功的，因为没有抛出异常。
      //为了提高查找性能，需要考虑带查找元素在链表的哪一个部分（前一半，后一半）
      Node<E> curr ;
      if(index < size>>1 ){
          int count = 0 ;
          curr = head ;
          while(count++ < index){
              curr = curr.next ;
          }
      }else{
          int count = size - 1;
          curr = last ;
          while(count-- > index){
              curr = curr.prev ;
          }
      }
  
      return curr.element ;
  }
  ```

* **注意：** 

  * 此时就可以利用get方法和size来遍历获得容器中所有的元素

    ```java
    LinkedBox<String> box = new LinkedBox<>() ;
    box.add("dmc");
    box.add("zzt");
    box.add("语晴");
    
    
    //String name = box.get(2) ;
    //System.out.println(name);
    
    for(int i=0;i<box.size();i++){
        String name = box.get(i);
        System.out.println(name);
    }
    ```

  * 但这里有一个问题就是，外部通过序号依次获得对应的元素。但内部，这个获取过程并不连续，而每一次都需要从头/尾找到对应位置的元素，
  * 从而内部的查询效率较低
  * **可以考虑使用迭代器来提供【遍历】链表元素的效率**

# 2022-02-10

#### c 迭代器封装遍历（Iterator）

* 之前我们已经完成了链结构的添加和获取
* 就可以利用获取方法，实现链表元素的遍历（从头到尾）
* 外部来看，就是根据逻辑顺序，依次获取第1个，第2个，第3个。。。。
* 内部发现，每次获取元素的时候，都需要从头数一遍。效率极低
* 为了提高链表内部的**遍历**效率，可以使用迭代器



* 有容器内部提供一个迭代器对象
* 这个对象可以从头到尾依次获得容器中的每一个元素。
* 当（外部的）容器的使用者想要遍历容器中的元素时，就不需要自己一个一个去遍历
* 只需要向容器获得迭代器，利用迭代器可以更快速的完成容器元素的变量。



* jdk为我们提供了一个迭代器的规范

  ```java
  public Iterator iterator(){
      return new LinkedIterator() ;
  }
  
  class LinkedIterator implements Iterator{
      private Node next = head;
      @Override
      public boolean hasNext() {
          return next != null;
      }
  
      @Override
      public Object next() {
          if(next == null){
              //证明没有下一个元素了，结果还要写一个元素
              //应该抛出一个异常
          }
          Object result =  next.element;
          next = next.next;
          return result;
      }
  }
  ```

  ```java
  Iterator<String> it = box.iterator();
  while(it.hasNext()){
      String name = it.next();
      System.out.println(name);
  }
  ```

#### d 加强for循环遍历

* 容器是用来存储元素的
* 不同的容器，内部使用不同的数据结构来存储元素。
* 有些结构适合遍历检索
* 有些结构不适合遍历检索
* jdk也提供了一个规则（Iterable），建议所有适合遍历容器，都遵守这个规则。
  * 一旦遵守了这个规则，容器内部就应该提供一个更适合遍历的迭代器对象



* jdk1.5之后，提供了一种新的for循环遍历方式，就是增加for循环 （写法更简单，但只适合从头到尾遍历）

* 增强for循环的使用有前提条件， 只能遍历数组 和 可迭代的容器(实现 Iterable)。

  ```java
  int[] nums = new int[]{1,2,3};
  for(int num :nums){
      ....
  }
  //==>
  for(int i=0;i<nums.length;i++){
      int num = nums[i] ;
      ....
  }    
  ```

# 2022-02-11

#### e 删除元素方法（remove）

* 所谓的删除一个元素

* 就是将这个元素所处的节点删除掉。

* 要想删除节点，需要先找到这个节点。

* 无论获取元素，还是删除元素，都需要先获得对应节点。所以将获得节点的方法做一个封装

  ```java
  private Node<E> selectNode(int index){
      //内部需要从链表结构中获取指定位置的元素。
      //需要从头 或 从尾 数到指定的位置。
      //  在找之前需要先做一件什么事？先检查位置是否正确
      checkPosition(index);
  
      //代码执行至此，证明上面位置检测是成功的，因为没有抛出异常。
      //为了提高查找性能，需要考虑带查找元素在链表的哪一个部分（前一半，后一半）
      Node<E> curr ;
      if(index < size>>1 ){
          int count = 0 ;
          curr = head ;
          while(count++ < index){
              curr = curr.next ;
          }
      }else{
          int count = size - 1;
          curr = last ;
          while(count-- > index){
              curr = curr.prev ;
          }
      }
      return curr ;
  }
  ```

* 设计删除方法

  * 找到要删除的节点
  * 让上一个节点忘了待删除节点（需要考虑头节点情况）
  * 让下一个节点忘了待删除节点（需要考虑尾节点情况）
  * 让待删除节点忘记上一个和下一个节点

  ```java
  public E remove(int index){
  
      Node<E> curr = selectNode(index);
  
      Node<E> prev = curr.prev ;
      Node<E> next = curr.next ;
      E element = curr.element ;
  
      if(prev == null){
          //我的上一个元素是null，证明我是头节点。
          //现在我要被删除了， 证明我的下一个节点变成了头节点
          head = next ;
      }else{
          //我有上一个节点，我被删除后， 我上一个节点下一个节点就变成了我的下一个节点。
          prev.next = next ;
      }
  
      if(next == null){
          //我的下一个是null，证明我是尾节点
          //我删除后，我的上一个变成了尾节点
          last = prev ;
      }else{
          //我有下一个节点，我删除后，我下一个节点的上一个节点就变成了我的上一个节点
          next.prev = prev ;
      }
  
      curr.element = null ;
      curr.prev = null ;
      curr.next = null ;
  
      return element ;
  }
  ```

# 2022-02-17

## 9 哈希结构的容器封装

### 1） 哈希结构存取特点

* 无论哪种数据结构，目的就是实现数据的存取。
* 存储目的在于对单一数据的快存，快取。
  * 希望可以快速找到存放的位置 （放进去，取出来）
* 首选要想快速的根据一个位置，找到其对应的空间，数组是最合适的。
* 所以hash结构底层使用数组来存放数据 （ 数据不是连续的 ），通过下标可以快速找到内存位置。
* hash特点就体现在如何快速找到这个下标。
  * 我们可以通过一些算法，根据要存储的数据，来算出应该存放的位置。
  * 未来我们要从hash结构中取数据的时候，只要我们知道要取的是哪一个数据，就可以用相同的方法来计算出其存储的位置。
* 根据hash结构的存取特点可知，为了可以快速的计算出数据存放的位置，我们在存储数据时，除了需要提供存储的数据外，还需要提供一个可以计算位置的key（生辰八字）
* 所以hash结构存储的数据是由2部分组成的（key-value模式）



* hash结构在根据key计算存储位置时，还有另外一个问题，就是hash碰撞问题
* 所谓的hash碰撞，就是根据hash算法计算位置时，和另外一个不同的key算在了相同的位置上。
  * 遇见相同位置，去重。（后来的去掉不存储）
  * 遇见相同位置，覆盖。（保存后来的，先来的去掉）
  * 遇见相同的位置，如果不是相同的数据key，就都进行存储 （在一个位置上可以存储多个数据，有顺序）
    * **链表** 或 数组



* 如何根据key计算出存储的位置，一般都会利用对象的hashcode

# 2022-02-18

### 2） 哈希容器封装设计

* 使用数组存储元素

* 每一个元素由两部分组成

* 在产生hash碰撞时，碰撞的元素会形成链表，所以每一个元素都是链表中的节点

* 基本设计如下：

  ```java
  public class HashBox<K,V> {
  
      Data<K,V>[] elements ;
  
      /**
       * Data类型不仅仅表示hash结构中存储的数据类型，也表示碰撞后形成的链（节点）
       * @param <K>
       * @param <V>
       */
      class Data<K,V>{
          K key ;
          V value ;
  
          Data<K,V> next ;
  
          public Data(K key, V value) {
              this.key = key;
              this.value = value;
          }
      }
  
      public HashBox(){
          elements = new Data[0x10];
      }
  
      public HashBox(int length){
          elements = new Data[length];
      }
  }
  ```

### 3） hash容器封装实现

#### a 添加元素方法（put）

* 外部存储需要传递key和value
* 内部需要组成一个整体
* 根据key计算出位置
* 检测位置上没有数据，直接存放
* 位置上有数据，再检测是否有重复
  * key重复，value覆盖
  * 不重复，作为尾节点插入

```java
public void put(K key , V value){
    Data<K,V> data = new Data<>(key,value);
    //先来计算获得当前元素在数组中存放的位置
    //需要使用key来计算
    //利用hashcode计算位置
    int hash = key.hashCode();
    int index = hash%elements.length ;

    Data old = elements[index] ;
    if(old == null){
        //证明当前位置还没有存储过数据，当前数据就是第一个
        elements[index] = data ;
    }else{
        //证明当前位置已经有数据了
        //证明碰撞了
        //先判断是否重复，不重复就形成链表，重复就覆盖
        //由于之前的数据本身就可能有多个（链表），所以当前的数据会成为链表的下一个还是原链表节点中的重复的一个呢
        Data<K,V> temp = old ;
        while(true){
            if(temp.key == key || 
               temp.key .equals( key ) && temp.key.hashCode() == key.hashCode() ){
                //key重复了,value覆盖
                temp.value = value ;
                return ;
            }
            //当前节点不重复
            if(temp.next != null){
                //有下一个节点,继续判断下一个节点
                temp = temp.next ;
                continue ;
            }
            //代码至此，表示没有下一个节点了，证明到最后都没有重复，证明此次是一个新节点
            //单向链表的头插和尾插
            temp.next = data ;
            break ;
        }
    }

    size++ ;

}
```

# 2022-02-24

#### b 获取元素方法（get）

* 需要利用key快速找到带寻找的元素的位置（下标）

* 如果没有任何元素，表示没有找到  return null

* 如果有元素，也可能是一个链表（多个元素），需要遍历，依次判断。找到返回数据value，没找到返回null

  ```java
  public V get(K key){
      int hash = key.hashCode();
      int index = hash%elements.length ;
      Data<K,V> data = elements[index] ;
      if(data != null){
          //有数据，判断这些数据中有没有要寻找的数据
          if(data.key == key || data.key.equals(key)&&data.key.hashCode() == hash ){
              //找到了
              return data.value ;
          }
          //代码至此，上面的判断没有成立，证明第一个元素不是我们要找到
          //接下来就看看有没有下一个元素
          if(data.next != null){
              //有下一个元素，形成链，遍历链表。
              Data<K,V> temp = data.next ;
              while(temp != null){
                  if(temp.key==key || temp.key.equals(key)&&temp.key.hashCode() == hash){
                      return temp.value;
                  }
                  temp = temp.next ;
              }
  
          }
      }
      return null ;
  }
  ```

  

#### c 移除元素方法（remove）

* 所谓的移除，就是先通过key，找到这个元素，然后将元素删除

* 在删除元素时，有可能是数组的删除，也有可能是链表的删除

  * 所谓的数组删除，就是索引位置只有一个元素，没有形成链表，直接复制成null即可。
  * 如果是链表结构删除，只需要上上一个节点的下一个执行待删除的节点的下一个即可。所以在查找时，既要记录每次的节点，还要记录其父节点，方便删除。

  ```java
  /**
       *
       * @param key
       * @return value 返回被被删除的元素 or null 没有找到被删除的元素
  */
  public V remove(K key){
      int hash = key.hashCode();
      int index = hash%elements.length;
  
      Data<K,V> data ;
      if( (data = elements[index]) == null ){
          return null ;
      }
  
      if(data.key == key || data.key.equals(key)&&data.key.hashCode() == hash){
          //证明数组这个位置的第一个元素就是我们要删除的元素
          elements[index] = data.next ;
          data.next = null ;
          size-- ;
          return data.value ;
      }
  
      //代码至此，找到的第一个元素并不是我们要删除的元素
      if(data.next == null){
          //还没有下一个元素，则表示没有找到
          return null ;
      }
  
      //代码至此，表示第一个元素不是我们要删除的，但还有下一个元素（成链），遍历链表
      Data<K,V> p = data ;	//记录每次查找节点的父级点，方便实现删除
      Data<K,V> temp = data.next ; //记录每次查找的节点
      while(temp != null){
          if(temp.key == key || temp.key.equals(key)&&temp.key.hashCode() == hash){
              //找到了要删除的数据 temp
              //删除 单向链表的删除
              p.next = temp.next ;
              temp.next = null ;
              //返回数据
              size-- ;
              return temp.value ;
          }
          p = temp ;
          temp = temp.next ;
      }
  
      return null ;
  }
  ```

# 2022-02-25

#### d 元素迭代遍历（iterator）

* 尽管我们知道，hash结构更适合的是单一元素的快存快取。

* 但毕竟可以存储多个元素，所以应该可以实现元素的遍历

* 根据之前链表结构的讲解，我们认为，使用迭代器遍历更合适。

* 由于hash结构中存储的容器由2部分组成的（key，value）

* 所以我们的遍历可能会存在3种情况

  * **只遍历key**

    1. hashbox提供方法，可以供使用者获得一个装有key的容器，同时需要自定义keyBox类

       ```java
       /**
            * 会返回一个只装有key的容器
            * 这个容器应该只对当前这个hash结构有效。
            * 所以这个容器类可以定义为一个内部类。
       */
       public KeyBox keyBox(){
           return new KeyBox();
       }
       
       public class KeyBox<K> implements Iterable<K>{
           //keybox中有所少个key，其实就是hashbox中有多少对元素
           public int size(){
               return HashBox.this.size ;
           }
       
           @Override
           public Iterator<K> iterator() {
               return new KeyIterator<>();
           }
       }
       ```

    2. key容器需要实现Iterable接口，使用者可以通过key容器获得迭代器对象Iterator，并自定义迭代器

       ```java
       private class KeyIterator<K> implements Iterator<K>{
       
           K next ;
           int index = 0 ;
           Data curr ;
           Data[] table ;
       
           public KeyIterator(){
               table = HashBox.this.elements ;
               for(int i=0;i<table.length;i++){
                   Data data = table[i];
                   if(data == null){
                       continue ;
                   }
                   //当前data不是null
                   next = (K) data.key;
                   index = i ;
                   curr = data ;
                   break ;
               }
           }
       
           @Override
           public boolean hasNext() {
               return next != null;
           }
       
           @Override
           public K next() {
               K temp = next ;
               //返回当前这次遍历元素的同时，还需要获取下一次遍历的元素。
               //先判断data是不是一个链表，有没有下一个节点。
               //如果有下一个节点，下一个节点就是其下一个元素
               //如果没有下一个节点，就移动光标
               if(curr.next != null){
                   next = (K) curr.next.key;
                   curr = curr.next ;
               }else{
                   //没有下一个节点，需要扫描下标
                   if(index == table.length-1){
                       //证明数组的所有下标位置都已经扫描过了。都没有找到元素
                       curr = null ;
                       next = null ;
                   }else{
                       //后面数组还有位置，就需要继续遍历
                       curr = null ;
                       next = null ;
                       for(int i=index+1;i<table.length;i++){
                           Data data = table[i] ;
                           if(data==null){
                               continue ;
                           }
                           curr = data ;
                           next = (K) data.key;
                           index = i ;
                           break ;
                       }
                       //for循环结束，有2种可能。
                       //一种就是找到了元素，此时next，curr，index都赋值了
                       //另一种就是遍历完整个数组都没有再找到元素，此时next，curr应该都是null
                   }
               }
               return temp ;
           }
       }
       ```

    3. 测试

       ```java
       HashBox<String,String> box = new HashBox<String,String>(3);
       
       box.put("101","dmc");
       box.put("102","zzt");
       box.put("103","语晴");
       box.put("104","博哥");
       
       System.out.println(box.size());
       
       //现在我有一个需求，想将hashbox中的所有key都遍历查看一下
       //我们知道hashbox给我们提供了一个keySet方法，这个方法会返回一个box，这个容器中装着我所需要的key
       HashBox.KeyBox keyBox = box.keyBox();
       //通过hashbox，获得了装有key的容器后，如何从容器中遍历所需要的所有的key呢
       //之前说了，可以使用迭代器
       System.out.println(keyBox.size());
       
       Iterator<String> iterator = keyBox.iterator();
       while(iterator.hasNext()){
           String key = iterator.next() ;
           System.out.println(key);
       }
       ```

    4. 调用过程

       <img src="images/22022501.png" alt="1645774182843" style="zoom:50%;" />

  * 只遍历value

  * 也可能key-value同时遍历

# 2020-03-03

## 10 树结构的容器封装

### 1） 树结构特点

* 是一种逻辑结构， 某一个节点，有一个前序节点，可能多个后续节点。 最终的效果类似于倒置树。
* 可以使用数组 或 链式结构来实现。
* 树相关的概念：
  * 根节点： 每一棵树有且只有一个根节点。
  * 普通节点： 树就是由一个一个的节点链接而成的。
  * 子节点：某一个节点的后续节点。（分支）
  * 叶子节点：没有子节点。

### 2） 树的分类

* 树根据每一个节点拥有的子节点数可以分成不同的形式： 二叉树，三叉树，b树，b+树，234树

#### a 二叉树

* 每个节点最多用2个子节点。

#### b 满二叉树

* 每一个节点要么没有子节点，要么就必须有2个子节点

![image-20220303141958706](images/22030301.png)

#### c 完全二叉树

* 所有的叶子节点必须都在同一层，如果不是满二叉树，叶子节点必须从左到右排列

  ![image-20220303142341104](images/22030302.png)

#### d 二叉搜索树（BST）

* 更关注的是二叉树结构中，存储数据的特点

* 要求存储的数据有顺序，未来查找时，可以利用二分查找机制，提高查询效率。

* 存储数据有顺序的大小特点，要求是：左节点 < 根节点 < 右节点

* 也称为 **二叉排序树**

  <img src="images/22030303.png" alt="image-20220303143639408" style="zoom:50%;" />

* 注意： 在特殊情况下，二叉搜索树可能会形成一个单链表，此时其查找的性能较低

​		`1,2,3,4,5,6`

* 此时就引出了一种新二叉树：平衡二叉树

#### e 平衡二叉树（AVL）

* 基于二叉搜索树

* 要求每一个节点到子节点的高度差不能大于1（平衡因子）

* 如果高度差大于1，会通过左旋和右旋实现平衡。

  <img src="images/22030304.png" alt="image-20220303144924328" style="zoom:50%;" />

* 二叉查找树也好，平衡二叉树也好，目的是为了快速查找所需要的数据

* 如果频繁的需要插入和删除操作，二叉树也需要频繁的旋转。降低效率

* 所以有了新的解决方案：红黑树

#### f 红黑树

* 为每一个节点都设置一种颜色（红 或 黑）
* 根节点必须是黑。
* 叶子必须是黑
* 红的子节点必须是黑
* 任意节点到子节点过程中，黑节点数量一致。

* 新节点初始都是红色，再调整颜色，再检测，再旋转。



* 演示网站：[www.cs.usfca.edu](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)
* 测试数据：10 5 20 30 **40** **50**

### 3） 树的遍历

1. 前序遍历
2. 中序遍历
3. 后序遍历
4. 层序遍历

<img src="images/22030401.png" alt="image-20220304142515138" style="zoom:67%;" />

### 4） 对象比较

* 我们要封装的树形结构，主要是BST，目的就是可以在检索元素时，利用二分查找机制，提高效率。
* 我们知道，二分查找前提是需要确保存储的元素的有大小顺序。
* 有顺序的前提是要求我们存储的元素可以比较。
* 所以在设计树形结构存储容器时，要求使用者在存储元素时要么存储的元素可以比较，要么就提供一个可以比较的key （TreeSet ， TreeMap）

* 无论哪一种，都涉及到一个问题，就是对象的比较。

* 我们知道：java有两种数据类型 （基本类型，引用类型）

  * 基本类型计算机底层字节（0，1）可以使用比较运算符来比较大小
  * 引用类型会产生对象，对象本身无法比较大小

* 有2两种方式：

  1. **对象自身比较**

     * 要求对象的类实现Comparable，并重写对应的方法compareTo方法

     * 该方法实现了某一个对象自己与另一个对象的比较

     * 返回一个int值。负值表示dmc自己<zzt , 0值表示dmc==zzt，正值表示dmc自己>zzt

       ```java
       static class Student implements Comparable<Student>{
           String name ;
           int age ;
       
           public Student(String name, int age) {
               this.name = name;
               this.age = age;
           }
       
           @Override
           public int compareTo(Student o) {
               return this.age - o.age; //+
           }
       }
       
       public static void main(String[] args) {
           Student s1 = new Student("dmc",18) ;
           Student s2 = new Student("zzt",37) ;
           //主方法 让 dmc自己去和zzt比较
           int r = s1.compareTo(s2);
           System.out.println( r==0?"dmc和zzt一般大":(r<0?"dmc比zzt小":"dmc比zzt大"));
       }
       ```

  2. **第三方比较器**

     * 要求比较器类实现Comparator接口，重写方法

     ```java
     // is - a   继承父类 实现关系
     static class StudentComparator  implements Comparator<Student>{
         @Override
         public int compare(Student dmc, Student zzt) {
             return dmc.age - zzt.age;
         }
     }
     
     public static void main(String[] args) {
         Student s1 = new Student("dmc",18) ;
         Student s2 = new Student("zzt",37) ;
         //主方法 让 dmc自己去和zzt比较
         //int r = s1.compareTo(s2);
         //System.out.println( r==0?"dmc和zzt一般大":(r<0?"dmc比zzt小":"dmc比zzt大"));
     
         //之前主方法想知道dmc和zzt谁打谁小，让dmc自己去和zzt比
         //发现dmc耍赖
         //现在主方法准备找一个第三方比较器（语晴老师），让她去比较一下dmc和zzt
         StudentComparator yuqing = new StudentComparator() ;
         int r = yuqing.compare(s1,s2) ;
         System.out.println( r==0?"dmc和zzt一般大":(r<0?"dmc比zzt小":"dmc比zzt大"));
     
     }
     ```

# 2022-03-10

### 5） 树结构设计

#### a 树节点设计

```java
/**
 * 这是一个容器，可以供外部人使用
 * 内部使用的是BST 二叉搜索树结构实现的数据处理
 */
public class TreeBox<K,V> {

    /**
     * 默认情况，需要存储的元素中的key可以自身比较  key implements Comparable
     */
    public TreeBox(){}

    /**
     * 要求使用者在创建容器时，传递一个第三方比较器
     * 未来在元素比较时，就会使用指定的比较器来进行比较。
     * @param comparator
     */
    public TreeBox(Comparator<? super K> comparator){
        this.comparator = comparator ;
    }

    private Comparator<? super K> comparator ;

    /*
     * 容器内部如何使用二叉树结构实现存储嗯
     * 我们知道，二叉树结构是由一个一个节点链接而成
     *      所以我们需要先提供一个节点对象
     *      对于整个二叉树结构而言，我们只需要获得其根节点，就可以根据节点的链接，来获得所有的节点。
     * 我们在容器中，使用二叉树，不仅仅需要他的结构，更需要用这种结构实现数据的存储。
     *      对于节点而言（链表节点，树节点），节点本身可以存储数据，为节点增加value属性
     * 我们此次封装的是BST 二叉树搜索树， 存储的元素可以与之前的元素进行大小比较。
     *      我们要求存储的时候，除了存储要存储的数据value以外
     *      再额外传递一个key，来作为比较内容。
     *
     *
     */
    Node root ;
    private int size ;

    static class Node<K,V>{
        K key ;//用来比较，从而确定存储位置的。
        V value ;
        Node left ;
        Node right ;
        Node parent ;

        Node(K key, V value){
            this.key = key ;
            this.value = value ;
        }
    }
}
```

#### b 元素存储（add）

```java
/**
     * 对外提供的一个api方法
     * 允许外部通过这个方法，向容器内部存储一个元素
*/
public void add(K key , V value){
    //每一组外部存储的数据，在容器内部都是以节点的形式存在
    Node<K,V> newNode = new Node<>(key,value);

    //找到这个节点存储的位置
    if(root == null){
        //这棵树还不存在呢
        //此时，当前这个新节点，即为树的根节点
        root = newNode ;
        size++ ;
        return ;
    }
    //此时这棵树已经存在，需要找到存储的位置。
    Node<K,V> temp = root ;//临时变量，用来存储每次用来比较的节点
    Node<K,V> parent = null ;
    int com = 0 ;
    while(temp != null){
        parent = temp ;
        //在寻找位置的过程中，需要通过key进行比较。
        //对象的比较有两种，对象自身比较，使用第三方比较器
        if(comparator != null){
            //有第三方比较器，就优先使用第三方比较器
            if((com=comparator.compare(newNode.key , temp.key)) < 0){
                //就要跟temp的左节点比较
                temp = temp.left ;
            }else if((com=comparator.compare(newNode.key , temp.key)) > 0){
                //就要跟temp的右节点比较
                temp = temp.right ;
            }else{
                //相等了，元素存储重复了。
                //新值覆盖旧值，节点不加入了
                temp.value = newNode.value ;
                return ;
            }
        }else{
            //没有第三方比较器，就需要key自身比较
            //如果key可以自身比较，key 一定实现了 Comparable接口
            Comparable<K> comparable = (Comparable<K>)newNode.key;
            if((com=comparable.compareTo( temp.key)) < 0){
                //就要跟temp的左节点比较
                temp = temp.left ;
            }else if((com=comparable.compareTo(temp.key)) > 0){
                //就要跟temp的右节点比较
                temp = temp.right ;
            }else{
                //相等了，元素存储重复了。
                //新值覆盖旧值，节点不加入了
                temp.value = newNode.value ;
                return ;
            }
        }

    }
    //代码至此，循环结束，temp==null，也就是说找到了要存储的位置。当前位置父节点的左侧、右侧
    if(com < 0){
        parent.left = newNode;
    }else{
        parent.right = newNode ;
    }
    newNode.parent = parent ;
    ++size ;
}
```

# 2022-03-11

#### c 元素获取（get）

* 因为存储元素时，除了存储我们最需要存放的元素value以外，未来确保可以在BST结构中找到对应的存储位置
* 存储时还需要额外传递一个用来比较的key。

* 所以我们就可以通过这个key，经过内部的大小比较，找到其对应元素存储的位置，从而获得这个元素。

```java
public V get(K key){
    Node<K,V> temp = root ;
    while(temp != null){
        //需要用key和temp.key大小比较
        //相等就表示找到了要找的节点，返回value
        //不相同，就需要继续找，继续找左边还是右边呢？  需要比较
        //对象的大小比较，有2种方式。 自身比较，第三方比较器比较
        if(comparator != null){
            //有第三方比较器，优先使用比较器
            int com = comparator.compare(key,temp.key);
            if( com == 0){
                return temp.value ;
            }else if(com < 0){
                //继续向左寻找
                temp = temp.left ;
                continue ;
            }else{
                //继续向右寻找
                temp = temp.right ;
            }
        }else{
            //没有比计较器，需要key自身比较。 自身比较的前提是key implements Comparable接口
            Comparable<K> comparable = (Comparable<K>) key;
            //有第三方比较器，优先使用比较器
            int com = comparable.compareTo(temp.key);
            if( com == 0){
                return temp.value ;
            }else if(com < 0){
                //继续向左寻找
                temp = temp.left ;
                continue ;
            }else{
                //继续向右寻找
                temp = temp.right ;
            }
        }
    }
    //代码至此，while循环结束，在循环中并没有结束方法，说明一个相等节点都没有找到
    //表示没有找到
    return null ;
}
```

#### d 元素删除的分析

* BST结构的元素删除，大体上有这样的3种。

1. 要删除的是叶子节点

   * 直接删除即可
   * 要考虑到如果删除的是根节点，则root=null

   <img src="images/22031101.png" style="zoom:50%;" />

2. 要删除的是非叶子节点，且只有一支子节点

   * 父节点指向这一支的子节点
   * 要考虑到如果删除的是根节点，则其左/右节点为根节点

   <img src="images/22031102.png" style="zoom:50%;" />

3. 要删除的是非叶子节点，且有左右两只子节点

   * 可以使用左枝最大的节点代替要删除的节点
   * 也可以使用右枝最小的节点代替要删除的节点
   

<img src="images/22031103.png" style="zoom:50%;" />

   * **注意：**
     * 以上图为例，如果要使用6 替换 5  
     * 也就是将5的父级变为6的父级，5的左子树变为6的左子树，5的右子树变为6的右子树，既完成替换
     * 其中需要考虑，如果6 本身就是5的右子树，则右子树不在需要替换，否则就会出现循环引用问题。

# 2022-03-17

#### e 元素删除实现（remove）

* **get方法的抽取**

  ```java
  public V get(K key){
      Node<K, V> node = getNode(key);
  
      return node==null?null:node.value ;
  }
  
  private Node<K,V> getNode(K key){
      Node<K,V> temp = root ;
      while(temp != null){
          //需要用key和temp.key大小比较
          //相等就表示找到了要找的节点，返回value
          //不相同，就需要继续找，继续找左边还是右边呢？  需要比较
          //对象的大小比较，有2种方式。 自身比较，第三方比较器比较
          if(comparator != null){
              //有第三方比较器，优先使用比较器
              int com = comparator.compare(key,temp.key);
              if( com == 0){
                  return temp ;
              }else if(com < 0){
                  //继续向左寻找
                  temp = temp.left ;
                  continue ;
              }else{
                  //继续向右寻找
                  temp = temp.right ;
              }
          }else{
              //没有比计较器，需要key自身比较。 自身比较的前提是key implements Comparable接口
              Comparable<K> comparable = (Comparable<K>) key;
              //有第三方比较器，优先使用比较器
              int com = comparable.compareTo(temp.key);
              if( com == 0){
                  return temp ;
              }else if(com < 0){
                  //继续向左寻找
                  temp = temp.left ;
                  continue ;
              }else{
                  //继续向右寻找
                  temp = temp.right ;
              }
          }
      }
      //代码至此，while循环结束，在循环中并没有结束方法，说明一个相等节点都没有找到
      //表示没有找到
      return null ;
  }
  ```

* 删除实现

  ```java
  /**
       * 根据指定的参数key，找到其对应的元素，并将其删除，同时返回这个删除的元素
       * 如果没有找到，返回null
       * @param key
       * @return
  */
  public V remove(K key){
      //要删除某一个元素（节点），需要先通过key找到那个节点
      Node<K, V> node = getNode(key);
      if(node == null){
          return null ;
      }
  
      //代码至此，表示找到了要删除的节点。
      //获得节点元素，准备在后面删除后返回。
      V value = node.value ;
  
      if(node.left == null && node.right == null){
          //是一个子节点
          if(node.parent == null){
              //没有父节点，node是根节点。
              root = null ;
          }else if(node == node.parent.left){
              node.parent.left = null ;
          }else{
              node.parent.right = null ;
          }
  
  
      }else if(node.left != null && node.right == null){
          //node有一个左节点
          if(node.parent == null){
              //要删除的是根节点，此时左节点就是树的新根节点
              root = node.left ;
          }else if(node == node.parent.left){
              node.parent.left = node.left ;
          }else{
              node.parent.right = node.left ;
          }
  
  
      }else if(node.left == null && node.right != null){
          //node有一个右节点
  
          if(node.parent == null){
              root = node.right ;
          }else if(node == node.parent.left){
              node.parent.left = node.right ;
          }else{
              node.parent.right = node.right ;
          }
  
  
      }else{
          //node有2个子节点
          //需要找左侧最大的节点或者右侧最小的节点替换当前这个node节点
          //node=5 , temp = node.right = 8 ;
          //parent=8 , temp = 8.left=null
          Node<K,V> temp = node.right ;
          Node<K,V> parent = null ;
          while(temp != null){
              parent = temp ;
              temp = temp.left ;
          }
          //代码至此temp=null,parent记录的就是最小的那个子节点。
          Node<K,V> replaceNode = parent ;
  
          //如果替换的节点不是删除的左节点，需要继承删除节点的左节点
          if(replaceNode != node.left){
              replaceNode.left = node.left ;
          }
  
          //如果替换的节点不是删除的右节点，需要继承删除节点的右节点
          if(replaceNode != node.right){
              replaceNode.right = node.right ;
          }
          replaceNode.parent = node.parent ;
          if(node.parent == null){
              root = replaceNode ;
          }else if(node == node.parent.left){
              node.parent.left = replaceNode ;
          }else{
              node.parent.right= replaceNode;
          }
  
      }
  
      node.parent = null ;
      node.right = null ;
      node.left = null ;
      size-- ;
      return value ;
  }
  ```

# 2022-03-25

#### f 元素迭代遍历

* 所谓的元素遍历，就是从头到尾的依次获得我们容器中的元素

* 对于容器而言，内部使用二叉树结构存储数据

* 但从外部而言，并不清楚内部的存储结构

* 如何进行遍历呢？  

* 由容器对象提供一个对象，这个对象可以帮使用者实现容器内部的元素遍历。

  ```java
  /**
       * 返回给使用者一个容器，装载所有可遍历的key
       */
      public KeyBox keyBox(){
          return new KeyBox() ;
      }
      /**
       * 用来装载当前二叉树结构中所有的key
       * @param <K>
       */
      public class KeyBox<K> implements Iterable<K>{
          @Override
          public Iterator<K> iterator() {
              return new KeyIterator<>();
          }
      }
      /**
       * 是一个 用来迭代遍历key的 迭代器
       * is - a
       */
      private class KeyIterator<K> implements Iterator<K>{}
  
  
  
      /**
       * 返回给使用者一个容器，装载所有可遍历的value
       */
      public void valueBox(){}
  
      /**
       * 返回给使用者一个容器，装载所有可以遍历的数据（key-value）
       */
      public void dataBox(){}
  ```

  

* 外部使用者先获得这个迭代器，根据迭代器对象的指引，完成内容的遍历。

  ```java
  TreeBox<Integer, String>.KeyBox<Integer> keyBox = box.keyBox();
  
  //想通过遍历获得每一个key，从而获得每一个value ( =get(key) )
  Iterator<Integer> iterator = keyBox.iterator();
  
  while(iterator.hasNext()){
      Integer key = iterator.next() ;
      System.out.println( key );
      System.out.println( box.get(key) );
  }
  ```

  

* 迭代器的实现

  * 首先需要获得遍历的第一个节点
  
* 第一个节点就是最小的节点
  
* 准备找到任意节点的下一个节点。大约有以下3种情况
  
  1. 当前正在遍历的这个节点（左节点一定都已经比那里过了），有右节点 ，右节点中最左的节点就是下一个节点
  
     <img src="images/22032501.png" alt="1648191961849" style="zoom:50%;" />
  
  2. 当前正在遍历的节点没有右节点（左节点都遍历过了），应该找其父节点。
  
     2.1 当前正在遍历的节点，是其父节点的左子树，按照中序遍历特点，左边遍历完成，下一个就是父节点
  
     <img src="images/22032502.png" alt="1648192001342" style="zoom:50%;" />
  
     2.2 当前正在遍历的节点，是其父节点的右子树，按照中序遍历特点，父节点已经遍历过了。再以父节点为基准，看看是否是其父节点的左节点。如果不是就循环这个操作，直到根节点（结束）或左节点。
  
     <img src="images/22032503.png" alt="1648192020405" style="zoom:50%;" />
  
  ```java
  /**
       * 返回给使用者一个容器，装载所有可遍历的key
  */
  public KeyBox keyBox(){
      return new KeyBox() ;
  }
  
  /**
       * 用来装载当前二叉树结构中所有的key
       * @param <K>
  */
  public class KeyBox<K> implements Iterable<K>{
  
      public int size(){
          return TreeBox.this.size ;
      }
  
      @Override
      public Iterator<K> iterator() {
          return new KeyIterator<>();
      }
  }
  
  /**
       * 是一个 用来迭代遍历key的 迭代器
       * is - a
  */
  private class KeyIterator<K> implements Iterator<K>{
  
      KeyIterator(){
          next = first() ;
      }
  
      //找到第一个节点，最小的节点，最左节点
      private Node<K,Object> first(){
          if(root == null){
              //一个节点都没有
              return null ;
          }
          //有，找最左面的
          Node<K,Object> temp = root ;
          while(temp.left != null){
              temp = temp.left ;
          }
          //循环结束时，就是temp.left = null temp就是最左的节点
          return temp ;
      }
  
      private Node<K,Object> next ;
  
      @Override
      public boolean hasNext() {
          return next != null;
      }
  
      @Override
      public K next() {
          Node<K,Object> curr = next ;
  
          //提前准备好下一个节点。
          Node<K,Object> temp = next ;
          if(temp.right != null){
              //有右节点，下一次遍历的节点，就是右枝中最左的节点
              temp = temp.right ;
              while(temp.left != null){
                  temp = temp.left ;
              }
              next = temp ;
          }else{
              //没有右节点，需要找其父节点
              Node<K,Object> parent = temp.parent ;
  
              while(true){
                  if(parent == null){
                      //已经到根了，就没有下一个了
                      next = null ;
                  }else if(temp == parent.left){
                      //此时parent的左子树都遍历完了，按照中序遍历特点，父节点就是下一次遍历的节点
                      next = parent ;
                  }else{
                      //此时temp是parent的右节点
                      //parent已经遍历过了
                      //看看parent的下一个是谁
                      temp =parent ;
                      parent = temp.parent ;
                      continue ;
                  }
  
                  break ;
              }
          }
  
          return curr.key;
      }
  }
  
  ```
# ======工具类======

# 2022-04-01

## 1 包装类

### 1） 什么是包装类

* jdk提供了8种基本数据类型对应的引用类型表示

  * java是一种面向对象的编程语言
  * 希望我们在编写程序时都是用面向对象的这一特点（创建对象，调用方法实现功能）
  * 基本数据类型无法产生对象，这就使得java面向对象的特点存在不足或缺陷
  * 除此以外，基本类型在使用时也会有一定限制或不足，比如
    * 基本类型没有方法，使得许多操作需要我们手动完成。  类型转换，进制转换，字符串转换。
    * 有些容器（之前我们自己封装的容器，之后我们要学习集合），只允许存储引用类型的数据
  * 所以包装类就应运而生了。

* 包装类的本质也是一个类，是引用类型，默认的值null 。 

  ```java
  class A{
      int i ;//默认值0
      Integer _i ;//默认值null
  }
  ```

### 2） 都有哪些包装类

| 基本类型 | 包装类        | 备注 |
| -------- | ------------- | ---- |
| byte     | Byte          |      |
| short    | Short         |      |
| int      | **Integer**   |      |
| long     | Long          |      |
| float    | Float         |      |
| double   | Double        |      |
| char     | **Character** |      |
| boolean  | Boolean       |      |

* 每一个包装类中都包含了其所对应的基本类型数据。 

  ![1648796068411](images/22040101.png)

* 包装类中还增加了许多的方法，通过这些方法，可以更容易的操作我们的基本类型

### 3） 装箱和拆箱

* 所谓装箱就是将基本类型 组成 对应的包装类对象
* 所谓拆箱就是将包装类对象中的基本类型数据取出来
* 可以使用如下方法来实现拆箱和装箱

```java
//手动装箱
Integer num = new Integer(10) ;
Integer num = Integer.valueOf(10) ;

//手动拆箱
int _num = num.intValue();
```

* 在jdk1.5之后，基本类型可以自动与包装类进行转换——自动拆装箱

```java
Integer num = 10 ;

int _num = num ;

num++ ; //拆箱取出基本类型， 再++，再装箱变成Integer
```

* 从语法上，有了自动拆装箱后，包装类的使用似乎和基本类型的使用很像。
* 其底层是在编译时，帮我们调用了对应的拆装箱方法。
  * debug验证
  * javap命令反编译.class文件

<img src="images/22040102.png" alt="1648795878354" style="zoom:50%;" />

# 2022-04-02

### 4）常用API（方法）

> **字符串转换成基本类型或包装类**

* 除Character以外，其他7种包装类都提供了将字符串转换成对应类型的方法

```java
Integer num = new Integer("100") ;
int num = Integer.parseInt("100") ;

Double num = new Double("3.14") ;
double num = Double.parseDouble("3.14") ;

```

> **包装类之间的转换**

* 8种基本数据类型中，除了boolean以外，其他7种类型可以进行转换（自动转换，强制类型转换）
* 但大家需要明白，包装类的本质，是类。 类之间的转换，需要基于子父类关系（上转型，下转型）

* 我们通过源码发现，包装类之间，不存在子父关系

  * byte 和 int 可以转换
  * Byte  和 Integer 不可以转换。

* 我们通过源码继续观察可以发现，除了Character和Boolean以外，其他6个和数字相关的包装类，都继承了一个公共的父类——**Number**

* 继续观察发现，Number父类提供了6个抽象方法。

  ```java
  byteValue();
  shortValue();
  intValue();
  longValue();
  floatValue();
  doubleValue();
  ```

  * 子类就会重写这个6个方法
  * 所以可以调用每一个数字形式的包装类的这6个方法，来实现类型的转换。 
  * `Integer i= 10 ;`  `i.longValue() ;`  `i.byteValue()`

> **包装类提供的常量属性**

* 每一个包装类都提供了一些比较常用的常量属性
* 其中6个数字相关的包装类，都提供了对应类型的最大值和最小值的常量

```java
Integer.MIN_VALUE
Integer.MAX_VALUE
```

```java
int num = ____ ;

if( num <0 && num == -num ){
    System.out.println("hello");
}

//请填空，使得最终可以打印hello

```

### 5）包装类的缓冲区

```java
Integer i1 = 100 ;
Integer i2 = 100 ;

Integer i3 = 200 ;
Integer i4 = 200 ;

Integer i5 = new Integer(100) ;
Integer i6 = new Integer(100) ;

Double i7 = 100 ;
Double i8 = 100 ;

System.out.println(i1==i2);
System.out.println(i3==i4);
System.out.println(i5==i6);
System.out.println(i7==i8);

// true , false , false , false
```

* 答案解析：

  * 包装类4个整形相关的包装类，每一个包装类中都有一个缓冲区。这个缓冲区是一个数组，存储着-128~127这256个当前类型的对象。

    ```java
    private static class ByteCache {
            private ByteCache(){}
    
            static final Byte cache[] = new Byte[-(-128) + 127 + 1];
    
            static {
                for(int i = 0; i < cache.length; i++)
                    cache[i] = new Byte((byte)(i - 128));
            }
        }
    }
    ```

  * 在为包装类进行=直接赋值时`Integer i = 100`,在底层，会调用Integer.valueOf(100)，通过源码可知，在valueOf方法中会进行判断，如果赋的值在缓冲区范围内，则直接从缓冲区获取，否则会创建新的对象

    ```java
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
    ```

  * 所以 i1 和 i2都在缓冲区范围内，所以获得的是同一个Integer对象

  * 而i3和i4在范围外，所以会创建2个同值不同Integer对象

  * ==在比较引用类型时，比较的是地址，两个对象自然就是两个地址

    * 所以i1==i2   true
    * i3==i4  false
    * i5==i6 false  因为直接使用了new关键字，开辟两个空间

  * 浮点型的包装类没有这个缓冲区，每次都会新创建对象

    * 所以 i7==i8 false

* 注意： 在jdk高版本中，Integer的构造器已经不推荐使用（丢弃）。

# 2022-04-07

## 2 BigInteger和BigDecimal

### 1） BigInteger

* 长整形。
* 整形：byte，short，int，long
  * int  2<sup>31</sup> -1  10位
  * long 2<sup>63</sup> -1 19位
* 如果要存储或计算超过19位的整数，就可以使用这个长整形了 。 
* 计算：200!

#### a 原理

* 长整型之所以可以存储更长更多的整数，是因为其内部使用int[]存储   21亿位

  `int num = 256 ;`

  `BigInteger->int[]->{2,5,6}`	

* 计算原理

  ```text
  256 * 79
  {2,5,6} * {7,9}
  ------拆成-------
  {2,5,6} * 9
  {2,5,6,0} * 7
  ------计算-------
    {18,45,54}
  {14,35,42,0}
  ------相加-------
  {14,53,87,54}
  -------进位------
  {2,0,2,2,4}
  ```

#### b API

```java
BigInteger num = new BigInteger("200") ;  // int num = 200 ;
BigInteger num2 = new BigInteger("100") ;
num.add(num2) ;			//加法
num.subtract(num2) ;	//减法
num.multiply(num) ;		//乘法
num.divide(num2) ;		//除法
num.compareTo(num2) ;	//大小比较  负数、0、正数
```

```java
public class Test1 {
    public static void main(String[] args) {

        BigInteger num = new BigInteger("1000");
        BigInteger sum = new BigInteger("1") ;
        final BigInteger one = new BigInteger("1") ;
        // num >= 1
        while(num.compareTo(one) >= 0){
            sum = sum.multiply(num) ;
            num = num.subtract(one) ;
        }

        System.out.println(sum);

    }
}
```

### 2） BigDecimal

* float（7-8），double（15-16）  

* 理论上 BigDecimal可以存储更多的小数位，但一般很少会用到

* 我们一般使用BigDecimal是因为以下两个原因

  1. 浮点数计算时会出现无差

     十进制与二进制的转换

     ```text
     10.4(10) --> ?(2)
     整数位转换 除2取余倒序 ， 小数位转换，乘2取整正序
     10/2=5..0			0.4*2=0.8....0
     5/2=2...1			0.8*2=1.6....1
     2/2=1...0			0.6*2=1.2....1
     1/2=0...1			0.2*2=0.4....0
     最终的转换结果=1010.0110......
     ```

  2. 我们需要保留指定的小数位

     * 在使用BigDecima做除法计算时，有可能除不尽。此时可以指定保留的小数位及四舍五入策略
     * 如果没有指定保留小数位，会抛出异常。

     ```java
     //对两个小数无法除尽的结果进行小数位保留
     d1.divide(d2,3,BigDecimal.ROUND_DOWN);
     //BigDecimal.ROUND_DOWN   截取掉指定位数后面的内容
     //BigDecimal.ROUND_UP     截取掉指定位数后面的内容，小数+1
     //ROUND_HALF_DOWN		  小数位后面的内容>5 进1
     //ROUND_HALF_UP		      小数位后面的内容>=5 进1
     
     //对单一浮点数设置保留的小数位
     d1.setScale(3,BigDecimal.ROUND_DOWN)
     ```

# 2022-04-08

## 3 字符串

* 字符串编写程序是会被频繁使用。
* 字符串就是一组字符序列，不是一个字符，不属于基本类型char。所以必然是引用类型，以对象形式的存在
* 可以使用char[]来存储字符序列，但不利用使用。
* 所以我们使用String对象表示一个字符串。

### 1）字符串的产生

* 如何使用String来创建（表示）一个字符串呢？
* 大约有以下的3种情况

```java
String s1 = "dmc" ;
String s2 = new String("dmc") ;
String s3 = new String(new char[]{'d','m','c'});
```

* 字符串是一种引用类型，以对象的形式存在，并存储。字符串对象有2个存储位置

  * 一个就是普通的堆区。允许多个字符串对象有相同的内容
  * 一个就是专门存储字符串的常量区。这里面的字符串对象，同一个内容只有一个份。

* 使用""声明的字符串对象，会存储在常量区中。 所以每次使用双引号声明字符串时，在jvm底层会先去常量区找对应里内容的对象，如果找到，直接返回（地址）。如果没有找到，就会创建这个对象。

  ```java
  String s1 = "dmc" ; //准备创建一个字符串对象，会先去常量区找，一开始肯定没有这个对象，创建并返回
  String s2 = "dmc" ; //准备创建一个字符串对象，会先去常量区找，因为上一次已经创建了，就不再创建，直接返回上一次的对象
  ```

* 使用new 就一定会在堆区创建一个字符串对象。第二种方式，创建String对象时，会传递参数。我们发现这个参数是使用""声明的。也就是说这段代码可能会产生2个对象，一个在堆区，一个在常量区

* 第三种方式只会在堆区产生一个字符串的对象。

* **笔试题1：**

  ```java
  String s1 = "dmc" ;
  String s2 = "dmc" ;
  String s3 = new String("dmc") ;
  String s4 = new String("dmc") ;
  
  System.out.println(s1 == s2);
  System.out.println(s1.equals(s2));
  System.out.println(s3 == s4);
  System.out.println(s3.equals(s4));
  
  //请写出最终的打印结果 true true false true
  //此题涉及两个知识点
  //一个就是关于字符串对象创建位置的问题
  //另一个就是关于 == 与  equals问题
  //	== 可以比较基本类型和引用类型，比较基本类型是值，比较引用类型是地址
  //  equals是类的方法，只能比较引用类型，默认比较的是地址，可以通过重写equals方法来实现内容的比较。
  //		jdk中绝大多数用来存储数据的对象都重写了equals方法 （String，Integer，Date）
  //		String重写equals后，比较的就是内容
  ```

* **笔试题2：**

  ```java
  String s1 = new String("dmc") ;
  
  //内存中产生了几个字符串对象？  1个 或  2个
  //new会在堆区产生一个字符串对象
  //"dmc"会去常量区找，找到并返回。找不到就会创建一个并返回，那此时就会产生2个对象，一个堆，一个常量区
  ```
  
* **笔试题3：**

  ```java
  public static void main(String[] args){
      int i1 = 17 ;
      String s2 = "dmc" ;
      char[] s3 = new char[]{'d','m','c'} ;
      
      t1(i1);
      t2(s2);
      t3(s3);
      
      System.out.println(i1); 					// 17  (47)
      System.out.println(s2); 					// dmc (zzt)
      System.out.println(Arrays.toString(s3) ); 	// zzt
  }
  
  public static void t1(int i1){
      i1 = 47 ;
  }
  
  public static void t2(String s2){
      s2 = "zzt" ;
  }
  
  public static void t3(char[] s3){
      //s3 = new char[]{'z','z','t'} ;
      
      s3[0] = 'z' ;
      s3[1] = 'z' ;
      s3[2] = 't' ;
     
  }
                         
  //问在主方法中最终打印的结果   17,dmc,zzt
  //本题涉及一个知识内容： 值传递和引用传递
  //	值传递的情况下，调用方法中变量值改变， 原值不变。
  //  地址传递的情况下，调用方法中根据地址修改了地址对象中的内容，则原地址找到的对象也改变。
  //  地址传递的情况下，调用方法中更改了新的地址，则原地址找到的内容不变。
  
  //本题还涉及一个问题
  //String是引用类型
  //但s2="zzt" 并不会将原来字符串对象中的dmc内容，改为zzt。而是会产生新的String对象，所以更换了地址。
  ```

  <img src="images/22041401.png" alt="1649917967561" style="zoom:50%;" />

# 2022-04-14

### 2）字符串的不可变特性

* String对象一旦创建，其长度和内容就不能再改变了。反之，一旦认为改了，一定是产生了新的字符串对象。

  * 官方说明
  * 应用感知

* 通过源码分析特点

  * String底层，使用char[]变量存储字符序列，字符串内容

    `private final char value[];`

  * 我们发现这个变量使用final修饰

    * final修饰变量什么特点？  不可变，常量
    * value变量中储存的是什么？  数组地址。  
    * 不可变指的是什么呢？ 不能再变成其他数组的地址了，只能指向当前这个一个数组
    * 我们知道，数组一旦创建，长度不能改变。**所以 String内容的长度不能改变。**
    * 数组长度不能改变，内容是否可以改变？ 理论上是可以的。

  * 数组的长度不能变，但内容理论上是可以变的。但String为什么内容也不能变呢？

    * 这里面主要是因为java的**封装特性**。
    * 存储字符串内容的value属性，使用private关键字修饰，**私有的**，外部使用者不能直接操作
    * 同时还没有提供可以操作数组内容的**对外的操作方法**。
    * **所以内容不可变**

* 注意：

  * String不可变性，长度不可变是由语法决定。内容不可变，是通过封装特性实现的，编码实现。未来我们可以通过反射操作私有属性。
  * jdk9之后，String底层不再使用char[]存储字符串内容，而是使用byte[]
    * 1char  2字节
    * 1byte  1字节  a - 97   1个字节存储范围-128 ~ 127 , 之前需要2字节，9之后需要1字节存储，省内存。降低gc频率，提高jvm性能。



# 2022-04-15

### 3） StringBuilder/StringBuffer

* 在编写程序时，有时我们需要使用字符串，但可能会需要一系列的处理才能确定最终的字符串内容。
* 也就是说，需要对字符序列有一定的添加，删除，修改操作。
* 此时如果使用String来实现字符串内容的一些从处理，最终我不仅仅会产生我们所需要的对象，过程中还会产生一些其他的，未来不使用的对象（浪费）
* 这个时候我们更推荐使用可变的字符串对象（StringBuilder ， StringBuffer）



* 无论是StringBuilder 还是StringBuffer，有相同的api方法，谁用方式相同。两者的不同点主要体现在线程安全问题上（暂时不考虑），更推荐使用StringBuilder
* 与String相比。 String是不可变字符串。StringBuilder是可变字符串，是一个字符串内容的缓冲，其长度和内容在没有最终确认前，是可以改变的。
* StringBuilder为什么长度和内容可以改变呢？
  * 通过StringBuilder的原码分析
  * 底层也是使用`char[] value` 来存储字符序列
  * 因为没有使用fianl关键字修饰，所以value属性可以指向其他长度的数组地址，所以长度和内容可以改变。
  * 同时StringBuilder还提供了对value数组元素增删改相关的api方法。（封装特征）
* **StringBuilder API**

```java
/*构造器方法*/
//StringBuilder的构建，必须使用new关键字
StringBuilder str = new StringBuilder(); //底层创建一个长度为16的字符数组（缓冲）
StringBuilder str = new StringBuilder("dmc"); //设置初始值，字符数组长度为16+3
StringBuilder str = new StringBuilder(32); //底层创建一个指定长度的字符数组

/*更改字符内容的方法  "dmc"*/
str.append(" and ") ;//追加一个字符串内容   "dmc and "
str.insert(1",") ;//在指定下标位置插入内容 "d,mc"
str.delete(0,2) ;//删除指定索引范围内的内容 索引边界[左闭右开) "c"
str.deleteCharAt(0);//删除指定位置的那一个字符 "mc"
str.replaceAll(0,3,"zzt");//将指定索引范围内字符替换成新内容 "zzt"
str.setCharAt(0,'D') ;//将指定索引位置的字符改为指定的内容  "Dmc"
str.reverse(); //将字符串内容反转 "cmd"
str.toString();


/*其他方法*/
str.indexOf();
str.substring();
```

* 问题：构建包含99个Y的字符串

  ```java
  String str = "" ;
  for(int i=1;i<=99;i++){
      str += "Y" ;
  }
  
  //--------------------------
  StringBuilder str = new StringBuilder(99);
  for(int i=1;i<=99;i++){
      str.append("Y");
  }
  
  //简述两种实现代码的优缺点。
  ```



# 2022-04-21

### 4）String API

#### a 编码解码

* 编码：将中文字符串转换成对应的字节表示
* 解码：将字节转换成对应的字符串内容
* 编码解码一般都是在io读写文件时使用的。

```java
/*String提供了以下几种和编码转码相关的方法*/
//Charset.defaultCharset();获得jvm默认字符集
byte[] bs = string.getBytes() ; //默认的编码格式，jdk8，utf-8
byte[] bs = string.getBytes("GBK");//指定编码字符集

String str = new String(bs); //使用默认字符集解码
String str = new String(bs,"GBK"); //使用指定字符集解码

/*Integer方法补充*/
//获得二进制序列
Integer.toBinaryString(0x4e00);

//获得八进制序列
Integer.toOctalString(0x4e00);

//获得十六进制序列
Integer.toHexString(19968);
```

* UTF-8编码

  * utf-8 与 unicode

  * unicode是一个字符集，提供不同字符对应的一个数字表示 "一" \u4e00 ->19968

  * utf-8是unicode编码的一个编码存储规则

    ​	0-127  	ascii码相同，  0xxxxxxx

    ​    128-2047  110xxxxx , 10xxxxxx

       2048-65535 1110xxxx   10xxxxxx  10xxxxxx 

     `>`65535  11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

  * 汉字”一“ 对应的数字19968 ，utf-8编码，由3个字节组成
    * 将16进制转成二进制表示  0x4e00 ----> 0100 1110 0000 0000
    * 将上述二进制带入到utf-8模板中，从地位开始填充，不足用0占位
    * 11100100   101110 00  1000 0000 
  * 上述二进制序列在计算中以补码的形式存在
    * 要想知道上述二进制对应的数字，需要将其转换换成对应的源码。
    * 补码 = 源码取反 + 1 ---> 源码=补码-1取反
    * 11100100-1 = 11100011 = 10011100 = -16+8+4=-28

* GBK编码

  * 要求使用2个字节直接表示中文
  * GBK编码表中 汉字”一“对应的数字是  D2BB 
  * 直接转换成二进制  1101 0010 1011 1011

  * 两个字节存储，分别为 11010010 ， 10111011 -- 10010111011

* 思考题：

  ```java
  String s= "一";
  
  byte[] bs = s.getBytes("GBK");
  
  String s2= new String(bs,"utf-8");
  System.out.println(s2);
  byte[] bs2 = s2.getBytes("utf-8");
  
  System.out.println(Arrays.toString(bs));
  System.out.println(Arrays.toString(bs2));
  
  //两个字节内容是否相同，如果换一个汉字，是否相同？ 尝试解释原因
  ```

# 2022-04-22

#### b 字符串连接

* String提供了字符串连接的方法

  `String newString = string.concat(other)`将当前字符串与指定的另一个字符串连接，形成一个新的字符串对象。

* java提供了一个更简单，可以实现两个字符串连接的方式，+运算符重载。赋予字符串连接到含义。

  `String newString = string + "good"`

  * 注意：当一个数字和字符串使用+运算时，+就是连接的作用。最终的结果就是一个字符串

    `1+"100"===>1100`

* **笔试题1：**

  ```java
  String s1 = "dmc"; 
  String s2 = "d"+"m"+"c";//编译时优化成 s2="dmc";
  String s3 = "d".concat("m").concat("c") ; //连接后产生了新的字符串。
  
  System.out.println(s1 == s2);
  System.out.println(s1 == s3);
  
  //请问最终的打印结果是什么？ true , false
  ```

* **笔试题2：**

  ```java
  String s1 = "d"+"m"+"c" ; 
  //内存中产生了多少个String对象，都在哪里产生的（堆，常量区） ， 1个 "dmc"， 常量区
  
  String s1 = "d" ;
  String s2 = s1 + "m" + "c"; //s1+"mc";
  //内存中产生了多少个String对象，都在哪里产生的（堆，常量区） , 3个，2个常量区d,mc,，1个堆区"dmc"
  
  ```

* **concat与+特点**

  * concat就是String第一个方法，用来与另一个字符串连接，在连接的过程中会产生新的对象（new）

  * +当有一侧是字符串时，就表示字符串连接，不再是加法运算了（注意运算符顺序问题）

    `1+2+"3"==>"33"`

    `"3"+1+2==>312`

    `5/2*1.0==>2.0`

  * String已经提供了concat实现连接，为什么还要提供+呢？+连接有什么特点 呢？

    * 使用+连接两个字符串时，在编译阶段（javac）会对代码进行优化（2点）

      1. 如果+两侧都是字符串常量，会在编译阶段，直接连接，并最终赋予完整的字符串内容

         <img src="images/22042201.png" alt="1650609323747" style="zoom:50%;" />

      2. 加号两侧有一侧是字符串变量时，就会产生一个StringBuilder对象，利用append方法持续追加（连接）字符串，直至连接完毕，调用StringBuilder.toString()产生最终完整的字符串对象。

         * 可以使用debug或者javap来证实

         <img src="images/22042202.png" alt="1650609880883" style="zoom:50%;" />

* 注意：在使用+连接字符串优化时

  * 早期jdk版本，只会对前面的字符串常量，做优化。 

    `"1"+"2"+s+"3"+"4" ;`编译阶段优化的结果：`"12" + s + "3" + "4"`

  * 目前jdk8+对上述代码再次优化，字符串变量后面如果也存在多个字符串常量连接，也会编译优化

    `"1"+"2"+s+"3"+"4" ;`编译阶段优化的结果：`"12" + s + "34"`

* 还有一个问题：是不是以后字符串连接的时候，就都是用+了呢？concat方法还有没有意义呢？

  1. 如果需要频繁的，在不同代码中拼出，建议直接使用StringBuilder + append方法
  2. 在一行代码中，需要多次拼接>2，建议使用+号。底层会使用StringBuilder
  3. 只做一次连接，只有2个字符串连接，建议使用concat



  



​			



