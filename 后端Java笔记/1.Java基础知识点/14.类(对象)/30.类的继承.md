<script src='/笔记/see/index.js'></script>
[toc]

#### 实现
- 继承通过 extends 关键字来实现
  - 所有的对象，默认继承 Object
  - 且一个 extends 只能继承一个 类
    - 要想继承多个类，可以利用穿串的方式，A 继承 B，B 继承 C。这样A就相当于继承了 B 和 C
```java
// A 继承 B
public class A extends B {
}
```
- 这样，通过A创建出来的对象，就能使用 B 中的`方法和属性`
  - 需要注意：只能使用 `public、protected` 这两个修饰符修饰的 方法和属性，私有的是无法获取的


#### 方法的重写
- 父类中的方法，可以在子类中进行重写
  - 重写后，在使用这个方法，使用的就是重写后的方法（查找方式从子类开始，往父类中查找，查找到了就调用，所以子类中重写的方法先被查询到，然后执行）
```java
// A 继承 B
public class A extends B {
    @Override
    public void fun() {
        System.out.println("重写方法");
    }
}
```
- 重写后，用A创建的对象，调用fun方法，调用的就是A中重写后的（直接用B创建对象，调用的就是B的，此时与A就没有关系了）
- 重写的方法，要与父类中对应的方法保持一致
  - 权限可以比父级的高
  - 错误的抛出，可以比父级更详细（级别低），并且个数不限（只要父级中抛出的错误，有一个范围更广，子级想写几个就写几个）
    - 比如
    ```java
      class A extends B {
          public int num = 3;
          public int[] ints = new int[24000];
          // 重写的错误就随意，个数也随意，只要都比 Exception 低就可以
          @Override
          public void b() throws IOException, Exception {
              System.out.println("重写b方法");
              System.out.println(this.num);
          }
      }

      class B {
          public int num = 6;

          // Exception 范围最广
          public void b() throws Exception {
              System.out.println("b方法");
          }
      }
    ```



#### 构造函数执行的问题
- 通过 new 创建出一个对象，会先发现父级的构造函数先执行
  - 如果父级还有父级，则父级的父级的构造函数先执行，然后在执行父级的构造函数

- 继承，要有父才能有子。所以继承的类要先创建出一个对象
 
- 父级创建对象，并没有通过new的方式创建对象，而是通过 super 这个东西创建出来的对象
  - 所以堆内存并没有重新开辟父级的对象空间，而是直接把父级对象的数据，放入了子级开辟的那个空间中（new 子级，开辟的那个空间）
  - **父级创建对象的原理**
    - 会在构造对象函数中的开头默认添加一个 super()
    - 而 super 指向的就是 `继承的那个类`
      - 而 super() 调用的就是 `继承的那个类的构造方法`
      - 而 继承的那个类的构造方法 中也会添加上 super()，然后就会调用父级的父级的构造方法
    - 由于 super() 会放在开头，所以就会造成 父级的构造函数先执行，子级的构造函数在执行的效果
      - 其实底层是 子级的构造函数先执行，父级的构造函数在执行
      - 由于 super() 会放在开头，所以写打印效果，看到的就是父级先执行
    - **super() 会自动添加在开头，但是这也是有条件的**
      - 如果开头写了 this()，或者 super() 就不会自动添加了
      - 如果写了 this()，继承的父级构造函数就无法执行了，所以会报错
  ```java
  class A extends B {
      public A() {
          // 这个东西会自动添加，如果自己写了就不会自动添加了，作用是调用 B 的构造函数，创建父级对象
          // 如果写 this()  就会报错
          super();
          System.out.println("A构造方法");
      }
  }
  ```