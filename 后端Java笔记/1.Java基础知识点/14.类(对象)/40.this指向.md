<script src='/笔记/see/index.js'></script>
[toc]

#### 指向问题
- 谁调用的就指向谁
  - 比如：`a.fun()`，即使调用的是父类中的方法，则在父类fun方法中，获取this，发现指向的是 A

- 但是通过 this 获取 A 中的属性与方法是有困难的，虽然this指向 A
  - **通过 this 无法获取A中的属性，只能获取当前类中的属性**
    - 比如 A 有 num = 3;  B 中有 num = 6。A继承B
    - 如果在其他的类中，通过a.num获取到的就是 3，从下往上找
    - 如果在 A 中，使用 this.num 获取，获取的是 3（当前类中）
    - 如果在 B 中，使用 this.num 获取，获取的是 6（当前类中）
    - 虽然，两个this都指向 A，但是B中获取的就是6，无法获取到3
    ```java
    public class Demo {
        public static void main(String[] arge) throws InterruptedException {
            A a = new A();
            a.c();
            // 其他类获取 num，从子类往父类中找，所以打印 3
            System.out.println(a.num);
        }
    }

    class A extends B {
        public int num = 3;
    }

    class B {
        public int num = 6;
        
        // 虽然this指向的是A，但是由于获取的是属性，所以只能获取当前类中的属性
        //    所以获取的是 6
        public void c() {
            System.out.println("c方法" + this.num);
        }
    }
    ```
  - **通过 this 调用方法，调用的就是重写后的方法（从子类往父类中查找，找到就执行）**
    - 但是，前提是当前类中必须有该方法，才能调用重写后的方法，否则就会报方法找不到的错误
    - 比如 A 有 fun  B 中通过 this 调用 fun 方法。
      - 首先 B 中要想使用 fun，就必须有fun 方法
      - 由于是通过 this 调用的 fun 方法，而 this 是指向 A 的，所以最终执行的是A中重写的fun方法（与属性是不一样的）
    ```java
    public class Demo {
        public static void main(String[] arge) throws InterruptedException {
            A a = new A();
            a.c();
        }
    }


    class A extends B {
        public int num = 3;

        @Override
        public void b() {
            System.out.println("重写b方法");
            // this使用属性，使用的是当前类中的属性，所以打印的是 3
            System.out.println(this.num);
        }
    }

    class B {
        public int num = 6;

        // 必须有个b，否则 this.b 会报错
        public void b() {
            System.out.println("b方法");
        }

        // 虽然当前类中有 b 方法，但是由于this指向的是A
        //    所以通过this调用方法，会从A开始找，然后就找到了重写后的方法，然后开始执行
        public void c() {
            this.b();
        }
    }
    ```


#### super的指向
- 指向当前类继承的那个父类（与this没有关系）
  - 比如 A 继承 B，B 继承 C     
  - 则 
    - A 中使用 super，指向的就是B（也就是直接调用B的方法，而不会调用A中重写的方法）
    - B 中使用 super，指向的就是C（也就是直接调用C的方法，而不会调用A和B中重写的方法）
  - 也就是 A 中想直接使用 B 中的方法，而不是调用重写后的方法，就可以使用 super
    - this实现不了，因为this获取的就是重写后的方法