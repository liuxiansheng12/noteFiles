<script src='/笔记/see/index.js'></script>
[toc]


#### Java语言的特点
- 跨平台性   
  - 平台(不同厂商的芯片)    
  - 平台(不同版本的操作系统)
- 面向对象
- 简单性	     
  - 省去了C++多继承，指针等等
- 健壮性
  - 垃圾回收机制   
  - 异常处理机制
- 多线程性	    
  - 并行操作、提高执行性能、要注意线程安全
- 大数据开发


#### 如何让计算机执行java程序
- 安装JDK -》 配置环境变量 -》cmd编译.java文件 -》cmd运行java程序



#### 基本数据类型
- 整数型：  byte、short、int、long
  - 使用long约束数据类型的时候，要注意，在最后加上 L
    - 比如: long d = 2147483648L;
    - 原因就是，这个类型太大，如果我们真的需要那么大的数字  必须在后面加L告知
- 浮点型：  float、double
  - 使用 float 约束数据类型的时候，要注意，在最后加上 F
    - 比如: float e = 3.4F;
  - double 可以直接写成小数，不用加标示 F
    - 加上也不报错
- 字符型：	char
- 布尔型：	boolean 




#### 二进制
- 电脑存储数据，只能存放 0和1，并且是已补码的形式存放数据
  - 正数的补码是它本身（反码、补码就是它本身）
  - 负数的补码是它的反码加1
    - 比如有二进制10000110，第一位是1，代表它是负数。反码就是每一位都取反，为01111001。所以，补码就是01111010（反码加1）
  - 由于加一的存在，所以负数的区间就比正数多一个
    - 比如：Byte的范围就是 -128 ~ 127

  



#### 类型转换
- 精度高的数据，不能转换成精度低的数据，因为会造成数据丢失，所以默认不允许
  - 就是为了防止类型写错，然后进行类型转换，从而造成数据出错
  - 除非强制转换，这样写就说明确实需要进行类型转换

.
- **低位的整数可以自动转换成高位的整数**
  - 高位的整数不能自动转换成低位的整数，可以强制转换
    - 高位的整数，转换成低位的整数，可能会造成数据丢失的问题，所以不能自动完成
  - 比如
  ```java
    int a = 32;
    // 不能自动转换
    // byte b = a;
    // 可以强制转换
    byte b = (byte)a;

    byte c = 32;
    // 可以自动转换
    int d = c;
    System.out.println(d);
  ```

.
- **低位的浮点型（小数）可以自动转换成高位的浮点型（小数）**
  - 高位的浮点型（小数）不能自动转换成低位的浮点型（小数），可以强制转换
    - 高位的浮点型（小数），转换成低位的浮点型（小数），可能会造成数据丢失的问题，所以不能自动完成
  - 比如
  ```java
    float a = 34.2F;
    // 地位可以自动转成高位
    double b = a;

    double c = 3.45;
    // 不能自动转换
    // float d = c;
    // 需要强制转换
    float d = (float)c;
  ```

.
- **所有类型的整数，能自动转换成小数**
  - 小数不能转换成整数，可以进行强制转换
  - 比如
  ```java
    float a = 34.2F;
    // 小数转整数，只能强制转换
    int b = (int)a;

    // 低位的能转换成对应的小数
    int c = 3;
    float d = c;

    // 即使是高位的也能自动转换成功
    long e = 3L;
    float f = e;
    double g = e;
  ```

.
- **char类型的数据，可以自动转换成整数和小数**
  - 如果写的是一个英文字符，是可以自动转换成 `byte` 的
  - 如果写的是一个中文的字符
    - 由于中文的字符是两个字节
    - 如果转换成 `byte` 类型的数据，就有可能发生数据丢失的问题。
    - 所以为了避免，无意中丢失数据，中文字符是不能自动转化成 `byte` 类型的数据的，必须强制转化
  - `int` 和 `float` 都是32 位的，装字符绰绰有余，所以可以自动转换
  - **整数转换成 char类型的数据**
    - short 范围的整数可以自动转换
    - int 范围的的数据，必须强制类型转换
    - 超过int 范围的数据，即使强制转换也不行
  - **小数数和转换成 char类型的数据**
   - 必须强制类型转换
   - char的编码就是一个整数，相当于从高精度转换成低精度（小数转整数）
   - 并且只能float 范围的数据可以转换


#### 两个整数互换
- 巧用 ^ 运算符 （相同为0，自己 ^ 自己 = 0。然后 0 ^ 另一个，自然就为另一个了，完成了互换）
- 示范代码
  ```java
  public class Demo {
      public static void main(String[] args) {
          int a = 3;
          int b = 4;
          // 不能直接 a = a ^ b ^ a，这样 3 就会消失
          a = a ^ b;
          b = a ^ b;  // 就相当于 b = a ^ b ^ b。b = a;
          a = a ^ b;  // 由于此时 b 变成了 a，虽然 a ^ b ^ b，其实是 a ^ b ^ a。a = b，这样两个都完成了互换
          
          System.out.println(a);
          System.out.println(b);
      }
  }
  ```



#### 枚举
- 某个类提前创建好需要的一些对象，并且对象个数固定，无法手动通过new的方式，创建出新的对象

- 具体的实现示范代码
  ```java
  enum En {
      // 这个东西必须写在第一行，
      en1, en2, en3("张三");  // 前两个使用无参构造方法，构造对象。后面的使用有参构造方法构造对象

      private En() {
          System.out.println("无参构造方法");
      }
      private En(String s) {
          System.out.println("有参构造方法，参数：" + s);
      }

      public void fun() {
          System.out.println("方法执行");
      }
  }


  public class Demo {
      public static void main(String[] arge) {
          // 不使用，枚举是不会构造对象的，只要一开始使用，则立马创建出所有的枚举对象（三个）

          // 访问枚举对象
          System.out.println(En.en1);

          // 调用枚举对象的方法
          En.en1.fun();
      }
  }
  ```

- **注意点**
  - 枚举由于会默认继承一个Enum类，所以就不能手动继承其他类了（一个类只能继承一个）
  - 枚举中不能写公有的构造函数，只能写私有的（不允许手动通过 new 的方式创建对象）
  - 枚举无法通过反射的技术，获取到内部的构造方法（不允许手动创建对象）

.
- `Enum`类中提供了一些属性和方法
  - `name`----->枚举对象的名字，`name()`获取name属性
  - `ordinal`--->枚举对象在类中罗列的顺序，类似index，也从0开始，`ordinal()`获取序号
  - `valueOf()` 通过给定的name获取对应的枚举对象
  - `values()` 获取全部的枚举对象  ---> 返回一个数组， Day[]
  - `compareTo()` 可以比较两个枚举对象，   int
  - `toString()` 由于这个方法没有final修饰，   可以覆盖(重写)


.
- 枚举通过普通类实现（和上面代码的效果一样，使用方式一样）
  - 底层原理就是单例模式
  - 枚举的特点
    - 创建出固定数量的对象，并且可以通过类.的方式使用，所以这就是静态属性
    - 无法通过new的方式构造出新的对象，所以这就是构造方法私有化
  - 示范代码
  ```java
  class En {
      public static final En en1 = new En();
      public static final En en2 = new En();
      public static final En en3 = new En("张三");

      private En() {
          System.out.println("无参构造方法");
      }
      private En(String s) {
          System.out.println("有参构造方法，参数：" + s);
      }

      public void fun() {
          System.out.println("方法执行");
      }
  }

  public class Demo {
      public static void main(String[] args) {
          En.en1.fun();
      }
  }
  ```






#### 运算符-逻辑运算符
1. `&` 逻辑与，**所有的条件都会进行处理**(并不是遇到false就停止)，只要有一个条件为false，最终得到的结果为false
2. `｜` 逻辑或，**所有的条件都会进行处理**(并不是遇到true就停止)，只要有一个条件为true，最终得到的结果为true
3. `^` 逻辑异或，**所有的条件都会进行处理**，只要左右两个结果不同，一个为true，一个为false，结果为true，相同为false。
4. **注意：**
   1. 这三个逻辑运算符，如果左右两侧的数据类型是 `char类型`和`整数类型(4个类型)`，则进行的是位运算
   2. 如果两侧，的数据类型是 `boolean`，则进行的是逻辑运算
   3. char类型和整数类型可以混用，得到的是整数类型。而boolean类型，两侧必须相同
   4. 浮点型，不能使用，也就是无法进行位运算
5. **所以 `&、｜、^` 这三个运算符，有两种含义，一个是位运算，一个是逻辑运算**



#### 运算符-短路逻辑运算符
1. `&&` 短路与，一个一个的条件进行判断，只要有一个为false，则立马停止，得到的是false，后面的表达式不再进行处理
2. `||` 短路或，一个一个的条件进行判断，只要有一个为true，则立马停止，得到的是true，后面的表达式不再进行处理
3. 需要注意的是，短路逻辑运算符，两侧的数据类型必须为 `boolean`。其他的数据类型不能使用
   1. 通常与**比较运算符**联合使用，比较运算符返回的就是boolean类型的数据



#### 运算符-比较运算符
- 得到的结果为boolean类型的数据

1. `>`、`>=`、`<`、`<=`、`!=`、`==`、`对象 instanceof 类`



#### 运算符-算术运算符
1. 算术运算：`+`、`-`、`*`、`/`、`%`、`++`、`--`
		    
2. 赋值运算：`=`、`+=`、`-=`、`*=`、`/=`、`%=`
	
3. 由于Java的数据类型很严格，所以 `整数除一个整数`，得到的是一个整数，如果是 `0.几`，结果就为0。除数或者被除数只要有一个为小数，得到的才是小数。




#### 运算符-位运算原理（了解底层数据的存储）
1. 数据的存储，分为原码，反码，补码。
2. 其中正数的原码、反码、补码相同，比如: 2的原码、反码、补码如下(以byte为例)
   1. 原码: 00000010
   2. 反码: 00000010
   3. 补码: 00000010
3. 其中负数的原码是显示的数据、反码取反(第一位是符号位，0表示正数，1表示负数，是不进行取反的)、补码是反码加一，比如: -2的原码、反码、补码如下(以byte为例)
   1. 原码: 10000010
   2. 反码: 11111101
   3. 补码: 11111110

4. 计算机底层存储的就是反码，运算使用的也是反码，使用的时候，在进行运算
   1. 正数不变，负数减一取反
   2. 比如一下的示范代码
   ```java
    byte a = 1;   // 底层存储的补码为: 0000 0001
    byte b = -2;  // 底层存储的补码为: 1111 1110   (1000 0010 -->  1111 1101 --> 1111 1110)
    System.out.println( a & b );    // 结果为 0
    // 底层计算的是   0000 0001 & 1111 1110  (全1为1)  --> 0000 0000  (这是补码，使用时要转换)  --> 0
    System.out.println( a | b );    // 结果为 -1
    // 底层计算的是   0000 0001 | 1111 1110  (有1为1)  --> 1111 1111 (这是补码，使用时要转换，减一取反) --> 1111 1110 --> 1000 0001  --> -1
    System.out.println( a ^ b );    // 结果为 -1
    // 底层计算的是   0000 0001 ^ 1111 1110  (相同为0，不同为1)  --> 1111 1111 (这是补码，使用时要转换，减一取反) --> 1111 1110 --> 1000 0001  --> -1
    System.out.println( ~a );    // 结果为 -2
    // 底层计算的是   ^ 0000 0001 (每一位取反)  --> 1111 1110  (这是补码，使用时要转换，减一取反) --> 1111 1101 --> 1000 0010  --> -2
   ```


#### 运算符-位运算
1. & (与)，运算规则，有0为0，全1为1
2. ｜ (或)，运算规则，有1为1，全0为0
3. ^ (异或)，运算规则，相同为0，不同为1
4. ～ (取反)，运算规则，每一位取反
5. 每一个位运算符，正常操作操作符号位，代码如上




#### 运算符-位移运算符
- 左移运算符
1. `<<`，
2. 相当于 `乘2的倍数`，由于直接操作位，所以比 运算符`*` 的效率要高
3. 比如: `5 << 3`，就相当于 `5 * 2 * 2 * 2`


- 右移运算符，符号位不动
1. `>>`
2. 相当于 `除2的倍数`，由于直接操作位，所以比 运算符`/` 的效率要高
3. 比如: `5 >> 3`，就相当于 `5 / 2 / 2 / 2`


- 右移运算符，符号位也进行移动
1. `>>>`
2. 正数没事，负数符号位一进行移动，就会变成一个很大的正数，所以不是 `除2的倍数` 
3. 比如: `byte a = -6;  a >>> 1;`
   1. **需要注意的是，虽然类型为byte，但是参与运算的时候，会变成 32 位的**
   2. 这样移动完，就变成了 `2147483645`




#### 字符串-字符串底层存放
- 字符串是通过String类进行创建的，即使写成字面量赋值，底层调用的也是 new String()
- String类中，有一个私有属性 private final char value[]，这个属性存放的就是字符串数据
- 所以，字符串数据的存放格式是每个字符拆开，然后存成 char 类型的数组

.
- 如果能修改这个char数组中的某一位，则当前字符串也会发生变化
  - 比如
    ```java
    public static void main(String[] arge) {
      String str = "abc";
      // 修改
      value[1] = 'x';
      System.out.println(str); // 此时在获取str，就变成了 axc
    }
    ```
- 但是由于这个属性是私有的，所以正常情况下获取不到，也就无法修改
  - 但是可以通过反射的方式获取到，然后进行修改，具体操作后面介绍



#### 字符串-字符串拆分
- 利用 split 这个函数，可以实现字符串的拆分

.
- 正常拆分
    ```java
    String s = "a,b,c,d";
    String[] arr = s.split(",");
    System.out.println(Arrays.toString(arr)); // 打印出[a, b, c, d]
    ```

.
- 最后一位是拆分标记（问题：拆分出来的集合，最后一位是否是空串）
    ```java
    String s = "a,b,c,d,";
    String[] arr = s.split(",");
    System.out.println(Arrays.toString(arr)); // 打印出[a, b, c, d]
    ```

.
- 最后两位都是拆分标记（问题：拆分出来的集合，最后几个空串，一个也没有）
    ```java
    String s = "a,b,c,d,,";
    String[] arr = s.split(",");
    System.out.println(Arrays.toString(arr)); // 打印出[a, b, c, d]
    ```
  - **总结：只要最后拆分出来得到是空串，就会忽略**
    - 比如：`,,,,,`，拆出来全是空串，可以看成最后都是空串，这样就会忽略，于是得到的是个空数组
    

.
- 首位是拆分标记（问题：开头能拆分出来空串吗，会忽略吗）
    ```java
    String s = ",a,b,,,,,c,d,,";
    String[] arr = s.split(",");
    System.out.println(Arrays.toString(arr)); // 打印出[, a, b, , , , , c, d]
    ```
  - **总结：只要拆分出来得到的空串不在最后，就不会忽略（无论是在开头还是在中间，还是连续多个空串，都不会忽略）**



.
- 拆分成指定位数的子字符串（比如；能拆成4段，但是需求是拆分成2段）
  - 利用第二个参数
    ```java
    String s = "a,b,c,d,,";
    String[] arr = s.split(",", 2);
    System.out.println(Arrays.toString(arr)); // 打印出[a, b,c,d,,]
    ```
    - 会从前往后拆，达到目标后，就不在进行拆分（所以，在a和b中间切一刀，就变成两段了，符合2，于是后面的b,c,d,,就不在进行拆分）
    - 如果是空串，也会看成一段，比如 `,a,b,c,d,,`，拆分成两段，得到的就是 `[, a,b,c,d,,]`
  - 当然，如果想要从中间切一刀（按照某个规则切），就需要借助正则表达式


.
- 拆分利用正则表达式
    ```java
    String s = "a1b2c3d";
    String[] arr = s.split("\\d");  // 按照数字进行切分
    System.out.println(Arrays.toString(arr)); // 打印出[a, b, c, d]

    //正则表达式中 \d标识数字，所以本题是按照数字对字符串进行拆分
    //正则表达式中的\在java中有转义的含义，所以需要利用\对其进行转义，转换成基本\的含义
    ```


#### 字符串-字符串拼接
- 第一种，使用 + 号运算符
  - 只要 + 号的**两侧有一个字符串类型的数据**，则 + 号就变成字符串的拼接
  - 比如
    ```java
    public class Demo {
        public static void main(String[] arge) {
            System.out.println( "a" + true );  // 打印 atrue
            System.out.println( "a" + null );  // 打印 anull
            System.out.println( null + "a" );  // 打印 nulla
            System.out.println( "null" + "a" );  // 打印 nulla
        }
    }
    ```
- 第二种运用 concat 方法
  - 这种方式，只能拼接字符串与字符串类型，因为 concat 的参数类型是字符串，而 concat 又是 String 上的方法，所以只能拼接字符串与字符串
  - 功能：把 concat 传入的字符串，**拼接在调用该方法的字符串的后面**
  - 比如
    ```java
    public class Demo {
        public static void main(String[] arge) {
            System.out.println( "a".concat("b") );  // 打印 ab
            System.out.println( "a".concat("b").concat("c") );  // 打印 abc
        }
    }
    ```



#### 字符串-字符串比较
- 不能使用  `>、< ` 比较，会报错。只能比较是否相等
- 使用 == 比较，比较的是地址索引
- 使用 equals 比较的是字面量

- 比如
```java
public class Demo {
    public static void main(String[] arge) {
        String s1 = "a";
        String s2 = "a";
        String s3 = new String("a");
        System.out.println( s1 == s2 );  // 打印 true
        System.out.println( s1 == s3 );  // 打印 false
        System.out.println( s1.equals(s3) );  // 打印 true
    }
}
```
  - 字面量赋值：String s1 = "a"，其实底层也是 new 一个 String，只不过创建后有缓存
    - 即 String s2 = "a";，一看有一个 "a"，就会直接复用地址索引
    - 所以 s1 == s2 才为 true



#### 数组-数组的使用
- 定义数组
  ```java
  // 开辟一个长度为 3 的数组
  int[] a = new int[3];
  System.out.println(a);

  // 开辟一个长度为 3 的数组，并赋值
  int[] b = {1, 3, 7};
  int[] c = new int[]{1, 3, 7};
  System.out.println(b);

  // 传参传入一个数组，只能这样写，不能写 {3, 2}
  //   如果这样写，就单独定义，然后传入一个索引
  B.demo(new int[]{3, 2});
  ```


#### 数组-常用的工具方法
- 所有的工具方法，必须通过Arrays调用，把要操作的数组，作为参数传进去

#### 数组-排序
```java
public static void main(String[] arge) {
  int[] arrs = {3, 6, 8, 9, 3, 3, 7};
  // 排序
  Arrays.sort(arrs);
  // 查看效果
  System.out.println(Arrays.toString(arrs));
}
```


#### 方法-行参默认值的问题
- 在java中，没有函数参数默认值这个写法，要想实现默认值效果，可以利用方法的重载
  - 默认值的作用，就是不传递参数，使用默认的。在函数内部赋默认值也一样，就是写法不同
- 比如
```java
package Fs;
// 具有线程锁的方法
public class Demo {
    String s1;
    String s2;
    String s3;

    public Demo() {};

    // 有默认值（ 相当于 d(String s1, String s2, String s3 = "默认值") ，但是这样写会报错 ，只能利用方法重载实现）
    public void d(String s1, String s2) {
        // 搞个默认值
        this.s3 = "默认值";

        this.s1 = s1;
        this.s2 = s2;
    }
    // 没有默认值
    public void d(String s1, String s2, String s3) {
        this.s3 = s3;
        this.s1 = s1;
        this.s2 = s2;
    }
}
```


#### 包装类-介绍
- 作用，把一个常量包装成一个对象，使其可以调用一些方法
- 包装类(封装类)，诞生于1.5版本之后，可以实现自动拆装包(自动包装，自动去包装)

.
- 包装类一共有八个，分别对应八个基本数据类型
   1. byte---`Byte` 
   2. short---`Short`   
   3. int---`Integer`  
   4. long---`Long`
   5. float---`Float`  
   6. double---`Double`  
   7. char---`Character`   
   8. boolean---`Boolean`

.
- 包装类的位置
	- 八个包装类都在同一个包下，java.lang包，Java.lang是不需要import导包的，可以直接使用

.
- 八个包装类的大体特性
  - 八个包装类中有六个是与数字相关的，所以都默认继承父类`Number`
    - `Number`类中有几个方法，`xxxValue()`
    - 这几个函数的作用，将一个包装类类型转化为对应的基本类型(拆包，还原回来)，前面的`xxx`是对应包装类对应的数据类型
  - 八个包装类都实现了`Serializable`, `Comparable`
  - 八个包装类都有带自己对应类型参数的构造方法
	  - 八个包装类中有七个(除了Character)还有构造方法重载，可以接受String类型的数据
    - 默认的构造方法，传入对应的数据类型


#### 包装类-使用
- **对一个常量手动包装**
  ```java
  Integer i1 = new Integer(10);
  // 调用第二个构造方法，传入一个字符串，char的包装类是没有这个功能的
  Integer i2 = new Integer(“10”);
  // 调用第二个构造方法，传入一个字符串，char的包装类是没有这个功能的
  Integer f1 = new Float(“10.011”);

  // 拆包，intValue就是Number类中的一个方法
  int value = i1.intValue();
  ```

.
- **对一个常量自动包装**
  ```java
  // 写成这种格式，数据类型为对应包装类的名称，就可以对一个数据完成自动包装
  Integer i2 = 10;
  ```

.
- **自动拆包**
```java
// 把一个包装类对象，用对应的常量接受，就会自动调用对应的xxxValue方法，进行拆包
//     此处，自动调用的是intValue方法，进行拆包
int value = new Integer(10);
```


#### 包装类-字符串转换成数字
- 字符串直接转成int或者float类型的基本数据类型，有两种方式
  - 利用包装类的第二个构造函数，然后自动拆包
  - 利用包装类提供的一个静态方法，`parseInt` 或者 `parseFloat`
  - 比如
    ```java
    int v = new Integer("123");
    int value = Integer.parseInt("123");	
    float f = Float.parseFloat("123.45");
    ```


#### 包装类-自动包装的缓存问题
- 为了提高效率，这八种包装类，在创建的时候，会创建一个静态的数组
  - 数组的每一项，是一个数据对应的包装类
- 这样的话，在自动包装的时候，就会先去这个静态数组中，查看有没有对应的包装类对象，如果有就直接取出使用，如果没有就是重新 new 一个
- 由于某些数据类型的数据量非常大，所以不可能每个数据都创建一遍，只会创建一部分
  - 比如 `int` 类型的，只有`-128～127`之间，会创建出对应的包装类集合 
    - 也就是一个byte类型的数据大小

- 这样就造成了一种现象（相等和不相等问题）
  - 比如
    ```java
    public static void main(String[] arge) {
      // 类型不一样，所以会自动进行包装
      Integer i1 = 10;
      Integer i2 = 10;
      // 由于范围在-128～127之间，所以两个取得都是缓存，所以两个相等
      System.out.println(i1 == i2); // true

      // 类型不一样，所以会自动进行包装
      Integer i3 = 200;
      Integer i4 = 200;
      // 由于范围不在-128～127之间，所以缓存中就没有，所以两个都会重新 new 一个出来
      //    只要经过 new 创建出的集合，都是新的，所以两个不相等
      System.out.println(i3 == i4); // false
    }
    ```
    


#### 包装类- equals 方法
- Object中有一个`equals`方法，Object中的方法，比较的是 `this == 参数`
- 包装类也是一个类，所以默认继承Object类，但是，包装类中的`equals`方法，进行了重写
  - 重写后，比较的是 `this.xxxValue() == (包装类)参数.xxxValue()`
    - 比较的是字面量，而不是集合本身
  - `(包装类)参数`，先进行强制类型转换，转换成包装类，因为只有包装类有`xxxValue`方法
    - 目的就是为了防止，传入基本数据类型，直接使用`xxxValue`方法报错
- 具体的示范代码
  ```java
  public static void main(String[] arge) {
    Integer i1 = 10;
		Integer i2 = new Integer(10);
    // equals 方法进行了重写，比较的是字面量，也就是 10 == 10，所以比较结果是 true
    System.out.println(i1.equals(i2)); // true


    Integer i3 = 200;
    Integer i4 = 200;
    // 直接比较，比较的是包装类集合本身（地址索引）
    //    由于超过了区间，所以缓存中没有，需要重新new，所以比较结果是false
    System.out.println(i3 == i4); // false
    // equals 方法进行了重写，比较的是字面量，也就是 200 == 200，所以比较结果是 true
    System.out.println(i3.equals(i4)); // true


    Integer i5 = new Integer(10);
		Integer i6 = new Integer(10);
    // equals 方法进行了重写，比较的是字面量，也就是 10 == 10，所以比较结果是 true
    System.out.println(i5.equals(i6)); // true

    // 如果没有重写，比较的就是 this == 参数，也就相当于比较的是集合本身，即：i3 == i4
  }
  ```



#### 注解-自定义注解

> 通过 `public @interface MyAnnotation {}` 创建一个注解
>> 1. `MyAnnotation` 就是注解名
>> 2. 注解使用时，通过 `@MyAnnotation`


> 注解是可以存放数据的
>> 要想存放数据，需要定义对应的接口方法
>>> 1. 有点类似get方法，方法名对应属性名，方法返回类型，对应属性类型
>>> 2. 然后，注解在使用的时候，就可以写成类似函数调用的方式，然后传入对应的属性值（注解中定义好的），必须传入
>>> 3. 这样的话就可以存储一些数据
>>> 4. **定义的方法，可以通过反射获取到，然后执行，得到对应的存储的数据**
>>> 5. **需要注意的是，要想获取注解存放的数据，元注解必须使用，否则是获取不到的**

> 比如，定义一个如下的注解
```java
public @interface Zhu {
    public abstract String value();
    public abstract String[] name();
    public abstract String age();
    
    // abstract可以省略，但是通常这么写
}
```

> 自定义注解的使用方式
```java
@Zhu(name = {"张三"}, age = "10", value = "ceshi")
public void a() {}
```


> 注解中，还可以定义常量，但是很少使用
>> 因为定义了就不能修改了，而注解就是给某个类存放一些动态的数据，向这些固定值，通常都直接写死在类中
>> 通过，`public static final 类型 属性名 = 固定值;`，在注解中定义一个固定值
>>> 固定值，是可以定义成其他类型的，不一定非得是字符串



#### 注解-元注解介绍
- 元注解是注解使用的注解，可以限制注解使用的范围
> 元注解，可以不使用
> 元注解，一共有四个
>> 1. `@Target`：描述当前的这个注解可以放置在哪里写的（限制使用范围）
>>> 1. @Target(ElementType.TYPE)：接口、类、枚举、注解
>>> 2. @Target(ElementType.FIELD)：字段、枚举的常量
>>> 3. @Target(ElementType.METHOD)：方法
>>> 4. @Target(ElementType.PARAMETER)：方法参数
>>> 5. @Target(ElementType.CONSTRUCTOR)：构造函数
>>> 6. @Target(ElementType.LOCAL_VARIABLE)：局部变量
>>> 7. @Target(ElementType.ANNOTATION_TYPE)：注解
>>> 8. @Target(ElementType.PACKAGE)：包   

>> 2. `@Retention`：描述当前的这个注解存在什么作用域中的
>>> 1. 源代码文件(`SOURCE`)--->编译--->字节码文件(`CLASS`)--->加载--->内存执行(`RUNTIME`)    
>> 3. `@Inherited`：描述当前这个注解是否能被子类对象继承
>> 4. `@Document`：描述这个注解是否能被文档所记录

> 示范代码

```java
import java.lang.annotation.*;

@Target({ElementType.CONSTRUCTOR,ElementType.METHOD,ElementType.FIELD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    public abstract String[] value();
    public abstract String c(); 
}
```



#### 注解-使用反射获取注解
> 注解，要不顶在类的上面，要不顶在方法的上面，要不顶在属性的上面
> 这样，就形成了一种对应关系
> 所以，只要找到对应的类、方法、属性，就可以找到对应的注解
> 而类、方法、属性，需要通过注解找到

> 先自定义一个注解
```java
// 要想通过反射的方式，获取注解，元注解是必须要设置上的
@Target({ElementType.CONSTRUCTOR,ElementType.METHOD,ElementType.FIELD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface Zhu {
    public abstract String value();
    public abstract String[] name();
    public abstract String age();
    public static final Integer a = 1;
}
```

> 使用注解的类
```java
@Zhu(name = {"张三"}, age = "10", value = "ceshi")
public class Ceshi {
    @Zhu(name = {"张三"}, age = "10", value = "构造")
    public Ceshi() {}
}
```


> 使用反射，获取注解
```java
public static void main(String[] str) throws Exception {
   // 通过反射获取类
   Class clazz = Class.forName("Ceshi");
   // 获取类上面的注解
   Annotation a = clazz.getAnnotation(Zhu.class);
   // 获取注解类
   Class cla = a.getClass();
   // 获取注解中，对应的方法
   Method method = cla.getMethod("value");
   // 执行方法，获取注解存放的数据
   String values = (String)method.invoke(a);
   System.out.println(values);

   // 其他地方的注解，也是一样，先获取对应的属性、方法。
   //    然后在使用 getAnnotation 获取注解，后续步骤就一样了，获取注解中对应的方法，执行方法

   // 比如：获取构造函数上的方法
   // 首先获取到构造函数
   Constructor con = clazz.getConstructor();
   // 然后获取上面的注解
   Annotation b = con.getAnnotation(Zhu.class);
   // 获取注解类
   Class clas = b.getClass();
   // 获取注解中，对应的方法
   Method methods = clas.getMethod("value");
   // 执行方法，获取注解存放的数据
   String value = (String)methods.invoke(b);
   System.out.println(value);
}
```






#### 线程-线程的概念
- 程序，可以理解为是一组静态的代码
- 进程，正在进行的程序、静态的代码，运行起来
- 线程，正在执行程序中的小单元

- 服务器就是利用线程思想做的
  - 当请求来临后，就创建一个线程对象，传入请求报文进行解析
  - 然后，使用start，让处理请求的run方法，进入执行的准备状态，准备执行



#### 线程-定义与使用（方式一）
- 通过继承Thread类，然后重写run方法实现
```java
// 类一
public class CeshiOne extends Thread {
    private String name;
    public CeshiOne(String name) {
        this.name = name;
    }

    @Override
    // 重写线程方法
    public void run() {
        for(int i = 0; i < 1000; i ++) {
            System.out.println(this.name + "：" + i);
        }
    }
}

// 主函数（让线程进入准备阶段）
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建一个线程对象
        CeshiOne x1 = new CeshiOne("线程一");
        // 构建一个线程对象（一个类可以起多个线程，他们之间互补干扰）
        CeshiOne x2 = new CeshiOne("线程二");
        // 构建一个线程对象
        CeshiTwo x3 = new CeshiTwo("线程三");

        // 线程进入准备状态
        //    也就是 对象中的run进行执行前的准备状态
        //    当拿到时间碎片后，就开始执行
        x1.start();
        x2.start();
        x3.start();
    }
}
```


#### 线程-定义与使用（方式二）
- 通过实现Runnable接口，然后重写run方法实现
```java
// 类一
public class CeshiOne implements Runnable {
    private String name;
    public CeshiOne(String name) {
        this.name = name;
    }

    // 重写线程方法
    public void run() {
        for(int i = 0; i < 1000; i ++) {
            System.out.println(this.name + "：" + i);
        }
    }
}


// 主函数（让线程进入准备阶段）
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建对象
        CeshiOne o1 = new CeshiOne("线程一");
        CeshiOne o2 = new CeshiOne("线程二");
        CeshiTwo o3 = new CeshiTwo("线程三");

        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        // 构建一个线程对象（）
        Thread x2 = new Thread(o2);
        // 构建一个线程对象
        Thread x3 = new Thread(o3);

        // 线程进入准备状态
        //    也就是 对象中的run进行执行前的准备状态
        //    当拿到时间碎片后，就开始执行
        x1.start();
        x2.start();
        x3.start();
    }
}
```


#### 线程-线程的执行原理
- 无论是方式一还是方式二，run方法是核心（相当于入口函数）

.
- 线程是操作系统级别的，我们控制不了，受电脑的cpu进行控制
  - 当线程准备好后，就等着时间碎片的来临
  - 当某个线程拿到时间碎片后，重写的run方法就开始执行（线程程序启动）
    - 所以run方法的执行是cpu控制的
  - 当线程执行一段时间后，时间碎片就会切换到其他线程，当前线程就失去了时间碎片，于是停止执行
  - 当另一个线程拿到时间碎片后，开始执行
    - **需要注意安全锁的问题，如果线程操作的代码被锁住，则陷入等待（等待时间碎片切换走）**
    - 安全锁可以保证数据的安全与准确性
  - cpu的时间碎片，随机分配，时间长短不定（所以线程的执行是随机的）
  - 当某个线程重新拿到时间碎片后，会继续往下执行
  - **如果一个线程被挂起，则时间碎片就不会分配到该线程**
    - 只有挂起的线程被唤醒，才进入等待过程（等待时间碎片的分配）
    - 拿到时间碎片后，进行执行，并且从上次停止的地方继续执行


#### 线程-线程沉睡
- 利用 Thread.sleep 方法，可以让某个线程沉睡一段时间
  - 沉睡，就是自动挂起一段时间（这段时间内时间碎片不会分配给该线程，也就是线程暂停执行），时间到了沉睡的线程会自动唤醒
  - 线程沉睡后，会立刻停止执行，当唤醒后，就会等待时间碎片的来临。当拿到时间碎片后，才会继续往后执行
- 使用的时候，必须处理错误
- 该方法传入一个时间，相当于沉睡的时间


- 使用示范代码
```java
// 带有线程沉睡的类
public class CeshiOne implements Runnable {
    
    // 重写线程方法
    public void run() {
        for(int i = 0; i < 1000; i ++) {
            // 让线程沉睡一段时间
            if(i == 500) {
                // 需要处理错误，可能一睡不醒
                try {
                    // 在这个地方，立马就进行了沉睡，不再往后执行
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(this.name + "：" + i);
        }
    }
}


// 开启线程
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建对象
        CeshiOne o1 = new CeshiOne("线程一");
        // 创建一个线程
        Thread x1 = new Thread(o1);
        // 线程启动
        x1.start();
    }
}
```




#### 线程-线程挂起
- 借助 wait 方法，进行线程的挂起（有两种使用方式）
  - 不传递参数，或者传递0，只能手动唤醒
  - 传递数字，表示多少秒后，自动唤醒

- wait 必须放在 synchronized 中进行线程的挂起（否则会报错）

- 比如：
  ```java
    class A {
        public synchronized void b() throws InterruptedException {
            // 线程的挂起
            this.wait(0);
        }
    }
  ```

- 如果，某个线程，正在操作某个对象，并且带有安全锁，此时这个对象就被锁住
  - 如果此时，线程被挂起，则锁住的对象立即释放
  - 如果线程被唤醒，继续从上次挂起的位置往后执行（还是安全锁中，因为是在安全锁的函数中挂起的），此时对象还是会被锁住的


#### 线程-挂起线程的唤醒
- 必须放在 synchronized 中进行线程的唤醒（否则会报错）
- 借助两个方法，都可以实现线程的唤醒
  - notify（随机唤醒一个线程，无法控制）
  - notifyAll（唤醒当前对象挂起的所有线程）
- 线程释放后，也不是立即执行，也是等着时间碎片的分配，才能执行
- 比如：
  ```java
    class A {
        public synchronized void b() throws InterruptedException {
            // 线程的唤醒
            this.notifyAll();
        }
    }


#### 线程-线程挂起和唤醒配合使用的限制一(同一对象)
- 线程的挂起和唤醒只能在同一个对象中进行
- 挂起和唤醒和对象挂钩，某个对象挂起的线程，只能由该对象进行唤醒（该对象无法唤醒其他对象挂起的线程）
  - 比如 A 对象挂起了 a线程。则 a线程必须由 A对象 进行释放

- 比如
```java
public class Demo {
    public static void main(String[] str) throws Exception {
        // 创建一个对象，用来线程的挂起和释放
        Gong gong = new Gong();
        // 两个线程都传入 共同的对象
        //    因为对象挂起的线程，只能通过该对象释放，并且一个线程挂起只能用另一个线程释放
        //    或者自动释放
        // 比如：线程1 被 gong 对象挂起，则只能通过 gong对象释放，并且只能借助另一个线程释放
        //    所以，线程2也要传入 gong 对象，这样才能唤醒 线程1
        CeshiTwo o1 = new CeshiTwo("线程一", gong);
        CeshiOne o2 = new CeshiOne("线程二", gong);
        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        Thread x2 = new Thread(o2);
        // 线程启动
        x1.start();
        x2.start();


        // 线程的挂起和释放不用同一个对象
        //    这样，线程1挂起，线程2是无法唤醒线程1的
        //    因为：线程的挂起和唤醒，用的不是同一个对象
        //    这样就会造成，线程1挂起后，就无法唤醒了
        CeshiTwo o1 = new CeshiTwo("线程一", new Gong());
        CeshiOne o2 = new CeshiOne("线程二", new Gong());
        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        Thread x2 = new Thread(o2);
        // 线程启动
        x1.start();
        x2.start();
    }
}
```



#### 线程-线程挂起和唤醒配合使用的限制二(线程锁)
- 线程的挂起和唤醒必须在安全锁函数中进行实现
- 如果调用的方法，没有添加安全锁，则在使用的过程中，就会报出 IllegalMonitorStateException 的错误
  - 比如
  ```java
    class A {
        // 调用 b 方法，由于没有添加 synchronized 所以在执行的时候就会报错
        public void b() throws InterruptedException {
            this.wait(0);
        }
    }
  ```

- 线程必须在安全锁中进行挂起和唤醒的原因（避免一个线程永远的被挂起）
  - 由于线程挂起后，就不在进行工作，所以挂起的线程要想唤醒，必须在另一个线程中进行
  - 所以线程的挂起和唤醒，是多个线程配合使用的
    - 当某个线程挂起后，另一个线程满足条件后，在把这个线程唤醒
  - 而线程的切换，我们是控制不了的
    - 假设，一个线程将要被挂起，但是还没有挂起，如果这个时候线程切换到了另外一个，而这时如果满足了唤醒的条件，就会唤醒线程（但是线程并没有挂起）。
    - 当线程切回挂起的代码后，线程才被挂起（但是此时唤醒的代码已经执行完了，所以这个线程就有可能永远的被挂起）
  - 加了 synchronized，就会变得不一样
    - 由于挂起和唤醒必须在同一个对象中（即同一个类中）
    - 当执行到挂起的代码后（还没有挂起），线程切换走了，如果此时满足了唤醒的条件，执行到唤醒代码，由于这个对象已经被挂起锁住了，所以唤醒代码就会陷入等待
    - 直到挂起代码执行完成，线程被挂起，对象才会被释放
    - 然后唤醒代码才会继续执行（而此时线程已经被挂起了），所以正常唤醒
    - **先挂起后唤醒，这样就避免了线程永远被挂起的问题**
      - 如果先唤醒后挂起（也会造成线程永远被挂起），但这就是代码设计的问题了
.
- 根据以上原因，java为了防止某个线程一挂不起，所以强制要求线程的挂起和唤醒必须放在 synchronized 中执行，否则就会报错






#### 线程-假死状态
- 线程的挂起，可能造成假死的状态
  - 即某个线程挂起，但是却没有被释放，最后程序就会陷入等待阶段，一直等下去







#### 线程-设置线程的优先级
- 优先级高的可能能更快的获取到时间碎片进行执行（只是可能，提高了一些概率，并不是一定）
- 借助 setPriority 方法实现
  - 如果两个线程同时被唤醒，但是想要某个线程优先执行(比较重要)，即优先获取资源，就可以使用该方法
- 在创建线程的时候，就设置好

- 示范代码
```java
public class Demo {
    public static void main(String[] args) {
        Ceshi ceshi = new Ceshi();
        // 创建线程对象
        Thread thread = new Thread(ceshi);
        // 在创建线程的时候，就进行设置
        thread.setPriority(5);

        // 启动线程
        ta.start();
    }
}
```




#### 线程-join方法的作用
- join的作用，就是挂起当前的线程
  - 底层也是用 wait 实现的线程挂起
- **线程的挂起，只能通过另一个线程对象，挂起当前线程**
  - 因为 join 方法，是线程对象上的一个方法，所以只能线程对象使用，但是当前线程肯定不能挂起当前线程，所以只能通过别的线程挂起当前线程
  - 比如 A 线程想要通过join挂起
    - 在 A 线程中，运行另一个线程的join方法，就会挂起当前A线程

.
- 使用方式
  - 不传递参数或者传递0
    - 功能：当前线程执行完毕后，会自动唤醒该线程挂起的线程
    - 比如：有两个线程 A 和 B
      - A 线程想要通过 join 挂起，只能使用 B.join()，这样 A 线程就会被挂起，这样就会切换到 B 线程执行
      - 只有当 B 线程执行结束，A线程才会被唤醒
  - 如果传递具体的数据，则时间过后，被挂起的线程会自动唤醒（单位ms）

.
- **注意点**
  - join挂起的线程，是无法通过 notifyAll 进行唤醒的（只能自动唤醒，定时唤醒）（底层代码决定的）
    - 使用 notifyAll 唤醒线程后，当时间碎片切换到这个唤醒的线程后，开始执行，然后就会立刻挂起
    - 所以，无法通过 notifyAll 唤醒 join 挂起的线程


.
示范代码

```java
// 线程一的类（使用join，挂起当前线程）
public class CeshiOne implements Runnable {
    private String name;
    // 保存一个线程，使用它的join方法（因为 join 只能通过另一个线程对象，挂起当前线程）
    private Thread ceshiTwo;


    // 重写线程方法
    public void run() {
        System.out.println("使用线程二，挂起当前线程");
        try {
            // 当线程二结束的时候，会自动释放
            ceshiTwo.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("释放了");
    }

    // 保存线程2的对象，用他来挂起当前线程
    public void setCeshiTwo(Thread ceshiTwo) {
        this.ceshiTwo = ceshiTwo;
    }
}

// 创建线程
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建对象
        CeshiOne o1 = new CeshiOne("线程一");
        CeshiTwo o2 = new CeshiTwo("线程二");

        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        Thread x2 = new Thread(o2);
        // 传入对应的线程对象（用来挂起线程）
        o1.setCeshiTwo(x2);

        // 线程进入准备状态
        x1.start();
        x2.start();
    }
}
```

#### 线程-借助join实现单线程效果
- 原理
  - A线程中创建B线程，然后马上利用B线程挂起
  - B线程中创建C线程，然后马上利用C线程挂起
  - 这样 A线程 和 B线程就会立即停止，然后C执行
    - 由于 B 线程是 C挂起的，所以C执行完，B就开始执行
    - 由于 A 线程是 B挂起的，所以B执行完，A就开始执行
    - 这样，执行顺序就是 C --> B --> A，并且是一个一个执行的，达到了单线程执行的效果

- 示范代码
```java
public class A extends Thread{
    public void run() {
        // 创建b线程
        B b = new B();
        b.start()
        // 立刻挂起a线程，还没有执行后面的功能
        b.join();
    }
}
public class B extends Thread{
    public void run() {
        // 创建c线程
        C c = new C();
        c.start()
        // 立刻挂起b线程，还没有执行后面的功能
        c.join();
    }
}
public class C extends Thread{
    public void run() {

    }
}

// 主函数，创建线程（创建A线程就可以）
//    如果三个线程都在这里创建然后采用传入的方式挂起线程，是不合适的
//    因为线程的执行顺序不可控，如果B先执行，B就挂起了，然后A执行的时候就无法挂起了
public static void main(String[] args) {
    A a = new A();
    a.start();
}
```




#### 线程-join方法的底层源码
- 无法通过notifyAll唤醒的原因
  - 就是因为底层使用了 while
  - 即使唤醒后，由于唤醒条件不满足，所以还是处于 while 中，然后就又被挂起了

- 具体代码分析
```java
// 不传递时间，底层会自动赋成0
if (millis == 0) {
    // isAlive 判断线程是否执行完成
    //    因为 join 是通过 线程.join 挂起的。所以 isAlive() 就相当于 线程.isAlive()
    //    所以判断的是另一个线程是否执行完成，即 A 通过 B挂起，这个地方判断就是B线程是否执行完成
    //    如果没有执行完成，继续陷入挂起
    // 所以，通过notifyAll唤醒后或者自动唤醒后，都还是处于 while 中，会继续进行条件判断
    //    如果条件满足，说明挂起线程还没有执行完，是notifyAll唤醒的，然后就又陷入沉睡了
    //    所以无法通过 notifyAll 唤醒
    while (isAlive()) {
        wait(0);
    }
} 
else {
    // 这个的左右上面介绍了
    while (isAlive()) {
        // 求时间差
        //    millis是传入的时间，now是当前时间与刚开始挂起的时间差
        long delay = millis - now;
        // 如果时间差大0，说明唤醒的时间-挂起的时间 < 设置的时间
        //    证明是 notifyAll 唤醒的，然后往后执行，继续挂起
        // 如果小于等于0，说明唤醒的时间-挂起的时间 >= 设置的时间，说明时间到了，不再挂起
        if (delay <= 0) {
            break;
        }
        wait(delay);
        // 得到唤醒的时间-挂起的时间，然后就会回到上面执行，进行判断
        //    因为，走到这一步说明刚被唤醒，还在 whild 中
        //    如果whild的条件满足，就进行时间判断
        //    如果条件不满足说明另一个线程已经执行完了
        //    当前线程也就不再进行挂起（不执行上面的代码，唤醒后就不再被挂起）
        now = System.currentTimeMillis() - base;
    }
}
```




#### 线程-线程锁的概念
- 作用：保护数据的安全性（因为安全锁，会锁住一个对象）
- 工作原理
  - 当某个线程执行某个对象中，带有安全锁的方法时，该线程就会锁住该对象
    - 直到该线程执行完安全锁中的代码，该对象才会被释放
  - 当某个对象被锁住的时候，其他线程就无法调用该对象中带有安全锁的代码
    - 注意：只是不能调用带有安全锁的代码，其他没有带有安全锁的代码，是可以正常执行的
    - **即：安全锁，锁住的不是一整个对象，而是该对象中带有安全锁的所有方法，普通的方法没有影响**
- 对线程切换的影响
  - **对线程切换没有影响**
  - 即：当某个线程锁住某个对象后，时间碎片是正常切换的
    - 并不是该线程执行完带有安全锁的代码后，在进行切换
  - 只不过，当时间碎片切换到某个线程后，该线程开始执行，发现将要执行的代码已经被另一个线程锁住了，于是就会进入等待（时间碎片正常切换）
    - 什么时候正常执行呢：当被锁住的对象释放后，该线程才会继续执行，然后就会又锁住了该对象



#### 线程-线程锁的实现
```java
public class Demo {
    public static void main(String[] arge) {
        A a = new A();
        Thread thread = new Thread(a);
        thread.start();
    }
}


class A implements Runnable  {
    @Override
    public void run() {
        B b = new B();
        b.demo1();
    }
}

class B {
    public synchronized void demo1() {
        System.out.println("demo1");
        this.demo2();
        synchronized (this) {
            System.out.println("局部锁");
        }
    }
    public synchronized void demo2() {
        System.out.println("demo2");
    }

    public void demo3() {
        System.out.println("由于这个没有上锁，所以即使demo1锁住了这个对象，其他线程也是能够调用该方法的");
    }
}
```


#### 线程-当前对象锁住别的对象（容易产生死锁问题）
- 只能借助局部锁，方法锁只能锁住当前对象
- 释放时间，为局部锁执行完成的时间
- 示范代码
```java
synchronized (this.demo) {
  this.demo.C(this.name);
}
```
- 上述代码，可以在任意类中写，作用是执行到这个地方，立马锁住指定的对象（demo）
- 如果当前对象已经被其他线程锁住，则在这个地方陷入等待，直到该对象释放，才会继续执行，然后锁住指定对象
  - 对象锁住后，其他线程就不能再执行该对象中带有安全锁的代码
  


#### 线程-线程锁的缺点
- 安全锁的使用，会出现一种死锁的现象，但是这种现象很难发生，具体看后面的介绍




#### 线程-线程的死锁
- 就是由于 `synchronized` 使用不当造成的
  - 使用局部锁，同时操作两个对象
  - 比如：线程1锁住了A，要想操作B。如果线程2刚好锁住了B，想要操作A，就产生了死锁的问题
    - 线程切换到1，一看B锁住了，就陷入等待
    - 线程切换到2，一看A锁住了，就陷入等待
    - 两个都进行等待过程，就造成了A、B永远不会解锁（执行不完，无法解锁），这样就陷入了永远的等待过程（两个线程永远结束不了）

- 示范代码
```java
// 线程类
public class Zhe extends Thread {
    // 两个共同的对象
    private A a;
    private B b;

    public Zhe() {};
    public Zhe(A a, B b) {
        this.a = a;
        this.b = b;
    };

    // 线程的入口函数
    public void run() {
        // 看看a有没有锁住，锁住等待，没有锁住执行，锁住a
        synchronized (this.a) {
            System.out.println("锁住A");
            // 如果另一个线程操作A，锁住了B，则下面的代码进入等待过程，另一个线程也进入等待过程，就产生了死锁现象

            // 看看b有没有锁住，锁住等待，没有锁住执行，锁住b
            synchronized (this.b) {
                System.out.println("锁住B");
            }
            // 执行完，释放b
        }
        // 执行完释放a
    }
}

```


#### 线程-死锁的解决方式
1. 产生时间差，避免同时拿到一个对象的操作权限，另一个却抢不到了，有了时间差，就可以给其他线程得到对象的操作权限，然后释放
2. 不操作同一个对象，就没有锁定的效果




#### 反射-反射机制的介绍
- 可以通过反射操作类和对象
- 反射一共有六个大类
  - `Class` -------- 用来描述类本身
  - `Package` -------- 用来描述类所属的包
  - `Field` -------- 用来描述类中的属性(共有的私有的都可能获取到，并且进行修改)
  - `Method` -------- 用来描述类中的方法
  - `Constructor` -------- 用来描述类中的构造方法
  - `Annotation` -------- 用来描述类中的注解





#### 反射-通过反射修改字符串
- 字符串底层是存在一个私有字符数组中，正常情况下无法获取这个数组，但是可以通过反射获取，然后修改数组，从而影响字符串
- 比如
  ```java
  public static void main(String[] arge) throws NoSuchFieldException, IllegalAccessException {
    String str = "abc";
    å// 通过反射获取私有属性value
    Class s = str.getClass();
    Field v = s.getDeclaredField("value");
    // 这个设置成 true，才能获取到私有属性
    v.setAccessible(true);

    // 获取集合 str 中的 value属性
    char[] value = (char[])v.get(str);
    // 修改
    value[1] = 'x';
    // 字符串发生了变化，打印 axc
    System.out.println( str );

    // 重新赋一个char集合
    v.set(str, new char[]{'重', '新'});
    // 字符串发生了变化，打印 重新
    System.out.println( str );
  }
  ```

#### 反射-通过反射机制获取类(Class)
- 通过反射，获取类，一共有三种方法
  ```java
  public static void main(String[] str) throws Exception {
    // 通过反射获取类_方式一
    Class clazz_1 = Class.forName("Ceshi");
    // 通过反射获取类_方式二
    Class clazz_2 = Ceshi.class;
    // 通过反射获取类_方式三
    Class clazz_3 = new Ceshi().getClass();

    System.out.println(clazz_1);
    System.out.println(clazz_2);
    System.out.println(clazz_3);
  }
  ```

.
- 三种方式的区别
  - Class.forName("包名.类名")
    - 会加载类中的静态元素
    - 可以使用该方法初始化一个类(加载静态元素，以便使用)，比如`Driver`
  - 类名.class
    - 不会加载类中的静态元素
  - 对象.getClass()
    - 这是Object上的一个方法

.
- Class中的常用方法
  - `int result = clazz.getModifiers();` 获取类的修饰符(权限 特征)
    - 每一个修饰符 用一个整数来进行表示
    - 0开始---0、1、2、4、8、16、32、64、128、256、512
      - 0--默认不写、1--public、2--private、4--protected
      - 8--static、16--final、32--synchronized、64--volatile
      - 128--transient、256--native、512--interface、1024--abstract
  - `String name = clazz.getName();`获取名字
  - `String simpleName = clazz.getSimpleName();`简单名
  - `Object obj = clazz.newInstance();`  默认调用无参数构造方法创建对象
  - `Class sclazz = clazz.getSuperClass(); `  获取超类(父类)
  - `Class[] classes = clazz.getInterface();` 获取接口



#### 反射-获取类所属包的信息(Package)
- 示范代码
  ```java
  public static void main(String[] str) throws Exception {
    // 首先获取Class
    Class clazz = Student.class;
    // 获取包名  domain.Student 
    String name = clazz.getName();

    System.out.println(name);
  }
  ```







#### 反射-通过反射操作类中的属性(Field)
- 公有属性，私有属性，父类公有属性都能获取到，但是调用的方法不同
  - 也包括静态属性
- 父类的私有属性是获取不到的
- 流程是先获取到类中有哪些属性，然后从这个类创建的对象中，获取该属性对应的值
  - 属性值是属于对象的，所以要借助一个对象
  - 而属性是属于类的
- 示范代码
  ```java
  import java.lang.reflect.Field;
  class Fuji {
    private String siyou = "父级_私有";
    public String gongyou = "父级_公有";
    public static String jingtai = "父级_静态";
  }
  class Ceshi extends Fuji {
    private String siyou_f = "子级_私有";
    public String gongyou_f = "子级_公有";
    public static String jingtai_f = "子级_静态";
  }

  public class Demo {
    public static void main(String[] arge) throws InstantiationException, IllegalAccessException {
      // 首先获取Class
      Class clazz = Ceshi.class;

      // 获取公有和父级公有属性
      Field[] fs = clazz.getFields();
      // 创建一个对象，便于获取数据
      //    clazz.getFields只能获取到所有的属性标记，要想获取具体的数据，首先要有一个对象，然后从这个对象中获取
      Ceshi ceshi = (Ceshi) clazz.newInstance();
      // 便利所有属性
      for(Field field : fs) {
        // 获取属性名
        System.out.println(field.getName());
        // 使用get方法，获取属性值
        System.out.println(field.get( ceshi ));
      }
      // 可以通过 Field f = clazz.getField("属性名"); 获取某个具体的属性


      // 获取自己的公有属性，和私有属性。继承类是获取不到的
      Field[] fx = clazz.getDeclaredFields();
      // 便利所有属性
      for(Field field : fx) {
        // 获取属性名
        System.out.println(field.getName());

        // 由于涉及到了私有属性值的获取，所以需要设置
        field.setAccessible(true);
        // 使用get方法获取属性值
        System.out.println(field.get( ceshi ));
      }
      // 可以通过 Field f = clazz.cgetDeclaredField("属性名"); 获取某个具体的属性
    }
  } 
  ```

.   
- Field类中的常用方法
  - `int a = f.getModifers()`：获取属性的修饰符
  - `Class a = f.getType()`：获取属性对应的类映射(Class)
    - 该方法，通常与 `.getSimpleName`连用，获取属性的类型
  - `String a = f.getName()`：获取属性名 
    - 获取到名字后，可以通过反射的方式，使用字符串拼接的方式，获取到对应的 `getXXX` 或者 `setXXX`方法，操作对应的属性
  - `f.set(该类创建的对象, 值)`：对属性进行重新赋值
  - `Object a = f.get(该类创建的对象)`：取某个属性的值，如果想要使用，需要进行造型
    - 如果想要通过set或者get操作私有属性，需要先设置 `f.setAccessable(true);`，否则会报错 
    - 可以通过它，修改字符串某一位的值，原理上是不可以的，属性是私有的，没有提供操作他的方法

.
- 获取对应属性的属性值(有两种方式)
  - 一种是通过 f.getName() 获取属性名
    - 然后使用字符串分析的方法，找到对应的 get 或者 set方法，进行执行，需要借助该类创建的对象(通过反射创建)
  - 一种是，通过 f.get() 或者 f.set() 操作属性。需要借助对象(通过反射创建)






#### 反射-通过反射获取类中的普通方法(Method)
- 方法的执行，也是依靠某个对象，所以不光要通过反射获取方法信息，还要利用反射创建出一个对象
  - 由于方法的执行，是依靠于对象，所以是可以使用对象中的属性与方法的。
  - 比如，依靠demo对象执行方法，就相当于 demo.fun(); 
- 公有方法，私有方法，父类公有方法都能获取到，但是调用的方法不同
  - 也包括静态方法
- 父类的私有方法是获取不到的

.
- 运行获取的方法
  - Object result = m.invoke(对象, 传递的参数);
    - 传入的对象，表示方法运行的时候，this指向那个对象
    - 如果传入的对象，没有即将运行的方法，也不会报错，只不过没有效果


.
- 测试代码
  ```js
  import java.lang.reflect.InvocationTargetException;
  import java.lang.reflect.Method;

  class Fuji {
      private String str = "张三";
      private void siyou_f() {
          System.out.println("父级的私有方法");
      }
      public void gongyou_f() {
          System.out.println("父集的公有方法");
          // 由于方法的执行，是依靠于对象，所以是可以使用对象中的属性与方法的
          System.out.println(this.str);
      }
      public static void jingtai_f() {
          System.out.println("父集的静态方法");
      }
  }

  class Ceshi extends Fuji {
      private void siyou() {
          System.out.println("子集的私有方法");
      }
      public void gongyou() {
          System.out.println("子集的公有方法");
      }
      public static void jingtai() {
          System.out.println("子集的静态方法");
      }
  }


  public class Demo {
      public static void main(String[] arge) throws InstantiationException, IllegalAccessException, InvocationTargetException {
          // 首先获取Class
          Class clazz = Ceshi.class;
          // 创建一个对象，便于执行对应的方法
          Ceshi ceshi = (Ceshi) clazz.newInstance();


          // 获取公有和父级公有方法，私有的获取不到（这种方式可以获取到Object上的方法）
          Method[] fs = clazz.getMethods();
          // 遍历
          for(Method method : fs) {
              // 执行对应的方法
              //    这种方式可以获取到Object上的方法，执行的时候需要进行判断，不执行Object上的方法
              if(method.getDeclaringClass().getName() == "java.lang.Object") continue;
              // 执行，依靠于对象进行执行
              method.invoke(ceshi);
          }
          // 获取某个具体的方法
          // 可以通过 Method f = clazz.getMethod("方法名", 参数类型.class, 参数类型.class, ···);
          // 因为方法有重载，所以，想要获取具体的一个方法，还需要指定对应的参数类型


          // 获取自己的公有方法，和私有方法。继承类是获取不到的
          Method[] fx = clazz.getDeclaredMethods();
          // 遍历所有方法
          for(Method method : fx) {
              // 如果是私有方法，是不允许调用的，需要进行下面的配置，才可以使用
              method.setAccessible(true);
              // 执行对应方法，依靠于对象进行执行
              method.invoke(ceshi);
          }
          // 获取某个具体的方法
          // 可以通过 Method f = clazz.getDeclaredMethod("方法名", 参数类型.class, 参数类型.class, ···);
          // 因为方法有重载，所以，想要获取具体的一个方法，还需要指定对应的参数类型
      }
  }
  ```

.
- 常用的方法
  - `int mm = m.getModifiers();`：获取方法的修饰符(权限+特征)
  - `Class mrt = m.getReturnType();`：获取返回值数据类型
  - `String mn = m.getName();`：获取方法的名字
  - `Class[] mpts = m.getParameterTypes();`：获取方法参数列表的类型
  - `Class[] mets = m.getExceptionTypes();`：获取方法抛出异常的类型 
  - `Class c = method.getDeclaringClass();`：获取方法所属的类映射 





#### 反射-通过反射获取构造方法(Constructor)
- 公有的构造方法，或者私有的构造方法都能获取，但是继承类是无法获取的
- 这样，就可以通过反射，获取到构造函数，然后创建对象。就不用非得通过new的方式创建对象了

- 获取构造方法的示范代码
  ```java
  import java.lang.reflect.Constructor;

  class Ceshi {
      public Ceshi() {
          System.out.println("无参构造方法");
      }

      private Ceshi(String s1) {
          System.out.println("有参私有构造方法");
      }

      public Ceshi(String s1, Integer i1, int i2) {
          System.out.println("有参公有构造方法");
      }
  }


  public class Demo {
      public static void main(String[] arge) throws NoSuchMethodException {
          // 首先获取Class
          Class clazz = Ceshi.class;

          // 获取所有的构造方法（只能获取公有的）
          Constructor[] cons = clazz.getConstructors();
          for(Constructor constructor : cons) {
              // 打印下名称
              System.out.println(constructor.getName());
          }

          //  获取所有的构造方法（公有的，私有的都能获取）
          Constructor[] conz = clazz.getDeclaredConstructors();
          for(Constructor constructor : conz) {
              // 打印下名称
              System.out.println(constructor.getName());
          }


          // 获取具体的构造方法（根据构造函数的参数类型，进行区分）
          Constructor con1 = clazz.getConstructor();  // 获取公有的无参构造方法
          System.out.println(con1);
          Constructor con2 = clazz.getDeclaredConstructor();  // 获取私有的或者公有的无参构造方法
          System.out.println(con2);
          Constructor con3 = clazz.getConstructor(String.class, Integer.class, int.class);  // 获取公有的有参构造方法（传入对应的数据类型）
          System.out.println(con3);
          Constructor con4 = clazz.getDeclaredConstructor(String.class);  // 获取私有的或者公有的有参构造方法（传入对应的数据类型）
          System.out.println(con4);
      }
  }
  ```


- 使用获取到的构造方法，创建出一个对象
  ```java
  import java.lang.reflect.Constructor;
  import java.lang.reflect.InvocationTargetException;

  class Ceshi {
      public Ceshi() {
          System.out.println("无参构造方法");
      }

      private Ceshi(String s1) {
          System.out.println("有参私有构造方法，参数为：" + s1);
      }

      public Ceshi(String s1, Integer i1, int i2) {
          System.out.println("有参公有构造方法，参数为：" + s1 + "、" + i1 + "、" + i2);
      }

      public void fun() {
          System.out.println("方法执行了");
      }
  }


  public class Demo {
      public static void main(String[] arge) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
          // 首先获取Class
          Class clazz = Ceshi.class;

          // 获取构造函数（私有的）
          Constructor con4 = clazz.getDeclaredConstructor(String.class);
          // 创建对象，由于构造函数是私有的，所以要进行下面的配置
          con4.setAccessible(true);
          // 构造一个对象，传入对应的参数
          Ceshi c1 = (Ceshi)con4.newInstance("张三");
          // 执行对象中的方法，查看是否创建成功
          c1.fun();

          // 获取构造函数（公有的）
          Constructor con3 = clazz.getConstructor(String.class, Integer.class, int.class);
          // 构造一个对象，传入对应的参数
          Ceshi c2 = (Ceshi)con3.newInstance("张三", 4, 5);
          // 执行对象中的方法，查看是否创建成功
          c2.fun();
      }
  }
  ```



- 常用的方法
  - `int mm = con.getModifiers();`：获取方法的修饰符(权限+特征)   
  - `String mn = con.getName();`：获取方法的名字 
  - `Class[] mpts = con.getParameterTypes();`：获取方法参数列表的类型
  - `Class[] mets = con.getExceptionTypes();`：获取方法抛出异常的类型  





