<script src='/笔记/see/index.js'></script>
[toc]


#### Java语言的特点
- 跨平台性   
  - 平台(不同厂商的芯片)    
  - 平台(不同版本的操作系统)
- 面向对象
- 简单性	     
  - 省去了C++多继承，指针等等
- 健壮性
  - 垃圾回收机制   
  - 异常处理机制
- 多线程性	    
  - 并行操作、提高执行性能、要注意线程安全
- 大数据开发


#### 如何让计算机执行java程序
- 安装JDK -》 配置环境变量 -》cmd编译.java文件 -》cmd运行java程序



#### 基本数据类型
- 整数型：  byte、short、int、long
  - 使用long约束数据类型的时候，要注意，在最后加上 L
    - 比如: long d = 2147483648L;
    - 原因就是，这个类型太大，如果我们真的需要那么大的数字  必须在后面加L告知
- 浮点型：  float、double
  - 使用 float 约束数据类型的时候，要注意，在最后加上 F
    - 比如: float e = 3.4F;
  - double 可以直接写成小数，不用加标示 F
    - 加上也不报错
- 字符型：	char
- 布尔型：	boolean 




#### 二进制
- 电脑存储数据，只能存放 0和1，并且是已补码的形式存放数据
  - 正数的补码是它本身（反码、补码就是它本身）
  - 负数的补码是它的反码加1
    - 比如有二进制10000110，第一位是1，代表它是负数。反码就是每一位都取反，为01111001。所以，补码就是01111010（反码加1）
  - 由于加一的存在，所以负数的区间就比正数多一个
    - 比如：Byte的范围就是 -128 ~ 127

  



#### 类型转换
- 精度高的数据，不能转换成精度低的数据，因为会造成数据丢失，所以默认不允许
  - 就是为了防止类型写错，然后进行类型转换，从而造成数据出错
  - 除非强制转换，这样写就说明确实需要进行类型转换

.
- **低位的整数可以自动转换成高位的整数**
  - 高位的整数不能自动转换成低位的整数，可以强制转换
    - 高位的整数，转换成低位的整数，可能会造成数据丢失的问题，所以不能自动完成
  - 比如
  ```java
    int a = 32;
    // 不能自动转换
    // byte b = a;
    // 可以强制转换
    byte b = (byte)a;

    byte c = 32;
    // 可以自动转换
    int d = c;
    System.out.println(d);
  ```

.
- **低位的浮点型（小数）可以自动转换成高位的浮点型（小数）**
  - 高位的浮点型（小数）不能自动转换成低位的浮点型（小数），可以强制转换
    - 高位的浮点型（小数），转换成低位的浮点型（小数），可能会造成数据丢失的问题，所以不能自动完成
  - 比如
  ```java
    float a = 34.2F;
    // 地位可以自动转成高位
    double b = a;

    double c = 3.45;
    // 不能自动转换
    // float d = c;
    // 需要强制转换
    float d = (float)c;
  ```

.
- **所有类型的整数，能自动转换成小数**
  - 小数不能转换成整数，可以进行强制转换
  - 比如
  ```java
    float a = 34.2F;
    // 小数转整数，只能强制转换
    int b = (int)a;

    // 低位的能转换成对应的小数
    int c = 3;
    float d = c;

    // 即使是高位的也能自动转换成功
    long e = 3L;
    float f = e;
    double g = e;
  ```

.
- **char类型的数据，可以自动转换成整数和小数**
  - 如果写的是一个英文字符，是可以自动转换成 `byte` 的
  - 如果写的是一个中文的字符
    - 由于中文的字符是两个字节
    - 如果转换成 `byte` 类型的数据，就有可能发生数据丢失的问题。
    - 所以为了避免，无意中丢失数据，中文字符是不能自动转化成 `byte` 类型的数据的，必须强制转化
  - `int` 和 `float` 都是32 位的，装字符绰绰有余，所以可以自动转换
  - **整数转换成 char类型的数据**
    - short 范围的整数可以自动转换
    - int 范围的的数据，必须强制类型转换
    - 超过int 范围的数据，即使强制转换也不行
  - **小数数和转换成 char类型的数据**
   - 必须强制类型转换
   - char的编码就是一个整数，相当于从高精度转换成低精度（小数转整数）
   - 并且只能float 范围的数据可以转换



#### 数组的使用
- 定义数组
  ```java
  // 开辟一个长度为 3 的数组
  int[] a = new int[3];
  System.out.println(a);

  // 开辟一个长度为 3 的数组，并赋值
  int[] b = {1, 3, 7};
  int[] c = new int[]{1, 3, 7};
  System.out.println(b);

  // 传参传入一个数组，只能这样写，不能写 {3, 2}
  //   如果这样写，就单独定义，然后传入一个索引
  B.demo(new int[]{3, 2});
  ```


#### 数组上常用的工具方法
- 所有的工具方法，必须通过Arrays调用，把要操作的数组，作为参数传进去

#### 数组方法—排序
```java
public static void main(String[] arge) {
  int[] arrs = {3, 6, 8, 9, 3, 3, 7};
  // 排序
  Arrays.sort(arrs);
  // 查看效果
  System.out.println(Arrays.toString(arrs));
}
```


#### 包装类—介绍
- 作用，把一个常量包装成一个对象，使其可以调用一些方法
- 包装类(封装类)，诞生于1.5版本之后，可以实现自动拆装包(自动包装，自动去包装)

.
- 包装类一共有八个，分别对应八个基本数据类型
   1. byte---`Byte` 
   2. short---`Short`   
   3. int---`Integer`  
   4. long---`Long`
   5. float---`Float`  
   6. double---`Double`  
   7. char---`Character`   
   8. boolean---`Boolean`

.
- 包装类的位置
	- 八个包装类都在同一个包下，java.lang包，Java.lang是不需要import导包的，可以直接使用

.
- 八个包装类的大体特性
  - 八个包装类中有六个是与数字相关的，所以都默认继承父类`Number`
    - `Number`类中有几个方法，`xxxValue()`
    - 这几个函数的作用，将一个包装类类型转化为对应的基本类型(拆包，还原回来)，前面的`xxx`是对应包装类对应的数据类型
  - 八个包装类都实现了`Serializable`, `Comparable`
  - 八个包装类都有带自己对应类型参数的构造方法
	  - 八个包装类中有七个(除了Character)还有构造方法重载，可以接受String类型的数据
    - 默认的构造方法，传入对应的数据类型


#### 包装类—使用
- **对一个常量手动包装**
  ```java
  Integer i1 = new Integer(10);
  // 调用第二个构造方法，传入一个字符串，char的包装类是没有这个功能的
  Integer i2 = new Integer(“10”);
  // 调用第二个构造方法，传入一个字符串，char的包装类是没有这个功能的
  Integer f1 = new Float(“10.011”);

  // 拆包，intValue就是Number类中的一个方法
  int value = i1.intValue();
  ```

.
- **对一个常量自动包装**
  ```java
  // 写成这种格式，数据类型为对应包装类的名称，就可以对一个数据完成自动包装
  Integer i2 = 10;
  ```

.
- **自动拆包**
```java
// 把一个包装类对象，用对应的常量接受，就会自动调用对应的xxxValue方法，进行拆包
//     此处，自动调用的是intValue方法，进行拆包
int value = new Integer(10);
```


#### 包装类—字符串转换成数字
- 字符串直接转成int或者float类型的基本数据类型，有两种方式
  - 利用包装类的第二个构造函数，然后自动拆包
  - 利用包装类提供的一个静态方法，`parseInt` 或者 `parseFloat`
  - 比如
    ```java
    int v = new Integer("123");
    int value = Integer.parseInt("123");	
    float f = Float.parseFloat("123.45");
    ```


#### 包装类—自动包装的缓存问题
- 为了提高效率，这八种包装类，在创建的时候，会创建一个静态的数组
  - 数组的每一项，是一个数据对应的包装类
- 这样的话，在自动包装的时候，就会先去这个静态数组中，查看有没有对应的包装类对象，如果有就直接取出使用，如果没有就是重新 new 一个
- 由于某些数据类型的数据量非常大，所以不可能每个数据都创建一遍，只会创建一部分
  - 比如 `int` 类型的，只有`-128～127`之间，会创建出对应的包装类集合 
    - 也就是一个byte类型的数据大小

- 这样就造成了一种现象（相等和不相等问题）
  - 比如
    ```java
    public static void main(String[] arge) {
      // 类型不一样，所以会自动进行包装
      Integer i1 = 10;
      Integer i2 = 10;
      // 由于范围在-128～127之间，所以两个取得都是缓存，所以两个相等
      System.out.println(i1 == i2); // true

      // 类型不一样，所以会自动进行包装
      Integer i3 = 200;
      Integer i4 = 200;
      // 由于范围不在-128～127之间，所以缓存中就没有，所以两个都会重新 new 一个出来
      //    只要经过 new 创建出的集合，都是新的，所以两个不相等
      System.out.println(i3 == i4); // false
    }
    ```
    


#### 包装类— equals 方法
- Object中有一个`equals`方法，Object中的方法，比较的是 `this == 参数`
- 包装类也是一个类，所以默认继承Object类，但是，包装类中的`equals`方法，进行了重写
  - 重写后，比较的是 `this.xxxValue() == (包装类)参数.xxxValue()`
    - 比较的是字面量，而不是集合本身
  - `(包装类)参数`，先进行强制类型转换，转换成包装类，因为只有包装类有`xxxValue`方法
    - 目的就是为了防止，传入基本数据类型，直接使用`xxxValue`方法报错
- 具体的示范代码
  ```java
  public static void main(String[] arge) {
    Integer i1 = 10;
		Integer i2 = new Integer(10);
    // equals 方法进行了重写，比较的是字面量，也就是 10 == 10，所以比较结果是 true
    System.out.println(i1.equals(i2)); // true


    Integer i3 = 200;
    Integer i4 = 200;
    // 直接比较，比较的是包装类集合本身（地址索引）
    //    由于超过了区间，所以缓存中没有，需要重新new，所以比较结果是false
    System.out.println(i3 == i4); // false
    // equals 方法进行了重写，比较的是字面量，也就是 200 == 200，所以比较结果是 true
    System.out.println(i3.equals(i4)); // true


    Integer i5 = new Integer(10);
		Integer i6 = new Integer(10);
    // equals 方法进行了重写，比较的是字面量，也就是 10 == 10，所以比较结果是 true
    System.out.println(i5.equals(i6)); // true

    // 如果没有重写，比较的就是 this == 参数，也就相当于比较的是集合本身，即：i3 == i4
  }
  ```



#### 注解—自定义注解

> 通过 `public @interface MyAnnotation {}` 创建一个注解
>> 1. `MyAnnotation` 就是注解名
>> 2. 注解使用时，通过 `@MyAnnotation`


> 注解是可以存放数据的
>> 要想存放数据，需要定义对应的接口方法
>>> 1. 有点类似get方法，方法名对应属性名，方法返回类型，对应属性类型
>>> 2. 然后，注解在使用的时候，就可以写成类似函数调用的方式，然后传入对应的属性值（注解中定义好的），必须传入
>>> 3. 这样的话就可以存储一些数据
>>> 4. **定义的方法，可以通过反射获取到，然后执行，得到对应的存储的数据**
>>> 5. **需要注意的是，要想获取注解存放的数据，元注解必须使用，否则是获取不到的**

> 比如，定义一个如下的注解
```java
public @interface Zhu {
    public abstract String value();
    public abstract String[] name();
    public abstract String age();
    
    // abstract可以省略，但是通常这么写
}
```

> 自定义注解的使用方式
```java
@Zhu(name = {"张三"}, age = "10", value = "ceshi")
public void a() {}
```


> 注解中，还可以定义常量，但是很少使用
>> 因为定义了就不能修改了，而注解就是给某个类存放一些动态的数据，向这些固定值，通常都直接写死在类中
>> 通过，`public static final 类型 属性名 = 固定值;`，在注解中定义一个固定值
>>> 固定值，是可以定义成其他类型的，不一定非得是字符串



#### 注解—元注解介绍
- 元注解是注解使用的注解，可以限制注解使用的范围
> 元注解，可以不使用
> 元注解，一共有四个
>> 1. `@Target`：描述当前的这个注解可以放置在哪里写的（限制使用范围）
>>> 1. @Target(ElementType.TYPE)：接口、类、枚举、注解
>>> 2. @Target(ElementType.FIELD)：字段、枚举的常量
>>> 3. @Target(ElementType.METHOD)：方法
>>> 4. @Target(ElementType.PARAMETER)：方法参数
>>> 5. @Target(ElementType.CONSTRUCTOR)：构造函数
>>> 6. @Target(ElementType.LOCAL_VARIABLE)：局部变量
>>> 7. @Target(ElementType.ANNOTATION_TYPE)：注解
>>> 8. @Target(ElementType.PACKAGE)：包   

>> 2. `@Retention`：描述当前的这个注解存在什么作用域中的
>>> 1. 源代码文件(`SOURCE`)--->编译--->字节码文件(`CLASS`)--->加载--->内存执行(`RUNTIME`)    
>> 3. `@Inherited`：描述当前这个注解是否能被子类对象继承
>> 4. `@Document`：描述这个注解是否能被文档所记录

> 示范代码

```java
import java.lang.annotation.*;

@Target({ElementType.CONSTRUCTOR,ElementType.METHOD,ElementType.FIELD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    public abstract String[] value();
    public abstract String c(); 
}
```



#### 注解—使用反射获取注解
> 注解，要不顶在类的上面，要不顶在方法的上面，要不顶在属性的上面
> 这样，就形成了一种对应关系
> 所以，只要找到对应的类、方法、属性，就可以找到对应的注解
> 而类、方法、属性，需要通过注解找到

> 先自定义一个注解
```java
// 要想通过反射的方式，获取注解，元注解是必须要设置上的
@Target({ElementType.CONSTRUCTOR,ElementType.METHOD,ElementType.FIELD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface Zhu {
    public abstract String value();
    public abstract String[] name();
    public abstract String age();
    public static final Integer a = 1;
}
```

> 使用注解的类
```java
@Zhu(name = {"张三"}, age = "10", value = "ceshi")
public class Ceshi {
    @Zhu(name = {"张三"}, age = "10", value = "构造")
    public Ceshi() {}
}
```


> 使用反射，获取注解
```java
public static void main(String[] str) throws Exception {
   // 通过反射获取类
   Class clazz = Class.forName("Ceshi");
   // 获取类上面的注解
   Annotation a = clazz.getAnnotation(Zhu.class);
   // 获取注解类
   Class cla = a.getClass();
   // 获取注解中，对应的方法
   Method method = cla.getMethod("value");
   // 执行方法，获取注解存放的数据
   String values = (String)method.invoke(a);
   System.out.println(values);

   // 其他地方的注解，也是一样，先获取对应的属性、方法。
   //    然后在使用 getAnnotation 获取注解，后续步骤就一样了，获取注解中对应的方法，执行方法

   // 比如：获取构造函数上的方法
   // 首先获取到构造函数
   Constructor con = clazz.getConstructor();
   // 然后获取上面的注解
   Annotation b = con.getAnnotation(Zhu.class);
   // 获取注解类
   Class clas = b.getClass();
   // 获取注解中，对应的方法
   Method methods = clas.getMethod("value");
   // 执行方法，获取注解存放的数据
   String value = (String)methods.invoke(b);
   System.out.println(value);
}
```






#### 线程-线程的概念
- 程序，可以理解为是一组静态的代码
- 进程，正在进行的程序、静态的代码，运行起来
- 线程，正在执行程序中的小单元

- 服务器就是利用线程思想做的
  - 当请求来临后，就创建一个线程对象，传入请求报文进行解析
  - 然后，使用start，让处理请求的run方法，进入执行的准备状态，准备执行



#### 线程-定义与使用（方式一）
- 通过继承Thread类，然后重写run方法实现
```java
// 类一
public class CeshiOne extends Thread {
    private String name;
    public CeshiOne(String name) {
        this.name = name;
    }

    @Override
    // 重写线程方法
    public void run() {
        for(int i = 0; i < 1000; i ++) {
            System.out.println(this.name + "：" + i);
        }
    }
}

// 主函数（让线程进入准备阶段）
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建一个线程对象
        CeshiOne x1 = new CeshiOne("线程一");
        // 构建一个线程对象（一个类可以起多个线程，他们之间互补干扰）
        CeshiOne x2 = new CeshiOne("线程二");
        // 构建一个线程对象
        CeshiTwo x3 = new CeshiTwo("线程三");

        // 线程进入准备状态
        //    也就是 对象中的run进行执行前的准备状态
        //    当拿到时间碎片后，就开始执行
        x1.start();
        x2.start();
        x3.start();
    }
}
```


#### 线程-定义与使用（方式二）
- 通过实现Runnable接口，然后重写run方法实现
```java
// 类一
public class CeshiOne implements Runnable {
    private String name;
    public CeshiOne(String name) {
        this.name = name;
    }

    // 重写线程方法
    public void run() {
        for(int i = 0; i < 1000; i ++) {
            System.out.println(this.name + "：" + i);
        }
    }
}


// 主函数（让线程进入准备阶段）
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建对象
        CeshiOne o1 = new CeshiOne("线程一");
        CeshiOne o2 = new CeshiOne("线程二");
        CeshiTwo o3 = new CeshiTwo("线程三");

        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        // 构建一个线程对象（）
        Thread x2 = new Thread(o2);
        // 构建一个线程对象
        Thread x3 = new Thread(o3);

        // 线程进入准备状态
        //    也就是 对象中的run进行执行前的准备状态
        //    当拿到时间碎片后，就开始执行
        x1.start();
        x2.start();
        x3.start();
    }
}
```


#### 线程-线程的执行原理
- 无论是方式一还是方式二，run方法是核心（相当于入口函数）

.
- 线程是操作系统级别的，我们控制不了，受电脑的cpu进行控制
  - 当线程准备好后，就等着时间碎片的来临
  - 当某个线程拿到时间碎片后，重写的run方法就开始执行（线程程序启动）
    - 所以run方法的执行是cpu控制的
  - 当线程执行一段时间后，时间碎片就会切换到其他线程，当前线程就失去了时间碎片，于是停止执行
  - 当另一个线程拿到时间碎片后，开始执行
    - **需要注意安全锁的问题，如果线程操作的代码被锁住，则陷入等待（等待时间碎片切换走）**
    - 安全锁可以保证数据的安全与准确性
  - cpu的时间碎片，随机分配，时间长短不定（所以线程的执行是随机的）
  - 当某个线程重新拿到时间碎片后，会继续往下执行
  - **如果一个线程被挂起，则时间碎片就不会分配到该线程**
    - 只有挂起的线程被唤醒，才进入等待过程（等待时间碎片的分配）
    - 拿到时间碎片后，进行执行，并且从上次停止的地方继续执行


#### 线程-线程沉睡
- 利用 Thread.sleep 方法，可以让某个线程沉睡一段时间
  - 沉睡，就是自动挂起一段时间（这段时间内时间碎片不会分配给该线程，也就是线程暂停执行），时间到了沉睡的线程会自动唤醒
  - 线程沉睡后，会立刻停止执行，当唤醒后，就会等待时间碎片的来临。当拿到时间碎片后，才会继续往后执行
- 使用的时候，必须处理错误
- 该方法传入一个时间，相当于沉睡的时间


- 使用示范代码
```java
// 带有线程沉睡的类
public class CeshiOne implements Runnable {
    
    // 重写线程方法
    public void run() {
        for(int i = 0; i < 1000; i ++) {
            // 让线程沉睡一段时间
            if(i == 500) {
                // 需要处理错误，可能一睡不醒
                try {
                    // 在这个地方，立马就进行了沉睡，不再往后执行
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(this.name + "：" + i);
        }
    }
}


// 开启线程
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建对象
        CeshiOne o1 = new CeshiOne("线程一");
        // 创建一个线程
        Thread x1 = new Thread(o1);
        // 线程启动
        x1.start();
    }
}
```




#### 线程-线程挂起
- 借助 wait 方法，进行线程的挂起（有两种使用方式）
  - 不传递参数，或者传递0，只能手动唤醒
  - 传递数字，表示多少秒后，自动唤醒

- wait 必须放在 synchronized 中进行线程的挂起（否则会报错）

- 比如：
  ```java
    class A {
        public synchronized void b() throws InterruptedException {
            // 线程的挂起
            this.wait(0);
        }
    }
  ```

- 如果，某个线程，正在操作某个对象，并且带有安全锁，此时这个对象就被锁住
  - 如果此时，线程被挂起，则锁住的对象立即释放
  - 如果线程被唤醒，继续从上次挂起的位置往后执行（还是安全锁中，因为是在安全锁的函数中挂起的），此时对象还是会被锁住的


#### 线程-挂起线程的唤醒
- 必须放在 synchronized 中进行线程的唤醒（否则会报错）
- 借助两个方法，都可以实现线程的唤醒
  - notify（随机唤醒一个线程，无法控制）
  - notifyAll（唤醒当前对象挂起的所有线程）
- 线程释放后，也不是立即执行，也是等着时间碎片的分配，才能执行
- 比如：
  ```java
    class A {
        public synchronized void b() throws InterruptedException {
            // 线程的唤醒
            this.notifyAll();
        }
    }


#### 线程-线程挂起和唤醒配合使用的限制一(同一对象)
- 线程的挂起和唤醒只能在同一个对象中进行
- 挂起和唤醒和对象挂钩，某个对象挂起的线程，只能由该对象进行唤醒（该对象无法唤醒其他对象挂起的线程）
  - 比如 A 对象挂起了 a线程。则 a线程必须由 A对象 进行释放

- 比如
```java
public class Demo {
    public static void main(String[] str) throws Exception {
        // 创建一个对象，用来线程的挂起和释放
        Gong gong = new Gong();
        // 两个线程都传入 共同的对象
        //    因为对象挂起的线程，只能通过该对象释放，并且一个线程挂起只能用另一个线程释放
        //    或者自动释放
        // 比如：线程1 被 gong 对象挂起，则只能通过 gong对象释放，并且只能借助另一个线程释放
        //    所以，线程2也要传入 gong 对象，这样才能唤醒 线程1
        CeshiTwo o1 = new CeshiTwo("线程一", gong);
        CeshiOne o2 = new CeshiOne("线程二", gong);
        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        Thread x2 = new Thread(o2);
        // 线程启动
        x1.start();
        x2.start();


        // 线程的挂起和释放不用同一个对象
        //    这样，线程1挂起，线程2是无法唤醒线程1的
        //    因为：线程的挂起和唤醒，用的不是同一个对象
        //    这样就会造成，线程1挂起后，就无法唤醒了
        CeshiTwo o1 = new CeshiTwo("线程一", new Gong());
        CeshiOne o2 = new CeshiOne("线程二", new Gong());
        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        Thread x2 = new Thread(o2);
        // 线程启动
        x1.start();
        x2.start();
    }
}
```



#### 线程-线程挂起和唤醒配合使用的限制二(线程锁)
- 线程的挂起和唤醒必须在安全锁函数中进行实现
- 如果调用的方法，没有添加安全锁，则在使用的过程中，就会报出 IllegalMonitorStateException 的错误
  - 比如
  ```java
    class A {
        // 调用 b 方法，由于没有添加 synchronized 所以在执行的时候就会报错
        public void b() throws InterruptedException {
            this.wait(0);
        }
    }
  ```

- 线程必须在安全锁中进行挂起和唤醒的原因（避免一个线程永远的被挂起）
  - 由于线程挂起后，就不在进行工作，所以挂起的线程要想唤醒，必须在另一个线程中进行
  - 所以线程的挂起和唤醒，是多个线程配合使用的
    - 当某个线程挂起后，另一个线程满足条件后，在把这个线程唤醒
  - 而线程的切换，我们是控制不了的
    - 假设，一个线程将要被挂起，但是还没有挂起，如果这个时候线程切换到了另外一个，而这时如果满足了唤醒的条件，就会唤醒线程（但是线程并没有挂起）。
    - 当线程切回挂起的代码后，线程才被挂起（但是此时唤醒的代码已经执行完了，所以这个线程就有可能永远的被挂起）
  - 加了 synchronized，就会变得不一样
    - 由于挂起和唤醒必须在同一个对象中（即同一个类中）
    - 当执行到挂起的代码后（还没有挂起），线程切换走了，如果此时满足了唤醒的条件，执行到唤醒代码，由于这个对象已经被挂起锁住了，所以唤醒代码就会陷入等待
    - 直到挂起代码执行完成，线程被挂起，对象才会被释放
    - 然后唤醒代码才会继续执行（而此时线程已经被挂起了），所以正常唤醒
    - **先挂起后唤醒，这样就避免了线程永远被挂起的问题**
      - 如果先唤醒后挂起（也会造成线程永远被挂起），但这就是代码设计的问题了
.
- 根据以上原因，java为了防止某个线程一挂不起，所以强制要求线程的挂起和唤醒必须放在 synchronized 中执行，否则就会报错






#### 线程-假死状态
- 线程的挂起，可能造成假死的状态
  - 即某个线程挂起，但是却没有被释放，最后程序就会陷入等待阶段，一直等下去







#### 线程-设置线程的优先级
- 优先级高的可能能更快的获取到时间碎片进行执行（只是可能，提高了一些概率，并不是一定）
- 借助 setPriority 方法实现
  - 如果两个线程同时被唤醒，但是想要某个线程优先执行(比较重要)，即优先获取资源，就可以使用该方法
- 在创建线程的时候，就设置好

- 示范代码
```java
public class Demo {
    public static void main(String[] args) {
        Ceshi ceshi = new Ceshi();
        // 创建线程对象
        Thread thread = new Thread(ceshi);
        // 在创建线程的时候，就进行设置
        thread.setPriority(5);

        // 启动线程
        ta.start();
    }
}
```




#### 线程-join方法的作用
- join的作用，就是挂起当前的线程
  - 底层也是用 wait 实现的线程挂起
- **线程的挂起，只能通过另一个线程对象，挂起当前线程**
  - 因为 join 方法，是线程对象上的一个方法，所以只能线程对象使用，但是当前线程肯定不能挂起当前线程，所以只能通过别的线程挂起当前线程
  - 比如 A 线程想要通过join挂起
    - 在 A 线程中，运行另一个线程的join方法，就会挂起当前A线程

.
- 使用方式
  - 不传递参数或者传递0
    - 功能：当前线程执行完毕后，会自动唤醒该线程挂起的线程
    - 比如：有两个线程 A 和 B
      - A 线程想要通过 join 挂起，只能使用 B.join()，这样 A 线程就会被挂起，这样就会切换到 B 线程执行
      - 只有当 B 线程执行结束，A线程才会被唤醒
  - 如果传递具体的数据，则时间过后，被挂起的线程会自动唤醒（单位ms）

.
- **注意点**
  - join挂起的线程，是无法通过 notifyAll 进行唤醒的（只能自动唤醒，定时唤醒）（底层代码决定的）
    - 使用 notifyAll 唤醒线程后，当时间碎片切换到这个唤醒的线程后，开始执行，然后就会立刻挂起
    - 所以，无法通过 notifyAll 唤醒 join 挂起的线程


.
示范代码

```java
// 线程一的类（使用join，挂起当前线程）
public class CeshiOne implements Runnable {
    private String name;
    // 保存一个线程，使用它的join方法（因为 join 只能通过另一个线程对象，挂起当前线程）
    private Thread ceshiTwo;


    // 重写线程方法
    public void run() {
        System.out.println("使用线程二，挂起当前线程");
        try {
            // 当线程二结束的时候，会自动释放
            ceshiTwo.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("释放了");
    }

    // 保存线程2的对象，用他来挂起当前线程
    public void setCeshiTwo(Thread ceshiTwo) {
        this.ceshiTwo = ceshiTwo;
    }
}

// 创建线程
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建对象
        CeshiOne o1 = new CeshiOne("线程一");
        CeshiTwo o2 = new CeshiTwo("线程二");

        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        Thread x2 = new Thread(o2);
        // 传入对应的线程对象（用来挂起线程）
        o1.setCeshiTwo(x2);

        // 线程进入准备状态
        x1.start();
        x2.start();
    }
}
```

#### 线程-借助join实现单线程效果
- 原理
  - A线程中创建B线程，然后马上利用B线程挂起
  - B线程中创建C线程，然后马上利用C线程挂起
  - 这样 A线程 和 B线程就会立即停止，然后C执行
    - 由于 B 线程是 C挂起的，所以C执行完，B就开始执行
    - 由于 A 线程是 B挂起的，所以B执行完，A就开始执行
    - 这样，执行顺序就是 C --> B --> A，并且是一个一个执行的，达到了单线程执行的效果

- 示范代码
```java
public class A extends Thread{
    public void run() {
        // 创建b线程
        B b = new B();
        b.start()
        // 立刻挂起a线程，还没有执行后面的功能
        b.join();
    }
}
public class B extends Thread{
    public void run() {
        // 创建c线程
        C c = new C();
        c.start()
        // 立刻挂起b线程，还没有执行后面的功能
        c.join();
    }
}
public class C extends Thread{
    public void run() {

    }
}

// 主函数，创建线程（创建A线程就可以）
//    如果三个线程都在这里创建然后采用传入的方式挂起线程，是不合适的
//    因为线程的执行顺序不可控，如果B先执行，B就挂起了，然后A执行的时候就无法挂起了
public static void main(String[] args) {
    A a = new A();
    a.start();
}
```




#### 线程-join方法的底层源码
- 无法通过notifyAll唤醒的原因
  - 就是因为底层使用了 while
  - 即使唤醒后，由于唤醒条件不满足，所以还是处于 while 中，然后就又被挂起了

- 具体代码分析
```java
// 不传递时间，底层会自动赋成0
if (millis == 0) {
    // isAlive 判断线程是否执行完成
    //    因为 join 是通过 线程.join 挂起的。所以 isAlive() 就相当于 线程.isAlive()
    //    所以判断的是另一个线程是否执行完成，即 A 通过 B挂起，这个地方判断就是B线程是否执行完成
    //    如果没有执行完成，继续陷入挂起
    // 所以，通过notifyAll唤醒后或者自动唤醒后，都还是处于 while 中，会继续进行条件判断
    //    如果条件满足，说明挂起线程还没有执行完，是notifyAll唤醒的，然后就又陷入沉睡了
    //    所以无法通过 notifyAll 唤醒
    while (isAlive()) {
        wait(0);
    }
} 
else {
    // 这个的左右上面介绍了
    while (isAlive()) {
        // 求时间差
        //    millis是传入的时间，now是当前时间与刚开始挂起的时间差
        long delay = millis - now;
        // 如果时间差大0，说明唤醒的时间-挂起的时间 < 设置的时间
        //    证明是 notifyAll 唤醒的，然后往后执行，继续挂起
        // 如果小于等于0，说明唤醒的时间-挂起的时间 >= 设置的时间，说明时间到了，不再挂起
        if (delay <= 0) {
            break;
        }
        wait(delay);
        // 得到唤醒的时间-挂起的时间，然后就会回到上面执行，进行判断
        //    因为，走到这一步说明刚被唤醒，还在 whild 中
        //    如果whild的条件满足，就进行时间判断
        //    如果条件不满足说明另一个线程已经执行完了
        //    当前线程也就不再进行挂起（不执行上面的代码，唤醒后就不再被挂起）
        now = System.currentTimeMillis() - base;
    }
}
```




#### 线程-线程锁的概念
- 作用：保护数据的安全性（因为安全锁，会锁住一个对象）
- 工作原理
  - 当某个线程执行某个对象中，带有安全锁的方法时，该线程就会锁住该对象
    - 直到该线程执行完安全锁中的代码，该对象才会被释放
  - 当某个对象被锁住的时候，其他线程就无法调用该对象中带有安全锁的代码
    - 注意：只是不能调用带有安全锁的代码，其他没有带有安全锁的代码，是可以正常执行的
    - **即：安全锁，锁住的不是一整个对象，而是该对象中带有安全锁的所有方法，普通的方法没有影响**
- 对线程切换的影响
  - **对线程切换没有影响**
  - 即：当某个线程锁住某个对象后，时间碎片是正常切换的
    - 并不是该线程执行完带有安全锁的代码后，在进行切换
  - 只不过，当时间碎片切换到某个线程后，该线程开始执行，发现将要执行的代码已经被另一个线程锁住了，于是就会进入等待（时间碎片正常切换）
    - 什么时候正常执行呢：当被锁住的对象释放后，该线程才会继续执行，然后就会又锁住了该对象



#### 线程-线程锁的实现
```java
public class Demo {
    public static void main(String[] arge) {
        A a = new A();
        Thread thread = new Thread(a);
        thread.start();
    }
}


class A implements Runnable  {
    @Override
    public void run() {
        B b = new B();
        b.demo1();
    }
}

class B {
    public synchronized void demo1() {
        System.out.println("demo1");
        this.demo2();
        synchronized (this) {
            System.out.println("局部锁");
        }
    }
    public synchronized void demo2() {
        System.out.println("demo2");
    }

    public void demo3() {
        System.out.println("由于这个没有上锁，所以即使demo1锁住了这个对象，其他线程也是能够调用该方法的");
    }
}
```


#### 线程-当前对象锁住别的对象（容易产生死锁问题）
- 只能借助局部锁，方法锁只能锁住当前对象
- 释放时间，为局部锁执行完成的时间
- 示范代码
```java
synchronized (this.demo) {
  this.demo.C(this.name);
}
```
- 上述代码，可以在任意类中写，作用是执行到这个地方，立马锁住指定的对象（demo）
- 如果当前对象已经被其他线程锁住，则在这个地方陷入等待，直到该对象释放，才会继续执行，然后锁住指定对象
  - 对象锁住后，其他线程就不能再执行该对象中带有安全锁的代码
  


#### 线程-线程锁的缺点
- 安全锁的使用，会出现一种死锁的现象，但是这种现象很难发生，具体看后面的介绍




#### 线程-线程的死锁
- 就是由于 `synchronized` 使用不当造成的
  - 使用局部锁，同时操作两个对象
  - 比如：线程1锁住了A，要想操作B。如果线程2刚好锁住了B，想要操作A，就产生了死锁的问题
    - 线程切换到1，一看B锁住了，就陷入等待
    - 线程切换到2，一看A锁住了，就陷入等待
    - 两个都进行等待过程，就造成了A、B永远不会解锁（执行不完，无法解锁），这样就陷入了永远的等待过程（两个线程永远结束不了）

- 示范代码
```java
// 线程类
public class Zhe extends Thread {
    // 两个共同的对象
    private A a;
    private B b;

    public Zhe() {};
    public Zhe(A a, B b) {
        this.a = a;
        this.b = b;
    };

    // 线程的入口函数
    public void run() {
        // 看看a有没有锁住，锁住等待，没有锁住执行，锁住a
        synchronized (this.a) {
            System.out.println("锁住A");
            // 如果另一个线程操作A，锁住了B，则下面的代码进入等待过程，另一个线程也进入等待过程，就产生了死锁现象

            // 看看b有没有锁住，锁住等待，没有锁住执行，锁住b
            synchronized (this.b) {
                System.out.println("锁住B");
            }
            // 执行完，释放b
        }
        // 执行完释放a
    }
}

```


#### 线程-死锁的解决方式
1. 产生时间差，避免同时拿到一个对象的操作权限，另一个却抢不到了，有了时间差，就可以给其他线程得到对象的操作权限，然后释放
2. 不操作同一个对象，就没有锁定的效果


