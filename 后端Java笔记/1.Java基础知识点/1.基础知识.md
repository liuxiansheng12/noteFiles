<script src='/笔记/see/index.js'></script>
[toc]


#### Java语言的特点
- 跨平台性   
  - 平台(不同厂商的芯片)    
  - 平台(不同版本的操作系统)
- 面向对象
- 简单性	     
  - 省去了C++多继承，指针等等
- 健壮性
  - 垃圾回收机制   
  - 异常处理机制
- 多线程性	    
  - 并行操作、提高执行性能、要注意线程安全
- 大数据开发


#### 如何让计算机执行java程序
- 安装JDK -》 配置环境变量 -》cmd编译.java文件 -》cmd运行java程序



#### 基本数据类型
- 整数型：  byte、short、int、long
  - 使用long约束数据类型的时候，要注意，在最后加上 L
    - 比如: long d = 2147483648L;
    - 原因就是，这个类型太大，如果我们真的需要那么大的数字  必须在后面加L告知
- 浮点型：  float、double
  - 使用 float 约束数据类型的时候，要注意，在最后加上 F
    - 比如: float e = 3.4F;
  - double 可以直接写成小数，不用加标示 F
    - 加上也不报错
- 字符型：	char
- 布尔型：	boolean 




#### 二进制
- 电脑存储数据，只能存放 0和1，并且是已补码的形式存放数据
  - 正数的补码是它本身（反码、补码就是它本身）
  - 负数的补码是它的反码加1
    - 比如有二进制10000110，第一位是1，代表它是负数。反码就是每一位都取反，为01111001。所以，补码就是01111010（反码加1）
  - 由于加一的存在，所以负数的区间就比正数多一个
    - 比如：Byte的范围就是 -128 ~ 127

  



#### 类型转换
- 精度高的数据，不能转换成精度低的数据，因为会造成数据丢失，所以默认不允许
  - 就是为了防止类型写错，然后进行类型转换，从而造成数据出错
  - 除非强制转换，这样写就说明确实需要进行类型转换

.
- **低位的整数可以自动转换成高位的整数**
  - 高位的整数不能自动转换成低位的整数，可以强制转换
    - 高位的整数，转换成低位的整数，可能会造成数据丢失的问题，所以不能自动完成
  - 比如
  ```java
    int a = 32;
    // 不能自动转换
    // byte b = a;
    // 可以强制转换
    byte b = (byte)a;

    byte c = 32;
    // 可以自动转换
    int d = c;
    System.out.println(d);
  ```

.
- **低位的浮点型（小数）可以自动转换成高位的浮点型（小数）**
  - 高位的浮点型（小数）不能自动转换成低位的浮点型（小数），可以强制转换
    - 高位的浮点型（小数），转换成低位的浮点型（小数），可能会造成数据丢失的问题，所以不能自动完成
  - 比如
  ```java
    float a = 34.2F;
    // 地位可以自动转成高位
    double b = a;

    double c = 3.45;
    // 不能自动转换
    // float d = c;
    // 需要强制转换
    float d = (float)c;
  ```

.
- **所有类型的整数，能自动转换成小数**
  - 小数不能转换成整数，可以进行强制转换
  - 比如
  ```java
    float a = 34.2F;
    // 小数转整数，只能强制转换
    int b = (int)a;

    // 低位的能转换成对应的小数
    int c = 3;
    float d = c;

    // 即使是高位的也能自动转换成功
    long e = 3L;
    float f = e;
    double g = e;
  ```

.
- **char类型的数据，可以自动转换成整数和小数**
  - 如果写的是一个英文字符，是可以自动转换成 `byte` 的
  - 如果写的是一个中文的字符
    - 由于中文的字符是两个字节
    - 如果转换成 `byte` 类型的数据，就有可能发生数据丢失的问题。
    - 所以为了避免，无意中丢失数据，中文字符是不能自动转化成 `byte` 类型的数据的，必须强制转化
  - `int` 和 `float` 都是32 位的，装字符绰绰有余，所以可以自动转换
  - **整数转换成 char类型的数据**
    - short 范围的整数可以自动转换
    - int 范围的的数据，必须强制类型转换
    - 超过int 范围的数据，即使强制转换也不行
  - **小数数和转换成 char类型的数据**
   - 必须强制类型转换
   - char的编码就是一个整数，相当于从高精度转换成低精度（小数转整数）
   - 并且只能float 范围的数据可以转换


#### 两个整数互换
- 巧用 ^ 运算符 （相同为0，自己 ^ 自己 = 0。然后 0 ^ 另一个，自然就为另一个了，完成了互换）
- 示范代码
  ```java
  public class Demo {
      public static void main(String[] args) {
          int a = 3;
          int b = 4;
          // 不能直接 a = a ^ b ^ a，这样 3 就会消失
          a = a ^ b;
          b = a ^ b;  // 就相当于 b = a ^ b ^ b。b = a;
          a = a ^ b;  // 由于此时 b 变成了 a，虽然 a ^ b ^ b，其实是 a ^ b ^ a。a = b，这样两个都完成了互换
          
          System.out.println(a);
          System.out.println(b);
      }
  }
  ```



#### 枚举
- 某个类提前创建好需要的一些对象，并且对象个数固定，无法手动通过new的方式，创建出新的对象

- 具体的实现示范代码
  ```java
  enum En {
      // 这个东西必须写在第一行，
      en1, en2, en3("张三");  // 前两个使用无参构造方法，构造对象。后面的使用有参构造方法构造对象

      private En() {
          System.out.println("无参构造方法");
      }
      private En(String s) {
          System.out.println("有参构造方法，参数：" + s);
      }

      public void fun() {
          System.out.println("方法执行");
      }
  }


  public class Demo {
      public static void main(String[] arge) {
          // 不使用，枚举是不会构造对象的，只要一开始使用，则立马创建出所有的枚举对象（三个）

          // 访问枚举对象
          System.out.println(En.en1);

          // 调用枚举对象的方法
          En.en1.fun();
      }
  }
  ```

- **注意点**
  - 枚举由于会默认继承一个Enum类，所以就不能手动继承其他类了（一个类只能继承一个）
  - 枚举中不能写公有的构造函数，只能写私有的（不允许手动通过 new 的方式创建对象）
  - 枚举无法通过反射的技术，获取到内部的构造方法（不允许手动创建对象）

.
- `Enum`类中提供了一些属性和方法
  - `name`----->枚举对象的名字，`name()`获取name属性
  - `ordinal`--->枚举对象在类中罗列的顺序，类似index，也从0开始，`ordinal()`获取序号
  - `valueOf()` 通过给定的name获取对应的枚举对象
  - `values()` 获取全部的枚举对象  ---> 返回一个数组， Day[]
  - `compareTo()` 可以比较两个枚举对象，   int
  - `toString()` 由于这个方法没有final修饰，   可以覆盖(重写)


.
- 枚举通过普通类实现（和上面代码的效果一样，使用方式一样）
  - 底层原理就是单例模式
  - 枚举的特点
    - 创建出固定数量的对象，并且可以通过类.的方式使用，所以这就是静态属性
    - 无法通过new的方式构造出新的对象，所以这就是构造方法私有化
  - 示范代码
  ```java
  class En {
      public static final En en1 = new En();
      public static final En en2 = new En();
      public static final En en3 = new En("张三");

      private En() {
          System.out.println("无参构造方法");
      }
      private En(String s) {
          System.out.println("有参构造方法，参数：" + s);
      }

      public void fun() {
          System.out.println("方法执行");
      }
  }

  public class Demo {
      public static void main(String[] args) {
          En.en1.fun();
      }
  }
  ```






#### 运算符-逻辑运算符
1. `&` 逻辑与，**所有的条件都会进行处理**(并不是遇到false就停止)，只要有一个条件为false，最终得到的结果为false
2. `｜` 逻辑或，**所有的条件都会进行处理**(并不是遇到true就停止)，只要有一个条件为true，最终得到的结果为true
3. `^` 逻辑异或，**所有的条件都会进行处理**，只要左右两个结果不同，一个为true，一个为false，结果为true，相同为false。
4. **注意：**
   1. 这三个逻辑运算符，如果左右两侧的数据类型是 `char类型`和`整数类型(4个类型)`，则进行的是位运算
   2. 如果两侧，的数据类型是 `boolean`，则进行的是逻辑运算
   3. char类型和整数类型可以混用，得到的是整数类型。而boolean类型，两侧必须相同
   4. 浮点型，不能使用，也就是无法进行位运算
5. **所以 `&、｜、^` 这三个运算符，有两种含义，一个是位运算，一个是逻辑运算**



#### 运算符-短路逻辑运算符
1. `&&` 短路与，一个一个的条件进行判断，只要有一个为false，则立马停止，得到的是false，后面的表达式不再进行处理
2. `||` 短路或，一个一个的条件进行判断，只要有一个为true，则立马停止，得到的是true，后面的表达式不再进行处理
3. 需要注意的是，短路逻辑运算符，两侧的数据类型必须为 `boolean`。其他的数据类型不能使用
   1. 通常与**比较运算符**联合使用，比较运算符返回的就是boolean类型的数据



#### 运算符-比较运算符
- 得到的结果为boolean类型的数据

1. `>`、`>=`、`<`、`<=`、`!=`、`==`、`对象 instanceof 类`



#### 运算符-算术运算符
1. 算术运算：`+`、`-`、`*`、`/`、`%`、`++`、`--`
		    
2. 赋值运算：`=`、`+=`、`-=`、`*=`、`/=`、`%=`
	
3. 由于Java的数据类型很严格，所以 `整数除一个整数`，得到的是一个整数，如果是 `0.几`，结果就为0。除数或者被除数只要有一个为小数，得到的才是小数。




#### 运算符-位运算原理（了解底层数据的存储）
1. 数据的存储，分为原码，反码，补码。
2. 其中正数的原码、反码、补码相同，比如: 2的原码、反码、补码如下(以byte为例)
   1. 原码: 00000010
   2. 反码: 00000010
   3. 补码: 00000010
3. 其中负数的原码是显示的数据、反码取反(第一位是符号位，0表示正数，1表示负数，是不进行取反的)、补码是反码加一，比如: -2的原码、反码、补码如下(以byte为例)
   1. 原码: 10000010
   2. 反码: 11111101
   3. 补码: 11111110

4. 计算机底层存储的就是反码，运算使用的也是反码，使用的时候，在进行运算
   1. 正数不变，负数减一取反
   2. 比如一下的示范代码
   ```java
    byte a = 1;   // 底层存储的补码为: 0000 0001
    byte b = -2;  // 底层存储的补码为: 1111 1110   (1000 0010 -->  1111 1101 --> 1111 1110)
    System.out.println( a & b );    // 结果为 0
    // 底层计算的是   0000 0001 & 1111 1110  (全1为1)  --> 0000 0000  (这是补码，使用时要转换)  --> 0
    System.out.println( a | b );    // 结果为 -1
    // 底层计算的是   0000 0001 | 1111 1110  (有1为1)  --> 1111 1111 (这是补码，使用时要转换，减一取反) --> 1111 1110 --> 1000 0001  --> -1
    System.out.println( a ^ b );    // 结果为 -1
    // 底层计算的是   0000 0001 ^ 1111 1110  (相同为0，不同为1)  --> 1111 1111 (这是补码，使用时要转换，减一取反) --> 1111 1110 --> 1000 0001  --> -1
    System.out.println( ~a );    // 结果为 -2
    // 底层计算的是   ^ 0000 0001 (每一位取反)  --> 1111 1110  (这是补码，使用时要转换，减一取反) --> 1111 1101 --> 1000 0010  --> -2
   ```


#### 运算符-位运算
1. & (与)，运算规则，有0为0，全1为1
2. ｜ (或)，运算规则，有1为1，全0为0
3. ^ (异或)，运算规则，相同为0，不同为1
4. ～ (取反)，运算规则，每一位取反
5. 每一个位运算符，正常操作操作符号位，代码如上




#### 运算符-位移运算符
- 左移运算符
1. `<<`，
2. 相当于 `乘2的倍数`，由于直接操作位，所以比 运算符`*` 的效率要高
3. 比如: `5 << 3`，就相当于 `5 * 2 * 2 * 2`


- 右移运算符，符号位不动
1. `>>`
2. 相当于 `除2的倍数`，由于直接操作位，所以比 运算符`/` 的效率要高
3. 比如: `5 >> 3`，就相当于 `5 / 2 / 2 / 2`


- 右移运算符，符号位也进行移动
1. `>>>`
2. 正数没事，负数符号位一进行移动，就会变成一个很大的正数，所以不是 `除2的倍数` 
3. 比如: `byte a = -6;  a >>> 1;`
   1. **需要注意的是，虽然类型为byte，但是参与运算的时候，会变成 32 位的**
   2. 这样移动完，就变成了 `2147483645`




#### 字符串-字符串底层存放
- 字符串是通过String类进行创建的，即使写成字面量赋值，底层调用的也是 new String()
- String类中，有一个私有属性 private final char value[]，这个属性存放的就是字符串数据
- 所以，字符串数据的存放格式是每个字符拆开，然后存成 char 类型的数组

.
- 如果能修改这个char数组中的某一位，则当前字符串也会发生变化
  - 比如
    ```java
    public static void main(String[] arge) {
      String str = "abc";
      // 修改
      value[1] = 'x';
      System.out.println(str); // 此时在获取str，就变成了 axc
    }
    ```
- 但是由于这个属性是私有的，所以正常情况下获取不到，也就无法修改
  - 但是可以通过反射的方式获取到，然后进行修改，具体操作后面介绍



#### 字符串-字符串拆分
- 利用 split 这个函数，可以实现字符串的拆分

.
- 正常拆分
    ```java
    String s = "a,b,c,d";
    String[] arr = s.split(",");
    System.out.println(Arrays.toString(arr)); // 打印出[a, b, c, d]
    ```

.
- 最后一位是拆分标记（问题：拆分出来的集合，最后一位是否是空串）
    ```java
    String s = "a,b,c,d,";
    String[] arr = s.split(",");
    System.out.println(Arrays.toString(arr)); // 打印出[a, b, c, d]
    ```

.
- 最后两位都是拆分标记（问题：拆分出来的集合，最后几个空串，一个也没有）
    ```java
    String s = "a,b,c,d,,";
    String[] arr = s.split(",");
    System.out.println(Arrays.toString(arr)); // 打印出[a, b, c, d]
    ```
  - **总结：只要最后拆分出来得到是空串，就会忽略**
    - 比如：`,,,,,`，拆出来全是空串，可以看成最后都是空串，这样就会忽略，于是得到的是个空数组
    

.
- 首位是拆分标记（问题：开头能拆分出来空串吗，会忽略吗）
    ```java
    String s = ",a,b,,,,,c,d,,";
    String[] arr = s.split(",");
    System.out.println(Arrays.toString(arr)); // 打印出[, a, b, , , , , c, d]
    ```
  - **总结：只要拆分出来得到的空串不在最后，就不会忽略（无论是在开头还是在中间，还是连续多个空串，都不会忽略）**



.
- 拆分成指定位数的子字符串（比如；能拆成4段，但是需求是拆分成2段）
  - 利用第二个参数
    ```java
    String s = "a,b,c,d,,";
    String[] arr = s.split(",", 2);
    System.out.println(Arrays.toString(arr)); // 打印出[a, b,c,d,,]
    ```
    - 会从前往后拆，达到目标后，就不在进行拆分（所以，在a和b中间切一刀，就变成两段了，符合2，于是后面的b,c,d,,就不在进行拆分）
    - 如果是空串，也会看成一段，比如 `,a,b,c,d,,`，拆分成两段，得到的就是 `[, a,b,c,d,,]`
  - 当然，如果想要从中间切一刀（按照某个规则切），就需要借助正则表达式


.
- 拆分利用正则表达式
    ```java
    String s = "a1b2c3d";
    String[] arr = s.split("\\d");  // 按照数字进行切分
    System.out.println(Arrays.toString(arr)); // 打印出[a, b, c, d]

    //正则表达式中 \d标识数字，所以本题是按照数字对字符串进行拆分
    //正则表达式中的\在java中有转义的含义，所以需要利用\对其进行转义，转换成基本\的含义
    ```


#### 字符串-字符串拼接
- 第一种，使用 + 号运算符
  - 只要 + 号的**两侧有一个字符串类型的数据**，则 + 号就变成字符串的拼接
  - 比如
    ```java
    public class Demo {
        public static void main(String[] arge) {
            System.out.println( "a" + true );  // 打印 atrue
            System.out.println( "a" + null );  // 打印 anull
            System.out.println( null + "a" );  // 打印 nulla
            System.out.println( "null" + "a" );  // 打印 nulla
        }
    }
    ```
- 第二种运用 concat 方法
  - 这种方式，只能拼接字符串与字符串类型，因为 concat 的参数类型是字符串，而 concat 又是 String 上的方法，所以只能拼接字符串与字符串
  - 功能：把 concat 传入的字符串，**拼接在调用该方法的字符串的后面**
  - 比如
    ```java
    public class Demo {
        public static void main(String[] arge) {
            System.out.println( "a".concat("b") );  // 打印 ab
            System.out.println( "a".concat("b").concat("c") );  // 打印 abc
        }
    }
    ```



#### 字符串-字符串比较（equals 和 == 的区别）
- 不能使用  `>、< ` 比较，会报错。只能比较是否相等
- 使用 == 比较，比较的是地址索引
- 使用 equals 比较的是字面量

- 比如
```java
public class Demo {
    public static void main(String[] arge) {
        String s1 = "a";
        String s2 = "a";
        String s3 = new String("a");
        System.out.println( s1 == s2 );  // 打印 true
        System.out.println( s1 == s3 );  // 打印 false
        System.out.println( s1.equals(s3) );  // 打印 true
    }
}
```
  - 字面量赋值：String s1 = "a"，其实底层也是 new 一个 String，只不过创建后有缓存
    - 即 String s2 = "a";，一看有一个 "a"，就会直接复用地址索引
    - 所以 s1 == s2 才为 true




#### 字符串-StringBuffer和StringBuilder
- StringBuffer 和 StringBuilder的区别
  - StringBuffer是早期版本，是线程安全的，但是执行效率赶不上StringBuilder
  - StringBuilder是线程非安全的，可以多线程并发访问，执行效率高，但是容易出现抢资源的问题

- 特点：可变字符串，动态扩容

- 构造方法（两个都一样）
  - 无参构造方法，底层默认创建一个16长度的数组，存放字符串
  - 传入int类型的数据，指定创建的数组长度
  - 传入String、StringBuffer、StringBuilder 的数据
    - 底层创建的数组长度是 `有效字符的长度 + 16`
- 为什么底层创建的是数组：作用是存放字符串的每个字符（和String的底层存储一样）


.
- 常用方法（两个都一样）
  - 获取字符串的长度：`int = length()`
   - 获取的是字符串的长度，不是底层存放字符串的那个char类型数组的长度
  - 设置字符串的有效元素的个数：`setLength( int );`
    - 如果设置的值过小，则会发生字符串的截取，后面的就给去掉了
    - 如果设置的值过大，字符串没有影响，但是进行拼接或者删除的时候，在获取length，发现是在这个基础上变化的
      - 比如: `123` 执行 `setLength(7)` 获取长度变成了 `7`, 拼接一个 `a`，字符串是`123a`，在获取长度变成了 `8`
      - 会影响到 `length` 获取的值
  - 获取某个位置的字符：`char = charAt(int index);`
  - 在指定的位置，插入一个字符串：`insert(int index, value);`
    - 这个方法有很多重载
  - 字符串的反转：`StringBuffer = reverse()`
    - 虽然返回值是 `StringBuffer` 但是底层代码是 `return this`，目的是产生链式调用
    - 底层修改的还是原字符串(反转的是底层存放字符的那个 `char` 类型的数组)
  - `toString`，该方法进行了重写，返回的是 `new String( toStringCache, true )`，得到具体的字符串
    - 底层的数据存储结构是一个数组
    - 将StringBuilder对象 构建成一个string对象 返回
  - 在后面拼接字符串：`append()`
    - 不会返回新的，是在原有的基础上进行拼接
  - 确保底层数组容量够用：ensureCapacity(int minimumCapacity)  
  - 字符串底层char[]的容量：capacity();
  - int = codePointAt(int index);
  - String = substring(int start [,int end]);
    - 注意需要接受返回值 看见截取出来的新字符串效果
  - StringBuilder = delete(int start [,int end]);
    - StringBuilder类中独有的方法String类没有
    - 将start到end之间的字符串删掉  不用接受返回值就看到效果啦
  - StringBuilder = deleteCharAt(int index);
    - String类中没有的方法
    - 将给定index位置的某一个字符删除掉啦
  - int = indexOf(String str [,int fromIndex]);
  - int = lastIndexOf(String str [,int fromIndex])
    - 找寻给定的str在字符串中第一次出现的索引位置  带重载 则从某一个位置开始找
  - replace(int start, int end, String str);
    - 将start和end之间的部分替换成str
    - 比如：builder.replace(2,5,"zzt");
  - setCharAt(int index,char value);
    - 将index位置的字符改成给定的value
  - trimToSize()
    - 将数组中无用的容量去掉  变成length长度的数组





#### 字符串-正则表达式（规则）
- 常用的正则匹配规则（范围）
  - `[abc]`：abc其中的一个
  - `[^abc]`：不能是abc其中的一个 其他都可以
  - `[a-zA-Z]`：表示必须是这两个范围内的
  - `[a-z&&[^bc]]`：表示a-z其中的一个但不能是b和c
  - `.`：代表任意一个字符
  - `\d`：数字（[0-9]）
  - `\D`：非数字（[^0-9]）
  - `\s`：留白（空格、回车、换行）
  - `\S`：非留白
  - `\w`：数字或字母都可以（[0-9A-Za-z]）
  - `\W`：非单词（[^0-9A-Za-z]）
  - `|`：或者
  - `&&`：并且

- 常用的正则匹配规则（位数）
  - `?`：0-1次   
    - 比如：`[0-9]?`
  - `*`：0-n次
  - `+`：1-n次
  - `{n}`：固定n次
  - `{n, }`：至少出现n次
  - `{m, n}`：m-n次
  



#### 字符串-正则表达式（规则应用）
- 判断某个字符串是否符合正则表达式
  - `boolean = str.matches("regex");`
- 字符串的拆分及替换（除了传递具体的字符，还可以传入正则）		
  - String类中提供的方法replace、split

.
- 匹配一次，获取符合条件的字符串（示范代码）
  ```java
  public class Demo {
      public static void main(String[] args) throws IOException {
          String a = "abc123456dddd234567adf333444ff";
          // 定义一个匹配规则
          //   \D，根据规则介绍，匹配的是非数字，但是由于 \ 有其他的含义（转译），所以需要对 \ 使用一个转译，这样就变成了 \\
          Pattern pattern = Pattern.compile("\\D{4}");
          // 传入匹配数据
          Matcher matcher = pattern.matcher(a);

          // 匹配一次
          //    如果成功，返回 true
          //       通过 matcher.group() 就能获取到匹配成功的字符串
          //    如果一个成功的都没有，返回false
          Boolean boo = matcher.find();
          System.out.println(boo);

          // 获取匹配成功的字符串
          //    必须先进行匹配，并且匹配成功，才能使用该方法进行获取（如果没有匹配成功，就获取内容，就会报错）
          System.out.println( matcher.group() );   // 打印 dddd
      }
  }
  ```
- 获取所有符合条件的字符串（示范代码）
  - 还是利用 matcher.find();，一次匹配一个
    - 但是 matcher.find(); 下一次匹配，会接着上一次成功的位置，继续往后匹配
    - 所以，只要通过循环，一直使用 matcher.find() 进行匹配，最终就能把所有符合条件的字符串都匹配出来
    - 最后，如果 matcher.find() 返回 false，说明后面一个成功的也没有了
      - 所以，就可以利用 matcher.find() 作为条件
        - 如果返回true，就使用 matcher.group() 获取
        - 如果返回false，说明匹配结束，退出循环
        - 这样，就能获取到所有的匹配结果了
  - 示范代码
    ```java
    String a = "abc123456dddd234567adf333444ff";
    // 定义一个匹配规则
    //   \d，根据规则介绍，匹配的是数字，但是由于 \ 有其他的含义（转译），所以需要对 \ 使用一个转译，这样就变成了 \\
    Pattern pattern = Pattern.compile("\\d{6}");
    // 传入匹配数据
    Matcher matcher = pattern.matcher(a);
  
    // 循环，持续匹配
    while( matcher.find() ) {  
        // 只要进入循环，说明条件匹配成功，并且有符合条件的值，就可以直接获取了
        System.out.println( matcher.group() );
    }
    ```



#### 数组-数组的使用
- 定义数组
  ```java
  // 开辟一个长度为 3 的数组
  int[] a = new int[3];
  System.out.println(a);

  // 开辟一个长度为 3 的数组，并赋值
  int[] b = {1, 3, 7};
  int[] c = new int[]{1, 3, 7};
  System.out.println(b);

  // 传参传入一个数组，只能这样写，不能写 {3, 2}
  //   如果这样写，就单独定义，然后传入一个索引
  B.demo(new int[]{3, 2});
  ```


#### 数组-常用的工具方法
- 所有的工具方法，必须通过Arrays调用，把要操作的数组，作为参数传进去

- 从0开始，获取数组的子数组（0～i）
  - Arrays.copyOf(arrs, i);

#### 数组-排序
```java
public static void main(String[] arge) {
  int[] arrs = {3, 6, 8, 9, 3, 3, 7};
  // 排序
  Arrays.sort(arrs);
  // 查看效果
  System.out.println(Arrays.toString(arrs));
}
```



#### 集合-集合简介
- 一种是Collection集合，存储的是value，辖下两个集合分类
  - 一种是list集合，特点是有序有重复
  - 一种是set集合，特点是无序无重复
- 一种是Map集合，存储的是key-value
- set存放的数据，作为key，而不是作为value，主要是为了实现去重的效果，而value是可以重复的，所以只能作为key



#### 集合-ArrayList集合
- 创建一个ArrayList集合
  - 可以创建一个空的集合
  - 也可以创建一个带有数据的集合

- 传参
  - 可以无参
  - 可以传入一个具体的数字
    - 表示，创建一个初始空间多大的集合，默认是0
    - 如果合理应用，可以减少扩容的操作，因为底层是数组
  - 传入一个实现Collection接口的数据集合
    - 会把该集合的数据，作为初始数据，放入创建的ArrayList集合

.
- 示范代码
  ```java
  public class Demo {
      public static void main(String[] args) throws IOException {
          ArrayList<Integer> arrayList = new ArrayList<Integer>();
          arrayList.add(3);
          arrayList.add(4);

          System.out.println(arrayList);
      }
  }
  ```

.
- 创建一个迭代器，遍历集合
  - 集合的遍历，可以使用 for 循环。除了for循环，ArrayList还提供了一个迭代器，可以用来迭代数据（遍历）
- 示范代码
  ```java
  public class Demo {
      public static void main(String[] args) throws IOException {
          ArrayList<Integer> arrayList = new ArrayList<Integer>();
          arrayList.add(3);
          arrayList.add(4);
          arrayList.add(7);

          // 创建一个迭代器
          Iterator iterator = arrayList.iterator();
          // 开始迭代，遍历数据（iterator.hasNext()判断迭代是否完成，为true表示还有数据没有被迭代出来，继续迭代）
          while (iterator.hasNext()) {
              // 获取数据（迭代的特点，每次都取下一个数据），由于返回的是Object，所以需要造型
              int i = (int)iterator.next();
              System.out.println(i);
          }
      }
  }
  ```

.
- 把集合转换成数组
  - `arrayList.toArray();`，得到的是Object类型的数组
  - `String[] s = arrayList.toArray(new String[0]);`
    - 得到一个指定类型的数组
    - 传入的参数，只是决定得到的数组类型，没有其他的功能
    - 类型必须与创建集合时，指定的范型相同
    

.
- 常用方法（新增数据）
  - 在集合后面加入一个数据：`arrayList.add(e)`;
  - 在某个位置插入一个元素：`arrayList.add(index, e)`;
    - 是插入，并不是替换
  - 在最后存一组元素：`arrayList.addAll(Collection c)`
    - 传入的是一个实现Collection接口的数据集合
  - 在某个位置，插入一组元素：`arrayList.addAll(int index, Collection c)`
    - 传入的是一个实现Collection接口的数据集合

.
- 其他常用方法（取、删、改）
  - 获取数据：`arrayList.get(int index)`
  - 清空集合：`arrayList.clear()`
  - 删除某个位置数据：`arrayList.remove(int index)`
    - 返回删除的数据，传入的索引要是超出范围，则报错
  - 删除某个数据：`arrayList.remove(Object obj)`
    - 删除成功，返回true，没有该数据返回false
    - 如果有多个相同的数据，只删除第一个
  - 修改数据：`arrayList.set(int index, E value)`
  - 获取集合长度：`arrayList.size()`
    - 得到的是有效的个数，不是集合的长度
  - 验证某个数据是否在集合中：`boolean = arrayList.contains(Object e)`
    - 如果找到，返回`true`，如果找不到返回`false`
  - 判断两个集合有没有交集：`boolean b = arrayList.removeAll(Collection c)`
    - 两个数据集合中，存放的数据，至少有一个相同，返回`true`，全不相同，返回`false`
  - 判断两个集合有没有差集：`boolean b = arrayList.retainAll(Collection c)`
    - 两个数据集合中，存放的数据，至少有一个不相同，返回`true`，全相同，返回`false`
  - 获取某个数据的前索引：`int index = arrayList.indexOf(Object obj);`
    - 没有就返回 `-1`
  - 获取某个数据的后索引：`int index = arrayList.lastIndexOf(Object obj);`
    - 没有就返回 `-1`
  - 获取集合的某段子集合：`List arr = arrayList.subList(int begin, int end);`
  - 把集合的长度，变成有效元素的个数：`arrayList.trimToSize()`
  - 判断集合是否为空集合：`boolean a = arrayList.isEmpty();`
    - 为空返回`true`，不为空返回`false`





#### 集合-HashSet集合（Set）
- 特点，无序无重复
  - 无序只是相对而言，相对于使用者是无序的，底层存放是有序的
    - 底层存放也是一个数组（数组与链表相结合的方式存放数据）
    - **利用hash计算出存放位置**（源码中可以看出来，HashMap的源码）
      - 因为HashSet的底层用的就是HashMap，所以要看HashMap的源码
      - 底层是利用Hash，计算出数组的索引，然后进行链表的操作，存放数据
      - 由于数组是有序的，所以Set底层的存放其实是有序的
- HashSet，底层用的就是HashMap存放的数据，存的数据作为key，value是一个 Object 空对象
  - 值作为key，可以去重，这样就实现了Set去重的功能
- 所以说，new HashSet()，底层源码就new了一个 HashMap （可以查看源码）

.
- HashSet的使用示范代码
  ```java
  public class Demo {
      public static void main(String[] args) throws IOException {
          HashSet set = new HashSet();
          set.add(3);
          set.add(4);
          System.out.println(set);
      }
  }
  ```
  
.
- 常用方法
  - 添加元素：`boolean = set.add(E a);` 
  - 清除所有的元素：`void = set.clear(E a);` 
  - 添加一组元素：`void = set.addAll(collection c);` 
    - 传入的是一个实现Collection接口的数据集合
  - 删除指定的元素：`boolean = set.remove(Object o)`
    - 如果有，删除成功，返回的是true。如果没有则返回false。
  - 保留当前集合中和传入集合中一样的元素：`boolean = set.retainAll(Collection<?> c)`
    - 传入集合中没有找到的元素，直接删除，会直接影响原集合，不会返回新的集合
    - 比如set中存放的元素为1、2、3、4，传入的参数 c 中存放的元素为2、3、5
      - 运算完，set中存放的元素就变成了2、3
  - 删除当前集合中和传入集合中一样的元素：`boolean = set.removeAll(Collection<?> c)`
    - 传入集合中存在的元素，直接删除，会直接影响原集合，不会返回新的集合
    - 比如set中存放的元素为1、2、3、4，传入的参数 c 中存放的元素为2、3、5
      - 运算完，set中存放的元素就变成了1、4
  - 获取一个迭代器对象（**遍历Set**）：`Iterator<E> = set.iterator()`
    - 用法和 ArrayList 中的一样，可以看 ArrayList 中的介绍
  - 获取有效元素的个数：`int = set.size()`
		
.
- **无重复的原则（可以改变去重规则）**
  - HashMap存放数据的源码简要概述，具体看HashMap存放数据的源码分析
  - 去重方式：使用`equals`方法和`hashCode`方法，联合判断
  - 判断方式
    - 先使用hashCode，获取hash，得到的是一个int值，经过计算，算出存放的位置（数组索引）
      - 如果对应位置没有值，则存入
	    - 如果计算的位置有值，则使用equals进行判断（判读数据是否重复，去重）
        - 如果返回值为true，则认为是重复的，不进行存入，跳过
	      - 如果，返回false，表示不是同一个数据，需要存入。
          - 但是hash相同，即存放的位置相同，则利用散列表结构
  - 所以，我们可以重写这两个方法，来影响某个类创建的对象，存入set时的去重处理
    - 比如：对象中的某个属性相同，就认为是重复的，直接去重
		
		



#### 集合-TreeSet集合（Set）
- 底层用的是TreeMap存放的数据
- 示范代码
  ```java
  public class Demo {
      public static void main(String[] args) throws IOException {
          TreeSet set = new TreeSet();
          set.add(3);
          set.add(4);
          System.out.println(set);
      }
  }
  ```


.
- **无重复的规则是如何实现的**
  - 利用的是 compareTo 这个函数（可以查看源码，具体分析在TreeMap存放数据的源码分析）
    - 这个函数，如果如果返回0，则认为是重复的，不存入set集合
    - 返回其他的数据，就认为不是重复的，就会存入set中

.
- **要想使用TreeSet，存放自定义的类，必须要实现Comparable接口，重写compareTo方法**
  - 因为底层会调用该方法，进行去重的判断
  - 由于该方法没有默认的（不像`equals`方法和`hashCode`方法有默认的所以可以不用重写）
  - 所以，如果没有实现compareTo方法，使用时找不到，就会报错




#### 集合-HashMap
- 特点：key不会重复，重复后就会替换之前的值（可以从下面的存放数据的源码解析，就可以看出来）

- 使用示范代码
  ```java
  public class Demo {
      public static void main(String[] args) throws IOException {
          HashMap maps = new HashMap();
          maps.put("a", 3);
          maps.put("b", 4);
          System.out.println(maps);
      }
  }
  ```

.
- 常用方法
  - 添加元素：`maps.put(key, value)`
    - 存放一组映射关系，`key-value`
	  - 不同的key可以存储相同的value
    - key若有相同的，则将原有的value覆盖，而不是拒绝存入
  - 删除某个元素：`E = maps.remove(key);`
  - 修改元素：` maps.put(key, value)`
    - 利用替换的原理（相同的key，新的值会替换旧的）
  - 替换元素（修改元素）：` maps.replace(key, newValue)`
  - 查找元素：`E = maps.get(key)`
  - 获取有效元素的个数：`int =  maps.size();`
  - 有就获取，没有就存入： `maps.putIfAbsent(key, value)`
    - 如果集合中，指定存入的健不存在，获取对应的value为null，则进行存入。
    - 如果有对应的value，则得到value，不进行存入
  - 有就获取，没有就返回指定的默认值(第二个参数)：`E = maps.getOrDefault(key, defaultValue);`
  - 添加一组存储结构是Map的集合数据L： maps.putAll(map)`
  - 清空整个集合：`void = maps.clear()`
  - 判断集合是否为空集合：`boolean = maps.isEmpty()`
    - 如果为空，则返回 `true`。
  - 判断某个集合中，有没有某个key：`boolean = maps.containsKey(key);`
    - 有就返回 `true`。
  - 判断某个集合中，有没有某个value：`boolean = maps.containsValue(value);`
    - 有就返回 `true`
  - 获取集合的所有keys（格式为Set集合）：`Set<Key> = maps.keySet();`
  - 获取集合中所有的Node节点（所有数据）： `Set<Map.Entry<>> a = maps.entrySet();`


.
- 遍历map集合的方式
  - 方式一，通过key进行遍历
    - 首先获取所有的key(得到的是一个Set集合)，然后遍历获取的key，从集合中依次取数据，得到value，达到遍历map集合的目的。
    - 代码示范
      ```java
        Set<String> setKey = hashMap.keySet();
        for(String a : setKey) {
            // 获取每一项的value
            System.out.println( hashMap.get(a) );
        }

        // 也可以获取setKey的迭代器对象进行迭代，不使用 增强for循环 进行遍历
        Iterator<String> iterator = set.iterator();
        while( iterator.hasNext() ) {
            // 获取每一个key值
            String key = iterator.next();
            System.out.println( key );
            // 获取对应的value
            System.out.println( hashMap.get( key ) );
        }
      ```
  - 方式二，获取所有的节点对象，进行遍历
    - `HashMap`，底层存放数据的原理，其实也是一个一个的 `Node` 节点，获取到这些节点，就相当于获取到了存储的全部数据，这样就可以实现遍历的效果。
	  - 获取所有的Node节点： `Set<Map.Entry<>> a = maps.entrySet();`
    - 代码示范
      ```java
        Set<Map.Entry<String, String>> set = hashMap.entrySet();
        for(Map.Entry<String, String> a: set) {
            // 获取每一项的value，获取每一个节点的value属性对应的值
            System.out.println( a.getValue() );
        }
	    ```	

.
- HashMap底层的数据结构存储（下面源码分析中可以替换）
  - 是以，散列表的形式进行存储，即 `数组 + 链表` 的形式
  - 多条链表，放在数组中，就形成了散列表的形式
  - 底层原理
    - 计算存放的位置，调用 `HashCode` 方法，获取到hashCode值。
      - 然后HashMap中提供了一套处理hashCode的方法，得到元素的存放位置。
    - 如果该位置没有值，equals不再执行，直接创建 Node节点，存放在数组的对应位置(上面计算出的)。
    - 如果该位置，有值，则顺着链表，向下比较每个节点的key，与当前的key。
      - 即调用 `Node.key.equals(key)` 方法，如果得到的是true，表示相同。
      - 不进行添加，但是value，换成了新的。即 `Node.value = value`;





#### 集合-TreeMap
- 底层数据结构的存储: 红黑二叉树

- 使用示范代码
  ```java
  public class Demo {
      public static void main(String[] args) throws IOException {
          TreeMap maps = new TreeMap();
          maps.put("a", 3);
          maps.put("b", 4);
          System.out.println(maps);
      }
  }
  ```

.
- TreeMap的底层实现原理（下面源码分析中可以体现）
  - TreeMap，底层的数据存储结构是一个红黑二叉树，并且存放位置是自然有序，内部并没有存放位置的独特算法
  - TreeMap，存放数据，并没有存放位置的计算方法，而是通过 `key` 中的 `compareTo` 方法，获取存放位置
    - 所以，存放的 `key` 元素，必须要实现Comparable接口，实现compareTo方法（否则会报错）
- 每存入一个元素，都会从树的根结点开始，调用 `compareTo` 方法
  - 如果得到的为 0 就认为是相同的，则value进行替换，更换成新的
  - 如果得到的，比当前元素返回值大，则往右分支查询，如果右分支还有元素，继续重复上面的步骤，进行比较，如果右分支没有元素，则创建新的，拼接在右分支上。
  - 如果得到的，比当前元素返回值小，则往左分支查询，如果左分支还有元素，继续重复上面的步骤，进行比较，如果左分支没有元素，则创建新的，拼接在左分支上。
  - 所以，要想元素排的靠前，返回值就尽量小，最好为负数（因为左侧先查，所以往左拼能提高先查出来的几率）
    - 并不是返回值为负数，就一定拼接在左侧，虽然刚开始的时候是放在左侧的，但是会进行二叉树的重新计算（使其平衡，源码分析中有体现）




#### 集合-Vector
- Vector是ArrayList集合的早期版本，是线程安全的
  - 但是线程安全，在多线程中，效率是低下的，但是能保证数据的安全
  - 但是有些时候，就是追求速度，所以后面就搞出了 ArrayList （线程非安全）
- 所以：Vector和ArrayList的使用，要根据情况来决定
  - 如果为了安全就使用Vector，如果为了速度就使用ArrayList
- Vector底层也是利用(动态)数组的形式存储
- 扩容方式与ArrayList不同
  - 默认是扩容2倍，可以通过构造方法创建对象时修改这一机制

.
- Vector的使用和ArrayList相同，可以看上面ArrayList的说明




#### 集合-Stack（栈）
- 什么是栈（先进后出，后进先出）
- 构造方法只有一个无参数
- 该类的底层，是通过`Vactor`类，实现的
  - 继承Vactor，利用Vactor来存储数据，这样就不用手动写数据的存储了
  - 然后提供几个方法，操作Vactor，实现压栈弹栈的操作

.
- 使用示范代码
  ```java
  public class Demo {
      public static void main(String[] args) throws IOException {
          Stack stack = new Stack();
          stack.push(2);
          stack.push(4);
          System.out.println(stack);
      }
  }
  ```

.
- 常用的方法
  - 由于继承了Vactor，所以`Vactor`中的方法，都能使用，并且功能相同
  - 除了Vactor上带的方法，Stack还提供了一些自己的方法（实现压栈弹栈的操作）
    - 将某一个元素压入栈顶：`vactor.push(E e)`
      - 其实底层，使用的就是 `add()`(Vactor中的方法)
  - 将某一个元素从栈顶取出并删掉，获取删除的元素：`E = vactor.pop()`
    - 其实底层，使用的是 `E = remove(int length)`(Vactor中的方法)
    - 由于删除的是栈顶的数据，所以每次传入的索引，就是集合的长度减一，这样删除的就是最后一个元素了
      - 即: `E = remove(list.size() - 1)`
    - 所以，从栈中删数据有两种方式
      - 一种使用`vactor.pop()`
      - 一种使用底层代码 `vactor.remove(list.size() - 1)`
  - 查看栈顶的一个元素：`E = vactor.peek()`
    - 底层，借助的是 `get()`(Vactor中的方法)
    - 所以，查看栈顶的数据，有两种方法
      - 一种是`vactor.peek()`
      - 一种是`vactor.get( list.size() - 1 )`
        - 由于获取的是栈顶的数据，所以每次传入的索引，就是集合的长度减一，这样获取的就是最后一个元素了
   4. 判断栈内元素是否为空：`boolean = vactor.empty()`
      1. 底层使用的就是 `isEmpty()`(Vactor中的方法)
   5. 查找给定的元素在栈集合中的位置：`int = vactor.search()`
      1. 底层使用的是 `indexOf()`(Vactor中的方法)
      2. 所以查看某个元素的位置，有两种方式
         - 一种是通过`vactor.search()`
         - 一种是通过`vactor.indexOf()`






#### 集合-Queue接口(队列接口)
- 队列：先进先出
- Queue只是一个队列的借口，不能直接创建队列
- 但是实现该接口的类可以实现队列的功能，通过类实现的Queue中的方法，实现队列的功能
  - 相当于，Queue接口接口定义出了一个队列该有哪些操作方法
- java中提供的实现类（队列）：`LinkedList`
- 只能通过无参数构造方法构建队列


- 接口中的方法
  - 往队列中添加元素：`boolean = queue.add(E d)`
  - 查看队列的第一个元素(头)，`E a = queue.element()`
  - 查看队列的第一个元素(头)，`E a = queue.peek()`
    - 与`element`的区别，如果为空队列，`peek`得到null，而`element`抛出异常
  - 每次从队列中，取出第一个元素（删除队列的头）：`E a = queue.remove()`
  - 每次从队列中，取出第一个元素（删除队列的头）：`E a = queue.poll()`
    - 与`remove`的区别，如果为空队列，`poll`得到null，而`remove`抛出异常
  - 往队列中添加元素: `boolean = queue.offer(E e);`









#### 集合-LinkedList（队列）
- LinkedList的数据存储结构是双向链表，不是数组
- LinkedList：适合于插入或删除  不适合遍历轮询
- 构建对象
  - 无参数构造方法   
  - 带参数的构造方法(collection)

.
- 使用示范代码
  ```java
  public class Demo {
      public static void main(String[] args) throws IOException {
          LinkedList linkedList = new LinkedList();
          // 添加元素（加载队列顶部）
          linkedList.add(2);
          linkedList.add(4);
          System.out.println(linkedList);

          // 从队列中取数据（从结果中，可以看出，先存的被先取出，符合队列条件）
          int i1 = (int)linkedList.remove();
          int i2 = (int)linkedList.remove();
          System.out.println(i1);
          System.out.println(i2);
      }
  }
  ```

.
- 常用的方法
  - 一次增加一个元素 `linkedList.add(E e)`
  - 移除某个元素: `E = linkedList.remove(int i)`
  - 修改某个元素: `linkedList.set(E e)`
  - 获取某个元素: `E = linkedList.get(int i)`
  - 获取有效元素的个数: `int l = linkedList.size()`







#### 集合-HashMap存放数据的源码分析	
- 源码（HashMap.java）
  ```java
  final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
      // 存放数据（从这个地方就可以看出，HashMap底层是用数组存放的数据，链接从下面可以看出来）
      //    所以，HashMap存放数据，使用的是数组和链表相结合的方式
      Node<K,V>[] tab; 
      // 当前所处的链表节点（Hash得到是上面数组的索引，而每个数组元素，都是一个链表）
      //    根据 Hash 可以定位到链表，但是还要扫描整个链表，查找是否有相同的数据
      //    有就更新（新的替换旧的），没有就创建一个，然后挂在链表的最后
      //    所以，hash只是决定在数组的那个位置，具体的位置还要看链表
      Node<K,V> p; 
      int n, i;
      
      // 先赋值，如果没有或者数组的长度为0，就需要创建出一个
      if ((tab = table) == null || (n = tab.length) == 0)
          n = (tab = resize()).length;
      //  如果没有这个Hash，就说明这是一个新的节点，于是存贮一个
      if ((p = tab[i = (n - 1) & hash]) == null)
          // i就是根据hash，得到的索引，存的是链表的根节点
          tab[i] = newNode(hash, key, value, null);

      // 如果某个hash，在数组中找到了，说明之前存储过该hash，就有可能存储过该数据
      //   所以要扫一下链表，看看有没有相同的数据，如果有就更新，如果没有就创建，然后挂载到链表的最后
      else {
          Node<K,V> e; K k;
          // 先判断，链表的根节点是不是当前数据（如果条件成立，就说明是）
          //   此时的p还是根节点（上面赋值的）
          if (p.hash == hash &&
              ((k = p.key) == key || (key != null && key.equals(k))))
              // 保存一下当前节点，然后后面会更新数据
              e = p;
          // 获取到相同数据的节点，然后后面会更新数据
          else if (p instanceof TreeNode)
              e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
          else {
              // 如果不是根节点并且处于链表中（不是TreeNode），于是就扫描整个链表，查找是否有相同的数据
              for (int binCount = 0; ; ++binCount) {
                  // 如果 == null，说明扫到最后，也没有找到相同的数据，说明没有，就创建一个
                  if ((e = p.next) == null) {
                      // 创建完成后，拼接在链表的最后
                      p.next = newNode(hash, key, value, null);
                      // 如果长度超过了8。就执行一下优化函数，保证链表不会出现过长的现象
                      if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                          treeifyBin(tab, hash);
                      break;
                  }
                  // 这个条件成立，说明找到了相同的数据
                  //   由于上面判断执行了 (e = p.next)，所以e就是当前节点（相同的数据）
                  //   就可以直接退出，然后后面通过e更新数据
                  if (e.hash == hash &&
                      ((k = e.key) == key || (key != null && key.equals(k))))
                      break;
                  
                  // 执行到这个地方，说明没有相同的数据，也没有扫到最后，于是就继续扫描链表的下一个节点
                  //   直到第一个if成立，扫到了最后，也没有找到相同的数据
                  //   或者第二个if，找到了相同的数据，上面就会执行退出循环的操作，并且重复的数据已经报错，e就是
                  p = e;
              }
          }
          // 如果e存在数据，说明上面找到了相同的数据，于是进行数据的更新
          if (e != null) { 
              V oldValue = e.value;
              if (!onlyIfAbsent || oldValue == null)
                  // 更新数据
                  e.value = value;
              afterNodeAccess(e);
              return oldValue;
          }
      }
      ++modCount;
      if (++size > threshold)
          resize();
      afterNodeInsertion(evict);
      return null;
  }
  ```



#### 集合-TreeMap存放数据的源码分析
- 源码（TreeMap.java）
  ```java
  public V put(K key, V value) {
      // 保存根节点
      Entry<K,V> t = root;
      // 没有根结点，说明这次存的是第一个数据（直接作为根节点，然后退出）
      if (t == null) {
          compare(key, key); 
          // 作为根节点
          root = new Entry<>(key, value, null);
          size = 1;
          modCount++;
          return null;
      }
      // 程序走到这一步，说明存的不是第一个元素，此时就需要去重的处理了
      int cmp;
      Entry<K,V> parent;
      // comparator 这个东西是 new TreeMap 的时候传入的，用于比较两个key是否相同（相同表示重复）
      // 如果创建TreeMap的时候，没有传入这个东西，则获取的就是 Null，就会走else的处理程序
      //    使用对象自带的 compareTo 方法进行比较
      //    如果没有compareTo，就报错，这也是存放自定义对象，必须带有compareTo方法的原因，不带就报错
      Comparator<? super K> cpr = comparator;
      if (cpr != null) {
          do {
              // 保存一下当前的节点
              parent = t;
              // 使用，传入的comparator，中的compare 方法判断是否相同
              cmp = cpr.compare(key, t.key);
              if (cmp < 0)
                  t = t.left;
              else if (cmp > 0)
                  t = t.right;
              // 如果 = 0 表示相同，就把值进行替换（后来的替换之前的）
              else
                  return t.setValue(value);
            
            // 如果最终，都没有相同的key，说明这是一个新的数据，下面会进行新增处理
          } while (t != null);
      }
      // 没有传入默认的判断是否重复的方法
      else {
          // 没有 key 就报错
          if (key == null)
              throw new NullPointerException();
          
          // 强制转一下类型看看有没有实现Comparable接口
          //    没有实现Comparable接口，即使定义了compareTo方法，这个地方也报错
          //    所以，存自定义对象，要先实现Comparable接口，在实现compareTo方法，否则就会报错
          @SuppressWarnings("unchecked")
              Comparable<? super K> k = (Comparable<? super K>) key;
          do {
              // 保存一下当前的节点
              parent = t;
              // 判断是否相同
              cmp = k.compareTo(t.key);
              if (cmp < 0)
                  t = t.left;
              else if (cmp > 0)
                  t = t.right;
              // 如果 = 0 表示相同，就把值进行替换（后来的替换之前的）
              else
                  return t.setValue(value);

            // 如果最终，都没有相同的key，说明这是一个新的数据，下面会进行新增处理
          } while (t != null);
      }

      // 上面都没有执行 return，说明没有找到对应的数据，说明是新的数据，所以这个地方先创建一个
      Entry<K,V> e = new Entry<>(key, value, parent);
      // 根据比较的结果，决定是放在左侧还是右侧
      if (cmp < 0)
          // parent是最后一个节点（上面每次循环，都会更新parent，使其为当前节点，上面的循环跑完，parent 就是最后一个节点了）
          // 然后把新的节点，放在最后（不能把节点插在中间，要不然后续的数据就丢了）
          parent.left = e;
      else
          parent.right = e;
      // 更新一下树，使其保持平衡（红黑树）
      fixAfterInsertion(e);
      size++;
      modCount++;
      return null;
  }
  ```
  






#### 类-权限修饰符
1. **public** ： 所有类，都可以访问
2. **protected**：受保护的，只有同包的类才能使用，其他的不可以（子包也不可以），继承类(子类)是可以使用的
3. **默认不写**	：只有同包的类才能使用，其他的不可以（子包也不可以），继承类(子类)也不能使用
4. **private**：私有的，只有当前类可以使用，子类也不行



#### 类-特征修饰符
1. **final**，最终的，不可更改的
2. **static**，静态的
3. **abstract**，抽象的
4. **native**，本地的
5. **transient**，瞬时的  短暂的------>序列化
6. **synchronized**，同步的，线程问题
7. **volatile**，不稳定的


#### 类-方法行参默认值的问题
- 在java中，没有函数参数默认值这个写法，要想实现默认值效果，可以利用方法的重载
  - 默认值的作用，就是不传递参数，使用默认的。在函数内部赋默认值也一样，就是写法不同
- 比如
```java
package Fs;
// 具有线程锁的方法
public class Demo {
    String s1;
    String s2;
    String s3;

    public Demo() {};

    // 有默认值（ 相当于 d(String s1, String s2, String s3 = "默认值") ，但是这样写会报错 ，只能利用方法重载实现）
    public void d(String s1, String s2) {
        // 搞个默认值
        this.s3 = "默认值";

        this.s1 = s1;
        this.s2 = s2;
    }
    // 没有默认值
    public void d(String s1, String s2, String s3) {
        this.s3 = s3;
        this.s1 = s1;
        this.s2 = s2;
    }
}
```


#### 类-this指向问题
- 谁调用的就指向谁
  - 比如：`a.fun()`，即使调用的是父类中的方法，则在父类fun方法中，获取this，发现指向的是 A

- 但是通过 this 获取 A 中的属性与方法是有困难的，虽然this指向 A
  - **通过 this 无法获取A中的属性，只能获取当前类中的属性**
    - 比如 A 有 num = 3;  B 中有 num = 6。A继承B
    - 如果在其他的类中，通过a.num获取到的就是 3，从下往上找
    - 如果在 A 中，使用 this.num 获取，获取的是 3（当前类中）
    - 如果在 B 中，使用 this.num 获取，获取的是 6（当前类中）
    - 虽然，两个this都指向 A，但是B中获取的就是6，无法获取到3
    ```java
    public class Demo {
        public static void main(String[] arge) throws InterruptedException {
            A a = new A();
            a.c();
            // 其他类获取 num，从子类往父类中找，所以打印 3
            System.out.println(a.num);
        }
    }

    class A extends B {
        public int num = 3;
    }

    class B {
        public int num = 6;
        
        // 虽然this指向的是A，但是由于获取的是属性，所以只能获取当前类中的属性
        //    所以获取的是 6
        public void c() {
            System.out.println("c方法" + this.num);
        }
    }
    ```
  - **通过 this 调用方法，调用的就是重写后的方法（从子类往父类中查找，找到就执行）**
    - 但是，前提是当前类中必须有该方法，才能调用重写后的方法，否则就会报方法找不到的错误
    - 比如 A 有 fun  B 中通过 this 调用 fun 方法。
      - 首先 B 中要想使用 fun，就必须有fun 方法
      - 由于是通过 this 调用的 fun 方法，而 this 是指向 A 的，所以最终执行的是A中重写的fun方法（与属性是不一样的）
    ```java
    public class Demo {
        public static void main(String[] arge) throws InterruptedException {
            A a = new A();
            a.c();
        }
    }


    class A extends B {
        public int num = 3;

        @Override
        public void b() {
            System.out.println("重写b方法");
            // this使用属性，使用的是当前类中的属性，所以打印的是 3
            System.out.println(this.num);
        }
    }

    class B {
        public int num = 6;

        // 必须有个b，否则 this.b 会报错
        public void b() {
            System.out.println("b方法");
        }

        // 虽然当前类中有 b 方法，但是由于this指向的是A
        //    所以通过this调用方法，会从A开始找，然后就找到了重写后的方法，然后开始执行
        public void c() {
            this.b();
        }
    }
    ```


#### 类-super的指向
- 指向当前类继承的那个父类（与this没有关系）
  - 比如 A 继承 B，B 继承 C     
  - 则 
    - A 中使用 super，指向的就是B（也就是直接调用B的方法，而不会调用A中重写的方法）
    - B 中使用 super，指向的就是C（也就是直接调用C的方法，而不会调用A和B中重写的方法）
  - 也就是 A 中想直接使用 B 中的方法，而不是调用重写后的方法，就可以使用 super
    - this实现不了，因为this获取的就是重写后的方法




#### 内部类-成员内部类
1. 与类中的其他成员，在同一级
2. 可以被权限修饰符，特征修饰符修饰
3. 成员内部类，可以使用外部类的所有属性和方法，包括私有的
   1. 内部类，无法通过 `this` 的方式 访问外部类中的属性，`this.`的方式，使用的是内部类中的属性或方法。可以通过 `外部类的名称.this.` 的方式，使用外部类的熟悉以及方法
   2. 内部类，可以直接通过属性名或者方法名，直接使用外部类中的熟悉和方法
      1. 如果内部类中有同名的，则先使用内部类的，没有才获取外部类的
4. 成员内部类的使用
   1. 由于成员内部类是外部类的一个成员，所以要想使用，必须通过外部类，先创建外部类对象，然后通过外部类创建的对象，在 new 创建出内部类对象，比如:
   ```java
    import demo.C;
    // 内部类的引入，也很特殊
    import demo.C.A;

    public class Demo {
        public static void main(String[] args) {
            // 外部类
            C c = new C();
            // 用外部类中的内部类创建出一个对象
            A a = c.new A();
            a.getA();
        }
    }
   ```
   2. 如果是外部类中使用内部类创建对象，可以直接 `new 内部类` 的名称，内部类就是外部类的一个成员，可以直接使用。
   3. **外部类中，使用内部类，创建出对象，是可以访问到内部类中的私有属性的，其他地方则不可以**
   4. 如果有继承关系，并且继承的父类中有内部类，子类是可以通过 `父类名.内部类名 a = new 父类名.内部类名();`，使用内部类创建对象的，**但是是访问不到内部类中的私有属性的**
   5. 由于，有继承关系，所以，使用子类创建的对象，也可以访问到父类中的成员内部类，使用它创建对象
   ```java
    import demo.C;
    // 内部类的引入，C，继承了 D，D中有一个内部类B
    import demo.D.B;

    public class Demo {
        public static void main(String[] args) {
            // 外部类
            C c = new C();
            // 用外部类中的内部类创建出一个对象，子类没有，会去找父类中的成员内部类
            B a = c.new B();
            a.getA();
        }
    }
   ```
   6. 使用内部类，创建的对象，调用一个内部类中没有的方法(但是外部类中有定义)，会出现问题的
      1. 虽然，内部类可以使用外部类中的数据，但是只限内部类中使用
      2. 是无法通过 `对象.` 的方式，使用内部类对应的外部类的属性和方法的



#### 内部类-局部内部类
1. 是在类中方法或者块中的进行创建，只用在函数内部或者块内部使用，外界是无法获取到函数内部的属性的，自然也获取不到局部内部类，自然无法使用
2. 局部内部类，可以访问到函数中的属性，也可以使用外部类中的属性和方法，包括私有的，如果外部类还是一个内部类，依旧可以继续往上查，还可以使用继承的（基本特性）
3. 局部内部类，只能获取函数中的变量，无法进行修改，外部类的属性可以重新赋值。
4. 可以使用两个修饰符: `abstract` 和 `final`(这个修饰符，用来修饰变量，自然可以用来修饰局部内部类);




#### 内部类-匿名内部类
1. 在new 的类后面，写类的结构，比如 `A a = new A(){ 类成员 }`，其中A，就相当于父类
   1. 其实就相当于new 了一个子类，创建对象，`A a`，就是多态的效果
2. 由于是内部类，所以上面这段代码写在类成员中，就是匿名成员内部类
3. 写在类中方法中，就是匿名局部内部类
4. 由于匿名内部类啥都没有，所以修饰符无法使用
5. 作用: 减少一个中间类的创建，在构建对象时，直接给出类结构
6. 匿名内部类中没有构造方法，原因是没有类的名称，创建不出构造方法




#### 内部类-静态成员内部类
1. 局部内部类，无法使用静态修饰符，所以静态内部类只有成员内部类
2. 使用数据，也可以获取外部类中的属性和方法，也能使用继承中的熟悉和方法
   1. 但是在静态修饰符的作用下，只能使用外部类的静态的属性和方法，也限制自己的成员内部类以及局部内部类，即使他们没有用静态修饰符修饰，但是获取最外侧的外部类中的属性和方法，也只能使用静态的
   2. 静态内部类中的属性和方法，没有要求
      1. 原因: 静态内部类，在刚开始的时候加载的时候，就放入静态元素区了，它在使用的使用，只能找到静态元素区中的内容，以及自身的内容。外部类的那些非静态的，由于不在一个地方，是获取不到的，所以只能使用外部类静态的一些东西
3. 静态成员内部类，可以不用借助外部类，就可以访问到，直接引入然后通过new 的方式，就可以创建出对象
```java
// B是D的一个静态成员内部类
import demo.D.B;

public class Demo {
    public static void main(String[] args) {
        // 可以就这样直接进行创建
        B a = new B();
        a.d();
        a.fun();
    }
}
```



#### 包装类-介绍
- 作用，把一个常量包装成一个对象，使其可以调用一些方法
- 包装类(封装类)，诞生于1.5版本之后，可以实现自动拆装包(自动包装，自动去包装)

.
- 包装类一共有八个，分别对应八个基本数据类型
   1. byte---`Byte` 
   2. short---`Short`   
   3. int---`Integer`  
   4. long---`Long`
   5. float---`Float`  
   6. double---`Double`  
   7. char---`Character`   
   8. boolean---`Boolean`

.
- 包装类的位置
	- 八个包装类都在同一个包下，java.lang包，Java.lang是不需要import导包的，可以直接使用

.
- 八个包装类的大体特性
  - 八个包装类中有六个是与数字相关的，所以都默认继承父类`Number`
    - `Number`类中有几个方法，`xxxValue()`
    - 这几个函数的作用，将一个包装类类型转化为对应的基本类型(拆包，还原回来)，前面的`xxx`是对应包装类对应的数据类型
  - 八个包装类都实现了`Serializable`, `Comparable`
  - 八个包装类都有带自己对应类型参数的构造方法
	  - 八个包装类中有七个(除了Character)还有构造方法重载，可以接受String类型的数据
    - 默认的构造方法，传入对应的数据类型


#### 包装类-使用
- **对一个常量手动包装**
  ```java
  Integer i1 = new Integer(10);
  // 调用第二个构造方法，传入一个字符串，char的包装类是没有这个功能的
  Integer i2 = new Integer(“10”);
  // 调用第二个构造方法，传入一个字符串，char的包装类是没有这个功能的
  Integer f1 = new Float(“10.011”);

  // 拆包，intValue就是Number类中的一个方法
  int value = i1.intValue();
  ```

.
- **对一个常量自动包装**
  ```java
  // 写成这种格式，数据类型为对应包装类的名称，就可以对一个数据完成自动包装
  Integer i2 = 10;
  ```

.
- **自动拆包**
```java
// 把一个包装类对象，用对应的常量接受，就会自动调用对应的xxxValue方法，进行拆包
//     此处，自动调用的是intValue方法，进行拆包
int value = new Integer(10);
```


#### 包装类-字符串转换成数字
- 字符串直接转成int或者float类型的基本数据类型，有两种方式
  - 利用包装类的第二个构造函数，然后自动拆包
  - 利用包装类提供的一个静态方法，`parseInt` 或者 `parseFloat`
  - 比如
    ```java
    int v = new Integer("123");
    int value = Integer.parseInt("123");	
    float f = Float.parseFloat("123.45");
    ```


#### 包装类-自动包装的缓存问题
- 为了提高效率，这八种包装类，在创建的时候，会创建一个静态的数组
  - 数组的每一项，是一个数据对应的包装类
- 这样的话，在自动包装的时候，就会先去这个静态数组中，查看有没有对应的包装类对象，如果有就直接取出使用，如果没有就是重新 new 一个
- 由于某些数据类型的数据量非常大，所以不可能每个数据都创建一遍，只会创建一部分
  - 比如 `int` 类型的，只有`-128～127`之间，会创建出对应的包装类集合 
    - 也就是一个byte类型的数据大小

- 这样就造成了一种现象（相等和不相等问题）
  - 比如
    ```java
    public static void main(String[] arge) {
      // 类型不一样，所以会自动进行包装
      Integer i1 = 10;
      Integer i2 = 10;
      // 由于范围在-128～127之间，所以两个取得都是缓存，所以两个相等
      System.out.println(i1 == i2); // true

      // 类型不一样，所以会自动进行包装
      Integer i3 = 200;
      Integer i4 = 200;
      // 由于范围不在-128～127之间，所以缓存中就没有，所以两个都会重新 new 一个出来
      //    只要经过 new 创建出的集合，都是新的，所以两个不相等
      System.out.println(i3 == i4); // false
    }
    ```
    


#### 包装类- equals 方法
- Object中有一个`equals`方法，Object中的方法，比较的是 `this == 参数`
- 包装类也是一个类，所以默认继承Object类，但是，包装类中的`equals`方法，进行了重写
  - 重写后，比较的是 `this.xxxValue() == (包装类)参数.xxxValue()`
    - 比较的是字面量，而不是集合本身
  - `(包装类)参数`，先进行强制类型转换，转换成包装类，因为只有包装类有`xxxValue`方法
    - 目的就是为了防止，传入基本数据类型，直接使用`xxxValue`方法报错
- 具体的示范代码
  ```java
  public static void main(String[] arge) {
    Integer i1 = 10;
		Integer i2 = new Integer(10);
    // equals 方法进行了重写，比较的是字面量，也就是 10 == 10，所以比较结果是 true
    System.out.println(i1.equals(i2)); // true


    Integer i3 = 200;
    Integer i4 = 200;
    // 直接比较，比较的是包装类集合本身（地址索引）
    //    由于超过了区间，所以缓存中没有，需要重新new，所以比较结果是false
    System.out.println(i3 == i4); // false
    // equals 方法进行了重写，比较的是字面量，也就是 200 == 200，所以比较结果是 true
    System.out.println(i3.equals(i4)); // true


    Integer i5 = new Integer(10);
		Integer i6 = new Integer(10);
    // equals 方法进行了重写，比较的是字面量，也就是 10 == 10，所以比较结果是 true
    System.out.println(i5.equals(i6)); // true

    // 如果没有重写，比较的就是 this == 参数，也就相当于比较的是集合本身，即：i3 == i4
  }
  ```



#### 工具类-Math（数学相关）
- 该类所有的方法，都是静态属性，可以直接调用
- 常用的方法
  - 取绝对值：Math.abs();
  - 向上取整：Math.ceil();
  - 向下取整：Math.floor();
  - 临近的整数：Math.rint();
    - 如果两边一样，取偶数
    - 比如3.5 --> 4;
    - 比如4.5 --> 4;
  - 四舍五入：Math.round();
  - 0~1随机数：Math.random();




#### 工具类-Random（数学相关）
- 专门构建随机数的一个类
- 该类的方法，要想使用，需要先创建一个 random 对象

- 常用的方法
  - 随机产生一个 int 取值范围的整数，有正有负：
    - random.nextInt()
  - 随机产生一个 0～n 取值范围的整数：
    - random.nextInt(n);
  - 随机产生一个 0~1 的小数：
    - random.nextFloat();
  - 随机产生一个boolean值：
    - random.nextBoolean();


#### 工具类-UUID
- 随机产生一个uuid

- 具体实现
  ```java
  public class Demo {
      public static void main(String[] args) {
          UUID uuid = UUID.randomUUID();
          String u = uuid.toString();
          System.out.println(uuid);
      }
  }
  ```



#### 工具类-BigInteger（存放大整数）
- 底层是以字符串存储的，字符串的长度就没有什么限制了，可以存一个非常大的数据，也可以存一个很小的整数
- 既然数据之以字符串形式存储的，所以 +-*/ 就不能用了
- 但是，BigInteger既然存储的是整数，所以就需要进行运算，所以 BigInteger 上提供了一些方法，可以实现 +-*/ 的功能
  - 底层就是对字符串的处理

- 运算的时候，也只能两个 BigInteger对象 进行运算（也就是传参需要传一个 BigInteger对象）
- 如果做除法得到的是一个小数，由于 BigInteger 只能存放整数，所以就会取整（向下取整）

- 具体使用
  ```java
  public class Demo {
      public static void main(String[] args) {
          // 存一个 2
          BigInteger result = new BigInteger("2");
          System.out.println(result);

          // 进行运算
          BigInteger result1 = result.add( new BigInteger("3") );  // + 3
          System.out.println(result1);

          BigInteger result2 = result.subtract( new BigInteger("3") );  // - 3
          System.out.println(result2);

          BigInteger result3 = result.multiply( new BigInteger("3") );  // * 3
          System.out.println(result3);

          BigInteger result4 = result.divide( new BigInteger("3") );  // / 3
          System.out.println(result4);
      }
  }
  ```
    
  



#### 工具类-BigDecimal（存放长小数或者整数）
- 通常用来处理小数，但是最后结果如果是整数，得到的也是个整数，是不会自动添加一个.0的
- 底层是以字符串存储的，字符串的长度就没有什么限制了，可以存一个小数点后面很长的小数
- 既然数据之以字符串形式存储的，所以 +-*/ 就不能用了
- 但是，BigDecimal既然存储的是小数，所以就需要进行运算，所以 BigDecimal 上提供了一些方法，可以实现 +-*/ 的功能
  - 底层就是对字符串的处理

- 运算的时候，也只能两个 BigDecimal对象 进行运算（也就是传参需要传一个 BigDecimal对象）
- 如果做除法得到的是一个小数，由于 BigDecimal 只能存放整数，所以就会取整（向下取整）

- 具体使用
  ```java
  public class Demo {
      public static void main(String[] args) {
          // 存一个 3
          BigDecimal result = new BigDecimal("3");
          System.out.println(result);

          // 进行运算
          BigDecimal result1 = result.add( new BigDecimal("3") );  // + 3
          System.out.println(result1);

          BigDecimal result2 = result.subtract( new BigDecimal("3") );  // - 3
          System.out.println(result2);

          BigDecimal result3 = result.multiply( new BigDecimal("3") );  // * 3
          System.out.println(result3);

          BigDecimal result4 = result.divide( new BigDecimal("4") );  // / 4
          System.out.println(result4);
      }
  }
  ```

- 如果想要保留几位小数，需要借助一个方法，示例如下
  - 第一个参数是保留几位小数
  - 第二个参数是什么格式（是向下取整、还是四舍五入）
  - 也是不会强制变成小数（不会自定在后面添加.0）
  ```java
  public class Demo {
      public static void main(String[] args) {
          // 存一个 3
          BigDecimal result = new BigDecimal("3");

          BigDecimal result4 = result.divide( new BigDecimal("4") );  // / 4
          // 保留1位小数
          result4 = result4.setScale(1, BigDecimal.ROUND_UP);
          System.out.println(result4);
      }
  }
  ```
    


#### 工具类-DecimalFormat（格式化数据）
- 比如：5 想要显示成 005;
- 比如：5.4 想要显示成 005.400;
- 当然了，如果长度超过了，是不会自动截取的，比如 5011 不会变成 501 或者 011
  - 只会在长度不够的情况下自动补0
- 当然了，如果配置格式化模版的时候，没有配置小数，则小数会自动忽略
  - 比如：5.2 就会变成 005

- 示范代码（格式化整数）
  ```java
  public class Demo {
      public static void main(String[] args) {
          DecimalFormat result = new DecimalFormat("000");
          // 格式化5（展示为005）
          String value1 = result.format(5);
          System.out.println(value1);

          // 格式化5011（展示为5011）
          String value2 = result.format(5011);
          System.out.println(value2);

          // 格式化5.2（展示为005）
          String value3 = result.format(5.2);
          System.out.println(value3);
      }
  }
  ```



- 示范代码（格式化小数，用 # 格式化）
  ```java
  public class Demo {
      public static void main(String[] args) {
          DecimalFormat result = new DecimalFormat("000.##");
          // 格式化5.3333（展示为005.33）
          String value1 = result.format(5.3333);
          System.out.println(value1);

          // 格式化5（展示为005）
          String value2 = result.format(5);
          System.out.println(value2);

          // 格式化5.3（展示为005.3）
          String value3 = result.format(5.3);
          System.out.println(value3);
      }
  }
  ```


- 示范代码（格式化小数，用 0 格式化）
  ```java
  public class Demo {
      public static void main(String[] args) {
          DecimalFormat result = new DecimalFormat("000.00");
          // 格式化5.3333（展示为005.33）
          String value1 = result.format(5.3333);
          System.out.println(value1);

          // 格式化5（展示为005.00）
          String value2 = result.format(5);
          System.out.println(value2);

          // 格式化5.3（展示为005.30）
          String value3 = result.format(5.3);
          System.out.println(value3);
      }
  }
  ```


- 根据上面的示例可以看出 # 和 0 的区别是
  - 用 # 格式化，如果不够，小数位不会自动补0
  - 用 0 格式化，如果不够，小数位会自动补0
-  小数位，超出的部分四舍五入
- 整数位，超出部分不会进行截取





#### 工具类-Date（时间）
- 要先构建对象，才能使用它提供的方法

- 常用方法
  - 获取时间戳：date.getTime();




#### 工具类-SimpleDateFormat（格式化时间）
- 该类的作用：是先创建一个格式化工厂，然后用工厂提供的方法，可以格式化时间对象
- 示范代码
  ```java
  public class Demo {
      public static void main(String[] args) {
          // 创建格式化工厂
          SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
          // 根据工厂，格式化时间对象
          String v = sdf.format( new Date() );
          System.out.println(v);
      }
  }
  ```






#### 注解-自定义注解

> 通过 `public @interface MyAnnotation {}` 创建一个注解
>> 1. `MyAnnotation` 就是注解名
>> 2. 注解使用时，通过 `@MyAnnotation`


> 注解是可以存放数据的
>> 要想存放数据，需要定义对应的接口方法
>>> 1. 有点类似get方法，方法名对应属性名，方法返回类型，对应属性类型
>>> 2. 然后，注解在使用的时候，就可以写成类似函数调用的方式，然后传入对应的属性值（注解中定义好的），必须传入
>>> 3. 这样的话就可以存储一些数据
>>> 4. **定义的方法，可以通过反射获取到，然后执行，得到对应的存储的数据**
>>> 5. **需要注意的是，要想获取注解存放的数据，元注解必须使用，否则是获取不到的**

> 比如，定义一个如下的注解
```java
public @interface Zhu {
    public abstract String value();
    public abstract String[] name();
    public abstract String age();
    
    // abstract可以省略，但是通常这么写
}
```

> 自定义注解的使用方式
```java
@Zhu(name = {"张三"}, age = "10", value = "ceshi")
public void a() {}
```


> 注解中，还可以定义常量，但是很少使用
>> 因为定义了就不能修改了，而注解就是给某个类存放一些动态的数据，向这些固定值，通常都直接写死在类中
>> 通过，`public static final 类型 属性名 = 固定值;`，在注解中定义一个固定值
>>> 固定值，是可以定义成其他类型的，不一定非得是字符串



#### 注解-元注解介绍
- 元注解是注解使用的注解，可以限制注解使用的范围
> 元注解，可以不使用
> 元注解，一共有四个
>> 1. `@Target`：描述当前的这个注解可以放置在哪里写的（限制使用范围）
>>> 1. @Target(ElementType.TYPE)：接口、类、枚举、注解
>>> 2. @Target(ElementType.FIELD)：字段、枚举的常量
>>> 3. @Target(ElementType.METHOD)：方法
>>> 4. @Target(ElementType.PARAMETER)：方法参数
>>> 5. @Target(ElementType.CONSTRUCTOR)：构造函数
>>> 6. @Target(ElementType.LOCAL_VARIABLE)：局部变量
>>> 7. @Target(ElementType.ANNOTATION_TYPE)：注解
>>> 8. @Target(ElementType.PACKAGE)：包   

>> 2. `@Retention`：描述当前的这个注解存在什么作用域中的
>>> 1. 源代码文件(`SOURCE`)--->编译--->字节码文件(`CLASS`)--->加载--->内存执行(`RUNTIME`)    
>> 3. `@Inherited`：描述当前这个注解是否能被子类对象继承
>> 4. `@Document`：描述这个注解是否能被文档所记录

> 示范代码

```java
import java.lang.annotation.*;

@Target({ElementType.CONSTRUCTOR,ElementType.METHOD,ElementType.FIELD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    public abstract String[] value();
    public abstract String c(); 
}
```



#### 注解-使用反射获取注解
> 注解，要不顶在类的上面，要不顶在方法的上面，要不顶在属性的上面
> 这样，就形成了一种对应关系
> 所以，只要找到对应的类、方法、属性，就可以找到对应的注解
> 而类、方法、属性，需要通过注解找到

> 先自定义一个注解
```java
// 要想通过反射的方式，获取注解，元注解是必须要设置上的
@Target({ElementType.CONSTRUCTOR,ElementType.METHOD,ElementType.FIELD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface Zhu {
    public abstract String value();
    public abstract String[] name();
    public abstract String age();
    public static final Integer a = 1;
}
```

> 使用注解的类
```java
@Zhu(name = {"张三"}, age = "10", value = "ceshi")
public class Ceshi {
    @Zhu(name = {"张三"}, age = "10", value = "构造")
    public Ceshi() {}
}
```


> 使用反射，获取注解
```java
public static void main(String[] str) throws Exception {
   // 通过反射获取类
   Class clazz = Class.forName("Ceshi");
   // 获取类上面的注解
   Annotation a = clazz.getAnnotation(Zhu.class);
   // 获取注解类
   Class cla = a.getClass();
   // 获取注解中，对应的方法
   Method method = cla.getMethod("value");
   // 执行方法，获取注解存放的数据
   String values = (String)method.invoke(a);
   System.out.println(values);

   // 其他地方的注解，也是一样，先获取对应的属性、方法。
   //    然后在使用 getAnnotation 获取注解，后续步骤就一样了，获取注解中对应的方法，执行方法

   // 比如：获取构造函数上的方法
   // 首先获取到构造函数
   Constructor con = clazz.getConstructor();
   // 然后获取上面的注解
   Annotation b = con.getAnnotation(Zhu.class);
   // 获取注解类
   Class clas = b.getClass();
   // 获取注解中，对应的方法
   Method methods = clas.getMethod("value");
   // 执行方法，获取注解存放的数据
   String value = (String)methods.invoke(b);
   System.out.println(value);
}
```






#### 线程-线程的概念
- 程序，可以理解为是一组静态的代码
- 进程，正在进行的程序、静态的代码，运行起来
- 线程，正在执行程序中的小单元

- 服务器就是利用线程思想做的
  - 当请求来临后，就创建一个线程对象，传入请求报文进行解析
  - 然后，使用start，让处理请求的run方法，进入执行的准备状态，准备执行



#### 线程-定义与使用（方式一）
- 通过继承Thread类，然后重写run方法实现
```java
// 类一
public class CeshiOne extends Thread {
    private String name;
    public CeshiOne(String name) {
        this.name = name;
    }

    @Override
    // 重写线程方法
    public void run() {
        for(int i = 0; i < 1000; i ++) {
            System.out.println(this.name + "：" + i);
        }
    }
}

// 主函数（让线程进入准备阶段）
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建一个线程对象
        CeshiOne x1 = new CeshiOne("线程一");
        // 构建一个线程对象（一个类可以起多个线程，他们之间互补干扰）
        CeshiOne x2 = new CeshiOne("线程二");
        // 构建一个线程对象
        CeshiTwo x3 = new CeshiTwo("线程三");

        // 线程进入准备状态
        //    也就是 对象中的run进行执行前的准备状态
        //    当拿到时间碎片后，就开始执行
        x1.start();
        x2.start();
        x3.start();
    }
}
```


#### 线程-定义与使用（方式二）
- 通过实现Runnable接口，然后重写run方法实现
```java
// 类一
public class CeshiOne implements Runnable {
    private String name;
    public CeshiOne(String name) {
        this.name = name;
    }

    // 重写线程方法
    public void run() {
        for(int i = 0; i < 1000; i ++) {
            System.out.println(this.name + "：" + i);
        }
    }
}


// 主函数（让线程进入准备阶段）
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建对象
        CeshiOne o1 = new CeshiOne("线程一");
        CeshiOne o2 = new CeshiOne("线程二");
        CeshiTwo o3 = new CeshiTwo("线程三");

        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        // 构建一个线程对象（）
        Thread x2 = new Thread(o2);
        // 构建一个线程对象
        Thread x3 = new Thread(o3);

        // 线程进入准备状态
        //    也就是 对象中的run进行执行前的准备状态
        //    当拿到时间碎片后，就开始执行
        x1.start();
        x2.start();
        x3.start();
    }
}
```


#### 线程-线程的执行原理
- 无论是方式一还是方式二，run方法是核心（相当于入口函数）

.
- 线程是操作系统级别的，我们控制不了，受电脑的cpu进行控制
  - 当线程准备好后，就等着时间碎片的来临
  - 当某个线程拿到时间碎片后，重写的run方法就开始执行（线程程序启动）
    - 所以run方法的执行是cpu控制的
  - 当线程执行一段时间后，时间碎片就会切换到其他线程，当前线程就失去了时间碎片，于是停止执行
  - 当另一个线程拿到时间碎片后，开始执行
    - **需要注意安全锁的问题，如果线程操作的代码被锁住，则陷入等待（等待时间碎片切换走）**
    - 安全锁可以保证数据的安全与准确性
  - cpu的时间碎片，随机分配，时间长短不定（所以线程的执行是随机的）
  - 当某个线程重新拿到时间碎片后，会继续往下执行
  - **如果一个线程被挂起，则时间碎片就不会分配到该线程**
    - 只有挂起的线程被唤醒，才进入等待过程（等待时间碎片的分配）
    - 拿到时间碎片后，进行执行，并且从上次停止的地方继续执行


#### 线程-线程沉睡
- 利用 Thread.sleep 方法，可以让某个线程沉睡一段时间
  - 沉睡，就是自动挂起一段时间（这段时间内时间碎片不会分配给该线程，也就是线程暂停执行），时间到了沉睡的线程会自动唤醒
  - 线程沉睡后，会立刻停止执行，当唤醒后，就会等待时间碎片的来临。当拿到时间碎片后，才会继续往后执行
- 使用的时候，必须处理错误
- 该方法传入一个时间，相当于沉睡的时间


- 使用示范代码
```java
// 带有线程沉睡的类
public class CeshiOne implements Runnable {
    
    // 重写线程方法
    public void run() {
        for(int i = 0; i < 1000; i ++) {
            // 让线程沉睡一段时间
            if(i == 500) {
                // 需要处理错误，可能一睡不醒
                try {
                    // 在这个地方，立马就进行了沉睡，不再往后执行
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(this.name + "：" + i);
        }
    }
}


// 开启线程
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建对象
        CeshiOne o1 = new CeshiOne("线程一");
        // 创建一个线程
        Thread x1 = new Thread(o1);
        // 线程启动
        x1.start();
    }
}
```




#### 线程-线程挂起
- 借助 wait 方法，进行线程的挂起（有两种使用方式）
  - 不传递参数，或者传递0，只能手动唤醒
  - 传递数字，表示多少秒后，自动唤醒

- wait 必须放在 synchronized 中进行线程的挂起（否则会报错）

- 比如：
  ```java
    class A {
        public synchronized void b() throws InterruptedException {
            // 线程的挂起
            this.wait(0);
        }
    }
  ```

- 如果，某个线程，正在操作某个对象，并且带有安全锁，此时这个对象就被锁住
  - 如果此时，线程被挂起，则锁住的对象立即释放
  - 如果线程被唤醒，继续从上次挂起的位置往后执行（还是安全锁中，因为是在安全锁的函数中挂起的），此时对象还是会被锁住的


#### 线程-挂起线程的唤醒
- 必须放在 synchronized 中进行线程的唤醒（否则会报错）
- 借助两个方法，都可以实现线程的唤醒
  - notify（随机唤醒一个线程，无法控制）
  - notifyAll（唤醒当前对象挂起的所有线程）
- 线程释放后，也不是立即执行，也是等着时间碎片的分配，才能执行
- 比如：
  ```java
    class A {
        public synchronized void b() throws InterruptedException {
            // 线程的唤醒
            this.notifyAll();
        }
    }


#### 线程-线程挂起和唤醒配合使用的限制一(同一对象)
- 线程的挂起和唤醒只能在同一个对象中进行
- 挂起和唤醒和对象挂钩，某个对象挂起的线程，只能由该对象进行唤醒（该对象无法唤醒其他对象挂起的线程）
  - 比如 A 对象挂起了 a线程。则 a线程必须由 A对象 进行释放

- 比如
```java
public class Demo {
    public static void main(String[] str) throws Exception {
        // 创建一个对象，用来线程的挂起和释放
        Gong gong = new Gong();
        // 两个线程都传入 共同的对象
        //    因为对象挂起的线程，只能通过该对象释放，并且一个线程挂起只能用另一个线程释放
        //    或者自动释放
        // 比如：线程1 被 gong 对象挂起，则只能通过 gong对象释放，并且只能借助另一个线程释放
        //    所以，线程2也要传入 gong 对象，这样才能唤醒 线程1
        CeshiTwo o1 = new CeshiTwo("线程一", gong);
        CeshiOne o2 = new CeshiOne("线程二", gong);
        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        Thread x2 = new Thread(o2);
        // 线程启动
        x1.start();
        x2.start();


        // 线程的挂起和释放不用同一个对象
        //    这样，线程1挂起，线程2是无法唤醒线程1的
        //    因为：线程的挂起和唤醒，用的不是同一个对象
        //    这样就会造成，线程1挂起后，就无法唤醒了
        CeshiTwo o1 = new CeshiTwo("线程一", new Gong());
        CeshiOne o2 = new CeshiOne("线程二", new Gong());
        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        Thread x2 = new Thread(o2);
        // 线程启动
        x1.start();
        x2.start();
    }
}
```



#### 线程-线程挂起和唤醒配合使用的限制二(线程锁)
- 线程的挂起和唤醒必须在安全锁函数中进行实现
- 如果调用的方法，没有添加安全锁，则在使用的过程中，就会报出 IllegalMonitorStateException 的错误
  - 比如
  ```java
    class A {
        // 调用 b 方法，由于没有添加 synchronized 所以在执行的时候就会报错
        public void b() throws InterruptedException {
            this.wait(0);
        }
    }
  ```

- 线程必须在安全锁中进行挂起和唤醒的原因（避免一个线程永远的被挂起）
  - 由于线程挂起后，就不在进行工作，所以挂起的线程要想唤醒，必须在另一个线程中进行
  - 所以线程的挂起和唤醒，是多个线程配合使用的
    - 当某个线程挂起后，另一个线程满足条件后，在把这个线程唤醒
  - 而线程的切换，我们是控制不了的
    - 假设，一个线程将要被挂起，但是还没有挂起，如果这个时候线程切换到了另外一个，而这时如果满足了唤醒的条件，就会唤醒线程（但是线程并没有挂起）。
    - 当线程切回挂起的代码后，线程才被挂起（但是此时唤醒的代码已经执行完了，所以这个线程就有可能永远的被挂起）
  - 加了 synchronized，就会变得不一样
    - 由于挂起和唤醒必须在同一个对象中（即同一个类中）
    - 当执行到挂起的代码后（还没有挂起），线程切换走了，如果此时满足了唤醒的条件，执行到唤醒代码，由于这个对象已经被挂起锁住了，所以唤醒代码就会陷入等待
    - 直到挂起代码执行完成，线程被挂起，对象才会被释放
    - 然后唤醒代码才会继续执行（而此时线程已经被挂起了），所以正常唤醒
    - **先挂起后唤醒，这样就避免了线程永远被挂起的问题**
      - 如果先唤醒后挂起（也会造成线程永远被挂起），但这就是代码设计的问题了
.
- 根据以上原因，java为了防止某个线程一挂不起，所以强制要求线程的挂起和唤醒必须放在 synchronized 中执行，否则就会报错






#### 线程-假死状态
- 线程的挂起，可能造成假死的状态
  - 即某个线程挂起，但是却没有被释放，最后程序就会陷入等待阶段，一直等下去







#### 线程-设置线程的优先级
- 优先级高的可能能更快的获取到时间碎片进行执行（只是可能，提高了一些概率，并不是一定）
- 借助 setPriority 方法实现
  - 如果两个线程同时被唤醒，但是想要某个线程优先执行(比较重要)，即优先获取资源，就可以使用该方法
- 在创建线程的时候，就设置好

- 示范代码
```java
public class Demo {
    public static void main(String[] args) {
        Ceshi ceshi = new Ceshi();
        // 创建线程对象
        Thread thread = new Thread(ceshi);
        // 在创建线程的时候，就进行设置
        thread.setPriority(5);

        // 启动线程
        ta.start();
    }
}
```




#### 线程-join方法的作用
- join的作用，就是挂起当前的线程
  - 底层也是用 wait 实现的线程挂起
- **线程的挂起，只能通过另一个线程对象，挂起当前线程**
  - 因为 join 方法，是线程对象上的一个方法，所以只能线程对象使用，但是当前线程肯定不能挂起当前线程，所以只能通过别的线程挂起当前线程
  - 比如 A 线程想要通过join挂起
    - 在 A 线程中，运行另一个线程的join方法，就会挂起当前A线程

.
- 使用方式
  - 不传递参数或者传递0
    - 功能：当前线程执行完毕后，会自动唤醒该线程挂起的线程
    - 比如：有两个线程 A 和 B
      - A 线程想要通过 join 挂起，只能使用 B.join()，这样 A 线程就会被挂起，这样就会切换到 B 线程执行
      - 只有当 B 线程执行结束，A线程才会被唤醒
  - 如果传递具体的数据，则时间过后，被挂起的线程会自动唤醒（单位ms）

.
- **注意点**
  - join挂起的线程，是无法通过 notifyAll 进行唤醒的（只能自动唤醒，定时唤醒）（底层代码决定的）
    - 使用 notifyAll 唤醒线程后，当时间碎片切换到这个唤醒的线程后，开始执行，然后就会立刻挂起
    - 所以，无法通过 notifyAll 唤醒 join 挂起的线程


.
示范代码

```java
// 线程一的类（使用join，挂起当前线程）
public class CeshiOne implements Runnable {
    private String name;
    // 保存一个线程，使用它的join方法（因为 join 只能通过另一个线程对象，挂起当前线程）
    private Thread ceshiTwo;


    // 重写线程方法
    public void run() {
        System.out.println("使用线程二，挂起当前线程");
        try {
            // 当线程二结束的时候，会自动释放
            ceshiTwo.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("释放了");
    }

    // 保存线程2的对象，用他来挂起当前线程
    public void setCeshiTwo(Thread ceshiTwo) {
        this.ceshiTwo = ceshiTwo;
    }
}

// 创建线程
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建对象
        CeshiOne o1 = new CeshiOne("线程一");
        CeshiTwo o2 = new CeshiTwo("线程二");

        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        Thread x2 = new Thread(o2);
        // 传入对应的线程对象（用来挂起线程）
        o1.setCeshiTwo(x2);

        // 线程进入准备状态
        x1.start();
        x2.start();
    }
}
```

#### 线程-借助join实现单线程效果
- 原理
  - A线程中创建B线程，然后马上利用B线程挂起
  - B线程中创建C线程，然后马上利用C线程挂起
  - 这样 A线程 和 B线程就会立即停止，然后C执行
    - 由于 B 线程是 C挂起的，所以C执行完，B就开始执行
    - 由于 A 线程是 B挂起的，所以B执行完，A就开始执行
    - 这样，执行顺序就是 C --> B --> A，并且是一个一个执行的，达到了单线程执行的效果

- 示范代码
```java
public class A extends Thread{
    public void run() {
        // 创建b线程
        B b = new B();
        b.start()
        // 立刻挂起a线程，还没有执行后面的功能
        b.join();
    }
}
public class B extends Thread{
    public void run() {
        // 创建c线程
        C c = new C();
        c.start()
        // 立刻挂起b线程，还没有执行后面的功能
        c.join();
    }
}
public class C extends Thread{
    public void run() {

    }
}

// 主函数，创建线程（创建A线程就可以）
//    如果三个线程都在这里创建然后采用传入的方式挂起线程，是不合适的
//    因为线程的执行顺序不可控，如果B先执行，B就挂起了，然后A执行的时候就无法挂起了
public static void main(String[] args) {
    A a = new A();
    a.start();
}
```




#### 线程-join方法的底层源码
- 无法通过notifyAll唤醒的原因
  - 就是因为底层使用了 while
  - 即使唤醒后，由于唤醒条件不满足，所以还是处于 while 中，然后就又被挂起了

- 具体代码分析
```java
// 不传递时间，底层会自动赋成0
if (millis == 0) {
    // isAlive 判断线程是否执行完成
    //    因为 join 是通过 线程.join 挂起的。所以 isAlive() 就相当于 线程.isAlive()
    //    所以判断的是另一个线程是否执行完成，即 A 通过 B挂起，这个地方判断就是B线程是否执行完成
    //    如果没有执行完成，继续陷入挂起
    // 所以，通过notifyAll唤醒后或者自动唤醒后，都还是处于 while 中，会继续进行条件判断
    //    如果条件满足，说明挂起线程还没有执行完，是notifyAll唤醒的，然后就又陷入沉睡了
    //    所以无法通过 notifyAll 唤醒
    while (isAlive()) {
        wait(0);
    }
} 
else {
    // 这个的左右上面介绍了
    while (isAlive()) {
        // 求时间差
        //    millis是传入的时间，now是当前时间与刚开始挂起的时间差
        long delay = millis - now;
        // 如果时间差大0，说明唤醒的时间-挂起的时间 < 设置的时间
        //    证明是 notifyAll 唤醒的，然后往后执行，继续挂起
        // 如果小于等于0，说明唤醒的时间-挂起的时间 >= 设置的时间，说明时间到了，不再挂起
        if (delay <= 0) {
            break;
        }
        wait(delay);
        // 得到唤醒的时间-挂起的时间，然后就会回到上面执行，进行判断
        //    因为，走到这一步说明刚被唤醒，还在 whild 中
        //    如果whild的条件满足，就进行时间判断
        //    如果条件不满足说明另一个线程已经执行完了
        //    当前线程也就不再进行挂起（不执行上面的代码，唤醒后就不再被挂起）
        now = System.currentTimeMillis() - base;
    }
}
```




#### 线程-线程锁的概念
- 作用：保护数据的安全性（因为安全锁，会锁住一个对象）
- 工作原理
  - 当某个线程执行某个对象中，带有安全锁的方法时，该线程就会锁住该对象
    - 直到该线程执行完安全锁中的代码，该对象才会被释放
  - 当某个对象被锁住的时候，其他线程就无法调用该对象中带有安全锁的代码
    - 注意：只是不能调用带有安全锁的代码，其他没有带有安全锁的代码，是可以正常执行的
    - **即：安全锁，锁住的不是一整个对象，而是该对象中带有安全锁的所有方法，普通的方法没有影响**
- 对线程切换的影响
  - **对线程切换没有影响**
  - 即：当某个线程锁住某个对象后，时间碎片是正常切换的
    - 并不是该线程执行完带有安全锁的代码后，在进行切换
  - 只不过，当时间碎片切换到某个线程后，该线程开始执行，发现将要执行的代码已经被另一个线程锁住了，于是就会进入等待（时间碎片正常切换）
    - 什么时候正常执行呢：当被锁住的对象释放后，该线程才会继续执行，然后就会又锁住了该对象



#### 线程-线程锁的实现
```java
public class Demo {
    public static void main(String[] arge) {
        A a = new A();
        Thread thread = new Thread(a);
        thread.start();
    }
}


class A implements Runnable  {
    @Override
    public void run() {
        B b = new B();
        b.demo1();
    }
}

class B {
    public synchronized void demo1() {
        System.out.println("demo1");
        this.demo2();
        synchronized (this) {
            System.out.println("局部锁");
        }
    }
    public synchronized void demo2() {
        System.out.println("demo2");
    }

    public void demo3() {
        System.out.println("由于这个没有上锁，所以即使demo1锁住了这个对象，其他线程也是能够调用该方法的");
    }
}
```


#### 线程-当前对象锁住别的对象（容易产生死锁问题）
- 只能借助局部锁，方法锁只能锁住当前对象
- 释放时间，为局部锁执行完成的时间
- 示范代码
```java
synchronized (this.demo) {
  this.demo.C(this.name);
}
```
- 上述代码，可以在任意类中写，作用是执行到这个地方，立马锁住指定的对象（demo）
- 如果当前对象已经被其他线程锁住，则在这个地方陷入等待，直到该对象释放，才会继续执行，然后锁住指定对象
  - 对象锁住后，其他线程就不能再执行该对象中带有安全锁的代码
  


#### 线程-线程锁的缺点
- 安全锁的使用，会出现一种死锁的现象，但是这种现象很难发生，具体看后面的介绍




#### 线程-线程的死锁
- 就是由于 `synchronized` 使用不当造成的
  - 使用局部锁，同时操作两个对象
  - 比如：线程1锁住了A，要想操作B。如果线程2刚好锁住了B，想要操作A，就产生了死锁的问题
    - 线程切换到1，一看B锁住了，就陷入等待
    - 线程切换到2，一看A锁住了，就陷入等待
    - 两个都进行等待过程，就造成了A、B永远不会解锁（执行不完，无法解锁），这样就陷入了永远的等待过程（两个线程永远结束不了）

- 示范代码
```java
// 线程类
public class Zhe extends Thread {
    // 两个共同的对象
    private A a;
    private B b;

    public Zhe() {};
    public Zhe(A a, B b) {
        this.a = a;
        this.b = b;
    };

    // 线程的入口函数
    public void run() {
        // 看看a有没有锁住，锁住等待，没有锁住执行，锁住a
        synchronized (this.a) {
            System.out.println("锁住A");
            // 如果另一个线程操作A，锁住了B，则下面的代码进入等待过程，另一个线程也进入等待过程，就产生了死锁现象

            // 看看b有没有锁住，锁住等待，没有锁住执行，锁住b
            synchronized (this.b) {
                System.out.println("锁住B");
            }
            // 执行完，释放b
        }
        // 执行完释放a
    }
}

```


#### 线程-死锁的解决方式
1. 产生时间差，避免同时拿到一个对象的操作权限，另一个却抢不到了，有了时间差，就可以给其他线程得到对象的操作权限，然后释放
2. 不操作同一个对象，就没有锁定的效果




#### 反射-反射机制的介绍
- 可以通过反射操作类和对象
- 反射一共有六个大类
  - `Class` -------- 用来描述类本身
  - `Package` -------- 用来描述类所属的包
  - `Field` -------- 用来描述类中的属性(共有的私有的都可能获取到，并且进行修改)
  - `Method` -------- 用来描述类中的方法
  - `Constructor` -------- 用来描述类中的构造方法
  - `Annotation` -------- 用来描述类中的注解





#### 反射-通过反射修改字符串
- 字符串底层是存在一个私有字符数组中，正常情况下无法获取这个数组，但是可以通过反射获取，然后修改数组，从而影响字符串
- 比如
  ```java
  public static void main(String[] arge) throws NoSuchFieldException, IllegalAccessException {
    String str = "abc";
    å// 通过反射获取私有属性value
    Class s = str.getClass();
    Field v = s.getDeclaredField("value");
    // 这个设置成 true，才能获取到私有属性
    v.setAccessible(true);

    // 获取集合 str 中的 value属性
    char[] value = (char[])v.get(str);
    // 修改
    value[1] = 'x';
    // 字符串发生了变化，打印 axc
    System.out.println( str );

    // 重新赋一个char集合
    v.set(str, new char[]{'重', '新'});
    // 字符串发生了变化，打印 重新
    System.out.println( str );
  }
  ```

#### 反射-通过反射机制获取类(Class)
- 通过反射，获取类，一共有三种方法
  ```java
  public static void main(String[] str) throws Exception {
    // 通过反射获取类_方式一
    Class clazz_1 = Class.forName("Ceshi");
    // 通过反射获取类_方式二
    Class clazz_2 = Ceshi.class;
    // 通过反射获取类_方式三
    Class clazz_3 = new Ceshi().getClass();

    System.out.println(clazz_1);
    System.out.println(clazz_2);
    System.out.println(clazz_3);
  }
  ```

.
- 三种方式的区别
  - Class.forName("包名.类名")
    - 会加载类中的静态元素
    - 可以使用该方法初始化一个类(加载静态元素，以便使用)，比如`Driver`
  - 类名.class
    - 不会加载类中的静态元素
  - 对象.getClass()
    - 这是Object上的一个方法

.
- Class中的常用方法
  - `int result = clazz.getModifiers();` 获取类的修饰符(权限 特征)
    - 每一个修饰符 用一个整数来进行表示
    - 0开始---0、1、2、4、8、16、32、64、128、256、512
      - 0--默认不写、1--public、2--private、4--protected
      - 8--static、16--final、32--synchronized、64--volatile
      - 128--transient、256--native、512--interface、1024--abstract
  - `String name = clazz.getName();`获取名字
  - `String simpleName = clazz.getSimpleName();`简单名
  - `Object obj = clazz.newInstance();`  默认调用无参数构造方法创建对象
  - `Class sclazz = clazz.getSuperClass(); `  获取超类(父类)
  - `Class[] classes = clazz.getInterface();` 获取接口



#### 反射-获取类所属包的信息(Package)
- 示范代码
  ```java
  public static void main(String[] str) throws Exception {
    // 首先获取Class
    Class clazz = Student.class;
    // 获取包名  domain.Student 
    String name = clazz.getName();

    System.out.println(name);
  }
  ```







#### 反射-通过反射操作类中的属性(Field)
- 公有属性，私有属性，父类公有属性都能获取到，但是调用的方法不同
  - 也包括静态属性
- 父类的私有属性是获取不到的
- 流程是先获取到类中有哪些属性，然后从这个类创建的对象中，获取该属性对应的值
  - 属性值是属于对象的，所以要借助一个对象
  - 而属性是属于类的
- 示范代码
  ```java
  import java.lang.reflect.Field;
  class Fuji {
    private String siyou = "父级_私有";
    public String gongyou = "父级_公有";
    public static String jingtai = "父级_静态";
  }
  class Ceshi extends Fuji {
    private String siyou_f = "子级_私有";
    public String gongyou_f = "子级_公有";
    public static String jingtai_f = "子级_静态";
  }

  public class Demo {
    public static void main(String[] arge) throws InstantiationException, IllegalAccessException {
      // 首先获取Class
      Class clazz = Ceshi.class;

      // 获取公有和父级公有属性
      Field[] fs = clazz.getFields();
      // 创建一个对象，便于获取数据
      //    clazz.getFields只能获取到所有的属性标记，要想获取具体的数据，首先要有一个对象，然后从这个对象中获取
      Ceshi ceshi = (Ceshi) clazz.newInstance();
      // 便利所有属性
      for(Field field : fs) {
        // 获取属性名
        System.out.println(field.getName());
        // 使用get方法，获取属性值
        System.out.println(field.get( ceshi ));
      }
      // 可以通过 Field f = clazz.getField("属性名"); 获取某个具体的属性


      // 获取自己的公有属性，和私有属性。继承类是获取不到的
      Field[] fx = clazz.getDeclaredFields();
      // 便利所有属性
      for(Field field : fx) {
        // 获取属性名
        System.out.println(field.getName());

        // 由于涉及到了私有属性值的获取，所以需要设置
        field.setAccessible(true);
        // 使用get方法获取属性值
        System.out.println(field.get( ceshi ));
      }
      // 可以通过 Field f = clazz.cgetDeclaredField("属性名"); 获取某个具体的属性
    }
  } 
  ```

.   
- Field类中的常用方法
  - `int a = f.getModifers()`：获取属性的修饰符
  - `Class a = f.getType()`：获取属性对应的类映射(Class)
    - 该方法，通常与 `.getSimpleName`连用，获取属性的类型
  - `String a = f.getName()`：获取属性名 
    - 获取到名字后，可以通过反射的方式，使用字符串拼接的方式，获取到对应的 `getXXX` 或者 `setXXX`方法，操作对应的属性
  - `f.set(该类创建的对象, 值)`：对属性进行重新赋值
  - `Object a = f.get(该类创建的对象)`：取某个属性的值，如果想要使用，需要进行造型
    - 如果想要通过set或者get操作私有属性，需要先设置 `f.setAccessable(true);`，否则会报错 
    - 可以通过它，修改字符串某一位的值，原理上是不可以的，属性是私有的，没有提供操作他的方法

.
- 获取对应属性的属性值(有两种方式)
  - 一种是通过 f.getName() 获取属性名
    - 然后使用字符串分析的方法，找到对应的 get 或者 set方法，进行执行，需要借助该类创建的对象(通过反射创建)
  - 一种是，通过 f.get() 或者 f.set() 操作属性。需要借助对象(通过反射创建)






#### 反射-通过反射获取类中的普通方法(Method)
- 方法的执行，也是依靠某个对象，所以不光要通过反射获取方法信息，还要利用反射创建出一个对象
  - 由于方法的执行，是依靠于对象，所以是可以使用对象中的属性与方法的。
  - 比如，依靠demo对象执行方法，就相当于 demo.fun(); 
- 公有方法，私有方法，父类公有方法都能获取到，但是调用的方法不同
  - 也包括静态方法
- 父类的私有方法是获取不到的

.
- 运行获取的方法
  - Object result = m.invoke(对象, 传递的参数);
    - 传入的对象，表示方法运行的时候，this指向那个对象
    - 如果传入的对象，没有即将运行的方法，也不会报错，只不过没有效果


.
- 测试代码
  ```js
  import java.lang.reflect.InvocationTargetException;
  import java.lang.reflect.Method;

  class Fuji {
      private String str = "张三";
      private void siyou_f() {
          System.out.println("父级的私有方法");
      }
      public void gongyou_f() {
          System.out.println("父集的公有方法");
          // 由于方法的执行，是依靠于对象，所以是可以使用对象中的属性与方法的
          System.out.println(this.str);
      }
      public static void jingtai_f() {
          System.out.println("父集的静态方法");
      }
  }

  class Ceshi extends Fuji {
      private void siyou() {
          System.out.println("子集的私有方法");
      }
      public void gongyou() {
          System.out.println("子集的公有方法");
      }
      public static void jingtai() {
          System.out.println("子集的静态方法");
      }
  }


  public class Demo {
      public static void main(String[] arge) throws InstantiationException, IllegalAccessException, InvocationTargetException {
          // 首先获取Class
          Class clazz = Ceshi.class;
          // 创建一个对象，便于执行对应的方法
          Ceshi ceshi = (Ceshi) clazz.newInstance();


          // 获取公有和父级公有方法，私有的获取不到（这种方式可以获取到Object上的方法）
          Method[] fs = clazz.getMethods();
          // 遍历
          for(Method method : fs) {
              // 执行对应的方法
              //    这种方式可以获取到Object上的方法，执行的时候需要进行判断，不执行Object上的方法
              if(method.getDeclaringClass().getName() == "java.lang.Object") continue;
              // 执行，依靠于对象进行执行
              method.invoke(ceshi);
          }
          // 获取某个具体的方法
          // 可以通过 Method f = clazz.getMethod("方法名", 参数类型.class, 参数类型.class, ···);
          // 因为方法有重载，所以，想要获取具体的一个方法，还需要指定对应的参数类型


          // 获取自己的公有方法，和私有方法。继承类是获取不到的
          Method[] fx = clazz.getDeclaredMethods();
          // 遍历所有方法
          for(Method method : fx) {
              // 如果是私有方法，是不允许调用的，需要进行下面的配置，才可以使用
              method.setAccessible(true);
              // 执行对应方法，依靠于对象进行执行
              method.invoke(ceshi);
          }
          // 获取某个具体的方法
          // 可以通过 Method f = clazz.getDeclaredMethod("方法名", 参数类型.class, 参数类型.class, ···);
          // 因为方法有重载，所以，想要获取具体的一个方法，还需要指定对应的参数类型
      }
  }
  ```

.
- 常用的方法
  - `int mm = m.getModifiers();`：获取方法的修饰符(权限+特征)
  - `Class mrt = m.getReturnType();`：获取返回值数据类型
  - `String mn = m.getName();`：获取方法的名字
  - `Class[] mpts = m.getParameterTypes();`：获取方法参数列表的类型
  - `Class[] mets = m.getExceptionTypes();`：获取方法抛出异常的类型 
  - `Class c = method.getDeclaringClass();`：获取方法所属的类映射 





#### 反射-通过反射获取构造方法(Constructor)
- 公有的构造方法，或者私有的构造方法都能获取，但是继承类是无法获取的
- 这样，就可以通过反射，获取到构造函数，然后创建对象。就不用非得通过new的方式创建对象了

- 获取构造方法的示范代码
  ```java
  import java.lang.reflect.Constructor;

  class Ceshi {
      public Ceshi() {
          System.out.println("无参构造方法");
      }

      private Ceshi(String s1) {
          System.out.println("有参私有构造方法");
      }

      public Ceshi(String s1, Integer i1, int i2) {
          System.out.println("有参公有构造方法");
      }
  }


  public class Demo {
      public static void main(String[] arge) throws NoSuchMethodException {
          // 首先获取Class
          Class clazz = Ceshi.class;

          // 获取所有的构造方法（只能获取公有的）
          Constructor[] cons = clazz.getConstructors();
          for(Constructor constructor : cons) {
              // 打印下名称
              System.out.println(constructor.getName());
          }

          //  获取所有的构造方法（公有的，私有的都能获取）
          Constructor[] conz = clazz.getDeclaredConstructors();
          for(Constructor constructor : conz) {
              // 打印下名称
              System.out.println(constructor.getName());
          }


          // 获取具体的构造方法（根据构造函数的参数类型，进行区分）
          Constructor con1 = clazz.getConstructor();  // 获取公有的无参构造方法
          System.out.println(con1);
          Constructor con2 = clazz.getDeclaredConstructor();  // 获取私有的或者公有的无参构造方法
          System.out.println(con2);
          Constructor con3 = clazz.getConstructor(String.class, Integer.class, int.class);  // 获取公有的有参构造方法（传入对应的数据类型）
          System.out.println(con3);
          Constructor con4 = clazz.getDeclaredConstructor(String.class);  // 获取私有的或者公有的有参构造方法（传入对应的数据类型）
          System.out.println(con4);
      }
  }
  ```


- 使用获取到的构造方法，创建出一个对象
  ```java
  import java.lang.reflect.Constructor;
  import java.lang.reflect.InvocationTargetException;

  class Ceshi {
      public Ceshi() {
          System.out.println("无参构造方法");
      }

      private Ceshi(String s1) {
          System.out.println("有参私有构造方法，参数为：" + s1);
      }

      public Ceshi(String s1, Integer i1, int i2) {
          System.out.println("有参公有构造方法，参数为：" + s1 + "、" + i1 + "、" + i2);
      }

      public void fun() {
          System.out.println("方法执行了");
      }
  }


  public class Demo {
      public static void main(String[] arge) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
          // 首先获取Class
          Class clazz = Ceshi.class;

          // 获取构造函数（私有的）
          Constructor con4 = clazz.getDeclaredConstructor(String.class);
          // 创建对象，由于构造函数是私有的，所以要进行下面的配置
          con4.setAccessible(true);
          // 构造一个对象，传入对应的参数
          Ceshi c1 = (Ceshi)con4.newInstance("张三");
          // 执行对象中的方法，查看是否创建成功
          c1.fun();

          // 获取构造函数（公有的）
          Constructor con3 = clazz.getConstructor(String.class, Integer.class, int.class);
          // 构造一个对象，传入对应的参数
          Ceshi c2 = (Ceshi)con3.newInstance("张三", 4, 5);
          // 执行对象中的方法，查看是否创建成功
          c2.fun();
      }
  }
  ```



- 常用的方法
  - `int mm = con.getModifiers();`：获取方法的修饰符(权限+特征)   
  - `String mn = con.getName();`：获取方法的名字 
  - `Class[] mpts = con.getParameterTypes();`：获取方法参数列表的类型
  - `Class[] mets = con.getExceptionTypes();`：获取方法抛出异常的类型  





#### 文件-File（建立与文件的映射，获取文件信息）
- 映射建立完成后，才能获取一些文件的信息
- 具体示范代码
  ```java
  public class Demo {
      public static void main(String[] args) {
          File file = new File("/Users/liushanzhuang/Desktop/ss");
          System.out.println(file);
      }
  }
  ```

- 常用方法
  - 获取文件的绝对路径：`String path = f.getAbsolutePath()`
  - 获取文件中字节的个数：`int a = f.length()`
    - 英文为一个字节，中文为两个字节，也包括换行符，空格
    - 比如一个文件中，只有 `ab你好`，没有换行符，则获取的字节长度为6
  - 获取文件最后修改的时间：`int t = f.lastModified()`
    - 结果是：毫秒值
  - 获取文件的名字：`String name = f.getName()`
    - 获取结果：包括后缀名
  - 获取当前file对象的父类file的名字，也就是上一级文件夹的名字：`String pname = f.getParent()` 
  - 获取上一级文件夹对象：`File file = f.getParentFile()`
    - 因为得到的也是一个File对象，所以就可以操作父文件夹了
  - 获取所有子文件的名字（文件夹和文件）：`String[] names = f.list()`
    - 如果是文件，则获取null
    - 如果是空文件夹，获取的是数组，但是数组的长度为0
    - 如果File中指定的文件不存在，则获取是null
  - 获取所有子文件的对象（文件夹和文件）：`File[] files = f.listFiles();`
    -  因为得到的是一个File，所以就可以操作子文件了
  - 删除一个空的文件夹或者一个文件，注意文件夹必须是一个空文件夹才能删除：`boolean b = f.delete()`
    - 要想删除非空文件夹，需要先删除子文件，在删除该文件夹


#### 文件-File（创建文件夹）
- 共有两个方法，创建文件夹
  - `boolean b = file.mkdir(); `：创建新的文件夹（父文件夹没有，不能创建）
  - `boolean b = file.mkdirs();`：创建新的文件夹（父文件夹没有，可以创建，会自动创建出父文件夹）

- 创建失败不会报错，只不过返回false，所以，需要根据返回值类型来判断文件夹是否创建成功，创建成功才能进行后续操作（操作该文件夹）


- 具体示范代码
  ```java
  public class Demo {
      public static void main(String[] args) {
          // 是没有 a 这个文件夹的
          File file1 = new File("/Users/liushanzhuang/Desktop/ss/a/b");
          boolean boo1 = file1.mkdirs();
          System.out.println(boo1);   // true，创建成功（自动创建了父文件夹）

          // 是没有 c 这个文件夹的
          File file2 = new File("/Users/liushanzhuang/Desktop/ss/c/d");
          boolean boo2 = file2.mkdir();
          System.out.println(boo2);   // false，创建失败（没有父文件夹，所以创建失败）
      }
  }
  ```




#### 文件-File（创建文件）
- 要想创建一个文件，则文件所处的文件夹必须存在，否则创建失败，创建失败是会报错的（和创建文件夹不一样）
- 利用方法：`boolean b = file.createNewFile();` 进行创建


- 具体示范代码
  ```java
  public class Demo {
      public static void main(String[] args) throws IOException {
          // 有 ss 这个文件夹
          File file1 = new File("/Users/liushanzhuang/Desktop/ss/b.txt");
          boolean boo1 = file1.createNewFile();
          System.out.println(boo1);   // true，创建成功

          // 是没有 c 这个文件夹的（报错）
          File file2 = new File("/Users/liushanzhuang/Desktop/ss/c/b.txt");
          boolean boo2 = file2.createNewFile();
          System.out.println(boo2);   
      }
  }
  ```





#### 文件-FileReader-（字符型文件流-输入流-低级流）
- 输入流的意思就是，流入这个对象，也就是读文件（并不是流入文件）
- 只要流没有关闭，则每次读取都会接着上次的进行读取
- 由于是字符型文件流，所以只能读取文本文件（像图片视频等等，只能用字节型文件流操作）

.
- 使用示范代码（一次读取一个字符）
  - 返回结果是int类型，如果读取结束（没有内容了），返回的就是 -1，可以利用这个判断文件是否读取完成了
  - 如果只是想要获取某个字符，可以直接造型成char类型
    - 但是，如果通过while读取文件中所有的内容，就不能造型，因为要使用到 -1 来判断文件是否读取完成
    - 如果硬要造型也没有问题，最后得到的是 `''`，转换成 int 类型就是 65535。也可以利用 65535 进行判断是否读取完成
  - 代码示范
    ```java
    public class Demo {
        public static void main(String[] args) throws IOException {
            // 与文件建立关系
            File file = new File("/Users/liushanzhuang/Desktop/ss/b.txt");
            // 创建输入流
            FileReader fileReader = new FileReader(file);
            // 也可以不借助 File，直接传入路径，比如
            //  FileReader fileReader = new FileReader("/Users/liushanzhuang/Desktop/ss/b.txt");

            // 利用输入流读取文件数据（每次读一个）
            //    返回结果是 int 类型的，字符的编码（可以转一下类型）
            char c1 = (char)fileReader.read();
            // 接着上面的读取，在读一个（只要流没关闭，则每次读取都是从接着往后读）
            char c2 = (char)fileReader.read();
            System.out.println(c1);
            System.out.println(c2);

            // 读取所有内容，如果读取完成，则返回的int结果就是 -1
            while (true) {
                int c = fileReader.read();
                // 判断是否读取结束（说明已经读取完成）
                if (c == -1) break;

                // 因为要判断是否读取完成，所以上面就不能造型，要想看到具体的字符，就需要手动转换一下
                System.out.println(new Character((char) c));
            }

            // 操作完，一定要关闭流（正常情况下，放在finally中，防止上面操作报错，从而导致流没有关闭，保证代码健壮性）
            fileReader.close();
        }
    }
    ```

.
- 使用示范代码（一次读取一批字符，通常一次都是读取1024）
  - 传参：一个 char 类型的数字
    - 每次读取一批，读取出的一批字符，就会放入传入的数组中，从第0位开始放
    - 需要注意的是：他不会清空数组，而是把字符，直接放入对应的位数
      - 比如：本次读取出的第一个字符：`c[0] = `
      - 比如：本次读取出的第二个字符：`c[1] = `
      - 如果下次再读，依旧从第0位开始放置（因为这是新的一批了）
      - 造成的现象（数组不清空）
        ```java
        public class Demo {
            public static void main(String[] args) throws IOException {
                FileReader fileReader = new FileReader("/Users/liushanzhuang/Desktop/ss/b.txt");

                // 利用输入流读取文件数据（每次读9个字节，共10个）
                char[] cs = new char[9];
                int c1 = fileReader.read(cs);  // 得到的有效个数 9，本次读取都有效
                System.out.println(cs);        // 打印 abdss你好dd
                System.out.println(c1);        // 打印 9

                // 接着上面的读取，在读9个字节（只要流没关闭，则每次读取都是从接着往后读）
                int c2 = (char)fileReader.read(cs);   // 得到的有效个数 1，因为只有10个字符，上次读了9个，所以还剩一个
                System.out.println(cs);               // 打印 sbdss你好dd，因为只读取一个，所以 cs[0] = 's'，其他的不在管了，不会清空数组，所以剩下的就是上次读的内容（用的是同一个数组）
                System.out.println(c2);               // 打印 1

                // 操作完，一定要关闭流（正常情况下，放在finally中，防止上面操作报错，从而导致流没有关闭，保证代码健壮性）
                fileReader.close();
            }
        }
        ```

  - 返回值：int类型，标记本次读取的有效个数（利用这个值，截取数组，就可以得到有效的文件数据）
    - 比如传入的数组长度是1024，但是有效的只有8个（从文件中就读出8个字符），则返回值就是8
    - 如果一个有效的都没有（上一次已经读取完了），则返回值就是 65535，可以利用这个值来判断是否读取完成
  - 示范代码（循环读取所有内容）
    ```java
    public class Demo {
        public static void main(String[] args) throws IOException {
            // 与文件建立关系
            File file = new File("/Users/liushanzhuang/Desktop/ss/b.txt");
            // 创建输入流
            FileReader fileReader = new FileReader(file);
            // 也可以不借助 File，直接传入路径，比如
            //  FileReader fileReader = new FileReader("/Users/liushanzhuang/Desktop/ss/b.txt");

            // 定义一个数组，接受字符
            char[] cs = new char[3];
            // 定义一个字符串，拼接读取出来的内容，合成文件内容
            String str = "";

            while (true) {
                int i = fileReader.read( cs );
                // 判断是否读取完成（有效内容小于数组长度，也说明本次读取完成了）
                if (i == 65535 || i < cs.length) {
                    // 如果还有长度，说明这次读取出来了有效内容，需要拼接一下
                    //    注意：只获取有效的数据
                    if (i < cs.length) str += new String(Arrays.copyOf(cs, i));
                    break;
                }

                str += new String(cs);
            }
            System.out.println(str);


            // 操作完，一定要关闭流（正常情况下，放在finally中，防止上面操作报错，从而导致流没有关闭，保证代码健壮性）
            fileReader.close();
        }
    }
    ```
  





#### 文件-FileWriter-（字符型文件流-输出流-低级流）
- 输出流的意思就是，流出这个对象（流入文件），也就是写文件
- 由于是字符型文件流，所以只能写文本文件（像图片视频等等，只能用字节型文件流操作）

.
- 测试代码
  ```java
  public class Demo {
      public static void main(String[] args) throws IOException {
          // 与文件建立关系
          File file = new File("/Users/liushanzhuang/Desktop/ss/b.txt");
          // 创建输出流
          FileWriter fileWriter = new FileWriter(file);
          // 也可以不借助 File，直接传入路径，比如
          //  FileWriter fileWriter = new FileWriter("/Users/liushanzhuang/Desktop/ss/b.txt");

          try {
              // 刚开始写，会先清空原文件的内容，然后在进行写入操作

              // 往管道中写内容（其实就是写入文件，管道中的内容会逐步往文件中写）
              fileWriter.write('测');
              // 继续往管道中写内容（其实就是写入文件，管道中的内容会逐步往文件中写）
              fileWriter.write('s');
              // 继续往管道中写，int类型的数据，会自动转换成 char 类型的数据，当然也可以手动转化
              fileWriter.write(45);
              // 继续往管道中写，char[]类型的数据，直接写一堆数据（int类型的数组就不行了，必须是char类型的数组，int的单个数据可以）
              fileWriter.write(new char[]{'d', '呵'});

              // 把管道中的内容，写入文件中，并且更新文件，该方法可以不写，但是通常加上
              fileWriter.flush();
          }
          finally {
              // 操作完，一定要关闭流（正常情况下，放在finally中，防止上面操作报错，从而导致流没有关闭，保证代码健壮性）
              fileWriter.close();
          }
      }
  }
  ```
- 为什么往管道中写数据
  - 因为，往文件中写内容是很慢的（相对而言），java的执行速度很快
  - 所以为了不造成阻塞，就把数据先放到管道中，然后管道会慢慢的逐步把管道的内容写入文件中（这是同步执行的）
  - 所以最后调一下 fileWriter.flush();，就是为了防止管道的数据有遗漏的





#### 文件-FileInputStream-（字节型文件流-输入流-低级流）
- 输入流的意思就是，流入这个对象，也就是读文件（并不是流入文件）
- 只要流没有关闭，则每次读取都会接着上次的进行读取
- 由于是字节型文件流，所以操作文本文件时要注意，中文是两个字节，所以在读取的时候有可能分开（最好用字符型文件流）
  - 比如：就读4个字符，但是前三个是英文，第四个是中文，这样，中文字符就只读取了一半，指定出现问题

.
- 使用示范代码（一次读取一个字节，如果有中文，就会乱码）
  - 因为中文有两个字节，但是只获取一个，下一次在获取另一个，指定乱码
  - 返回结果是int类型，如果读取结束（没有内容了），返回的就是 -1，可以利用这个判断文件是否读取完成了
  - 如果只是想要获取某个字节，可以直接造型成char类型
    - 但是，如果通过while读取文件中所有的内容，就不能造型，因为要使用到 -1 来判断文件是否读取完成
    - 如果硬要造型也没有问题，最后得到的是 `''`，转换成 int 类型就是 65535。也可以利用 65535 进行判断是否读取完成
  - 代码示范
    ```java
    public class Demo {
        public static void main(String[] args) throws IOException {
            // 与文件建立关系
            File file = new File("/Users/liushanzhuang/Desktop/ss/b.txt");
            // 创建输入流
            FileInputStream fileInputStream = new FileInputStream(file);
            // 也可以不借助 File，直接传入路径，比如
            //  FileInputStream fileInputStream = new FileInputStream("/Users/liushanzhuang/Desktop/ss/b.txt");

            // 利用输入流读取文件数据（每次读一个）
            //    返回结果是 int 类型的，字符的编码（可以转一下类型）
            char c1 = (char)fileInputStream.read();
            // 接着上面的读取，在读一个（只要流没关闭，则每次读取都是从接着往后读）
            char c2 = (char)fileInputStream.read();
            System.out.println(c1);
            System.out.println(c2);

            // 读取所有内容，如果读取完成，则返回的int结果就是 -1
            while (true) {
                int c = fileInputStream.read();
                // 判断是否读取结束（说明已经读取完成）
                if (c == -1) break;

                // 因为要判断是否读取完成，所以上面就不能造型，要想看到具体的字符，就需要手动转换一下
                System.out.println(new Character((char) c));
            }

            // 操作完，一定要关闭流（正常情况下，放在finally中，防止上面操作报错，从而导致流没有关闭，保证代码健壮性）
            fileInputStream.close();
        }
    }
    ```

.
- 使用示范代码（一次读取一批字节，通常一次都是读取1024）
  - 传参：一个 byte 类型的数字
    - 为什么是 byte 的数组呢，因为一个字节 8 位，正好是 byte 的取值范围，所以 byte 就够用了，于是就限制了类型是 byte
      - 不能使用 char 类型的数据，范围过大，造型成 byte 可能会丢失数据（由高转低精度，是无法自动转化的，所以报错）
      - 除非强制转换成 byte 类型的数据
    - 每次读取一批，读取出的一批字节，就会放入传入的数组中，从第0位开始放
    - 需要注意的是：他不会清空数组，而是把字节，直接放入对应的位数
      - 比如：本次读取出的第一个字节：`c[0] = `
      - 比如：本次读取出的第二个字节：`c[1] = `
      - 如果下次再读，依旧从第0位开始放置（因为这是新的一批了）
      - 造成的现象（数组不清空）
        ```java
        public class Demo {
            public static void main(String[] args) throws IOException {
                FileInputStream FileInputStream = new FileInputStream("/Users/liushanzhuang/Desktop/ss/b.txt");

                // 利用输入流读取文件数据（每次读9个字节，共10个）
                byte[] cs = new byte[9];
                int c1 = FileInputStream.read(cs);  // 得到的有效个数 9，本次读取都有效
                System.out.println(cs);        // 打印 abdss你好dd
                System.out.println(c1);        // 打印 9

                // 接着上面的读取，在读9个字节（只要流没关闭，则每次读取都是从接着往后读）
                int c2 = (char)FileInputStream.read(cs);   // 得到的有效个数 1，因为只有10个字符，上次读了9个，所以还剩一个
                System.out.println(cs);               // 打印 sbdss你好dd，因为只读取一个，所以 cs[0] = 's'，其他的不在管了，不会清空数组，所以剩下的就是上次读的内容（用的是同一个数组）
                System.out.println(c2);               // 打印 1

                // 操作完，一定要关闭流（正常情况下，放在finally中，防止上面操作报错，从而导致流没有关闭，保证代码健壮性）
                FileInputStream.close();
            }
        }
        ```

  - 返回值：int类型，标记本次读取的有效个数（利用这个值，截取数组，就可以得到有效的文件数据）
    - 比如传入的数组长度是1024，但是有效的只有8个（从文件中就读出8个字节），则返回值就是8
    - 如果一个有效的都没有（上一次已经读取完了），则返回值就是 -1，可以利用这个值来判断是否读取完成
  - 示范代码（循环读取所有内容）
    ```java
    public class Demo {
        public static void main(String[] args) throws IOException {
            // 与文件建立关系
            File file = new File("/Users/liushanzhuang/Desktop/ss/b.txt");
            // 创建输入流
            FileInputStream fileInputStream = new FileInputStream(file);
            // 也可以不借助 File，直接传入路径，比如
            //  FileInputStream fileInputStream = new FileInputStream("/Users/liushanzhuang/Desktop/ss/b.txt");

            // 定义一个数组，接受字符
            byte[] cs = new byte[3];
            // 定义一个字符串，拼接读取出来的内容，合成文件内容
            String str = "";

            while (true) {
                int i = fileInputStream.read( cs );
                // 判断是否读取完成（有效内容小于数组长度，也说明本次读取完成了）
                if (i == -1 || i < cs.length) {
                    // 如果还有长度，说明这次读取出来了有效内容，需要拼接一下
                    //    注意：只获取有效的数据
                    if (i !== -1 && i < cs.length) str += new String(Arrays.copyOf(cs, i));
                    break;
                }

                str += new String(cs);
            }
            System.out.println(str);


            // 操作完，一定要关闭流（正常情况下，放在finally中，防止上面操作报错，从而导致流没有关闭，保证代码健壮性）
            fileInputStream.close();
        }
    }
    ```
  





#### 文件-FileOutputStream-（字符型文件流-输出流-低级流）
- 输出流的意思就是，流出这个对象（流入文件），也就是写文件
- 由于是字节型文件流，所以操作文本文件时要注意，中文是两个字节，写的时候有可能乱码（最好用字符型文件流）

.
- 测试代码
  ```java
  public class Demo {
      public static void main(String[] args) throws IOException {
          // 与文件建立关系
          File file = new File("/Users/liushanzhuang/Desktop/ss/b.txt");
          // 创建输出流
          FileOutputStream fileOutputStream = new FileOutputStream(file);
          // 也可以不借助 File，直接传入路径，比如
          //  FileOutputStream fileOutputStream = new FileOutputStream("/Users/liushanzhuang/Desktop/ss/b.txt");

          try {
              // 刚开始写，会先清空原文件的内容，然后在进行写入操作

              // 往管道中写内容（其实就是写入文件，管道中的内容会逐步往文件中写）
              fileOutputStream.write('测');
              // 继续往管道中写内容（其实就是写入文件，管道中的内容会逐步往文件中写）
              fileOutputStream.write('s');
              // 继续往管道中写，int类型的数据，会自动转换成 char 类型的数据，当然也可以手动转化
              fileOutputStream.write(45);
              // 继续往管道中写，byte[]类型的数据，直接写一堆数据（int类型的数组就不行了，必须是byte类型的数组，int的单个数据可以）
              //    因为一个字节 8 位，正好是 byte 的取值范围，所以 byte 就够用了，于是就限制了类型是 byte
              //    char 和 数字 混用没事，会自动转换（当然范围不能超过，比如中文）
              fileOutputStream.write(new byte[]{'b', 'a', 9});

              // 把管道中的内容，写入文件中，并且更新文件，该方法可以不写，但是通常加上
              fileOutputStream.flush();
          }
          finally {
              // 操作完，一定要关闭流（正常情况下，放在finally中，防止上面操作报错，从而导致流没有关闭，保证代码健壮性）
              fileOutputStream.close();
          }
      }
  }
  ```
- 为什么往管道中写数据
  - 因为，往文件中写内容是很慢的（相对而言），java的执行速度很快
  - 所以为了不造成阻塞，就把数据先放到管道中，然后管道会慢慢的逐步把管道的内容写入文件中（这是同步执行的）
  - 所以最后调一下 fileWriter.flush();，就是为了防止管道的数据有遗漏的




#### 范型
- 范型的作用
1. 灵活的进行类型约束，在使用的时候，动态指定。

.
- 用法
1. `泛型类`
	1. 类定义的时候描述某种数据类型，集合的使用就是这样
    2. 这样整个类中都可以使用，该范型进行类型的约束
2. `泛型接口`
	1. 与泛型类的使用基本一致，子类实现接口时必须添加泛型
3. `泛型方法`
   1. 方法调用时传参数 ，方法的泛型与类无关 ， 带有泛型的方法可以不放在带有泛型的类中
   2. 范型，放在修饰符的后面，返回值的前面，使用时，在 `.` 的后面，方法名前面指定范型所代表的类型
   3. 只能方法内部使用
   4. 比如：`public <E> void a( E d ) {}`，使用方式`obj.<String>a( "abc" )`
4. `高级泛型`  规范边界  `extends`，`super`
   1. 指定范型时，指定的类型，必须是`extends`后面跟的类型的子类或者本身，不能超出这个范围
   2. 就是进行了约束

5. 如果范型没有指定，则类型为 `Object`



#### 多态
1. Java面向对象的四大特性
   1. 继承  封装  多态  (抽象)

2. 多态
   1. 同一个对象 体现出来的多种不同形态(身份)  将一种行为表现出不同的效果
   2. 要想实现多态的效果 需要现有继承关系

3. 多态的体现:
   1. 父类类型的引用  指向  子类的对象
	  1. Person p = new Teacher();
   2. 该引用只能调用父类中定义的属性或方法
   3. 如果子类中将父类的方法重写，那么调取方法后执行的结果是子类重写之后的那个结果
	  1. 如果父类与子类有同名的属性，执行父类的属性
	  2. 如果父类与子类有同名的方法(重载)，执行子类重写之后的方法
   4. 若想要调用子类中独有的成员
	  1. (强制类型转化)  造型 铸型  (向上/向下转型)
   5. 造型时(强制向下转型时) 可能会出现一个运行时异常
	  1. ClassCastException   造型  铸型 异常
	  2. 如果想要避免造型的异常  可以用instanceof关键字来进行判断
	  3. `对象  instanceof  类`

	

#### 执行时常见的错误
1. InputMismatchException 输入不匹配
2. NumberFormateException   数字格式化异常
3. ArrayIndexOutOfBoundsException  数组索引越界
4. NegativeArraySizeException   数组长度负数
5. NullPointerException  空指针异常
6. ArithmeticException  算数异常
7. ClassCastException   造型异常  将对象的类型还原时  与真实类型不匹配
8. StackOverflowError  栈内存溢出错误