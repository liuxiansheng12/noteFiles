<script src='/笔记/see/index.js'></script>
[toc]


#### join方法的作用
- join的作用，就是挂起当前的线程
  - 底层也是用 wait 实现的线程挂起
- **线程的挂起，只能通过另一个线程对象，挂起当前线程**
  - 因为 join 方法，是线程对象上的一个方法，所以只能线程对象使用，但是当前线程肯定不能挂起当前线程，所以只能通过别的线程挂起当前线程
  - 比如 A 线程想要通过join挂起
    - 在 A 线程中，运行另一个线程的join方法，就会挂起当前A线程

.
- 使用方式
  - 不传递参数或者传递0
    - 功能：当前线程执行完毕后，会自动唤醒该线程挂起的线程
    - 比如：有两个线程 A 和 B
      - A 线程想要通过 join 挂起，只能使用 B.join()，这样 A 线程就会被挂起，这样就会切换到 B 线程执行
      - 只有当 B 线程执行结束，A线程才会被唤醒
  - 如果传递具体的数据，则时间过后，被挂起的线程会自动唤醒（单位ms）

.
- **注意点**
  - join挂起的线程，是无法通过 notifyAll 进行唤醒的（只能自动唤醒，定时唤醒）（底层代码决定的）
    - 使用 notifyAll 唤醒线程后，当时间碎片切换到这个唤醒的线程后，开始执行，然后就会立刻挂起
    - 所以，无法通过 notifyAll 唤醒 join 挂起的线程


.
示范代码

```java
// 线程一的类（使用join，挂起当前线程）
public class CeshiOne implements Runnable {
    private String name;
    // 保存一个线程，使用它的join方法（因为 join 只能通过另一个线程对象，挂起当前线程）
    private Thread ceshiTwo;


    // 重写线程方法
    public void run() {
        System.out.println("使用线程二，挂起当前线程");
        try {
            // 当线程二结束的时候，会自动释放
            ceshiTwo.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("释放了");
    }

    // 保存线程2的对象，用他来挂起当前线程
    public void setCeshiTwo(Thread ceshiTwo) {
        this.ceshiTwo = ceshiTwo;
    }
}

// 创建线程
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建对象
        CeshiOne o1 = new CeshiOne("线程一");
        CeshiTwo o2 = new CeshiTwo("线程二");

        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        Thread x2 = new Thread(o2);
        // 传入对应的线程对象（用来挂起线程）
        o1.setCeshiTwo(x2);

        // 线程进入准备状态
        x1.start();
        x2.start();
    }
}
```

#### 借助join，可以把多线程实现为单线程的效果
- 原理
  - A线程中创建B线程，然后马上利用B线程挂起
  - B线程中创建C线程，然后马上利用C线程挂起
  - 这样 A线程 和 B线程就会立即停止，然后C执行
    - 由于 B 线程是 C挂起的，所以C执行完，B就开始执行
    - 由于 A 线程是 B挂起的，所以B执行完，A就开始执行
    - 这样，执行顺序就是 C --> B --> A，并且是一个一个执行的，达到了单线程执行的效果

- 示范代码
```java
public class A extends Thread{
    public void run() {
        // 创建b线程
        B b = new B();
        b.start()
        // 立刻挂起a线程，还没有执行后面的功能
        b.join();
    }
}
public class B extends Thread{
    public void run() {
        // 创建c线程
        C c = new C();
        c.start()
        // 立刻挂起b线程，还没有执行后面的功能
        c.join();
    }
}
public class C extends Thread{
    public void run() {

    }
}

// 主函数，创建线程（创建A线程就可以）
//    如果三个线程都在这里创建然后采用传入的方式挂起线程，是不合适的
//    因为线程的执行顺序不可控，如果B先执行，B就挂起了，然后A执行的时候就无法挂起了
public static void main(String[] args) {
    A a = new A();
    a.start();
}
```




#### join方法的底层源码（无法通过notifyAll唤醒的原因）
- 无法通过notifyAll唤醒的原因
  - 就是因为底层使用了 while
  - 即使唤醒后，由于唤醒条件不满足，所以还是处于 while 中，然后就又被挂起了

- 具体代码分析
```java
// 不传递时间，底层会自动赋成0
if (millis == 0) {
    // isAlive 判断线程是否执行完成
    //    因为 join 是通过 线程.join 挂起的。所以 isAlive() 就相当于 线程.isAlive()
    //    所以判断的是另一个线程是否执行完成，即 A 通过 B挂起，这个地方判断就是B线程是否执行完成
    //    如果没有执行完成，继续陷入挂起
    // 所以，通过notifyAll唤醒后或者自动唤醒后，都还是处于 while 中，会继续进行条件判断
    //    如果条件满足，说明挂起线程还没有执行完，是notifyAll唤醒的，然后就又陷入沉睡了
    //    所以无法通过 notifyAll 唤醒
    while (isAlive()) {
        wait(0);
    }
} 
else {
    // 这个的左右上面介绍了
    while (isAlive()) {
        // 求时间差
        //    millis是传入的时间，now是当前时间与刚开始挂起的时间差
        long delay = millis - now;
        // 如果时间差大0，说明唤醒的时间-挂起的时间 < 设置的时间
        //    证明是 notifyAll 唤醒的，然后往后执行，继续挂起
        // 如果小于等于0，说明唤醒的时间-挂起的时间 >= 设置的时间，说明时间到了，不再挂起
        if (delay <= 0) {
            break;
        }
        wait(delay);
        // 得到唤醒的时间-挂起的时间，然后就会回到上面执行，进行判断
        //    因为，走到这一步说明刚被唤醒，还在 whild 中
        //    如果whild的条件满足，就进行时间判断
        //    如果条件不满足说明另一个线程已经执行完了
        //    当前线程也就不再进行挂起（不执行上面的代码，唤醒后就不再被挂起）
        now = System.currentTimeMillis() - base;
    }
}
```