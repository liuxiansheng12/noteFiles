<script src='/笔记/see/index.js'></script>
[toc]

#### 线程的挂起
- 借助 wait 方法，进行线程的挂起（有两种使用方式）
  - 不传递参数，或者传递0，只能手动唤醒
  - 传递数字，表示多少秒后，自动唤醒

- wait 必须放在 synchronized 中进行线程的挂起（否则会报错）

- 比如：
  ```java
    class A {
        public synchronized void b() throws InterruptedException {
            // 线程的挂起
            this.wait(0);
        }
    }
  ```

- 如果，某个线程，正在操作某个对象，并且带有安全锁，此时这个对象就被锁住
  - 如果此时，线程被挂起，则锁住的对象立即释放
  - 如果线程被唤醒，继续从上次挂起的位置往后执行（还是安全锁中，因为是在安全锁的函数中挂起的），此时对象还是会被锁住的


#### 线程的唤醒
- 必须放在 synchronized 中进行线程的唤醒（否则会报错）
- 借助两个方法，都可以实现线程的唤醒
  - notify（随机唤醒一个线程，无法控制）
  - notifyAll（唤醒当前对象挂起的所有线程）
- 线程释放后，也不是立即执行，也是等着时间碎片的分配，才能执行
- 比如：
  ```java
    class A {
        public synchronized void b() throws InterruptedException {
            // 线程的唤醒
            this.notifyAll();
        }
    }


#### 线程的挂起和唤醒只能在同一个对象中进行
- 挂起和唤醒和对象挂钩，某个对象挂起的线程，只能由该对象进行唤醒（该对象无法唤醒其他对象挂起的线程）
  - 比如 A 对象挂起了 a线程。则 a线程必须由 A对象 进行释放

- 比如
```java
public class Demo {
    public static void main(String[] str) throws Exception {
        // 创建一个对象，用来线程的挂起和释放
        Gong gong = new Gong();
        // 两个线程都传入 共同的对象
        //    因为对象挂起的线程，只能通过该对象释放，并且一个线程挂起只能用另一个线程释放
        //    或者自动释放
        // 比如：线程1 被 gong 对象挂起，则只能通过 gong对象释放，并且只能借助另一个线程释放
        //    所以，线程2也要传入 gong 对象，这样才能唤醒 线程1
        CeshiTwo o1 = new CeshiTwo("线程一", gong);
        CeshiOne o2 = new CeshiOne("线程二", gong);
        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        Thread x2 = new Thread(o2);
        // 线程启动
        x1.start();
        x2.start();


        // 线程的挂起和释放不用同一个对象
        //    这样，线程1挂起，线程2是无法唤醒线程1的
        //    因为：线程的挂起和唤醒，用的不是同一个对象
        //    这样就会造成，线程1挂起后，就无法唤醒了
        CeshiTwo o1 = new CeshiTwo("线程一", new Gong());
        CeshiOne o2 = new CeshiOne("线程二", new Gong());
        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        Thread x2 = new Thread(o2);
        // 线程启动
        x1.start();
        x2.start();
    }
}
```



#### 线程的挂起和唤醒必须在安全锁函数中进行实现
- 如果调用的方法，没有添加安全锁，则在使用的过程中，就会报出 IllegalMonitorStateException 的错误
  - 比如
  ```java
    class A {
        // 调用 b 方法，由于没有添加 synchronized 所以在执行的时候就会报错
        public void b() throws InterruptedException {
            this.wait(0);
        }
    }
  ```

- 线程必须在安全锁中进行挂起和唤醒的原因（避免一个线程永远的被挂起）
  - 由于线程挂起后，就不在进行工作，所以挂起的线程要想唤醒，必须在另一个线程中进行
  - 所以线程的挂起和唤醒，是多个线程配合使用的
    - 当某个线程挂起后，另一个线程满足条件后，在把这个线程唤醒
  - 而线程的切换，我们是控制不了的
    - 假设，一个线程将要被挂起，但是还没有挂起，如果这个时候线程切换到了另外一个，而这时如果满足了唤醒的条件，就会唤醒线程（但是线程并没有挂起）。
    - 当线程切回挂起的代码后，线程才被挂起（但是此时唤醒的代码已经执行完了，所以这个线程就有可能永远的被挂起）
  - 加了 synchronized，就会变得不一样
    - 由于挂起和唤醒必须在同一个对象中（即同一个类中）
    - 当执行到挂起的代码后（还没有挂起），线程切换走了，如果此时满足了唤醒的条件，执行到唤醒代码，由于这个对象已经被挂起锁住了，所以唤醒代码就会陷入等待
    - 直到挂起代码执行完成，线程被挂起，对象才会被释放
    - 然后唤醒代码才会继续执行（而此时线程已经被挂起了），所以正常唤醒
    - **先挂起后唤醒，这样就避免了线程永远被挂起的问题**
      - 如果先唤醒后挂起（也会造成线程永远被挂起），但这就是代码设计的问题了
.
- 根据以上原因，java为了防止某个线程一挂不起，所以强制要求线程的挂起和唤醒必须放在 synchronized 中执行，否则就会报错






#### 假死状态
- 线程的挂起，可能造成假死的状态
  - 即某个线程挂起，但是却没有被释放，最后程序就会陷入等待阶段，一直等下去









#### 设置线程的优先级
- 优先级高的可能能更快的获取到时间碎片进行执行（只是可能，提高了一些概率，并不是一定）
- 借助 setPriority 方法实现
  - 如果两个线程同时被唤醒，但是想要某个线程优先执行(比较重要)，即优先获取资源，就可以使用该方法
- 在创建线程的时候，就设置好

- 示范代码
```java
public class Demo {
    public static void main(String[] args) {
        Ceshi ceshi = new Ceshi();
        // 创建线程对象
        Thread thread = new Thread(ceshi);
        // 在创建线程的时候，就进行设置
        thread.setPriority(5);

        // 启动线程
        ta.start();
    }
}
```




