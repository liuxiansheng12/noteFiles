<script src='/笔记/see/index.js'></script>
[toc]


#### 线程是什么
- 程序，可以理解为是一组静态的代码
- 进程，正在进行的程序、静态的代码，运行起来
- 线程，正在执行程序中的小单元

- 服务器就是利用线程思想做的
  - 当请求来临后，就创建一个线程对象，传入请求报文进行解析
  - 然后，使用start，让处理请求的run方法，进入执行的准备状态，准备执行



#### 线程的定义与使用（方式一）
- 通过继承Thread类，然后重写run方法实现
```java
// 类一
public class CeshiOne extends Thread {
    private String name;
    public CeshiOne(String name) {
        this.name = name;
    }

    @Override
    // 重写线程方法
    public void run() {
        for(int i = 0; i < 1000; i ++) {
            System.out.println(this.name + "：" + i);
        }
    }
}

// 主函数（让线程进入准备阶段）
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建一个线程对象
        CeshiOne x1 = new CeshiOne("线程一");
        // 构建一个线程对象（一个类可以起多个线程，他们之间互补干扰）
        CeshiOne x2 = new CeshiOne("线程二");
        // 构建一个线程对象
        CeshiTwo x3 = new CeshiTwo("线程三");

        // 线程进入准备状态
        //    也就是 对象中的run进行执行前的准备状态
        //    当拿到时间碎片后，就开始执行
        x1.start();
        x2.start();
        x3.start();
    }
}
```


#### 线程的定义与使用（方式二）
- 通过实现Runnable接口，然后重写run方法实现
```java
// 类一
public class CeshiOne implements Runnable {
    private String name;
    public CeshiOne(String name) {
        this.name = name;
    }

    // 重写线程方法
    public void run() {
        for(int i = 0; i < 1000; i ++) {
            System.out.println(this.name + "：" + i);
        }
    }
}


// 主函数（让线程进入准备阶段）
public class Demo {
    public static void main(String[] str) throws Exception {
        // 构建对象
        CeshiOne o1 = new CeshiOne("线程一");
        CeshiOne o2 = new CeshiOne("线程二");
        CeshiTwo o3 = new CeshiTwo("线程三");

        // 把对象包装成线程对象
        Thread x1 = new Thread(o1);
        // 构建一个线程对象（）
        Thread x2 = new Thread(o2);
        // 构建一个线程对象
        Thread x3 = new Thread(o3);

        // 线程进入准备状态
        //    也就是 对象中的run进行执行前的准备状态
        //    当拿到时间碎片后，就开始执行
        x1.start();
        x2.start();
        x3.start();
    }
}
```


#### 线程的执行原理
- 无论是方式一还是方式二，run方法是核心（相当于入口函数）

.
- 线程是操作系统级别的，我们控制不了，受电脑的cpu进行控制
  - 当线程准备好后，就等着时间碎片的来临
  - 当某个线程拿到时间碎片后，重写的run方法就开始执行（线程程序启动）
    - 所以run方法的执行是cpu控制的
  - 当线程执行一段时间后，时间碎片就会切换到其他线程，当前线程就失去了时间碎片，于是停止执行
  - 当另一个线程拿到时间碎片后，开始执行
    - **需要注意安全锁的问题，如果线程操作的代码被锁住，则陷入等待（等待时间碎片切换走）**
    - 安全锁可以保证数据的安全与准确性
  - cpu的时间碎片，随机分配，时间长短不定（所以线程的执行是随机的）
  - 当某个线程重新拿到时间碎片后，会继续往下执行
  - **如果一个线程被挂起，则时间碎片就不会分配到该线程**
    - 只有挂起的线程被唤醒，才进入等待过程（等待时间碎片的分配）
    - 拿到时间碎片后，进行执行，并且从上次停止的地方继续执行


