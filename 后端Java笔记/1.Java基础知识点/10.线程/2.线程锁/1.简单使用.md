

#### 概念
- 多个线程，同时操作同一个对象（执行该对象中的代码），如果该代码在线程锁的范围内，就会锁住改对象。
  - 其他线程在想执行该对象中的方法，就会陷入等待过程。直到对象释放，才能恢复执行
- 作用：防止多个线程，同时操纵一个数据，产生数据冲突，造成数据紊乱或者丢失
  - 比如，总共有5毛
    - 线程1，花了一毛
    - 线程2，也花了一毛
    - 可能最终，还剩4毛。正确应该是3毛。两个线程，要在一个线程减完一后，在执行
  - 上例产生的原因：
    - 线程1执行，取出钱（5），准备减一，还没有减，线程就切换了
    - 线程2执行，取出钱（由于还没有减，所以还是 5），然后 5 - 1 = 4；
    - 线程在切回1，继续执行，由于线程1的钱，已经取出来了，所以运算 5 - 1 还是为 4
    - 最终结果，就是剩余4毛
  - 用线程锁，就可以解决上述问题
    - 线程一执行，就立马锁住对象，线程即使切换到2，也只能进行等待，然后线程在切回1，执行 5 - 1 = 4，然后线程在切换到2
    - 此时线程二，在获取钱，就已经是上一个线程减完后的了（4），然后执行 4 - 1 = 3
    - 最终结果：3毛（正确结果）

#### 执行原理
- 线程一锁住对象，并不是一直执行完，然后在进行切换，时间碎片，照常按照规律切换
- 如果，切换到没有线程锁的代码，正常执行
- 如果，切换到带有线程锁的代码，同一个对象，进行等待，直到时间碎片切换走，不是同一个对象，正常执行
  - **控制的不是时间碎片，而是其他线程不进行执行**
  - 类似 while(true) if (对象是否释放 == 是) break
  - 没有释放，就一直执行死循环，释放了才会继续往下执行代码
  - 时间碎片正常切换，切换到该线程，是死循环，不往下执行，现象就是该线程陷入了等待，没有反应
- **总结**
  - 如果其他线程，执行到给某个对象上锁的代码，如果该对象已经锁住，则立刻停止执行，进行等待
  - 直到该对象释放，才继续执行，给该对象上锁
  - 不能重复上锁


#### 示范代码
- 启动函数
```java
public class Main {
    public static void main(String str[]) {
        // 创建共同对象
        Demo demo = new Demo();  
        // 创建线程
        Jc1 o1 = new Jc1(demo, "线程一");
        Jc2 o2 = new Jc2(demo, "线程二");
        Jc3 o3 = new Jc3(demo, "线程三");
        Thread x1 = new Thread(o1);
        Thread x2 = new Thread(o2);
        Thread x3 = new Thread(o3);

        // 线程进入准备状态
        x1.start();
        x2.start();
        x3.start();
    }
}
```

- 线程函数（以线程1为例，另外两个线程函数一样）
```java
package Jc;

import Fs.Demo;

// 线程1
public class Jc1 implements Runnable {
    // 接收公共对象，验证线程锁
    public Demo demo;
    public String name;

    public Jc1(Demo demo, String name) {
        this.demo = demo;
        this.name = name;
    }

    // 重写方法，线程入口
    @Override
    public void run() {
        demo.A(this.name);
    }
}
```

- 创建共有对象的类（带有线程锁）
```java
package Fs;
// 具有线程锁的方法
public class Demo {
    // 直接锁住一个方法的范围，方法执行完，对象才进行释放
    public synchronized void A(String str) {
        for (int i = 0; i < 2; i ++) {
            System.out.println(str + "：A" + i);
        }
    }

    // 锁住局部，被锁住的部分执行完，对象就会进行释放
    public void B(String str) {
        for (int i = 0; i < 2; i ++) {
            System.out.println(str + "：B" + i);
        }
        synchronized (this) {
            for(int i = 4; i < 6; i ++) {
                System.out.println(str + "：B" + i);
            }
        }
    }

    // 没有线程锁的方法
    public void C(String str) {
        for (int i = 0; i < 2; i ++) {
            System.out.println(str + "：C" + i);
        }
    }
}
```
- 执行效果
  - 部分B执行，就是因为，B使用的是局部锁，前一部分并没有被锁住，所以当线程切换过来的时候，可以正常执行
  - 后一部分，只能A执行完（释放对象），才能继续执行，否则就会等待
<img src='../../../../imgs/img56.png' />


#### 最常使用安全锁的模式，生产消费者模式
- 生产消费者模式，主要是为了模仿线程的高并发的效果
- 几个线程用于生产，几个线程用于消费
- 生产和消费操作的是同一个数据存储空间，即同一个对象，所以要**注意线程安全的问题**


#### 缺点
- 安全锁的使用，会出现一种死锁的现象，但是这种现象很难发生，具体看后面的介绍