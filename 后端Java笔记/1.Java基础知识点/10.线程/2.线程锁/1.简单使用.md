<script src='/笔记/see/index.js'></script>
[toc]

#### 概念
- 作用：保护数据的安全性（因为安全锁，会锁住一个对象）
- 工作原理
  - 当某个线程执行某个对象中，带有安全锁的方法时，该线程就会锁住该对象
    - 直到该线程执行完安全锁中的代码，该对象才会被释放
  - 当某个对象被锁住的时候，其他线程就无法调用该对象中带有安全锁的代码
    - 注意：只是不能调用带有安全锁的代码，其他没有带有安全锁的代码，是可以正常执行的
    - **即：安全锁，锁住的不是一整个对象，而是该对象中带有安全锁的所有方法，普通的方法没有影响**
- 对线程切换的影响
  - **对线程切换没有影响**
  - 即：当某个线程锁住某个对象后，时间碎片是正常切换的
    - 并不是该线程执行完带有安全锁的代码后，在进行切换
  - 只不过，当时间碎片切换到某个线程后，该线程开始执行，发现将要执行的代码已经被另一个线程锁住了，于是就会进入等待（时间碎片正常切换）
    - 什么时候正常执行呢：当被锁住的对象释放后，该线程才会继续执行，然后就会又锁住了该对象



#### 示范代码
```java
public class Demo {
    public static void main(String[] arge) {
        A a = new A();
        Thread thread = new Thread(a);
        thread.start();
    }
}


class A implements Runnable  {
    @Override
    public void run() {
        B b = new B();
        b.demo1();
    }
}

class B {
    public synchronized void demo1() {
        System.out.println("demo1");
        this.demo2();
        synchronized (this) {
            System.out.println("局部锁");
        }
    }
    public synchronized void demo2() {
        System.out.println("demo2");
    }

    public void demo3() {
        System.out.println("由于这个没有上锁，所以即使demo1锁住了这个对象，其他线程也是能够调用该方法的");
    }
}
```


#### 当前对象锁住别的对象（容易产生死锁问题）
- 只能借助局部锁，方法锁只能锁住当前对象
- 释放时间，为局部锁执行完成的时间
- 示范代码
```java
synchronized (this.demo) {
  this.demo.C(this.name);
}
```
- 上述代码，可以在任意类中写，作用是执行到这个地方，立马锁住指定的对象（demo）
- 如果当前对象已经被其他线程锁住，则在这个地方陷入等待，直到该对象释放，才会继续执行，然后锁住指定对象
  - 对象锁住后，其他线程就不能再执行该对象中带有安全锁的代码
  


#### 缺点
- 安全锁的使用，会出现一种死锁的现象，但是这种现象很难发生，具体看后面的介绍