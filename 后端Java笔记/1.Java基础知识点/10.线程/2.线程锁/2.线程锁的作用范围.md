#### 概述
- **线程锁，作用于类创建的对象中，所有`带有线程锁`的方法**
  - 不带线程锁的方法，不受限制可以任意切换
    - 时间碎片的切换没有停止，不带线程锁的方法，就可以正常执行
  - **带线程锁的方法，陷入等待，直到对象释放后，才能继续执行**
    - A、B方法都带有线程锁，A执行锁住对象，B的调用也等待
    - 并不是A执行，只锁住了A方法，B可以正常切换（锁住的不是方法，而是对象）
  - 方法局部线程锁，同理。
    - 执行的地方只要有锁，就等待。没锁的部分正常切换（同一个对象）

- **如果，对象中一个方法带有线程锁，最好所有的方法都带有线程锁**
  - 除非功力很深，否则也容易对数据产生混乱的使用，被那些没有带有安全锁的方法，钻了空子


#### 示例（忽略启动函数，只有带有线程锁的类）
- **比如：**
  - A、B、C三个方法，三个线程分别调用，其中A、B带有线程锁
  - 时间碎片会在三个线程之间来回切换，其中如果对象被锁住（A锁住的）
    - 切换到A，A继续执行
    - 切换到B，对象锁住，B方法带有线程锁，啥都不动（不执行），等待时间碎片的切换
    - 切换到C，对象锁住，但是C方法，没有带线程锁，继续执行
  - 所以看到的效果是，A执行一段时间，C执行一段时间，B一直等着。直到A执行完毕（对象释放），B才会执行（如果C还没有执行完，效果又是，B执行一段时间，C执行一段时间）

- 代码实现
  ```java
    package Fs;
    // 具有线程锁的方法
    public class Demo {
        public synchronized void A(String str) {
            for (int i = 0; i < 2; i ++) {
                System.out.println(str + "：A" + i);
            }
        }

        public synchronized void B(String str) {
            for (int i = 0; i < 2; i ++) {
                System.out.println(str + "：B" + i);
            }
        }

        public void C(String str) {
            for (int i = 0; i < 2; i ++) {
                System.out.println(str + "：C" + i);
            }
        }
    }

  ```
- 执行效果
  - A 和 C来回切换，B最后执行（A执行完），就是因为对象锁住了，C正常切换，就会因为方法没有带有线程锁
<img src='../../../../imgs/img55.png' />