


#### 线程的死锁
- 就是由于 `synchronized` 使用不当造成的
  - 使用局部锁，同时操作两个对象
  - 比如：线程1锁住了A，要想操作B。如果线程2刚好锁住了B，想要操作A，就产生了死锁的问题
    - 线程切换到1，一看B锁住了，就陷入等待
    - 线程切换到2，一看A锁住了，就陷入等待
    - 两个都进行等待过程，就造成了A、B永远不会解锁（执行不完，无法解锁），这样就陷入了永远的等待过程（两个线程永远结束不了）

- 示范代码
```java
// 线程类
public class Zhe extends Thread {
    // 两个共同的对象
    private A a;
    private B b;

    public Zhe() {};
    public Zhe(A a, B b) {
        this.a = a;
        this.b = b;
    };

    // 线程的入口函数
    public void run() {
        // 看看a有没有锁住，锁住等待，没有锁住执行，锁住a
        synchronized (this.a) {
            System.out.println("锁住A");
            // 如果另一个线程操作A，锁住了B，则下面的代码进入等待过程，另一个线程也进入等待过程，就产生了死锁现象

            // 看看b有没有锁住，锁住等待，没有锁住执行，锁住b
            synchronized (this.b) {
                System.out.println("锁住B");
            }
            // 执行完，释放b
        }
        // 执行完释放a
    }
}

```


##### 死锁的解决方式(虽然是偶然的，但也要解决)
1. 产生时间差，避免同时拿到一个对象的操作权限，另一个却抢不到了，有了时间差，就可以给其他线程得到对象的操作权限，然后释放
2. 不操作同一个对象，就没有锁定的效果



