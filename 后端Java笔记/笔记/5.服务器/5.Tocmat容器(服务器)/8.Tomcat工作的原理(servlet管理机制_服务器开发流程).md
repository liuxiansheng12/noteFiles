


#### 请求流程(服务器开发流程)
1. 接受一个请求，然后 `Tomcat` 开启一个线程处理该请求(**handler**)
2. 线程开启后，就会分享请求发送过来的数据(字符串)，请求头和请求体
3. 然后分析请求路径，是静态请求还是动态请求（**ServletController**）
   1. 如果是静态请求，直接返回web下对应的静态资源
   2. 如果是动态请求，执行对应的处理方法(根据 **web 文件夹下的 web.xml**，找到对应的处理类，然后通过反射的方式，执行类中的方法)
4. 动态请求，执行的是 **`controller`** 文件夹下的类(控制层)
   1. 控制层的主要作用是，获取请求数据，调用 `service` (服务层) 中，对应的类，处理业务
   2. 拿到服务层，经过处理得到的数据，往响应中添加数据，发送给客户端
5. **`service`** (服务层) 中，进行一些服务处理
   1. 如果涉及到操作数据库，则操作数据库的代码，是放在 `Dao` 层的
6. **`Dao`** 层，是直接与数据库打交道的，只是打交道，没有一点数据的运算处理
   1. 与该层关联的，还有一个 **`domain`** 文件夹，内部都是一个一个的表的映射类，用来存放表中的数据（读取到的数据）
7. `Dao`层，读取到数据，返回给 `service` 层，`service`层，在返回给 `controller`层，然后`controller`层，在把数据返回给客户端
   1. 请求的处理，先是一层一层的进，然后处理结果在一层一层的往外传




#### Controller 文件夹下类的特点
1. Controller 下面的类，是受 `Tomcat` 管理的，通过 `web.xml`，进行管理
2. **管理特点: 使用的是单例模式**
   1. `Tomcat` 创建了一个 `map`集合，开始的时候是空的，啥也没有
   2. 当动态请求来临的时候，先从 `web.xml` 中找到一个对应的类映射，然后看看`map`集合中，有没有该类已经创建好的对象
   3. 如果没有，才通过反射的方式，创建一个对象，然后在缓存起来，下一次就是使用缓存了
   4. **也就是， Controller 文件夹下的类，只会有一个对象产生**
   5. **所有与之有关联的请求，使用的是同一个对象**
3. **问题:**
   1. **如果类中，定义了状态，并且进行了修改，会对其他请求产生影响的**
   2. 所以，不要轻易定义属性，更不要轻易修改属性
4. 使用的单例模式是`懒汉式`的，来一个请求，才添加一份对象




#### 让Controller 文件夹下的类，开始时就加载好
1. **如果想要，某个 Controller 文件夹下的类，在开始的时候就立马加载，需要在配置文件中(web.xml)进行配置**
   1. 由于该类，提前加载好了，这样请求来的时候，就直接从缓存中取对象使用了
   2. 配置方法
   ```xml
   <servlet>
        <servlet-name>index</servlet-name>
        <servlet-class>controller.IndexServlet</servlet-class>
        <!-- 填写的是一个整数，控制的是加载顺序（有多个类都在开始的时候加载，那个值小那个先加载） -->
        <load-on-startup>0</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>index</servlet-name>
        <url-pattern>/index</url-pattern>
    </servlet-mapping>
   ```



#### web.xml在开始的时候，就会解析，然后形成一个map集合
1. 所以，如果该文件下的配置写错了，服务器是无法启动的，会报错。



