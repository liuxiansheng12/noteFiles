


#### 题意
```java
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。


示例：

输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]
```




#### 暴力法
```java
public static List<String> generateParenthesis(int n) {
List<String> list = new ArrayList<String>();

// 暴力解法，每一位要么(   要么 ）  ，然后进行合理性判断
// 长度  为 2 * n
char[] cha = new char[2 * n];
a(cha, 0, list);
return list;
}

public static void a(char[] cha, int index, List<String> list) {
if( index == cha.length ) {
    // 判断是否符合条件
    if( pan(cha) ) {
        list.add( new String(cha) );
    }
}
else {
    // 先放'('
    cha[index] = '(';
    // 递归
    a(cha, index + 1, list);
    // 在放')'
    cha[index] = ')';
    a(cha, index + 1, list);
}
}
public static boolean pan(char[] cha) {
int a = 0;
for( int i = 0; i < cha.length; i ++) {
    if( cha[i] == '(' ) a ++;
    else a --;
    // 不能出现负数，先有（ 才能有 ）
    if(a < 0) return false;
}
return a == 0;
}
```




#### 回朔法
```java
/*
    回朔法
    （）是一对一对的，并且先 有 （   才能有  ）
    所以 优先创建 （   然后在创建  ）
    当 （ 和 ） 创建的个数 达到了 长度   ，说明创建完成
*/

public static List<String> generateParenthesis(int n) {
    List<String> list = new ArrayList<String>();
    StringBuffer cha = new StringBuffer();
    a(cha, 0, 0, n, list);
    return list;
}

public static void a(StringBuffer cha, int start, int end, int n, List<String> list) {
    if( start == n && end == n ) {
        list.add( cha.toString() );
    }
    // 优先添加 （  并且长度不能过多
    if( start < n ) {
        cha.append("(");
        // 优先添加，进行递归
        a(cha, start + 1, end, n, list);
        // 公用的一个 stringBuffer，退出递归，要删除递归添加的数据，恢复原样
        cha.deleteCharAt(cha.length() - 1);
    }
    // 然后添加 ） 并且个数不能 超过 ( 的个数
    if( end < start ) {
        cha.append(")");
        // 优先添加，进行递归
        a(cha, start, end + 1, n, list);
        // 公用的一个 stringBuffer，退出递归，要删除递归添加的数据，恢复原样
        cha.deleteCharAt(cha.length() - 1);
    }
}
```




#### 分析
```java
 /*
    分头和尾
    头有几对（）尾就有 n - a 对 ()
        头的规律为 至少由 一个 （）包着，至少
        尾的话，就是 n - a 对 () 的排列情况，直接递归
    头又可以划分 头 和 尾
    尾又可以划分 头 和 尾
*/

public static List<String> generateParenthesis(int n) {
    List<String> list = new ArrayList<String>();
    if(n == 0) {
        list.add("");
        return list;
    }
    if(n == 1) {
        list.add("()");
        return list;
    }
    // 头，从 1 到 n
    for(int i = 1; i <= n; i ++) {
        // 头至少有一个 ()
        String start = "(";
        // 头又分头和尾，就可以递归了，由于头，已经有一个 （）  所以 剩下的 i - 1 进行排列
        List<String> startList = generateParenthesis(i - 1);

        // 头的（）的个数确定了，尾就还剩 n - i 个 ()
        // 并且尾没有特殊的规律，可能为 （（））  可能为（）（），也就是 n - i 个 （）的所有的排列情况，此时就可以递归了
        List<String> endList = generateParenthesis(n - i);
        // 遍历尾，分别与每一个头进行相连
        for(int end = 0; end < endList.size(); end ++) {
            // 遍历头
            for (int starts = 0; starts < startList.size(); starts ++) {
                String str = start + startList.get(starts) + ")" + endList.get(end);
                list.add(str);
            }
        }
    }

    return list;
}
```