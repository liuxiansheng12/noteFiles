

#### 两数之和

1. 给定一个数，和一个数组，找到数组中，两个数据相加等于给定的数，并返回两个数据的下标
2. 要求: 数据不能重复使用，也就是不能是同一个数据(下标不能相同)



#### 穷举法
1. 双层遍历，效率最低，但是容易理解
2. 代码如下
```java
// 需要的数组和目标值最好动态传入
public static int[] twoSum() {
    // 给定一个目标值
    int a = 8;
    // 给定一个数组
    int[] arr = new int[] {1, 3, 2, 4, 6, 8, 4, 2};

    // 穷举法，双层遍历
    for(int i = 0; i < arr.length; i ++) {
        for(int j = i + 1; j < arr.length; j ++) {
            if( arr[i] + arr[j] == a ) return new int[]{i, j};
        }
    }
    // 没有找到
    return new int[]{-1, -1};
}
```



#### 倒推法
1. 两个数求和，等价于一个数减另一个数，得到一个数，看看数组中有没有相同的，这就是查询
   1. 查询，使用map更加方便，所以要先转成map
   2. key存数据，value存角标，这样就可以快速的定位到对应数据的角标
2. 代码如下
```java
// 需要的数组和目标值最好动态传入
public static int[] twoSum() {
    // 给定一个目标值
    int a = 8;
    // 给定一个数组
    int[] arr = new int[] {1, 3, 2, 4, 6, 8, 4, 2};

    // 倒推法
    // 创建map
    HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>();
    for(int i = 0; i < arr.length; i ++) {
        hashMap.put(arr[i], i);
    }

    // 遍历数组，找到差值
    for(int i = 0; i < arr.length; i ++) {
        int cha = a - arr[i];
        // hashMap.get(cha) != i 不能复用
        if( hashMap.containsKey(cha) && hashMap.get(cha) != i ) {
            return new int[]{ i, hashMap.get(cha) };
        }
    }

    // 没有找到
    return new int[]{-1, -1};
}
```



#### 优化倒推法
1. 在转成map的时候，由于也进行遍历，所以直接进行判断
   1. 前面的数被减后，由于后面的数还没有放进map中，所以判断不出来，而不符合就放进map中
   2. 这样的话，当遍历到后面的数据时，前面的数据已经添加过了，所以被减后，可以找到符合的数据
   3. 判断符合的时间可能往后推了，但是少了一次循环，所以即使往后推，效率也比上一个高
2. 代码如下
```java
// 需要的数组和目标值最好动态传入
public static int[] twoSum() {
    // 给定一个目标值
    int a = 8;
    // 给定一个数组
    int[] arr = new int[] {1, 3, 2, 4, 6, 8, 4, 2};

    // 倒推法
    // 创建map
    HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>();
    for(int i = 0; i < arr.length; i ++) {
        // 比较的时候，还没有map中还没有，所以不用考虑数据复用的问题
        if( hashMap.containsKey( a - arr[i] ) ) {
            return new int[] {i, hashMap.get(a - arr[i]) };
            // 找到2的时候，8 - 2 = 6，此时 6 还没有放入
            // 找到6的时候，8 - 6 = 2，此时 2 已经放入
        }
        hashMap.put(arr[i], i);
    }

    // 没有找到
    return new int[]{-1, -1};
}
```