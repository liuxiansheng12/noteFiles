

#### 数字反转



#### 具体的实现代码

1. 方式一，直接使用数字运算的方式
```java
/*
    123
    123 % 10  =  3;    0 * 10 + 3 = 3;
    12  % 10  =  2;    3 * 10 + 2 = 32;
    1   % 10  =  1;   32 * 10 + 1 = 321;
    而 
    123 / 10 = 12   
    12  /  10 = 1
*/
public static int reverse(int x) {

    int num = 0;
    while( x != 0 ) {
        // 获取到最后一位
        int end = x % 10;
        // 判断后面的拼接后，是否超出范围
        // 如果 num > Integer.MAX_VALUE / 10 ，经过下面的运算，num * 10 > Integer.MAX_VALUE，在加上end更大
        // 如果相等，即num * 10 = Integer.MAX_VALUE   就要判断end是否超出范围
        if( num > Integer.MAX_VALUE / 10 || (num == Integer.MAX_VALUE / 10 && end > 7) ) return 0;
        if( num < Integer.MIN_VALUE / 10 || (num == Integer.MIN_VALUE / 10 && end < -8) ) return 0;
        // 最后一位拼接到数据中
        num = num * 10 + end;

        x = x / 10;
    }
    return num;
}
```




2. 方式二，使用StringBuffer中提供的反转方法
```java
public static int reverse(int a) {
    // 判断是否为负数
    boolean boo = false;
    // 方式二，使用StringBuffer中提供的反转方法
    String s = String.valueOf(a);
    
    if( a < 0 ) {
        boo = true;
        // 如果为负数的话去掉负号
        s = s.substring(1);
    }
    String fys = new StringBuffer(s).reverse().toString();

    // 判断是否超出范围
    // 先判断数字的范围，也就是最高位是多少位，如果小于，ok，如果等于可能会超出边界
    // 先得到最高位的位数，和最大值的位数
    // log10要考虑负数和负数最小值的问题
    int max = (int)Math.pow(10, (int)Math.log10( Math.abs(a) ));
    if(a == Integer.MIN_VALUE) max = (int)Math.pow(10, (int)Math.log10( Math.abs(a + 1) ));
    int zuiDamax = (int)Math.pow(10, (int)Math.log10(Integer.MAX_VALUE));
    // 可能发生超出边界的问题，需要进行判断
    if(max >= zuiDamax) {
        // 先判断最高位
        int maxZuiGao = fys.charAt(0) - '0';
        if(boo) maxZuiGao = -maxZuiGao;
        int zuiDaMaxZuiGao = Integer.MAX_VALUE / zuiDamax;
        int zuiXiaoMaxZuiGao = Integer.MIN_VALUE / zuiDamax;
        // 表示超出了边界
        if( maxZuiGao < zuiXiaoMaxZuiGao || maxZuiGao > zuiDaMaxZuiGao) return 0;
        // 最高值一样，看后面的
        if( maxZuiGao == zuiXiaoMaxZuiGao || maxZuiGao == zuiDaMaxZuiGao) {
            int zuiDaMaxHou = Integer.MAX_VALUE % zuiDamax;
            int zuiXiaoMaxHou = Integer.MIN_VALUE % zuiDamax;
            int maxHou = new Integer(fys.substring(1));
            if(boo) maxHou = -maxHou;
            // 表示超出了边界
            if(maxHou < zuiXiaoMaxHou || maxHou > zuiDaMaxHou) return 0;
        }
    }
    
    
    if(boo) {
        // 如果为负数的话，在加上负号
        fys = "-" + fys;
    }
    // 转换成数字
    a = new Integer(fys);
    return a;
}
```




3. 方式三，转换成字符串，获取内部的char数组，手动便利反转
```java
public static int reverse(int a) {
    // 判断是否为负数
    boolean boo = false;
    // 方式三，转换成字符串，获取内部的char数组，手动便利反转
    String s = String.valueOf(a);
    if( a < 0 ) {
        boo = true;
        // 如果为负数的话去掉负号
        s = s.substring(1);
    }
    char[] c = s.toCharArray();
    for(int i = 0; i < c.length / 2; i ++) {
        // 两数互换的方式一
        char l = c[i];
        c[i] = c[ c.length - 1 - i ];
        c[c.length - 1 - i] = l;

        /*
        两数互换的方式二
        int l = c[i] ^ c[ c.length - 1 - i];
        c[i] = (char)(l ^ c[i]);
        c[c.length - 1 - i] = (char)(l ^ c[c.length - 1 - i]);
        */

        /*
        两数互换的方式三
        int l = (int)(c[i]) + (int)(c[ c.length - 1 - i]);
        c[i] = (char)( l - (int)c[i] );
        c[c.length - 1- i] = (char)( l - c[i]);
        */
    }
    String fys = new String(c);

    // 判断是否超出范围
    // 先判断数字的范围，也就是最高位是多少位，如果小于，ok，如果等于可能会超出边界
    // 先得到最高位的位数，和最大值的位数
    // log10要考虑负数和负数最小值的问题
    int max = (int)Math.pow(10, (int)Math.log10( Math.abs(a) ));
    if(a == Integer.MIN_VALUE) max = (int)Math.pow(10, (int)Math.log10( Math.abs(a + 1) ));
    int zuiDamax = (int)Math.pow(10, (int)Math.log10(Integer.MAX_VALUE));
    // 可能发生超出边界的问题，需要进行判断
    if(max >= zuiDamax) {
        // 先判断最高位
        int maxZuiGao = fys.charAt(0) - '0';
        if(boo) maxZuiGao = -maxZuiGao;
        int zuiDaMaxZuiGao = Integer.MAX_VALUE / zuiDamax;
        int zuiXiaoMaxZuiGao = Integer.MIN_VALUE / zuiDamax;
        // 表示超出了边界
        if( maxZuiGao < zuiXiaoMaxZuiGao || maxZuiGao > zuiDaMaxZuiGao) return 0;
        // 最高值一样，看后面的
        if( maxZuiGao == zuiXiaoMaxZuiGao || maxZuiGao == zuiDaMaxZuiGao) {
            int zuiDaMaxHou = Integer.MAX_VALUE % zuiDamax;
            int zuiXiaoMaxHou = Integer.MIN_VALUE % zuiDamax;
            int maxHou = new Integer(fys.substring(1));
            if(boo) maxHou = -maxHou;
            // 表示超出了边界
            if(maxHou < zuiXiaoMaxHou || maxHou > zuiDaMaxHou) return 0;
        }
    }
    if(boo) {
        // 如果为负数的话，在加上负号
        fys = "-" + fys;
    }
    // 转换成数字
    a = new Integer( fys );
    return a;
}
```



