


#### 二进制求和

1. 总结
   1. 三个值相加（a + b + 前一位的进位）
   2. 如果为 0 2 加完值为 0     求模（2）
   3. 如果为 1 3 加完值为 1     求模（2）
   4. 如果为 0 1 进位为   0     除（2）
   5. 如果为 2 3 进位为   1     除（2）
   6. **还要考虑最后一位是否有进位**



2. 具体的实现代码，和分析
```java
// 二进制的运算规律
// 当前位需要考虑到，后面是否进位，如果后面进位，则当前位在加一
// a + b   前一位的进位        总和
// 0   0   0 --> 0           0
// 0   1   0 --> 1           1
// 1   1   0 --> 0   进一     2
// 1   1   1 --> 1   进一     3

// 总结
// 三个值相加（a + b + 前一位的进位）
// 如果为 0 2 加完值为 0     求模（2）
// 如果为 1 3 加完值为 1     求模（2）
// 如果为 0 1 进位为   0     除（2）
// 如果为 2 3 进位为   1     除（2）
// 还要考虑最后一位是否有进位


// 代码
// 需要两个二进制类型的数据，和一个后一位的进位值
String a =    "1001";
String b = "1111101";
int jinWei = 0;

// 要分别对每一位进行相加，按照上面的规律，该进位的进位
// 进制数要从后面开始算，所以要获取两个进制数的长度
int aL = a.length();
int bL = b.length();

// 保存计算后的二进制数，由于频繁的进行字符串的拼接，所以使用stringBuffer，也可以使用 + 号拼接
StringBuffer s = new StringBuffer("");

// 由于不知道循环多少次，所以使用while循环
while(aL > 0 || bL > 0) {
    // 计算 每一位的和，还要考虑前一位的进位，也就是（a + b + 前一位的进位）
    int aW = 0;
    if( aL > 0 ) {
        aL --;
        // charAt 得到的是 '0' 或者 '1'，用int类型接收，得到的就是ASCII码值 (即 48 和 49)
        // 所以要减去 '0' 的 ASCII码值，或者直接减去 48，才能转换成数字 0 或者 1，进行二进制运算
        aW = a.charAt(aL) - '0';
    }
    int bW = 0;
    if( bL > 0) {
        bL --;
        // charAt 得到的是 '0' 或者 '1'，用int类型接收，得到的就是ASCII码值 (即 48 和 49)
        // 所以要减去 '0' 的 ASCII码值，或者直接减去 48，才能转换成数字 0 或者 1，进行二进制运算
        bW = b.charAt(bL) - 48;
    }
    int sum = aW + bW + jinWei;   // （a + b + 前一位的进位）

    // 处理当前位，按照上面的规律，对 2 求余就是当前位，由于每次都是在前面拼接，所以要使用insert，不能使用append
    s.insert(0, sum % 2);

    // 当前位的进位值，为下一位计算，做准备(下一位，要考虑到当前位的进位)
    // 按照上面的规律，除 2，得到的就是进位数
    jinWei = sum / 2;
}

// 如果最后一位还有进位，要进上去，由于每次都是在前面拼接，所以要使用insert，不能使用append
if(jinWei == 1) {
    s.insert(0, 1);
}

System.out.println(s);
```