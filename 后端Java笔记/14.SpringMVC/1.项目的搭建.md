


#### 基于注解，搭建一个SpringMVC（上面的依赖配置完成）
**SpringMVC的配置文件**
> 作用，扫描包，构建请求与类的映射
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <context:component-scan base-package="controller"></context:component-scan>

    <mvc:annotation-driven></mvc:annotation-driven>
</beans>
```


**controller下的类（注解使用，一个请求对应一个类）**
```java
@Controller
// method 配置请求的方式，默认是 GET 
@RequestMapping(path = "/testController.do", method = RequestMethod.POST)
public class TestController {
    // 请求的入口函数
    @RequestMapping
    public String test(){
        System.out.println("我是基于注解的controller，我执行啦，这多开心");
        return "welcome.jsp";
    }
}
```


**controller下的类（注解使用，一个类，对应多个请求，多个请求，分别执行不同的方法）**
```java
@Controller
public class TestController {
    // 请求一执行的方法
    @RequestMapping(path = "/demoA", method = RequestMethod.GET)
    public String testA(){
        System.out.println("我是基于注解的controller，我执行啦，这多开心");
        return "welcome.jsp";
    }

    // 请求二执行的方法
    @RequestMapping(path = "/demoB", method = RequestMethod.POST)
    public String testB(){
        System.out.println("我是基于注解的controller，我执行啦，这多开心");
        return "welcome.jsp";
    }
}
```

**注解中，除了指定请求方式外，还可以指定headers，还有一些其他的东西，具体看注解源码**
> 如果指定了headers，则请求中要带有对应的请求头，才能执行该方法，否则是不会执行的(对应不上)，其他的配置也一样




#### 基于配置文件，搭建一个SpringMVC（上面的依赖配置完成）
> controller中的类，需要实现一个接口，重写内部的一个方法，才能实现
>> 1. 重写的方法，就是请求对应执行的方法，所以用一个接口进行约束，否则找不到
>> 2. 有点类似 Tomcat 原生的开发
>>> 1. 继承 HttpServlet 类，重写 servlet 方法

>> 所以，这种方式过于麻烦，通常不用




**SpringMVC的配置文件**
> 构建请求与类的映射
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!-- 先创建好对应的对象 -->
    <bean id="testController" class="controller.TestController"></bean>
    

    <!-- 构建映射关系 -->
    <bean id="simpleUrlHandlerMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
        <property name="mappings">
            <props>
                <!--真实的请求和类对应关系-->
                <prop key="/demo">testController</prop>
            </props>
        </property>
    </bean>
</beans>
```


**controller下的类**
```java
// 接口要导这个包，因为还有一个注解，也叫 Controller，别导错了
import org.springframework.web.servlet.mvc.Controller;
public class TestController implements Controller {
    // 重写的方法
    @Override
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
        System.out.println("请求收到了");
        return null;
    }
}
```



