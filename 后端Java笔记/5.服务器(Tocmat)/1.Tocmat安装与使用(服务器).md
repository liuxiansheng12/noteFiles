<script src='/笔记/see/index.js'></script>
[toc]


#### Tocmat的下载
- 进入，官方网址: https://www.apache.org/
- 滑到最下面，就可以看到 **Tomcat**，点击它
- 找到对应的版本，点击 `下载`，会进入该版本的下载页面，选择对应电脑系统的版本（mac对应tar.gz），点击就会下载
- 版本的对应关系
  - Tomcat6 （JDK5，Servlet2.x，JSP2.x，EL2.x）
  - Tomcat7 （JDK6，Servlet3.x，JSP2.x，EL2.x）
  - Tomcat8 （JDK7，Servlet3.x，JSP2.x，EL3.x）
  - Tomcat9 （JDK8，Servlet4.0，JSP2.3，EL3.0）



#### 准备工作-引入Tocmat的流程（旧版）
- 第一步：打开编辑器，点击上方的 `Run`
- 第二步：点击 `Edit Configurations`
- 第三步：`左上角+号`   
  - 往下滑，找到 `Tomcat Server`，然后在点击 `Local`
  - 然后，就会进入一个配置页面
    - 点击 `configure`，选中要集成的 `Tomcat` 的路径（即上面下载的Tocmat所处的路径）
    - 以及给服务器起一个名字(可能有多个服务)
    - 集成成功后，最后有一个 `Warning: No artifacts configured` 警告，说明还没有项目，不用管，点击ok即可
    - 这样，Tocmat就运用成功，此时运行的地方，就会出现可运行的mian函数（是Tocmat上的）
  - 如果没有找到 `Tomcat Server`，可能隐藏了，点击最下面的收起隐藏
  - 如果还没有，证明IDEA中缺少相关的插件
    - 下载流程（按顺序点击）：(File--Settings--Plugins--Installed)
      - 最终进入一个页面，然后搜索 `Tomcat`，如果没有安装，是一个高亮的，如果已经安装，是个灰色的
      - 如果没有安装，选中（或者在前面打勾），点击 `apply` 进行安装，安装后点击OK，就会退出
    - 此时，Tomcat就安装好了，然后再回到第一步，此时就可以成功执行第三步，创建Tocmat项目了




#### 准备工作-引入Tocmat的流程（新版）
- 第一步：打开编辑器，点击上方的 `Run`
- 第二步：点击 `Edit Configurations`
- 第三步：`左上角+号`  
  - 选择Smart Tocmat
  - 如果没有，说明缺少 Smart Tocmat 插件
- 第四步：安装 Smart Tocmat 插件
  - 点击 IntelliJ IDEA（左上角）
  - 点击 Preferenecs
  - 点击 Plugins
  - 点击 Marketplace（默认选择的就是这个）
  - 然后，搜索 Tocmat （搜索结果可能比较慢，也有可能搜不出来，多搜几次）
  - 然后就会看到 Smart Tocmat
    - 然后，点击 install（没有下载，这个按钮就是高亮）
    - 点击后，就会进入下载流程，下载完成后，install 这个按钮就会变灰
    - 下载完成后，一定要点击OK，否则不起作用（依旧找不到这个插件）
- 第五步：安装完成后，就需要引入下载的Tocmat了
  - 点击 IntelliJ IDEA（左上角）
  - 点击 Preferenecs
  - 就会发现，在最后多了一个 Tocmat Server（点击这个）
    - 右侧就会出现一个页面
    - 点击 +
    - 然后选择，下载的Tocmat的文件路径，选中对应的Tocmat
    - 可以多导几个Tocmat
  - Tocmat导入完毕后，点击Ok

- 然后回到第一步，一直操作到第三步
  - 选择Smart Tocmat
  - 右侧就会出现一个配置页面
    - 选则要使用的Tocmat版本（只有第五步导入的Tocmat才能被选中）
      - 如果是个空的，则说明没有导入Tocmat，就需要进行第五步的操作
    - 然后在给服务器起一个名字(可能有多个服务)
  - 配置完成后，点击OK，Tocmat就引入到项目中了

- 如果编辑器一打开文件目录，就卡死（就无法导入下载的tocmat了），就卸载重装


#### 准备工作-搭建Web服务（创建项目）
- 要想启动tocmat服务，在搭建项目的时候，必须创建 web 服务项目
  - 这样的话，在引入Tocmat后，Tocmat的主函数才能正常启动，如果创建的不是web项目，则主函数启动不了

.
- web服务，要有一个核心的配置文件（启动配置文件）
- 该配置文件的路径为 src/web/WEB-INF/web.xml（启动配置文件）
  - src/web，下面放的就是静态资源了

- web文件的产生方式
  - 第一种，手动创建
  - 第二种，右键项目名称 -> 点击 add framwork support -> 点击 Web Application -> 默认勾选创建 web.xml
    - 确定后，项目中，就会多一个`web`文件夹，该文件夹中存放静态文件

- 配置项目路径
  - 打开 `run --> Edit Configurations`
  - 选中 `Deployment`，点击，右边的加号
  - 选择 `Artifact…`
    - 会自动添加当前的项目，修改下面的 `application context` 设置为当前项目的名字（可以不用设置）
    - 此时，如果访问 `ip:端口/项目名(或者默认的名字)/静态资源路径`，就可以访问到对应的静态资源
    - 会自动去 `web` 下面找，所以静态资源路径，就不用写 `web` 了





#### 准备工作-引入servlet包（核心包）
- 这个包，就是处理请求，分析请求数据的，所以只要提供web服务，都离不开这个包
- servlet包的引入方式（通过maven引入）
  ```xml
  <dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>4.0.1</version>
    <scope>provided</scope>
  </dependency>
  ```





#### 准备工作-解决IDEA控制台出现乱码的问题
- 修改一下IDEA安装目录bin文件夹中的配置文件
  - 找到IDEA安装目录下的 `bin`
    - 找到 `idea.exe.vmoptions` 和 `idea64.exe.vmoptions`
  - 记事本形式打开，添加一行，**-Dfile.encoding=UTF-8**
  - 如果不好用，另外再添加一行，**-Dconsole.encoding=UTF-8**

- 在配置Tomcat容器的时候做参数处理
  - server选项卡
    - `VM options`处添加，`-Dfile.encoding=UTF-8`
  - 如果还不好用
    - 在点击 `Startup/Connection` 选项卡
    - 勾选 `Pass  environment  variables`
    - 手动添加
      - `JAVA_OPTS`，**-Dfile.encoding=UTF-8**
      - `JAVA_TOOL_OPTIONS`，**-Dfile.encoding=UTF-8**


#### 请求处理-定义请求处理函数
- 在controller文件夹下，创建请求处理类，类中定义请求处理函数

- 随便创建一个类（通常在controller下定义）
  - 注意：**该类必须继承HttpServlet，然后重写service方法**
  - 原因：主函数是Tocmet提供的，并且请求也是Tocmet接收，然后分析，根据分析出的请求路径，调用对应的请求处理方法
    - 由于请求处理类，是自定义的，所以Tocmat调用起来很困难，于是Tocmat就定义了一个规范
      - 它通过反射获取请求处理类，然后直接调用 service 方法（如果这个方法没有重写，后果就是调用不到，即请求处理不了）
  - 所以：请求处理类必须继承HttpServlet，然后重写service方法


.
- Tocmat如何知道，某个请求对应的某个处理方法，根据的就是配置文件（web.xml）
  - 如果不配置映射关系，Tocmat就无法得知，某个请求该用哪个处理方法进行处理，于是就会忽略这个请求

- 具体配置如下（示范）
  ```xml
  <servlet>
    <servlet-name>test</servlet-name>
    <servlet-class>controller.Demo</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>test</servlet-name>
    <url-pattern>/test</url-pattern>
  </servlet-mapping>
  ```
  - 这样的话，访问`/test`，Tocmat就会调用 controller.Demo 中重写的 service 方法
  - 这样的话，`controller.Demo` 就能处理 `/test` 请求了



- 请求处理函数的示范代码（继承HttpServlet，重写service方法）
  ```java
  public class Demo extends HttpServlet {
      public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          
          // 设置响应数据的编码，防止中文乱码
          response.setCharacterEncoding("UTF-8");
          // 获取输出流
          PrintWriter printWriter = response.getWriter();
          
          // 响应数据
          printWriter.write("<html><head><meta charset='UTF-8'></head><body>122，你好");
          printWriter.write("</body></html>");
          // 这个一定要加上
          printWriter.flush();
          
      }
  }
  ```




#### 请求处理-解决响应中文乱码

- 请求映射具体配置如下（web.xml）
  ```xml
  <servlet>
    <servlet-name>test</servlet-name>
    <servlet-class>controller.Demo</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>test</servlet-name>
    <url-pattern>/test</url-pattern>
  </servlet-mapping>
  ```
  - 这样的话，访问`/test`，Tocmat就会调用 c 中重写的 service 方法
  - 这样的话，`controller.Demo` 就能处理 `/test` 请求了



- 请求处理函数的示范代码（继承HttpServlet，重写service方法）
  ```java
  public class Demo extends HttpServlet {
      public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          
          // 设置响应数据的编码，防止中文乱码
          response.setCharacterEncoding("UTF-8");
          // 获取输出流
          PrintWriter printWriter = response.getWriter();
          
          // 响应数据
          printWriter.write("<html><head><meta charset='UTF-8'></head><body>122，你好");
          printWriter.write("</body></html>");
          // 这个一定要加上
          printWriter.flush();
          
      }
  }
  ```





#### 请求处理-get请求获取传入的数据
- HttpServletRequest中有一个getParameter方法，通过该方法就可以获取请求传入的数据

.
- 请求映射具体配置如下（web.xml）
  ```xml
  <servlet>
    <servlet-name>test</servlet-name>
    <servlet-class>controller.Demo</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>test</servlet-name>
    <url-pattern>/test</url-pattern>
  </servlet-mapping>
  ```
  - 这样的话，访问`/test`，Tocmat就会调用 c 中重写的 service 方法
  - 这样的话，`controller.Demo` 就能处理 `/test` 请求了




- 请求处理函数的示范代码（继承HttpServlet，重写service方法）
  ```java
  public class Demo extends HttpServlet {
      public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          // 获取请求传入的数据
          String name = request.getParameter("name");
          String age = request.getParameter("age");
          System.out.println(name);
          System.out.println(age);
      }
  }
  ```
  - 假设访问的是 `/test?name=a&age=30`
    - 则获取的数据就是：name=a、age=30
    - 如果没有对应的数据，则得到的是 null






#### 请求处理-post请求获取传入的数据（k1=v1&k2=v2）
- HttpServletRequest中有一个getParameter方法，通过该方法就可以获取请求传入的数据
  - 上面介绍：该方法是get获取数据的，但是post中也能通过该方法获取数据
  - 要求：必须是通过`/test?name=a&age=30`传递的参数，post就能获取到传入的数据

.
- 请求映射具体配置如下（web.xml）
  - Tocmat没有请求方式的限制，只要路径对上，无论是post请求还是get请求，都会执行对应的请求处理方法
  - 要先限制请求方式，只有手动通过代码进行if判断，具体方式后续介绍
  ```xml
  <servlet>
    <servlet-name>test</servlet-name>
    <servlet-class>controller.Demo</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>test</servlet-name>
    <url-pattern>/test</url-pattern>
  </servlet-mapping>
  ```
  - 这样的话，访问`/test`，Tocmat就会调用 c 中重写的 service 方法
  - 这样的话，`controller.Demo` 就能处理 `/test` 请求了




- 请求处理函数的示范代码（继承HttpServlet，重写service方法）
  ```java
  public class Demo extends HttpServlet {
      public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          // 获取请求传入的数据
          String name = request.getParameter("name");
          String age = request.getParameter("age");
          System.out.println(name);
          System.out.println(age);
      }
  }
  ```
  - 假设发送的请求如下
    ```js
    fetch("/serviceDemo/test?name=张三&age=30", {
        method: 'post'
    })
    // 或者
    fetch("/serviceDemo/test", {
        method: 'post',
        // 这个必须加上，否则getParameter获取不到，但是这种方式有可能出现中文乱码，解决方式下面介绍
        headers: {
            "Content-Type": "application/x-www-form-urlencoded"
        },
        body: "name=张三&age=40"
    })
    ```
    - 则获取的数据就是：name=张三、age=30
    - 如果没有对应的数据，则得到的是 null
  - 实例中并没有指定请求处理函数是处理什么方式的请求（和get定义的一样），但是get和post都能触发请求处理函数
    - 说明：无论是post请求还是get请求，都会执行对应的请求处理方法




#### 请求处理-post请求获取传入的数据（JSON格式）
- 上面介绍了，Post如何获取 `name=张三&age=40` 这种格式传入的数据
- 但是Post最常见的是用请求体传递数据（格式是JSON）
  - **但是，原生中很难获取请求体为JSON的数据，后续框架可以轻松获取**
  - 原因：通过后续介绍的 `获取所有请求参数keys` 的方法，可以看到
    - **传入的请求体作为了一个key，所以根本就无法通过 `getParameter()` 这个方法获取请求体数据**
      - 因为：getParameter是根据key获取对应的数据
  - 只能：**通过获取所有的keys，然后遍历，通过分析keys，来判断传入的是不是请求体JSON数据**

- 示范代码如下
  - 请求映射具体配置如下（web.xml）
    ```xml
    <servlet>
      <servlet-name>test</servlet-name>
      <servlet-class>controller.Demo</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>test</servlet-name>
      <url-pattern>/test</url-pattern>
    </servlet-mapping>
    ```
  - 请求处理方法，获取请求体JSON数据
    - **请求头必须加上 `"Content-Type": "application/x-www-form-urlencoded"`**
      - 要不然，获取不到请求体中的数据的
    ```java
    public class Demo extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            request.setCharacterEncoding("UTF-8");

            // 获取所有的keys，而请求体JSON就是作为一个Keys，这样就获取到了
            Enumeration parameter = request.getParameterNames();
            // 迭代keys，获取每一个具体的key，这样就能得到JSON数据了
            while(parameter.hasMoreElements()) {
                // 返回值是一个Object，使用时需要造型
                String key = (String)parameter.nextElement();
                // 第一个就是JSON数据
                System.out.println(key);
            }
        }
    }
    ```
    - 请求测试
      ```js
      fetch("/serviceDemo/test", {
          method: 'post',
          headers: {
              "Content-Type": "application/x-www-form-urlencoded"
          },
          body: JSON.stringify({
              name: '张三',
              age: 20
          })
      })
      ```
    - 当然了，也可以通过如下方式传递JSON数据，但是有点奇怪
      ```js
      fetch("/serviceDemo/test", {
          method: 'post',
          headers: {
              "Content-Type": "application/x-www-form-urlencoded"
          },
          body: "json=" + JSON.stringify({
              name: '张三',
              age: 20
          })
      })
      ```
      - 指定一个key，然后value为要传递的JSON，这样就能通过固定的key获取到JSON数据了
        - 即：`String json = request.getParameter("json");`






#### 请求处理-get和post获取所有请求参数的keys
- 使用 `Enumeration parameter = request.getParameterNames();`获取所有的keys，返回的是一个枚举对象
  - 比如：传入的参数是`name=张三&age=40`，则获取的所有keys就是 `name、age`
  - 上例中介绍：可以通过该方法，获取请求体为JSON的数据（因为该类型数据会作为一个keys，所以可以获取到）
- 遍历keys就能拿到请求所有的数据

- 示范代码
  - 请求映射具体配置如下（web.xml）
    ```xml
    <servlet>
      <servlet-name>test</servlet-name>
      <servlet-class>controller.Demo</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>test</servlet-name>
      <url-pattern>/test</url-pattern>
    </servlet-mapping>
    ```
  - 请求处理方法（获取所有的请求参数数据）
    ```java
    public class Demo extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            request.setCharacterEncoding("UTF-8");

            // 获取所有的keys
            Enumeration parameter = request.getParameterNames();
            // 迭代keys，获取每一个具体的key，然后利用key获取对应的数据
            while(parameter.hasMoreElements()) {
                // 返回值是一个Object，使用时需要造型
                String key = (String)parameter.nextElement();
                // 获取具体的数据
                String str = request.getParameter(key);
                System.out.println(str);
            }
        }
    }
    ```
    - 请求测试
      ```js
      fetch("/serviceDemo/test?name=张三&age=24")
      ```




#### 请求处理-get和post获取一组数据（k相同，v不同）
- 比如：传递的参数是 `abc=1&abc=2&abc=3`
  - 要是通过 `request.getParameter('abc')` 获取，只能获取第一个
  - 迭代也不行，因为key都是 abc，所以迭代只能迭代出第一个
- 要想获取此类的所有数据，可以通过下面的方式
- 示范代码
  - 请求映射具体配置如下（web.xml）
    ```xml
    <servlet>
      <servlet-name>test</servlet-name>
      <servlet-class>controller.Demo</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>test</servlet-name>
      <url-pattern>/test</url-pattern>
    </servlet-mapping>
    ```
  - 请求处理方法（获取所有的请求参数数据）
    ```java
    public class Demo extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // 获取所有的 abc 数据
            String[] datas = request.getParameterValues("abc");
            // 遍历
            for(String p : datas) {
                System.out.println(p);
            }
        }
    }
    ```
    - 请求测试
      ```js
      fetch("/serviceDemo/test?abc=1&abc=2&abc=3")
      ```



#### 请求处理-解决请求参数乱码问题
- 打印的时候发现乱码了，就可以进行下面的操作，解决乱码（POST请求经常乱码）
- 其实就是和字符集有关
- 具体操作如下
  ```java
  // 在获取参数前，先设置一下字符集
  request.setCharacterEncoding("UTF-8");
  // 然后在获取数据，这样就不会乱码了
  String aname = request.getParameter("name");
  ```
  



#### 请求处理-获取请求头中的数据
- 根据key获取具体的请求头数据
- 示范代码
  - 请求映射具体配置如下（web.xml）
    ```xml
    <servlet>
      <servlet-name>test</servlet-name>
      <servlet-class>controller.Demo</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>test</servlet-name>
      <url-pattern>/test</url-pattern>
    </servlet-mapping>
    ```
  - 请求处理方法（获取所有的请求参数数据）
    ```java
    public class Demo extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // headers中的数据
            String abc = request.getHeader("abc");
            System.out.println(abc);
        }
    }
    ```
    - 请求测试
      - headers中不能有中文
      ```js
      fetch("/serviceDemo/test", {
          headers: {
              abc: "cs"
          }
      })
      ```



.
- 获取所有的keys，然后迭代获取所有的请求头数据
- 示范代码
  - 请求映射具体配置如下（web.xml）
    ```xml
    <servlet>
      <servlet-name>test</servlet-name>
      <servlet-class>controller.Demo</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>test</servlet-name>
      <url-pattern>/test</url-pattern>
    </servlet-mapping>
    ```
  - 请求处理方法（获取所有的请求参数数据）
    ```java
    public class Demo extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // 获取headers中的所有keys
            Enumeration headers = request.getHeaderNames();
            // 迭代keys，获取所有的headers中的数据
            while(headers.hasMoreElements()) {
                // 返回值是一个Object，使用时需要造型
                String key = (String)headers.nextElement();
                // 获取值
                String header = request.getHeader(key);
                System.out.println(key + ": " + header);
            }
        }
    }
    ```
    - 请求测试
      - headers中不能有中文
      ```js
      fetch("/serviceDemo/test", {
          headers: {
              abc: "cs",
              dds: 'ds'
          }
      })
      ```



#### 请求处理-获取请求路径
- 示范代码
  - 请求映射具体配置如下（web.xml）
    ```xml
    <servlet>
      <servlet-name>test</servlet-name>
      <servlet-class>controller.Demo</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>test</servlet-name>
      <url-pattern>/test</url-pattern>
    </servlet-mapping>
    ```
  - 请求处理方法（获取所有的请求参数数据）
    ```java
    public class Demo extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // 获取完整路径，包含协议域名端口，比如：http://localhost:8080/serviceDemo/test
            StringBuffer s1 = request.getRequestURL();
            System.out.println(s1);

            // 获取资源路径，只包含路径，不包含协议域名端口，比如：/serviceDemo/test
            String s2 = request.getRequestURI();
            System.out.println(s2);
        }
    }
    ```
    - 请求测试
      - headers中不能有中文
      ```js
      fetch("/serviceDemo/test")
      ```




#### 请求处理-重定向
- 示范代码
  - 请求映射具体配置如下（web.xml）
    ```xml
    <servlet>
      <servlet-name>test</servlet-name>
      <servlet-class>controller.Demo</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>test</servlet-name>
      <url-pattern>/test</url-pattern>
    </servlet-mapping>

    <servlet>
      <servlet-name>cdx</servlet-name>
      <servlet-class>controller.Cdx</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>cdx</servlet-name>
      <url-pattern>/cdx</url-pattern>
    </servlet-mapping>
    ```
  - 请求处理方法（获取所有的请求参数数据）
    ```java
    public class Demo extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // 重定向，不要忘了根路径
            response.sendRedirect("/serviceDemo/cdx");
        }
    }

    public class Cdx extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            System.out.println("重定向");
        }
    }
    ```
    - 请求测试
      - headers中不能有中文
      ```js
      fetch("/serviceDemo/test")
      ```

#### controller下的类创建对象的特点
- controller 下面的类，是受 `Tomcat` 管理的，通过 `web.xml`，进行管理
- 管理特点: 使用的是单例模式
  - `Tomcat` 创建了一个 `map`集合，开始的时候是空的，啥也没有
  - 当动态请求来临的时候，先从 `web.xml` 中找到一个对应的类映射，然后看看`map`集合中，有没有该类已经创建好的对象
  - 如果没有，才通过反射的方式，创建一个对象，然后在缓存起来，下一次就是使用缓存了
  - 也就是， Controller 文件夹下的类，只会有一个对象产生，所有与之有关联的请求，使用的是同一个对象
- 问题
  - 如果类中，定义了状态，并且进行了修改，会对其他请求产生影响的
  - 所以，不要轻易定义属性，更不要轻易修改属性

- 使用的单例模式是懒汉式的，来一个请求，才添加一份对象
  - 可以提前创建，看后面的介绍



#### controller下的类提前构建对象
- 要想让controller中的类，在加载的时候，就把对象创建出来，需要在配置文件中(web.xml)进行配置
  - 和接口处理的配置，配置在一块（因为接口的处理配置那里，指定了处理该接口的类，然后在加一个配置，就能让类提前创建对象）
  - 由于类，提前加载好了，这样请求来的时候，就直接从缓存中取对象使用了（不用先创建对象，然后在处理请求）

- 示范配置方法
  ```xml
  <servlet>
      <servlet-name>index</servlet-name>
      <servlet-class>controller.IndexServlet</servlet-class>
      <!-- 填写的是一个整数，控制的是加载顺序（有多个类都在开始的时候加载，那个值小那个先加载） -->
      <load-on-startup>0</load-on-startup>
  </servlet>
  <servlet-mapping>
      <servlet-name>index</servlet-name>
      <url-pattern>/index</url-pattern>
  </servlet-mapping>
  ```
  - 当项目启动的时候，就会解析web.xml。然后根据配置，立马创建出对象（这样，对象就会在开始的时候，就已经创建好了）



#### controller下类的生命周期
- 经过上面的介绍：`controller`下的类，是 `Tomcat` 进行管理的，并且使用的是单例模式
  - 而`Tomcat` 在管理这些类的时候，搞了几个生命周期函数，放在了继承类（`HttpServlet`）上
- 如果想要实现对应的生命周期函数，需要进行重写
  - 其实 `service` 就是一个生命周期函数，相当于render函数

.
- `init`方法
  - 在类加载的时候(创建对象的时候)，执行的生命周期函数
  - 由于类只加载一次，所以该方法只执行一次
  - 该方法还能获取`web.xml`配置文件中，对于该类配置的一些数据
  - 示范代码
  ```java
  public class IndexServlet extends HttpServlet {

      public void init() {
          System.out.println("该类激活了");
      }

      public void service(HttpServletRequest request, HttpServletResponse response) {
      }
  }
  ```


#### controller下的获取配置文件中的数据
- 配置文件(web.xml)，是可以给对应的映射类，配置一些数据（相当于初始数据）
  - 但是，这些配置数据，只能在`init`函数中接受读取


- 配置数据的示范代码
  ```xml
  <servlet>
      <servlet-name>index</servlet-name>
      <servlet-class>controller.IndexServlet</servlet-class>
      <!-- 第一个数据 -->
      <init-param>
          <!-- 相当于key -->
          <param-name>data1</param-name>
          <!-- 相当于value -->
          <param-value>数据1</param-value>
      </init-param>
      <!-- 第二个数据，想配置几个，就写几个这样的结构 -->
      <init-param>
          <param-name>data2</param-name>
          <param-value>数据2</param-value>
      </init-param>

      <!-- 是否提前加载 -->
      <!-- <load-on-startup>0</load-on-startup> -->
  </servlet>
  <servlet-mapping>
      <servlet-name>index</servlet-name>
      <url-pattern>/index</url-pattern>
  </servlet-mapping>
  ```


- 获取配置文件中的数据（获取指定的数据）
  ```java
  public class IndexServlet extends HttpServlet {
      // 只能在init方法中获取配置文件中的数据
      public void init(ServletConfig config) {
          // 返回的是string类型的数据，参数传入想要获取对应数据的key
          String a = config.getInitParameter("data1");
          System.out.println(a);
      }

      public void service(HttpServletRequest request, HttpServletResponse response) {
      }
  }
  ```

- 获取配置文件中的数据（获取所有的数据）
  ```java
  public class IndexServlet extends HttpServlet {
      // 只能在init方法中获取配置文件中的数据
      public void init(ServletConfig config) {
          // 获取所有的key，然后遍历key，在获取对应的数据
          Enumeration en = config.getInitParameterNames();
          while(en.hasMoreElements()){
              String key = (String)en.nextElement();
              String value = config.getInitParameter(key);
              System.out.println(key+"--"+value);
          }
      }

      public void service(HttpServletRequest request, HttpServletResponse response) {
      }
  }
  ```

- 其他的两个方法(不常用，与配置数据没有关系)
  ```java
  public class IndexServlet extends HttpServlet {
      public void init(ServletConfig config) {
          // 获取当前Servlet类的名字
          String name = config.getServletName();
          // 获取全局上下文对象
          ServletContext application = config.getServletContext();
      }

      public void service(HttpServletRequest request, HttpServletResponse response) {
      }
  }
  ```




#### Servlet继承的关系
1. 自己写一个类--->继承抽象类**HttpServlet**
   1. `HttpServlet`--->继承抽象类**GenricServlet**
   2. `GenricServlet`-->实现了三个接口  **Servlet、ServletConfig、Serializable**

2. `Servlet`接口含有5个方法
    1. init(ServletConfig config);
    2. service(ServletRequest,ServletResponse);
    3. destroy();
    4. ServletConfig = getServletConfig();
    5. String = getServletInfo();

3. `ServletConfig`接口含有4个方法
    1. String value = config.getInitParameter("key");
    2. Enumeration = config.getInitParameterNames();
    3. String = config.getServletName();
    4. ServletContext application = config.getServletContext();
4. `GenricServlet`抽象类体现出了缺省适配器模式
   1. 将上述两个接口中的8个方法全部添加了实现
   2. 只留下一个service抽象方法，需要用户自己填写逻辑
   3. 还添加了两个独有的方法，`init(){}无参数`、`log(){}`
5. `HttpServlet`体现了对于协议的具体化
   1. 将父类service方法实现了
      1. 目的是将两个跨协议的参数强制转化成HTTP协议
   2. 自己添加了一个**protected修饰的service方法**(参数HttpServletRequest)
      1. 目的是通过请求发送的方式**get/post**
      2. 找寻对应具体的执行方法**doGet、doPost**
   3. **所以，处理请求，不重写`service`，重写`doGet`、`doPost`也是可以的**（常用的）
      1. 这样，`Tomcat` 就会根据自己实现的 `service` 方法，找到对应请求类型的`doGet`或者`doPost`进行处理
      2. 重写这两个方法，具体的方法，处理具体类型的请求，增加了代码的可读性
      3. **如果请求类型搞错了，是无法执行的，需要注意**



#### 读取静态文件容易产生的问题
1. 由于写的服务器代码，最终会被部署到 `Tomcat` 中，所以实际运行的代码文件的位置并不是工程中所在位置
2. **所以，使用 `FileInputStream(url)` 获取对应的文件，使用的是相对路径**
   1. **在服务器中，由于运行的文件发生了变化，所以相对位置就会出现问题**
   2. 此时读取文件数据，就会出现问题，路径不对，找不到资源

3. 解决方式
```java
public class IndexServlet extends HttpServlet {
    public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        try {
            // 这样的话就能获取到文件的输入流，路径要注意，是相对于src的
            InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("abc.html");
            // 转化成字符流
            InputStreamReader r = new InputStreamReader(inputStream);
            // 转化成高级流，一次可以读一行
            BufferedReader reader = new BufferedReader(r);
            PrintWriter out = response.getWriter();

            String d = reader.readLine();
            while(d != "" && d != null) {
                out.write(d);
                out.flush();
                d = reader.readLine();
            }
            out.write(d);
            out.flush();
        } catch(Exception e) {
           PrintWriter out = response.getWriter();
           out.write("no");
           out.flush();
        }
    }
}
```


4. 需要注意的是，要读取的文件必须放在 `src` 下
   1. 并且，路径是相对于 `src` 的
   2. 比如：`src --> abc.html` ，对应的路径为 `abc.html`
   3. 比如：`src --> demo --> abc.html` ，对应的路径为 `demo/abc.html`
   




#### session的使用
- session的介绍
  - session是服务器存储一些数据的一种结构
  - session存活与一次会话的阶段中，当会话结束，session就会自动清空
  - 一次回话与一次请求的区别
    - 服务器开启到服务器关闭或者重启，为一次会话
    - 客户端发送一个请求，到服务器作出响应为一次请求（转发也为一次请求）
  - 由于session存在与整个回话中，所以可以存放一些数据，供多个请求使用，达到数据共享的效果
  - 一个浏览器，对应一个session，也就是一个浏览器发送的请求，在session中存放的数据，只能该浏览器使用
    - 也就是，一个客户端，对应一个session

.
- session存数据
  ```java
  public class IndexServlet extends HttpServlet {
      public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          // 获取session，JSP session是内置对象，可以不用获取
          HttpSession session = request.getSession();
          // 存放数据
          session.setAttribute("key", Object);
      }
  }
  ```


- session取数据
  ```java
  public class IndexServlet extends HttpServlet {
      public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          // 获取session，JSP session是内置对象，可以不用获取
          HttpSession session = request.getSession();
          // 根据 key 取一条数据，但是数据格式为 Object 类型的，要想使用需要先造型
          Object = session.getAttribute("key");


          // 获取session中存放的所有数据的 key，得到的是一个迭代对象
          Enumeration en = session.getAttributeNames();
          while(en.hasMoreElements()) {
              // 返回值是一个Object，使用时需要造型
              String key = (String)en.nextElement();
              // 根据 key 获取对应的数据
              String data = session.getAttribute(key);
              System.out.println(key + ":  " + data);
          }
      }
  }	
  ```


- 设置session中存储的数据的存活时间，当时间过去后，session自动清空
  - 只要有一个请求设置过时间，会作用与整个 `session`
    - 比如，a请求，存了一个a，设置时间为 10秒
    - b请求存了一个 b
    - 10s一到，整个session就会被清空，所以b也没有了，所以设置一次作用整个session
  - 默认时间是 30 分钟，30分钟一到，session就会被清空
  - 设置的时间差，代表的是多长时间没有操作session，session才会被清空。
    - 如果中间过程中，有一个请求操作了session，则时间重置，重新记时
  - 示范代码
    ```java
    public class IndexServlet extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // 获取session，JSP session是内置对象，可以不用获取
            HttpSession session = request.getSession();

            // 设置session多长时间没有操作，数据就会被清空，单位是 秒
            session.setMaxInactiveInterval(30);
        }
    }
    ```




- 删除session中的某个数据（手动删除）
  ```java
  public class IndexServlet extends HttpServlet {
      public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          // 获取session，JSP session是内置对象，可以不用获取
          HttpSession session = request.getSession();
          // 根据 key 删除一条数据
          session.removeAttribute("key");
      }
  }
  ```







#### 获取和设置响应码
- 获取和设置响应码，只能获取当前的响应码
- 服务器代码在执行的时候，会根据情况，修改对应的状态码，然后在后面就可以获取到对应的状态码进行操作
  - 比如: `response.sendRedirect('重定向');`，执行完，状态码就会自动设置成 `302`
    - 如果，在后面获取状态码，获取的就是 `302`，这只是现在的状态码
    - 如果，后面又有修改状态码的程序，状态码依旧会改变，比如代码报错了，状态码就会变成 `500`
    - 如果此时在获取状态码，获取的就又是 `500` 了

.
- 服务器除了自动设置状态码，还可以手动设置
- 示范代码
  ```java
  public class IndexServlet extends HttpServlet {
      public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          // 获取状态码
          int status = response.getStatus();
          // 设置状态码
          response.setStatus(int statusNumber);
      }
  }
  ```






#### 获取和设置cookie
```java
public class IndexServlet extends HttpServlet {
    public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取cookie，得到的是一个cookie数组
        Cookie[] coo = request.getCookies();
        // 遍历cookie数组
        for(int i = 0; i < coo.length; i++) {
            // 获取该条cookie数据的 name
            System.out.println( coo[i].getName() );
            // 获取该条cookie数据的 value
            System.out.println( coo[i].getValue() );
        }
        
        // 服务端种一个cookie（写一条cookie）
        response.addCookie(new Cookie("name", "value"));
        // 可以写多条cookie
        response.addCookie(new Cookie("name", "value"));
        // cookie中，如果name重复，则value会进行覆盖，和map集合差不多
    }
}
```




#### 文件上传
- 依赖的下载
  - `fileupload`和`io`

- 前端进行文件的上传，使用的form表单
  - 但是，一个form表单下，可以包含普通的数据，以及多个文件数据，所以接受的时候，就需要进行判断
  - 上传文件，服务端需要进行写文件的操作，但是写文件的速度稍微有些慢，上传的速度是很快的
    - 所以，为了防止丢包，会进行缓存(是一个特殊的文件)，有一个默认缓存的大小
    - 但是上传很大的文件，就需要设置一下缓存的大小（默认的就不行了），否则会出现问题
  - 上传文件的时候，也可以设置限制上传文件的大小

- 接受文件数据的示范接口代码
  ```java
  public class SaveFileController extends HttpServlet {
      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          try {
              request.setCharacterEncoding("UTF-8");
              // 创建一个工厂
              DiskFileItemFactory factory = new DiskFileItemFactory();
              // 设置缓冲区大小
              factory.setSizeThreshold(1024000);
              // factory.setRepository(new File(""));  //设置缓冲区位置（缓冲文件的位置）
              // 创建一个ServletFileUpload对象(构造方法中需要factory帮忙)
              ServletFileUpload upload = new ServletFileUpload(factory);
              // 设置一下，上传文件的大小
              upload.setSizeMax(102400000);

              // 上传过程中发生的事件
              upload.setProgressListener(new ProgressListener(){
                  public void update(long l, long l1, int i) {
                      //  第一个参数表示 已经上传的字节个数   4096个字节
                      //  第二个参数表示 上传文件的总字节数
                      //  第三个参数表示 正在上传第几个组件（第几个input标签，从1开始
                      //  比如上面的三个上传文件，分别对应2， 3， 4）
                      System.out.println("正在上传第"+i+"个组件,已经上传"+((((double)l/(double)l1)*100))+"%");
                  }
              });



              // 通过upload解析request对象(解析目的是因为请求携带的信息都在request对象中)
              List<FileItem> itemList = upload.parseRequest(request);
              // 将list中所有的item元素遍历（有普通数据和文件数据）
              for(FileItem item : itemList){
                  // 是一个普通的组件
                  if(item.isFormField()){
                      String key = item.getFieldName();//获取组件的name属性
                      //String value = item.getString();//获取组件的value属性
                      String value = item.getString("UTF-8");//使用重载方法传递处理字符集的key
                      System.out.println(key+"--"+value);
                  }
                  // 是一个file文件
                  else{
                      // 获取组件的name属性(标签行间设置的name属性)
                      String key = item.getFieldName(); 
                      // 获取上传文件的真实文件名  
                      String realFileName= item.getName();
                      // 如果传递的文件真实中文名有问题(在上面设置，两个都可以，通常使用第一种方式)
                      // request.setCharacterEncoding("UTF-8");
                      // upload.setHeaderEncoding("UTF-8");
                      System.out.println(key+"--"+realFileName);
                      // 如何获取，服务器的根目录(部署后，会发生变化，需要手动获取)
                      this.getServletContext().getRealPath("/");
                      // 获取一个输入流，读取网络传递过来的文件内容
                      InputStream inputStream = item.getInputStream(); 
                      // 写文件，文件路径，可以使用后面封装的方法获取
                      item.write(new File('文件路径'));
          
                      // 也可以使用原生的方式写文件
                      /* 
                      OutputStream outputStream = new FileOutputStream("D://test/"+realFileName);
                      byte[] b = new byte[1024];
                      int length = inputStream.read(b);
                      while(length!=-1){
                          outputStream.write(b,0,length);
                          outputStream.flush();
                          length = inputStream.read(b);
                      }
                      outputStream.close();
                      */
                  }
              }
          } catch (Exception e) {
              e.printStackTrace();
          }
      }
  }
  ```



#### 文件下载
- 依赖的下载
  - `fileupload`和`io`

- 响应文件数据的接口实现
  ```java
  public class DownLoadController extends HttpServlet {

      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          // 获取请求传递的文件名(需要下载的文件)
          String fileName = request.getParameter("fileName");
          // 通过fileName找到一个服务器中的真实文件(固定位置 当前工程内部)
          // 找到文件需要一个输入流读取文件中的内容
          InputStream inputStream = new FileInputStream("D://test/"+fileName);
          // 如果文件名含有中文，通过以下方式处理
          fileName = URLEncoder.encode(fileName,"UTF-8");
          
          // 设置格式，文件下载
          response.setContentType("application/x-msdownload");
          response.setHeader("Content-disposition","attachment;filename="+fileName);

          // 将内容响应回浏览器
          OutputStream outputStream = response.getOutputStream();
          byte[] b = new byte[1024];
          int length = inputStream.read(b);
          while(length != -1){
              outputStream.write(b, 0, length);
              outputStream.flush();
              length = inputStream.read(b);
          }
      }
  }
  ```


#### 存放文件的路径问题
- 项目部署后，路径会发生变化，并不是当前的路径，所以在设置存放文件的路径时，要注意不要使用相对路径
- 获取项目的绝对路径，可以借助一个类，先获取类的绝对路径，然后在进行截取
- 封装一个获取存放文件绝对路径的类
  ```java
  public class GetPath {
      public static String getPath() {
          // 截取跟路径
          String path = GetPath.class.getResource("").getPath().split("/WEB-INF")[0];
          File f = new File(path + "/img");
          String[] names = f.list();
          // 判断有没有该文件， 没有的话就创建
          if(names == null) {
              f.mkdir();
          }
          // 得到绝对路径
          String url = f.getAbsolutePath();
          return url;
      }
  }
  ```



#### 过滤器的使用（Filter）
- 基本使用
  - 自定义一个类，**如果Tomcat的版本大于9，需要继承`HttpFilter`**
    - 如果版本低的，不用继承任何东西
  - 重写方法，`doFilter`方法
    - 该方法有三个参数: `HttpServletRequest`，`HttpServletResponse`，`FilterChain`
    - 抛出两个异常: `ServletException`，`IOException`

- 要过滤那些请求的配置（web.xml中配置）
  ```xml
  <!-- 请求的处理配置 -->
  <servlet>
        <servlet-name>login</servlet-name>
        <servlet-class>controller.LoginController</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>login</servlet-name>
        <url-pattern>/login</url-pattern>
    </servlet-mapping>

    <!-- 过滤器的配置 -->
    <filter>
        <filter-name>filterOne</filter-name>
        <filter-class>filter.FilterOne</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>filterOne</filter-name>
        <url-pattern>/login</url-pattern>
    </filter-mapping>
  ```
  - 当一个请求的路径，可以被过滤器的`url-pattern`成功匹配，就会找到对应的类，执行重写的方法
    - 如果，过滤器函数没有放行，则请求到此终止
  - 过滤器重写的方法，有三个参数，其中前两个是`(request，responses)`
    - 所以，servlet可以处理的事情，过滤器都可以处理
      - 比如，获取请求数据，转发，重定向，给予响应
    - 第三个参数，就是起放行请求的功能

.
- 过滤器，实现类的示范代码
  ```java
  public class FilterOne extends HttpFilter {
      protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
          System.out.println("我是filter 找我干嘛呀");
          //1.直接给予响应  自己拼接字符串
          //response.getWriter().write("<>");
          //2.可以(请求)转发
          //request.getRequestDispatcher("路径").forward(request,response);
          //3.可以(请求)重定向
          //response.sendRedirect("路径");
          
          //4.可以放行(只要这个代码一执行，请求就会被放行)
          chain.doFilter(request,response);
      }
  }
  ```


- 如果没有HttpFilter，就要实现Filter接口
  ```java
  public class Two implements Filter {
      public void init(FilterConfig filterConfig) throws ServletException {

      }
      public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
          System.out.println("two_start");
          chain.doFilter(request, response);
          System.out.println("two_end");
      }
      public void destroy() {

      }
  }
  ```

.
- 可以多个请求，共用一个过滤器（在配置文件中进行配置）
  - 通常，把过滤器的路径匹配，设置成`/*`，所有的请求，都用同一个过滤器进行过滤
- 也可以给具体的请求，配置拦截器

- 从代码和流程图来看
  - 似乎Filter可以替代Servlet，功能上完全可以提到
  - 从使用上貌似不行(两种不同的功能)
    - 现实生活中，目标是真正做事的，过滤器负责拦截的
    - 目标是做一件事情的，过滤器好多请求都会经过
    - 过滤器，目标之前做点事情，目标之后还会做点事情
	



#### Filter链
- 同一个请求，可以被多个拦截器，进行拦截。
  - 执行顺序为，按照配置文件中的配置顺序，从上往下执行
- 过滤器中有一个 `chain.doFilter(request,response);` 的使用，可以放行请求
  - 如果这行代码的后面，还有代码，则后面的代码不会立即执行
    - 而是，后面的处理完成，才会继续执行
  - 放行后，就会去找下一个过滤器，或者servlet，当最后一个执行完成，才会执行下面的代码
    - 类似递归

.
- 示范代码
  ```xml
  <filter>
      <filter-name>three</filter-name>
      <filter-class>filter.FilterThree</filter-class>
  </filter>
  <filter-mapping>
      <filter-name>three</filter-name>
      <url-pattern>/*</url-pattern>
  </filter-mapping>
  <filter>
      <filter-name>one</filter-name>
      <filter-class>filter.FilterOne</filter-class>
  </filter>
  <filter-mapping>
      <filter-name>one</filter-name>
      <url-pattern>/*</url-pattern>
  </filter-mapping>
  <filter>
      <filter-name>two</filter-name>
      <filter-class>filter.FilterTwo</filter-class>
  </filter>
  <filter-mapping>
      <filter-name>two</filter-name>
      <url-pattern>/*</url-pattern>
  </filter-mapping>


  <servlet>
      <servlet-name>login</servlet-name>
      <servlet-class>controller.LoginController</servlet-class>
  </servlet>
  <servlet-mapping>
      <servlet-name>login</servlet-name>
      <url-pattern>/login</url-pattern>
  </servlet-mapping>
  <!-- 上面代码中有三个过滤器 -->
  <!-- 他们的执行顺序为 three(放行) -> one(放行) -> two(放行) 
      -> JSP(解析类执行完)或者login(处理业务)，如果转发，解析完转发的文件，如果是JSP，JSP解析完成的类执行完
      -> two(放行后面的代码) -> one(放行后面的代码) -> three(放行后面的代码) -> 浏览器  -->
  ```




#### 监听器的使用（Listener）
- Listener监听器的作用
  - 监听域对象`(Session、Request、Context这个是application)`产生和销毁的
  - 监听域对象`(Session、Request、Context这个是application`)存值，修改，删除
	  - 也就是这两个方法的使用，`setAttribute();  removeAttribute();`


- 具体的实现
  - 监听`request`对象的创建和销毁，需要实现  `ServletRequestListener` 接口
  - 监听`request`对象的存值，修改，删除，需要实现  `ServletRequestAttributeListener` 接口
  - 监听`Session`对象的创建和销毁，需要实现  `HttpSessionListener` 接口
  - 监听`Session`对象的存值，修改，删除，需要实现  `HttpSessionAttributeListener` 接口
  - 监听`application`对象的创建和销毁，需要实现  `ServletContextListener` 接口
  - 监听`application`对象的存值，修改，删除，需要实现  `ServletContextAttributeListener` 接口




- 示范代码(实现的方法都是一样的（只要继承上方介绍的对应的类就可以），以request为例)
  - 可以一个类中，实现多个接口，也可以一个类只实现一个接口
  - 比如
    ```java
    // 一次性实现两个接口
    public class TestRequestListener implements ServletRequestListener, ServletRequestAttributeListener {
        public void requestDestroyed(ServletRequestEvent sre) {
            System.out.println("request对象销毁啦");
        }

        public void requestInitialized(ServletRequestEvent sre) {
            System.out.println("request对象创建啦");
        }

        // -------------------------------------------------------------

        public void attributeAdded(ServletRequestAttributeEvent srae) {
            System.out.println("request添加了数据");
        }

        public void attributeRemoved(ServletRequestAttributeEvent srae) {
            System.out.println("request删除了数据");
        }

        public void attributeReplaced(ServletRequestAttributeEvent srae) {
            System.out.println("request修改了数据");
        }
    }
    ```



- 监听器实现类定义好后，必须在`web.xml`中配置，才能起作用
  ```xml
  <!-- 类一 -->
  <listener>
    <listener-class>listener.TestRequestListener</listener-class>
  </listener>
  <!-- 类二 -->
  <listener>
    <listener-class>listener.TestSessionListener</listener-class>
  </listener>
  ```

- 总结
  - 这样的话，无论什么请求，只要request对象，经过了对应的操作，就会被监听到，然后执行对应的方法
  - 由于对象是先创建的，所以监听器的执行时间，要大于 `Filter`，大于 `servlet`







#### JSP使用-介绍
- JSP是一种文件，内部既可以写 `html` 语言，也可以写 `java` 语言
  - 主要功能是用来创建显示页面的
- 通过JSP，可以使 `Tomcat` 响应页面数据变得简单，也使控制层的功能变得更加纯粹
  - 比如: 想要动态的创建`html`，需要在控制层，做字符串的拼接，麻烦不说，控制层中还具有了视图层的功能
  - 有了JSP，就可以在JSP文件中，动态控制显示的内容

- 使用方式（转发）
  - 要想响应`JSP`文件，必须利用转发


- JSP文件第一行代码的功能
  - `contentType="text/html;charset=UTF-8";`：告知浏览器格式
  - `language="java"`：用来说明JSP中可以含有除了HTML形式的其他语言
  - `pageEncoding="UTF-8"`：用来说明Tomcat在进行JSP编译的时候



#### JSP使用-响应JSP的实现
- 必须要利用转发，才能响应JSP文件
  - 因为JSP中可能有Java代码，所以java要先转换（解析）一下，才进行响应

- 比如
  ```java
  public class InquiryController extends HttpServlet {
      public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{

          // 转发
          request.getRequestDispatcher("a.jsp").forward(request,response);
      }
  }
  ```

- 转发路径，是对应的`JSP`文件，相对于 web文件夹的位置
  - 比如: `web -->  a.jsp`。转发路径为 `a.jsp`
  - 比如: `web --> demo --> a.jsp`。转发路径为 `demo/a.jsp`


- JSP文件中的示范内容
  ```html
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <html>
  <head>
      <title>Title</title>
      <style>
          div {
              color: #f0f;
          }
      </style>
  </head>
  <body>
    <div>jsp测试内容</div>
    <script>
        console.log("ok");
    </script>
  </body>
  </html>
  ```



#### JSP使用-文件中获取请求数据
- 利用内置对象 `request`，获取请求时传入的数据
- 示范代码
  ```html
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <html>
  <head>
      <title>Title</title>
  </head>
  <body>
      <%--  java代码  --%>
      <%
          // 使用内置对象，获取获取传入的数据，格式都是字符串格式的
          String data = request.getParameter("demo");
          // 是会打印出出结果的，说明java是可以运行的
          // 并且，定义的数据，相当于全局的，都可以使用，这样下面的<%=data%>才能使用到
          System.out.println(data);
      %>
      <%-- 要想显示某个java数据，需要使用 =变量名 --%>
      <div>动态传入的数据: <%=data%>  </div>

      <%!
          // 内部的Java代码，相当于在类中定义属性和方法，所以写法也相同
          // JSP最终会被解析成一个类，这个内部写的代码，最终会放在类中，并且是放在最上面
          // 所以内部的代码，要遵循类属性和方法的写法和规则
      %>
  </body>
  </html>
  ```





#### JSP使用-获取转发前java存入的数据
- `request` 中，有两个 `Map` 集合，一个用于存放解析的请求数据，另一个就可以动态存放一些数据
- 利用另一个 `request` 中的 `Map` 集合，就可以动态往JSP中传输数据
  - 数据，实际上还是存放在 `request` 中，会一起转发出去的
  - 这样，JSP就可以通过内置对象`request`获取到动态传入的数据


- 存入数据的示范代码
  ```java
  public class InquiryController extends HttpServlet {
    public void service(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException{
        //  request对象中有两个map集合，它们的取值方式如下
        //      请求数据：String value = request.getParameter("key");
        //      动态数据：String value = request.getAttribute("key");
        // JSP中也是这样取值

        // 存放数据
        request.setAttribute("data1", "abc");
        
        // 进行转发
        request.getRequestDispatcher("showBalance.jsp").forward(request,response);
    }
  }
  ```


- jsp中获取数据的示范代码
  ```html
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <html>
  <head>
      <title>Title</title>
  </head>
  <body>
      <%--  java代码  --%>
      <%
          // 这个玩意的返回值是Object格式，需要造型
          String data = (String)request.getAttribute("demo");
          // 是会打印出出结果的，说明java是可以运行的
          // 并且，定义的数据，相当于全局的，都可以使用，这样下面的<%=data%>才能使用到
          System.out.println(data);
      %>
    <%-- 要想显示某个java数据，需要使用 =变量名 --%>
    <div>动态传入的数据: <%=data%>  </div>
  </body>
  </html>
  ```




#### JSP使用-内置对象的介绍
1. `HttpServletRequest request`
2. `HttpServletResponse response`
3. `HttpSession session`
4. `ServletContext application`
   1. 全局上下文，只有JSP中有
   2. 作用于整个服务器的生命周期，与session不用的是，`application`只有一个，不同的浏览器使用的都是同一个`application`
   3. 常用的方法
      1. `application.setAttribute("key",Object);`
		2. `Object = application.getAttribute("key");`
		3. `application.removeAttributer("key");`
		4. `Enumeration en = application.getAttributeNames();`
		5. 获取web.xml(配置文件)中的全局初始数据，`String value = application.getInitParameter("key");`
         1. 比如:
         2. 
         ```xml
         <!-- 全局的初始配置数据 -->
         <context-param>
            <param-name>aaa</param-name>
            <param-value>12333</param-value>
         </context-param>
         <context-param>
            <param-name>bbb</param-name>
            <param-value>ddd</param-value>
         </context-param>

         <servlet>
            <servlet-name>index</servlet-name>
            <servlet-class>controller.IndexServlet</servlet-class>
            <!-- 局部的初始数据 -->
            <init-param>
                  <param-name>data1</param-name>
                  <param-value>数据1</param-value>
            </init-param>
         </servlet>
         <servlet-mapping>
            <servlet-name>index</servlet-name>
            <url-pattern>/index</url-pattern>
         </servlet-mapping>
         ```
		6. `Enumeration en = application.getInitParameterNames();`
      7. `application.getRequestDispatcher("").forwar(req,resp);`
         1. 也可以进行转发，但是不常用
		8. `String realPath = application.getRealPath("/");`
         1. 获取某个路径，在实际运行中对应的完整的绝对路径（比如：`/` 就是跟路径）
			2. 写完的源代码不能执行---需要部署
			3. 正常情况下部署到当前的工程的out文件夹内
			4. 修改了配置，部署到Tomcat的webapps文件夹内，这样的话，路径就发生了变化
         5. 读取一些静态资源，就会因为路径的问题，读取不到
         6. 使用这个方法，可以进行路径的拼接，拼成实际的路径
			7. 要注意，request.getRequestURL()、request.getRequestURI();的区别
5. `JSPWriter out`
   1. 使用 `out.write` 可以响应数据
6. `Object page`
   1. 相当于 `this`
   2. 当前页（JSP），最终会被解析成一个`Java`类，而page就相当于该`Java`类中的`this`
7. `PageContext pageContext`
   1. 当前页的上下文，只有在该页面中可以使用，并且只存在当前请求中，下一个请求又是一个新的对象
   2. 类似，本次请求存储数据的集合，下一次请求就获取不到他了，使用的是一个新的
   3. `JSP`中的代码，除了`<%! %>`，都会解析在一个方法中，而`pageContext`类似于在该方法中创建了一个集合
   4. 当该方法执行完(请求处理完成)，集合就没有了
8. `ServletConfig config`
   1. String value = config.getInitParameter("key");
      1. 获取配置文件(web.xml)中的配置数据，但是只能获取局部的
      2. 但是局部的，只有动态请求才有
      3. 所以，如果是转发，可以使用config，读取配置文件中的配置数据（进行转发动态路径的数据）
      4. **如果是，直接访问的jsp，则有三个默认值，配置文件的配置数据是获取不到的**
	2. Enumeration en = config.getInitParameterNames();
	3. String name = config.getServletName();
      1. 获取到的是后缀名 `jsp`
	4. ServletContext application = config.getServletContext();
      1. 可以获取到全局上下文
9. `Exception exception`
   1. 这个对象，如果没有设置，是没有的
   2. 可以写一个新的jsp	比如error.jsp
   3. 在error.jsp头信息上设置，`isErrorPage="true"`
   4. 在正常的jsp中设置头信息(其他的jsp)，`errorPage="error.jsp"`
      1. 当其他的页面代码执行报错的时候，就会跳转到`error.jsp`(设置什么，跳转到什么位置)
      2. 此时，`error.jsp`文件中，才会有 `exception` 内置对象
      3. 其他的地方，是没有该对象的
		4. `需要注意，404没有找到资源，不是异常，并不会进行跳转`

.
- 要注意`response`、`session` 和 `application` 之间的区别



#### JSP使用-读取静态文件产生的问题
1. JSP是要经过解析的，然后形成一个Java类，解析后的文件，并不在src下面
2. **所以，使用 `FileInputStream(url)` 获取对应的文件，使用的是相对路径**
   1. **在服务器中，由于运行的文件位置有变化，所以相对位置就会出现问题**
   2. 此时读取文件数据，就会出现问题，路径不对，找不到资源

3. 解决方式
```java
<%
try {
    // 这样的话就能获取到文件的输入流，路径要注意，是相对于src的
    InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("abc.html");
    // 转化成字符流
    InputStreamReader r = new InputStreamReader(inputStream);
    // 转化成高级流，一次可以读一行
    BufferedReader reader = new BufferedReader(r);
    PrintWriter out = response.getWriter();

    String d = reader.readLine();
    while(d != "" && d != null) {
        System.out.println(d);
        d = reader.readLine();
    }
} catch(Exception e) {
}
%>
```


4. 需要注意的是，要读取的文件必须放在 `src` 下
   1. 并且，路径是相对于 `src` 的
   2. 比如：`src --> abc.html` ，对应的路径为 `abc.html`
   3. 比如：`src --> demo --> abc.html` ，对应的路径为 `demo/abc.html`
   


#### JSP使用-导包使用的方式
1. 在JSP的最上面，写上 `<%@ page import="包名" %>`
   1. 比如： `<%@ page import="java.util.Properties" %>`
   2. 比如： `<%@ page import="java.io.*" %>`



#### JSP使用-EL表达式的使用
- EL作用，就是使JSP中，取数据变得更加的方便
  - 第一开始，是通过`<%= %>`，取值
  - 后来有了动作标签，就可以通过`<jsp:getProperty name="对象名" property="属性值"></jsp:getProperty>`，取值
  - 但是局限性比较大，只能获取四个作用域中存放的某个对象中的属性值(具体看jsp动作标签的介绍)
  - 在后来，就有了更加强大的EL(只能获取域对象中的值)
  - 可以获取值，还可以进行一些简单的运算操作


.
- 具体操作
  1. 获取`page(pageContext)`中的值
    1. 通过，`${pageScope.xxx}`，就可以获取到`page(pageContext)`中存放的某个值
    2. 比如: `${pageScope.name}`，就相当于 `pageContext.getAttribute("name")`
        1. 这样，就可以获取到`pageContext`中存放的`name`
        2. 通过反射，调用的`getAttribute`方法
    3. **如果，name存放的是一个对象，想要获取内部的某个属性**
        1. 可以通过 `${pageScope.name.xxx}` 这种方式获取
        2. **底层是自动调用的 `getXXX()`，所以name对象中要保证有该方法，否则会报错**
        3. 由于，`${pageScope.name}` 获取到的就是name对象，所以可以直接调用 `getXXX()` 进行数据的获取
          1. 比如: **`${pageScope.name.getA()}` 这也是可以获取的**
          2. 所以，`${pageScope.name}` 既然获取的是一个对象，所以可以调用name对象中任何公有的方法
              1. 比如: **`${pageScope.name.xxx()}`**
              2. 如果有返回值，也是可以获取到返回值进行展示的（比如getXxx）
              3. 如果没有返回值，则该位置展示的就为空（因为该方式就是获取值进行展示的）
    4. **如果，name存放的是一个数组，想要获取内部的某个属性**
        1. 可以通过 `${pageScope.name[xxx]}` 这种方式获取
        2. 并且数组，自动处理了空指针异常的错误，如果出现空指针异常，得到的是一个空
  2. 其他的三个域对象分别对应 `requestScope、sessionScope、applicationScope`
    1. 使用方式，与原理，与上面的一样
  3. **如果，没有写域对象对应的名字，直接获取某个属性**
    1. 比如: `${requestScope.xxx}`，写成了 `${xxx}`
    2. 取值原理为: 挨个扫描，如果取到了值，停止扫描，使用获取到的值
    3. **扫描顺序为: `pageScope、requestScope、sessionScope、applicationScope`**
  4. **如果，使用${}，得到的是一个引用数据，就会展示成对应的code码**


.
- 获取请求参数
  1. 获取一个: `${param.xxx}`
  2. 获取key相同的一组: `${paramValues.xxx}`，比如`a=3&a=4&a=5`，如果使用上面的方式，只能获取第一个值


.
- 其他的
  1. `${initParam.xxx}`，配置文件中的配置参数，是局部的，不是全局的。
    1. 所以这个方法，只有动态请求转发，才能获取值，获取的是动态请求配置的对应的局部参数
  2. `${cookie[xxx]}`
  3. `${header[accept-language]}`


.
- 加减乘除运算，需要特别注意
  1. 会把所有的数据，全部转换成数字，然后在进行运算
  2. `+` 是最特殊的，哪怕一侧或者两侧有一个字符串，进行的也是逻辑运算，并不会进行字符串的拼接。
    1. 底层，把字符串格式的数据，转换成数字
    2. **所以要注意，如果两侧有一个不是数字格式的字符串，是会报错的（底层转换不了）**





#### JSP使用-JSTL表达式的使用（导包）
1. JSTL要想使用，需要下载两个包，一个是`jstl.jar`、一个是`standard.jar`
2. 第二步，把这两个包，放在项目中，两种方法
   1. **可以在工程内web文件夹的WEB-INF文件夹内创建自己的文件夹lib，然后把这两个文件放在内部**
      1. 这样，部署的时候，才能跟着项目一块走
   2. **也可以直接将两个jar文件导入Tomcat中的lib文件夹**
3. 第三步，激活两个包
   1. 点击 `file`，然后在点击 `Project Structure`
   2. 点击 `modules`
   3. 点击加号，点击 `labrary`，点击 `new `，点击`java`，选中对应的 `jar`，点击ok，然后勾选上，在点击`apply`
   4. 最后点击下 `ok`，就添加成功了
4. JSTL中分为三种标签



#### JSP使用-JSTL表达式的使用（核心标签）
- 引入核心标签
  - `<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>`
  - 如果路径是红色的，说明导包没有导好，如果是绿色的，就可以使用了

.
- 遍历数据
  ```html
  <%@ page import="java.util.ArrayList" %>
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>


  <%--遍历一个集合--%>
  <%
      ArrayList<Integer> list = new ArrayList<Integer>();
      list.add(2);
      list.add(4);
      list.add(5);
      int[] arr = {3, 5, 7};
      request.setAttribute("list", list);
      request.setAttribute("arr", arr);
  %>
  <%--需要特别注意，不能遍历纯数组，因为end="${requestScope.arr.length}"
      实际上执行的是 getLength()，根本就没有这个方法，执行就会出错。
      除非end写一个固定的值，是可以遍历的，或者再动态存一个值
      要想遍历数组，需要借助增强循环
  --%>
  <%--其中items是将要遍历的是集合
      var是遍历出的数据
  --%>
  <%--${} 只能获取四大域中的数据，所以只能遍历域中存放的数据--%>
  <c:forEach begin="0" end="${requestScope.list.size() - 1}" items="${requestScope.list}" step="1" var="data">
      <c:out value="${data}"></c:out>
  </c:forEach>
  <%--使用增强for，进行便利，不用写起点和终点--%>
  <c:forEach items="${requestScope.list}" step="1" var="data">
      <c:out value="${data}"></c:out>
  </c:forEach>
  <%--由于终点是自动获取的，所以，可以遍历数组，是可以获取到length的--%>
  <c:forEach items="${requestScope.arr}" step="1" var="data">
      <c:out value="${data}"></c:out>
  </c:forEach>
  ```

.
- 循环
  ```js
  <%@ page import="java.util.ArrayList" %>
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>


  <%--循环，从1遍历到5(可以等于5)，每次增加一个，a就是索引--%>
  <%--相当于，for(int a = 1; a <= 5; a ++)--%>
  <%--但是 a 得到的是一个对象，要想取到具体的索引，需要a.index --%>
  <%--不能倒着增，也就是step不能为负数 begin不能大于end --%>
  <c:forEach begin="1" end="5" step="1" varStatus="a">
      <%--获取到索引--%>
      <c:out value="${a.index}"></c:out>
  </c:forEach>
  ```

.
- 判断
  ```js
  <%@ page import="java.util.ArrayList" %>
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

  <%--在浏览器展示出来--%>
  <c:out value="你好"></c:out>

  <%--进行判断，如果test中的条件为true，内部的元素才进行展示--%>
  <%--并且test中只能写EL表达式，其他的不能写--%>
  <%--没有c:else--%>
  <c:if test="${3<2}">
      <%
          System.out.println("ok");
      %>
      <c:out value="你好"></c:out>
  </c:if>

  <%-- if else-if else 的功能 --%>
  <c:choose>
      <%-- 相当于第一个if --%>
      <c:when test="${3>2}"><c:out value="你好"></c:out></c:when>
      <%-- 相当于 else——if --%>
      <c:when test="${3>2}"><c:out value="你好"></c:out></c:when>
      <%-- 相当于 else——if --%>
      <c:when test="${3>2}"></c:when>
      <%-- 相当于 else --%>
      <c:otherwise></c:otherwise>
      <%--所以只有第一个展示出来--%>
  </c:choose>
  ```

.
- 拆分字符串
  ```js
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

  <%
      request.setAttribute("str", "a-b-c-d-f");
  %>
  <%-- 把items中指定的字符串，按照delims指定的字符进行拆分，拆分出的每一项，赋值给value --%>
  <%-- 拆分完，会自动遍历 --%>
  <c:forTokens var="value" items="${requestScope.str}" delims="-">
      <div>${value}</div>
  </c:forTokens>
  ```



#### JSP使用-JSTL表达式的使用（函数）
- JSTL的函数，是用来处理字符串的，相当于String类中的一些常用方法

.
- 引入
  1. `<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn" %>`
  2. 如果路径是红色的，说明导包没有导好，如果是绿色的，就可以使用了
  3. **函数，必须放在EL中才能起作用**


- 具体使用
  ```js
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn" %>

  <%
      request.setAttribute("str", "a-b-c-d-f");
  %>


  <%--获取字符串的长度--%>
  ${fn:length(requestScope.str)}
  <%--截取，把一个字符串，从什么位置，截取到什么位置--%>
  ${fn:substring(requestScope.str, 1, 3)}
  ```


#### JSP使用-JSTL表达式的使用（格式化标签）
- 引入
  1. `<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %>`
  2. 如果路径是红色的，说明导包没有导好，如果是绿色的，就可以使用了



- 具体使用
  ```js
  <%@ page import="java.util.Date" %>
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %>

  <%
      request.setAttribute("date", new Date());
  %>


  <%--格式化时间--%>
  <fmt:formatDate value="${requestScope.date}" pattern="yyyy-MM-dd hh:mm:ss"></fmt:formatDate>
  ```


#### JSP使用-JSTL表达式的使用（自定义函数）
1. 自己描述一个类(创建一个类)
2. 类中描述自己的方法(创建一个方法)，**方法必须是静态的**，方法通常有返回值
3. **配置一个"说明书"----->xxx.tld**
   1. 当前工程下web文件夹中的`WEB-INF`文件夹下创建一个新的`xx.tld`文件
      1. 点击 `XML configuration file` 然后选中lib，可以快速创建
   2. 具体描述为
   ```xml
    <!-- 说明书的配置，下面两行，一个文件定义一次，说明的方法可以有多个 -->
    <short-name>myAdd</short-name>
    <!-- 通常前面的是相同的，只修改路径 -->
    <uri>http://zi_ding_yi.com/01</uri>

    <!-- 可以指定某个类中的某个方法 -->
    <function>
        <!-- 方法名(是自定义的) -->
        <name>add</name>
        <!-- 类位置 -->
        <function-class>myfn.MyFunctions</function-class>
        <!-- 调用类中的那个方法，用 返回值 函数名 参数 指定 -->
        <function-signature>int add(int,int)</function-signature>
    </function>
    
    <!-- 可以指定某个类中的另一个方法，或者别的类中的方法 -->
    <function>
        <!-- 方法名(是自定义的) -->
        <name>name</name>
        <!-- 类位置 -->
        <function-class>myfn.MyFunctions</function-class>
        <!-- 调用类中的那个方法，用 返回值 函数名 参数 指定 -->
        <function-signature>int name(int,int)</function-signature>
    </function>
   ```
4. 使用自定义的方法
```js
<!-- 引入配置的说明书 -->
<%@ taglib uri="http://zi_ding_yi.com/01" prefix="myAdd" %>
<!-- 使用该说明书中配置的方法 -->
${myAdd:add()}
```




#### JSP使用-JSTL表达式的使用（自定义标签）
1. 一个标签，就是一个类，自定义的方法，一个类可以提供多个方法
2. 定义的类，也是有约束的
   1. 实现一个Tag接口，重写里面的方法
   2. 具体的示范代码如下
   ```java
    public class MyOut implements Tag {
        // 行间传值，就会执行对应的 set方法，需要在说明书中进行配置
        private String value;
        public String getValue() {
            return value;
        }
        public void setValue(String value) {
            this.value = value;
        }
        
        // 标签头部解析完成执行( <xxx:xxx> 解析完成，该方法就会执行 )
        public int doStartTag() throws JspException {

            // 这个返回值，表示的是，所有的子节点，展示出来
            return Tag.EVAL_BODY_INCLUDE;
            // 这个返回值，表示的是，所有的子节点，不展示出来，也就是写了子节点无效
            //return Tag.SKIP_BODY;
        }
        // 标签尾部解析完成执行( </xxx:xxx> 解析完成，该方法就会执行 )
        public int doEndTag() throws JspException {
            try {
                //可以获取out对象
                JspWriter out = this.pageContext.getOut();
                // 这样该标签，就会展示出内容
                // 由于该方法是标签尾部解析完成才会执行
                // 所以展示的内容在所有字节点的最后面展示出来
                // 如果在上面的方法中进行输出，则会在所有的子节点的前面展示出来
                out.write(value+" 很帅！！！");
            } catch (IOException e) {
                e.printStackTrace();
            }

            // 这个返回值，表示的是，该标签后面的，所有标签展示出来（通常设置成这个值）
            return Tag.EVAL_PAGE;
            // 这个返回值，表示的是，该标签后面的，所有标签不展示出来
            //return Tag.SKIP_PAGE;
        }


        //============================================
        private Tag parent;
        public void setParent(Tag parent) {
            this.parent = parent;
        }
        public Tag getParent() {
            return this.parent;
        }

        private PageContext pageContext;
        public void setPageContext(PageContext pageContext) {
            this.pageContext = pageContext;
        }
        public PageContext getPageContext(){
            return this.pageContext;
        }

        public void release(){}
    }
   ```
3. 配置一个说明书，把定义的类映射成一个标签(说明书的创建方法和自定义方法的一样，内部的配置代码是不同的)
```xml
<!-- 先描述uri和short-name -->
<short-name>myTag</short-name>
<!-- 通常前面的是相同的，只修改路径 -->
<uri>http://zi_ding_yi.com/02</uri>

<!-- 再描述标签及标签内部的属性 -->
<tag>
    <!-- 名字 -->
    <name>out</name>
    <!-- 类映射 -->
    <tag-class>mytag.MyOut</tag-class>
    <body-content>JSP</body-content>
    <!-- 类中有需要动态传值的属性，通过标签的行间属性进行传值 -->
    <attribute>
        <name>value</name>
        <required>true</required>
        <rtexprvalue>true</rtexprvalue>
    </attribute>
</tag>
```

4. 使用自定义的标签
```xml
<!-- 引入配置的说明书 -->
<%@ taglib uri="http://zi_ding_yi.com/02" prefix="myTag" %>
<!-- 使用该说明书中配置的某个标签，比如上面配置的out -->
<myTag:out value="123"></myTag:out>
<!-- 说明书中，配置value，该属性，所以需要进行传递，会自动执行对应类中对应属性的set方法 -->
<!-- 如果还指定了其他的属性，则行间也需要传递，并且类中需要有对应的set方法 -->
```
		







#### JSP使用-指令标签
- 指令标签：`<%@ page %>`
  - 行间属性
    - `contentType="text/html;charset=UTF-8"`，告知浏览器解析时遵循的规则
    - `language="java"`，告知JSP中含有的语言(默认)
    - `pageEncoding="UTF-8"`，告知Tomcat解析JSP时遵循的字符规则
    - `import=""`，在JSP中导入的Java文件的包
    - `isErrorPage="true"`，设置当前JSP作为一个异常页，exception
    - `errorPage="xxx.jsp"`，发生异常，跳转的页面


- 指令标签：`<%@ taglib %>`


- 指令标签：`<%@ include file="文件路径" %>`
  - 用来在当前JSP中引入已经写好的资源（.jsp，.html）
  - include标签引入一个JSP资源正常(不会出现中文乱码的问题，脚本也同时好用)
  - include标签引入一个HTML资源(产生中文乱码，即便是设置了charset也不好用)
    - 解决上述HTML乱码问题需要配置一个文件，web.xml
    - 主要配置`page-encoding`就可以了
    - 比如
      ```xml
      <jsp-config>
          <jsp-property-group>
              <description>JSPConfiguration</description>
              <display-name>JSPConfiguration</display-name>
              <url-pattern>*.jsp</url-pattern>
              <el-ignored>false</el-ignored>
              <page-encoding>UTF-8</page-encoding>
              <scripting-invalid>false</scripting-invalid>
          </jsp-property-group>
          <jsp-property-group>
              <description>HTMLConfiguration</description>
              <display-name>HTMLConfiguration</display-name>
              <url-pattern>*.html</url-pattern>
              <el-ignored>false</el-ignored>
              <page-encoding>UTF-8</page-encoding>
              <scripting-invalid>false</scripting-invalid>
          </jsp-property-group>
      </jsp-config>
      ```
  - 引入规律
    - 把`head`标签下的所有内容和`body`标签下的所有内容和不在这两个标签下的内容，全部放在，写`<%@ include file=""%>`的地方
    - 也就是，去除掉所有的`html、head、body、<!DOCTYPE html>标签`，剩下的所有内容
      - 是所有的，并不是最外侧的
    - 比如:
      ```html
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <title>Title</title>
          <script>
              console.log("adfasd");
          </script>
          <head>bacn</head>
      </head>
      <body>demo</body>
          demo
          <div>demo</div>
      </html>

      <!-- 去除 html、head、body、<!DOCTYPE html>标签 -->
      <meta charset="UTF-8">
      <title>Title</title>
      <script>
          console.log("adfasd");
      </script>
          bacn
      demo
      demo
      <div>demo</div>
      <!-- 会把上面这一段，放在 <%@ include file=""%> 进行替换 -->
    ```



#### JSP使用-代码标签
1. JSP编译执行的原理
   1. JSP看起来像是一个文件资源，其实本质上是一个操作资源，JSP本质就是一个Servlet
   2. 浏览器发送请求，index.jsp	--->请求到达Tomcat，参考web.xml配置文件(工程 容器)
   3. *.jsp的配置--->JspServlet(JSP解析引擎)
   4. JspServlet这个类读取index.jsp的文件资源内容--->解析--->index_jsp.java
   5. index_jsp.java源代码--->编译--->index_jsp.class字节码文件--->执行，out.write("<>");
2. 浏览器接受了回写回来的响应信息--->解析--->效果
   1. `<%!  %>`，生成的代码存在xxx_jsp.java类中，作为成员存在，通常用来定义属性，方法
   2. `<%  %>`，生成的代码存在xxx_jsp.java类中的_jspService()方法内部，方法内的局部，通常是写逻辑
   3. `<%=  %>`，生成的代码存在xxx_jsp.java类中的_jspService()方法内部，通常用来赋值或者打印输出




#### JSP使用-动作标签
- JSP动作标签，用来替代JSP中java创建对象，对象的赋值取值，请求转发，携带参数
  - 格式为: `<jsp:xxx>`

- 动作标签：`<jsp:include page="模块路径">`
  - 导入其他模块，可以导入`.jsp、.html`，并且导入的方式和 `<%@ include file=""%>`完全一样
  - 去除所有的 `html、body、head、<!DOCTYPE html>`，剩下的内容，替换掉对应的`<jsp:include page="">`

.
- 动作标签：`<jsp:useBean id="abc" class="dom.Abc" scope="request"></jsp:useBean>`
  - `id`表示创建的对象名
  - `class`表示使用那个包创建对象(使用反射的机制创建对象)
  - `scope`把创建好的对象放在那个环境下
  - 原理，判断该环境下有没有该对象，如果有不再进行创建，如果没有才会进行对象的创建
  - 比如
    ```java
        // 没有才进行创建，request是指定的环境，如果环境指定为 session 则为 session.getAttribute
        // abc为id指定的，也就是对象的名称
        if(request.getAttribute('abc') == null) {
          // 使用指定的包名，利用反射进行创建
          Class clazz = Class.forName("dom.Abc");
          // 把创建好的对象存起来
          request.setAttribute("abc", abc);
        }
    ```

.
- 动作标签：`<jsp:setProperty name="" property="" param=""></jsp:setProperty>`
  - `name`指定的是对象名，也就是创建时的`id`名
  - `property`指定的是给那个属性负值，底层**调用的是对应的set方法，所以该方法要存在，否则会报错**
  - `param`指定的是，把请求中的那个参数赋值给该属性
     - 比如请求参数是 `a=123&b=456`，如果`param`写的是 `param='a'` 
     - 则该属性的属性值为123
  - 除了上面的三个属性，还有一个 `value` 属性，直接 `value` 指定的值，赋值给属性，不从请求中拿，直接定死

.
- 动作标签：`<jsp:getProperty name="" property=""></jsp:getProperty>`
  - `name`指定的是对象名，也就是创建时的`id`名
  - `property`指定的是给那个属性负值，底层**调用的是对应的get方法，所以该方法要存在，否则会报错**
  - 会把取出的值，替换掉 `<jsp:getProperty name="" property=""></jsp:getProperty>`，浏览器进行展示

.
- 转发
  ```xml
  <!-- 进行转发，page是转发的路径 -->
  <jsp:forward page="">
      <!-- 携带的初始参数，可以随着转发，一起到另一个页面，name相当于key -->
      <jsp:param name="" value=""></jsp:param>
  </jsp:forward>
  ```
  6. **转发，会共享request，而，通过指令标签创建对象过程中的 scope="request"，指定的是环境**
    1. 其实，本质的作用是，调用 `scope` 指定的环境的，**setAttribute方法，把创建的对象存放起来**
    2. 所以，转发后的页面，就可以通过对应环境的 **getAttribute方法，把创建的对象取出来进行使用**
        1. 这个方法返回值是 `Object` 类型的，所以在使用的时候，不要忘了造型
  7. 转发过程中，还可以传递默认值，它们的取值方法
  ```java
  // //接收前面传递的参数（具体值）
  String data = request.getParameter("key");
  //接收前面传递的参数（所有）
  Enumeration en = request.getParameterNames();
  while(en.hasMoreElements()){
    String key = (String)en.nextElement();
    String value = request.getParameter(key);
    System.out.println(key+"---"+value);
  }
  ```



- 诞生的过程
  1. 技术最早是ModelOne模式
      1. 只有Servlet，VC+M
      2. VC在一起的，拼接响应信息V ，很麻烦
  2. 技术稍微革新了一下ModelTwo模式
      1. JSP+Servlet，V+C
      2. V和C分开
  3. JSP技术出现以后，写法比较简单，更像是一个文件资源
    1. 而且这个文件中还能直接写Java程序
    2. JSP--->V、JSP--->Servlet
    3. 运行性能就有问题，不安全，管理起来也不方便
    4. JSP2.0，动作标签，替代对象创建，赋值，请求转发
  4. JSP展示时候会出现一些逻辑的问题
    1. 所有JSP的标签风格不统一
    2. EL+JSTL
    3. Expression，Language
  5. 新的模板语言产生

.
- 总结
  1. JSP三个指令标签：`<%@page%>、<%@taglib%>、<%@include%>`
  2. JSP六个动作标签：`<jsp:>、useBean、setProperty、getProperty、forward、param、include`
  3. JSP四个作用域：`page(pageContext)、request、session、application`
  4. JSP九个内置对象：`request、response、session、application 、out 、page、pageContext、config、exception`






#### xml文件-文件的创建
- xml文件的作用：保存数据和传递数据

- xml文件的核心，就是一对一对的标签，然后在标签中，定义数据
  - 标签，并没有固定的标签，可以随意定义
  - 但是要想定义的标签，起作用，必须进行说明(配置)，这种方式，被称为 DTD**
    - 可以在网上，搜 DTD，查看使用文档

.
- 具体使用
  1. 第一步：描述根标签 `<!DOCTYPE 根标签的名字 [规则]>`
  2. 第二步：描述根标签中的其他标签（只有描述了，才能使用）
    1. 描述方式 `<!ELEMENT 元素名 类别|(元素里面的内容) >`
        1. `类别|(元素里面的内容)` 表示，可以填写`类别`，或者 `子节点`
        2. `子节点`，要写在 `()` 中，多个子节点，中间用 `,`或者`|` 隔开
          1. `子节点`是普通的文字，写 `#PCDATA`，这个描述，节点内也可以为空
          2. 描述子节点的时候，可以描述个数范围
          3. 只有 `?`(0-1)、`*`(0-n)、`+`(1-n) 三种情况
        3. 类别，通常是`EMPTY`
        4. 多个子节点，中间用 `,`或者`|` 隔开
          1. `,`表示，两侧的节点，都要存在（个数在定义的范围内）
          2. `|`表示，两侧的节点，必须只能存在一个（个数在定义的范围内）
  3. 第三步：描述标签的行间属性
    1. 具体的描述方式: `<!ATTLIST 标签名 属性名 什么类型 值   属性名 什么类型 值>`
      1. 通常类型的描述
      1. `CDATA`，原封不动 (通常用来描述属性名)
      2. 如果想要描述多个类型: 使用 `(t1|t2|t3)` 来描述
      3. 值的描述（有两种，一种直接描述默认值，一种是描述格式）
        1. 默认值，`"xxx"`
        2. 格式: `#REQUIRED`(必须)、`#IMPLIED`(非必需)、`#FIXED 具体值`(固定的)

  4. 如果想要描述实体
    1. `<!ENTITY 实体名字 "实体的值">`
    2. 比如: `<!ENTITY spring "this is spring">`
    3. 使用自定义的实体 `<div>&spring;</div>`

  5. 第一步必须写在xml中，第二步往后，可以提出来写在具体的文件中(这也是常用的方式)
    1. 写在xml文件中，第二步往后，需要写在，第一步的`[]`中
    2. 如果把规则提取出来，文件后缀名为 `.dtd`
      1. 第一步，只需要引入对应的规则就可以了
      2. 引入方式为: `<!DOCTYPE school SYSTEM "规则文件路径">`

.
- 规则描述的示范代码
  ```js
  <?xml version="1.0" encoding="UTF-8" ?>

  <!ELEMENT school (class*)>
  <!ELEMENT class (teacher,student*)>
  <!ELEMENT teacher (sex)>
  <!ELEMENT student (sex)>
  <!ELEMENT sex (#PCDATA)>

  <!ATTLIST school
      id CDATA #IMPLIED
      name CDATA #IMPLIED
      loc CDATA #IMPLIED
  >
  <!ATTLIST class
      id CDATA #IMPLIED
      name CDATA #IMPLIED
      loc CDATA #IMPLIED
  >
  <!ATTLIST teacher
      id CDATA #IMPLIED
      name CDATA #IMPLIED
      age CDATA #IMPLIED
  >
  <!ATTLIST student
      id CDATA #IMPLIED
      name CDATA #IMPLIED
      age CDATA #IMPLIED
  >
  ```

.
- 规则描述的xml文件
  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE school SYSTEM "myxml.dtd">

  <school id="xxx" name="" loc="">
      <class id="" name="" loc="">
          <teacher id="" name="" age="">
              <sex>男</sex>
          </teacher>
          <student id="" name="" age="">
              <sex>女</sex>
          </student>
          <student>
              <sex></sex>
          </student>
          <student>
              <sex></sex>
          </student>
      </class>
      <class>
          <teacher>
              <sex></sex>
          </teacher>
          <student>
              <sex></sex>
          </student>
          <student>
              <sex></sex>
          </student>
          <student>
              <sex></sex>
          </student>
      </class>
  </school>
  ```




#### xml文件-文件的解析方式（概述）
1. DOM解析
   1. 树结构处理方式
   2. 将文档全部解析，形成一个树结构，节点---标签
   3. 优点: 编程容易  
   4. 缺点: 必须将整个文档全部处理完毕(慢)

2. SAX解析
   1. 类似流媒体方式
   2. 基于事件的模式，解析时候触发一系列事件
   3. 当某一个tag标签被解析的时候，激活后续的方法
   4. 优点: 快(不需要将所有文档都一次性处理完)
   5. 缺点: 编写很麻烦(复用性也不强)

3. JDOM
   1. 外部jar包，基于DOM方式，底层提升了性能


4. DOM4J
   1. 外部jar包，基于JDOM方式，底层提升了性能




#### xml文件-文件的解析方式（DOM解析）
```java
public class Dom {
    public static void main(String[] args){
        try {
            //1.需要一个工厂(建造工人)
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            //2.利用工厂创建工人
            DocumentBuilder builder = factory.newDocumentBuilder();
            //3.工人创建一个document对象(需要一张图纸 xml文件)
            File file = new File("src/testxml/school.xml");
            // 如果是 Tomcat，可以使用下面的方式读取内容，最终会进行部署，路径会进行变化
            //InputStream inputStream = Thread.currentThread().getContextClassLoader().
            Document document = builder.parse(file);

            //4.解析xml文件
            //获取根标签对象(school)
            //方式一
            Element school = document.getDocumentElement();
            //方式二
//          Element school = document.getElementById("duyi");//需要有dtd规则
            //方式三，得到的是一个集合，获取所有的school标签
//          NodeList RootList = document.getElementsByTagName("school");
//          要使用第几个，就获取第几个
//          Element school = RootList.item(0);

            // 获取school标签中的属性
            String schoolID = school.getAttribute("id");
            String schoolName = school.getAttribute("name");
            String schoolLOC = school.getAttribute("loc");
            System.out.println(schoolID+"--"+schoolName+"--"+schoolLOC);


            // 获取school标签中的子标签
            // 方式一
//            NodeList classList = document.getElementsByTagName("class");
            //方式二
            NodeList classList = school.getElementsByTagName("class");
            //方式三
//            NodeList classList = school.getChildNodes();//需要有dtd规则
            for(int i=0;i<classList.getLength();i++){
                //某一个class标签
                Element classEle = (Element)classList.item(i);
                // 获取行间属性
                String classID = classEle.getAttribute("id");
                String className = classEle.getAttribute("name");
                String classLOC = classEle.getAttribute("loc");
                System.out.println("\t"+classID+"--"+className+"--"+classLOC);


                // class标签的子标签teacher
                //方式一，如果只有一个标签，就可以直接获取，不用进行遍历
                Element teacher = (Element)classEle.getElementsByTagName("teacher").item(0);
                //方式二
//                Element teacher = (Element)classEle.getFirstChild();//需要有dtd规则
                // 获取行间属性
                String teacherID = teacher.getAttribute("id");
                String teacherName = teacher.getAttribute("name");
                String teacherAge = teacher.getAttribute("age");
                Element teacherSexEle = (Element)teacher.getElementsByTagName("sex").item(0);
                // 获取标签的文本节点内容
                String teacherSex = teacherSexEle.getTextContent();
                System.out.println("\t\t"+teacherID+"--"+teacherName+"--"+teacherAge+"--"+teacherSex);

                // class标签中的子标签student
                NodeList studentList = classEle.getElementsByTagName("student");
                for(int j=0;j<studentList.getLength();j++){
                    Element student = (Element)studentList.item(j);
                    // 获取行间属性
                    String studentID = student.getAttribute("id");
                    String studentName = student.getAttribute("name");
                    String studentAge = student.getAttribute("age");
                    Element sex = (Element)student.getElementsByTagName("sex").item(0);
                    // 获取标签的文本节点内容
                    String studentSex = sex.getTextContent();
                    System.out.println("\t\t"+studentID+"--"+studentName+"--"+studentAge+"--"+studentSex);
                }
            }

      } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```


1. 读取标签的方式，方法大致相同，可以进行封装




#### xml文件-文件的解析方式（JDOM解析）

1. JDOM
   1. 外部jar包，基于DOM方式，底层提升了性能
   2. 所以，要想使用JDOM解析xml，需要下载包，然后把包导入工程中（可以参照其他的导包方式）
2. 包的下载方式
   1. 进入官网：`http://www.jdom.org/`
   2. 点击: `Get JDOM Here!`
   3. 选中一个版本下载即可，比如 `JDOM 2.0.6`
   4. 下载下来的是一个文件夹，只要核心的文件导入工程中即可



3. 使用方式
```java
public class JDOM {
    public static void main(String[] args){
        try {
            System.out.println("以JDOM形式进行解析 需要一个jdom.jar外部包");
            //获取builder对象   自己创建
            SAXBuilder builder = new SAXBuilder();
            File file = new File("src/testxml/school.xml");
            //工人创建document对象
            Document document = builder.build(file);

            //读取school.xml中的根标记  school
            Element school = document.getRootElement();
            //获取school标签中的属性
            String schoolID = school.getAttributeValue("id");
            String schoolName = school.getAttributeValue("name");
            String schoolLOC = school.getAttributeValue("loc");
            System.out.println(schoolID+"--"+schoolName+"--"+schoolLOC);
            //获取school标记的子元素 好几个class
            List<Element> classList = school.getChildren("class");
            for(Element classEle : classList){
                //获取classEle中的属性
                String classID = classEle.getAttributeValue("id");
                String className = classEle.getAttributeValue("name");
                String classLOC = classEle.getAttributeValue("loc");
                System.out.println("\t"+classID+"--"+className+"--"+classLOC);
                //获取class中的子元素 teacher
                Element teacher = classEle.getChild("teacher");
                String teacherID = teacher.getAttributeValue("id");
                String teacherName = teacher.getAttributeValue("name");
                String teacherAge = teacher.getAttributeValue("age");
                Element teacherSexEle = teacher.getChild("sex");
                // 获取该节点的文本节点
                String teacherSex = teacherSexEle.getText();
                System.out.println("\t\t"+teacherID+"--"+teacherName+"--"+teacherAge+"--"+teacherSex);
                //获取class中的子元素 好多student
                List<Element> studentList = classEle.getChildren("student");
                for(Element student : studentList){
                    String studentID = student.getAttributeValue("id");
                    String studentName = student.getAttributeValue("name");
                    String studentAge = student.getAttributeValue("age");
                    // 可以直接获取子节点中的文本，不用在获取子节点，然后在获取文本
                    String studentSex = student.getChildText("sex");
                    System.out.println("\t\t"+studentID+"--"+studentName+"--"+studentAge+"--"+studentSex);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}
```




#### xml文件-文件的解析方式（DOM4J解析）
1. DOM4J
   1. 外部jar包，基于JDOM方式，底层提升了性能
   2. 所以，要想使用DOM4J解析xml，需要下载包，然后把包导入工程中（可以参照其他的导包方式）
2. 包的下载方式
   1. 进入官网：`https://dom4j.github.io/`
   2. 点击某个版本的: `DownLoad`
   3. 选中一个版本下载即可
   4. 下载下来的是一个文件，直接导入工程中

3. 使用方式
```java
public class DOM4J {
    public static void main(String[] args){
        try {
            System.out.println("利用DOM4J形式解析 需要以来外部dom4j.jar");
            //创建一个解析对象
            SAXReader reader = new SAXReader();//理解为是之前的builder对象
            //提供一个文件
            File file = new File("src/testxml/school.xml");
            //让解析对象读取file并产生一个document对象
            Document document = reader.read(file);

            //获取根元素
            Element school = document.getRootElement();
            //获取school中的属性
            String schoolID = school.attributeValue("id");
            String schoolName = school.attributeValue("name");
            String schoolLOC = school.attributeValue("loc");
            System.out.println(schoolID+"--"+schoolName+"--"+schoolLOC);

            //获取school中的子元素 class
            List<Element> classList = school.elements("class");
            for(Element classEle : classList){
                //获取class中的属性
                String classID = classEle.attributeValue("id");
                String className = classEle.attributeValue("name");
                String classLOC = classEle.attributeValue("loc");
                System.out.println("\t"+classID+"--"+className+"--"+classLOC);
                //获取class中的子元素(一个teacher)
                Element teacher = classEle.element("teacher");
                String teacherID = teacher.attributeValue("id");
                String teacherName = teacher.attributeValue("name");
                String teacherAge = teacher.attributeValue("age");
                Element teacherSexEle = teacher.element("sex");
                // 获取该节点的文本信息
                String teacherSex = teacherSexEle.getText();
                System.out.println("\t\t"+teacherID+"--"+teacherName+"--"+teacherAge+"--"+teacherSex);
                //获取class中的子元素(好多student)
                List<Element> studentList = classEle.elements("student");
                for(Element student : studentList){
                    String studentID = student.attributeValue("id");
                    String studentName = student.attributeValue("name");
                    String studentAge = student.attributeValue("age");
                    // 获取子节点中的文本
                    String studentSex = student.elementText("sex");
                    System.out.println("\t\t"+studentID+"--"+studentName+"--"+studentAge+"--"+studentSex);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

