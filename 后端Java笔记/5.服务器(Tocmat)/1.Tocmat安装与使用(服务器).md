<script src='/笔记/see/index.js'></script>
[toc]


#### Tocmat的下载
- 进入，官方网址: https://www.apache.org/
- 滑到最下面，就可以看到 **Tomcat**，点击它
- 找到对应的版本，点击 `下载`，会进入该版本的下载页面，选择对应电脑系统的版本（mac对应tar.gz），点击就会下载
- 版本的对应关系
  - Tomcat6 （JDK5，Servlet2.x，JSP2.x，EL2.x）
  - Tomcat7 （JDK6，Servlet3.x，JSP2.x，EL2.x）
  - Tomcat8 （JDK7，Servlet3.x，JSP2.x，EL3.x）
  - Tomcat9 （JDK8，Servlet4.0，JSP2.3，EL3.0）



#### 准备工作-引入Tocmat的流程（旧版）
- 第一步：打开编辑器，点击上方的 `Run`
- 第二步：点击 `Edit Configurations`
- 第三步：`左上角+号`   
  - 往下滑，找到 `Tomcat Server`，然后在点击 `Local`
  - 然后，就会进入一个配置页面
    - 点击 `configure`，选中要集成的 `Tomcat` 的路径（即上面下载的Tocmat所处的路径）
    - 以及给服务器起一个名字(可能有多个服务)
    - 集成成功后，最后有一个 `Warning: No artifacts configured` 警告，说明还没有项目，不用管，点击ok即可
    - 这样，Tocmat就运用成功，此时运行的地方，就会出现可运行的mian函数（是Tocmat上的）
  - 如果没有找到 `Tomcat Server`，可能隐藏了，点击最下面的收起隐藏
  - 如果还没有，证明IDEA中缺少相关的插件
    - 下载流程（按顺序点击）：(File--Settings--Plugins--Installed)
      - 最终进入一个页面，然后搜索 `Tomcat`，如果没有安装，是一个高亮的，如果已经安装，是个灰色的
      - 如果没有安装，选中（或者在前面打勾），点击 `apply` 进行安装，安装后点击OK，就会退出
    - 此时，Tomcat就安装好了，然后再回到第一步，此时就可以成功执行第三步，创建Tocmat项目了




#### 准备工作-引入Tocmat的流程（新版）
- 第一步：打开编辑器，点击上方的 `Run`
- 第二步：点击 `Edit Configurations`
- 第三步：`左上角+号`  
  - 选择Smart Tocmat
  - 如果没有，说明缺少 Smart Tocmat 插件
- 第四步：安装 Smart Tocmat 插件
  - 点击 IntelliJ IDEA（左上角）
  - 点击 Preferenecs
  - 点击 Plugins
  - 点击 Marketplace（默认选择的就是这个）
  - 然后，搜索 Tocmat （搜索结果可能比较慢，也有可能搜不出来，多搜几次）
  - 然后就会看到 Smart Tocmat
    - 然后，点击 install（没有下载，这个按钮就是高亮）
    - 点击后，就会进入下载流程，下载完成后，install 这个按钮就会变灰
    - 下载完成后，一定要点击OK，否则不起作用（依旧找不到这个插件）
- 第五步：安装完成后，就需要引入下载的Tocmat了
  - 点击 IntelliJ IDEA（左上角）
  - 点击 Preferenecs
  - 就会发现，在最后多了一个 Tocmat Server（点击这个）
    - 右侧就会出现一个页面
    - 点击 +
    - 然后选择，下载的Tocmat的文件路径，选中对应的Tocmat
    - 可以多导几个Tocmat
  - Tocmat导入完毕后，点击Ok

- 然后回到第一步，一直操作到第三步
  - 选择Smart Tocmat
  - 右侧就会出现一个配置页面
    - 选则要使用的Tocmat版本（只有第五步导入的Tocmat才能被选中）
      - 如果是个空的，则说明没有导入Tocmat，就需要进行第五步的操作
    - 然后在给服务器起一个名字(可能有多个服务)
  - 配置完成后，点击OK，Tocmat就引入到项目中了

- 如果编辑器一打开文件目录，就卡死（就无法导入下载的tocmat了），就卸载重装


#### 准备工作-搭建Web服务（创建项目）
- 要想启动tocmat服务，在搭建项目的时候，必须创建 web 服务项目
  - 这样的话，在引入Tocmat后，Tocmat的主函数才能正常启动，如果创建的不是web项目，则主函数启动不了

.
- web服务，要有一个核心的配置文件（启动配置文件）
- 该配置文件的路径为 src/web/WEB-INF/web.xml（启动配置文件）
  - src/web，下面放的就是静态资源了

- web文件的产生方式
  - 第一种，手动创建
  - 第二种，右键项目名称 -> 点击 add framwork support -> 点击 Web Application -> 默认勾选创建 web.xml
    - 确定后，项目中，就会多一个`web`文件夹，该文件夹中存放静态文件

- 配置项目路径
  - 打开 `run --> Edit Configurations`
  - 选中 `Deployment`，点击，右边的加号
  - 选择 `Artifact…`
    - 会自动添加当前的项目，修改下面的 `application context` 设置为当前项目的名字（可以不用设置）
    - 此时，如果访问 `ip:端口/项目名(或者默认的名字)/静态资源路径`，就可以访问到对应的静态资源
    - 会自动去 `web` 下面找，所以静态资源路径，就不用写 `web` 了





#### 准备工作-引入servlet包（核心包）
- 这个包，就是处理请求，分析请求数据的，所以只要提供web服务，都离不开这个包
- servlet包的引入方式（通过maven引入）
  ```xml
  <dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>4.0.1</version>
    <scope>provided</scope>
  </dependency>
  ```





#### 准备工作-解决IDEA控制台出现乱码的问题
- 修改一下IDEA安装目录bin文件夹中的配置文件
  - 找到IDEA安装目录下的 `bin`
    - 找到 `idea.exe.vmoptions` 和 `idea64.exe.vmoptions`
  - 记事本形式打开，添加一行，**-Dfile.encoding=UTF-8**
  - 如果不好用，另外再添加一行，**-Dconsole.encoding=UTF-8**

- 在配置Tomcat容器的时候做参数处理
  - server选项卡
    - `VM options`处添加，`-Dfile.encoding=UTF-8`
  - 如果还不好用
    - 在点击 `Startup/Connection` 选项卡
    - 勾选 `Pass  environment  variables`
    - 手动添加
      - `JAVA_OPTS`，**-Dfile.encoding=UTF-8**
      - `JAVA_TOOL_OPTIONS`，**-Dfile.encoding=UTF-8**


#### 请求处理-定义请求处理函数
- 在controller文件夹下，创建请求处理类，类中定义请求处理函数

- 随便创建一个类（通常在controller下定义）
  - 注意：**该类必须继承HttpServlet，然后重写service方法**
  - 原因：主函数是Tocmet提供的，并且请求也是Tocmet接收，然后分析，根据分析出的请求路径，调用对应的请求处理方法
    - 由于请求处理类，是自定义的，所以Tocmat调用起来很困难，于是Tocmat就定义了一个规范
      - 它通过反射获取请求处理类，然后直接调用 service 方法（如果这个方法没有重写，后果就是调用不到，即请求处理不了）
  - 所以：请求处理类必须继承HttpServlet，然后重写service方法


.
- Tocmat如何知道，某个请求对应的某个处理方法，根据的就是配置文件（web.xml）
  - 如果不配置映射关系，Tocmat就无法得知，某个请求该用哪个处理方法进行处理，于是就会忽略这个请求

- 具体配置如下（示范）
  ```xml
  <servlet>
    <servlet-name>test</servlet-name>
    <servlet-class>controller.Demo</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>test</servlet-name>
    <url-pattern>/test</url-pattern>
  </servlet-mapping>
  ```
  - 这样的话，访问`/test`，Tocmat就会调用 c 中重写的 service 方法
  - 这样的话，`controller.Demo` 就能处理 `/test` 请求了



- 请求处理函数的示范代码（继承HttpServlet，重写service方法）
  ```java
  public class Demo extends HttpServlet {
      public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          
          // 设置响应数据的编码，防止中文乱码
          response.setCharacterEncoding("UTF-8");
          // 获取输出流
          PrintWriter printWriter = response.getWriter();
          
          // 响应数据
          printWriter.write("<html><head><meta charset='UTF-8'></head><body>122，你好");
          printWriter.write("</body></html>");
          // 这个一定要加上
          printWriter.flush();
          
      }
  }
  ```




#### 请求处理-解决响应中文乱码

- 请求映射具体配置如下（web.xml）
  ```xml
  <servlet>
    <servlet-name>test</servlet-name>
    <servlet-class>controller.Demo</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>test</servlet-name>
    <url-pattern>/test</url-pattern>
  </servlet-mapping>
  ```
  - 这样的话，访问`/test`，Tocmat就会调用 c 中重写的 service 方法
  - 这样的话，`controller.Demo` 就能处理 `/test` 请求了



- 请求处理函数的示范代码（继承HttpServlet，重写service方法）
  ```java
  public class Demo extends HttpServlet {
      public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          
          // 设置响应数据的编码，防止中文乱码
          response.setCharacterEncoding("UTF-8");
          // 获取输出流
          PrintWriter printWriter = response.getWriter();
          
          // 响应数据
          printWriter.write("<html><head><meta charset='UTF-8'></head><body>122，你好");
          printWriter.write("</body></html>");
          // 这个一定要加上
          printWriter.flush();
          
      }
  }
  ```





#### 请求处理-get请求获取传入的数据
- HttpServletRequest中有一个getParameter方法，通过该方法就可以获取请求传入的数据

.
- 请求映射具体配置如下（web.xml）
  ```xml
  <servlet>
    <servlet-name>test</servlet-name>
    <servlet-class>controller.Demo</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>test</servlet-name>
    <url-pattern>/test</url-pattern>
  </servlet-mapping>
  ```
  - 这样的话，访问`/test`，Tocmat就会调用 c 中重写的 service 方法
  - 这样的话，`controller.Demo` 就能处理 `/test` 请求了




- 请求处理函数的示范代码（继承HttpServlet，重写service方法）
  ```java
  public class Demo extends HttpServlet {
      public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          // 获取请求传入的数据
          String name = request.getParameter("name");
          String age = request.getParameter("age");
          System.out.println(name);
          System.out.println(age);
      }
  }
  ```
  - 假设访问的是 `/test?name=a&age=30`
    - 则获取的数据就是：name=a、age=30
    - 如果没有对应的数据，则得到的是 null






#### 请求处理-post请求获取传入的数据（name=张三&age=40）
- HttpServletRequest中有一个getParameter方法，通过该方法就可以获取请求传入的数据
  - 上面介绍：该方法是get获取数据的，但是post中也能通过该方法获取数据
  - 要求：必须是通过`/test?name=a&age=30`传递的参数，post就能获取到传入的数据

.
- 请求映射具体配置如下（web.xml）
  - Tocmat没有请求方式的限制，只要路径对上，无论是post请求还是get请求，都会执行对应的请求处理方法
  - 要先限制请求方式，只有手动通过代码进行if判断，具体方式后续介绍
  ```xml
  <servlet>
    <servlet-name>test</servlet-name>
    <servlet-class>controller.Demo</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>test</servlet-name>
    <url-pattern>/test</url-pattern>
  </servlet-mapping>
  ```
  - 这样的话，访问`/test`，Tocmat就会调用 c 中重写的 service 方法
  - 这样的话，`controller.Demo` 就能处理 `/test` 请求了




- 请求处理函数的示范代码（继承HttpServlet，重写service方法）
  ```java
  public class Demo extends HttpServlet {
      public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          // 获取请求传入的数据
          String name = request.getParameter("name");
          String age = request.getParameter("age");
          System.out.println(name);
          System.out.println(age);
      }
  }
  ```
  - 假设发送的请求如下
    ```js
    fetch("/serviceDemo/test?name=张三&age=30", {
        method: 'post'
    })
    // 或者
    fetch("/serviceDemo/test", {
        method: 'post',
        // 这个必须加上，否则getParameter获取不到，但是这种方式有可能出现中文乱码，解决方式下面介绍
        headers: {
            "Content-Type": "application/x-www-form-urlencoded"
        },
        body: "name=张三&age=40"
    })
    ```
    - 则获取的数据就是：name=张三、age=30
    - 如果没有对应的数据，则得到的是 null
  - 实例中并没有指定请求处理函数是处理什么方式的请求（和get定义的一样），但是get和post都能触发请求处理函数
    - 说明：无论是post请求还是get请求，都会执行对应的请求处理方法




#### 请求处理-post请求获取传入的数据（JSON格式）
- 上面介绍了，Post如何获取 `name=张三&age=40` 这种格式传入的数据
- 但是Post最常见的是用请求体传递数据（格式是JSON）
  - **但是，原生中很难获取请求体为JSON的数据，后续框架可以轻松获取**
  - 原因：通过后续介绍的 `获取所有请求参数keys` 的方法，可以看到
    - **传入的请求体作为了一个key，所以根本就无法通过 `getParameter()` 这个方法获取请求体数据**
      - 因为：getParameter是根据key获取对应的数据
  - 只能：**通过获取所有的keys，然后遍历，通过分析keys，来判断传入的是不是请求体JSON数据**

- 示范代码如下
  - 请求映射具体配置如下（web.xml）
    ```xml
    <servlet>
      <servlet-name>test</servlet-name>
      <servlet-class>controller.Demo</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>test</servlet-name>
      <url-pattern>/test</url-pattern>
    </servlet-mapping>
    ```
  - 请求处理方法，获取请求体JSON数据
    - **请求头必须加上 `"Content-Type": "application/x-www-form-urlencoded"`**
      - 要不然，获取不到请求体中的数据的
    ```java
    public class Demo extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            request.setCharacterEncoding("UTF-8");

            // 获取所有的keys，而请求体JSON就是作为一个Keys，这样就获取到了
            Enumeration parameter = request.getParameterNames();
            // 迭代keys，获取每一个具体的key，这样就能得到JSON数据了
            while(parameter.hasMoreElements()) {
                // 返回值是一个Object，使用时需要造型
                String key = (String)parameter.nextElement();
                // 第一个就是JSON数据
                System.out.println(key);
            }
        }
    }
    ```
    - 请求测试
      ```js
      fetch("/serviceDemo/test", {
          method: 'post',
          headers: {
              "Content-Type": "application/x-www-form-urlencoded"
          },
          body: JSON.stringify({
              name: '张三',
              age: 20
          })
      })
      ```
    - 当然了，也可以通过如下方式传递JSON数据，但是有点奇怪
      ```js
      fetch("/serviceDemo/test", {
          method: 'post',
          headers: {
              "Content-Type": "application/x-www-form-urlencoded"
          },
          body: "json=" + JSON.stringify({
              name: '张三',
              age: 20
          })
      })
      ```
      - 指定一个key，然后value为要传递的JSON，这样就能通过固定的key获取到JSON数据了
        - 即：`String json = request.getParameter("json");`






#### 请求处理-get和post获取所有请求参数的keys
- 使用 `Enumeration parameter = request.getParameterNames();`获取所有的keys，返回的是一个枚举对象
  - 比如：传入的参数是`name=张三&age=40`，则获取的所有keys就是 `name、age`
  - 上例中介绍：可以通过该方法，获取请求体为JSON的数据（因为该类型数据会作为一个keys，所以可以获取到）
- 遍历keys就能拿到请求所有的数据

- 示范代码
  - 请求映射具体配置如下（web.xml）
    ```xml
    <servlet>
      <servlet-name>test</servlet-name>
      <servlet-class>controller.Demo</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>test</servlet-name>
      <url-pattern>/test</url-pattern>
    </servlet-mapping>
    ```
  - 请求处理方法（获取所有的请求参数数据）
    ```java
    public class Demo extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            request.setCharacterEncoding("UTF-8");

            // 获取所有的keys
            Enumeration parameter = request.getParameterNames();
            // 迭代keys，获取每一个具体的key，然后利用key获取对应的数据
            while(parameter.hasMoreElements()) {
                // 返回值是一个Object，使用时需要造型
                String key = (String)parameter.nextElement();
                // 获取具体的数据
                String str = request.getParameter(key);
                System.out.println(str);
            }
        }
    }
    ```
    - 请求测试
      ```js
      fetch("/serviceDemo/test?name=张三&age=24")
      ```




#### 请求处理-get和post获取一组数据（key相同，value不同）
- 比如：传递的参数是 `abc=1&abc=2&abc=3`
  - 要是通过 `request.getParameter('abc')` 获取，只能获取第一个
  - 迭代也不行，因为key都是 abc，所以迭代只能迭代出第一个
- 要想获取此类的所有数据，可以通过下面的方式
- 示范代码
  - 请求映射具体配置如下（web.xml）
    ```xml
    <servlet>
      <servlet-name>test</servlet-name>
      <servlet-class>controller.Demo</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>test</servlet-name>
      <url-pattern>/test</url-pattern>
    </servlet-mapping>
    ```
  - 请求处理方法（获取所有的请求参数数据）
    ```java
    public class Demo extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // 获取所有的 abc 数据
            String[] datas = request.getParameterValues("abc");
            // 遍历
            for(String p : datas) {
                System.out.println(p);
            }
        }
    }
    ```
    - 请求测试
      ```js
      fetch("/serviceDemo/test?abc=1&abc=2&abc=3")
      ```



#### 请求处理-解决请求参数乱码问题
- 打印的时候发现乱码了，就可以进行下面的操作，解决乱码（POST请求经常乱码）
- 其实就是和字符集有关
- 具体操作如下
  ```java
  // 在获取参数前，先设置一下字符集
  request.setCharacterEncoding("UTF-8");
  // 然后在获取数据，这样就不会乱码了
  String aname = request.getParameter("name");
  ```
  



#### 请求处理-获取请求头中的数据
- 根据key获取具体的请求头数据
- 示范代码
  - 请求映射具体配置如下（web.xml）
    ```xml
    <servlet>
      <servlet-name>test</servlet-name>
      <servlet-class>controller.Demo</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>test</servlet-name>
      <url-pattern>/test</url-pattern>
    </servlet-mapping>
    ```
  - 请求处理方法（获取所有的请求参数数据）
    ```java
    public class Demo extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // headers中的数据
            String abc = request.getHeader("abc");
            System.out.println(abc);
        }
    }
    ```
    - 请求测试
      - headers中不能有中文
      ```js
      fetch("/serviceDemo/test", {
          headers: {
              abc: "cs"
          }
      })
      ```



.
- 获取所有的keys，然后迭代获取所有的请求头数据
- 示范代码
  - 请求映射具体配置如下（web.xml）
    ```xml
    <servlet>
      <servlet-name>test</servlet-name>
      <servlet-class>controller.Demo</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>test</servlet-name>
      <url-pattern>/test</url-pattern>
    </servlet-mapping>
    ```
  - 请求处理方法（获取所有的请求参数数据）
    ```java
    public class Demo extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // 获取headers中的所有keys
            Enumeration headers = request.getHeaderNames();
            // 迭代keys，获取所有的headers中的数据
            while(headers.hasMoreElements()) {
                // 返回值是一个Object，使用时需要造型
                String key = (String)headers.nextElement();
                // 获取值
                String header = request.getHeader(key);
                System.out.println(key + ": " + header);
            }
        }
    }
    ```
    - 请求测试
      - headers中不能有中文
      ```js
      fetch("/serviceDemo/test", {
          headers: {
              abc: "cs",
              dds: 'ds'
          }
      })
      ```



#### 请求处理-获取请求路径
- 示范代码
  - 请求映射具体配置如下（web.xml）
    ```xml
    <servlet>
      <servlet-name>test</servlet-name>
      <servlet-class>controller.Demo</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>test</servlet-name>
      <url-pattern>/test</url-pattern>
    </servlet-mapping>
    ```
  - 请求处理方法（获取所有的请求参数数据）
    ```java
    public class Demo extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // 获取完整路径，包含协议域名端口，比如：http://localhost:8080/serviceDemo/test
            StringBuffer s1 = request.getRequestURL();
            System.out.println(s1);

            // 获取资源路径，只包含路径，不包含协议域名端口，比如：/serviceDemo/test
            String s2 = request.getRequestURI();
            System.out.println(s2);
        }
    }
    ```
    - 请求测试
      - headers中不能有中文
      ```js
      fetch("/serviceDemo/test")
      ```




#### 请求处理-重定向
- 示范代码
  - 请求映射具体配置如下（web.xml）
    ```xml
    <servlet>
      <servlet-name>test</servlet-name>
      <servlet-class>controller.Demo</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>test</servlet-name>
      <url-pattern>/test</url-pattern>
    </servlet-mapping>

    <servlet>
      <servlet-name>cdx</servlet-name>
      <servlet-class>controller.Cdx</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>cdx</servlet-name>
      <url-pattern>/cdx</url-pattern>
    </servlet-mapping>
    ```
  - 请求处理方法（获取所有的请求参数数据）
    ```java
    public class Demo extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            // 重定向，不要忘了根路径
            response.sendRedirect("/serviceDemo/cdx");
        }
    }

    public class Cdx extends HttpServlet {
        public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
            System.out.println("重定向");
        }
    }
    ```
    - 请求测试
      - headers中不能有中文
      ```js
      fetch("/serviceDemo/test")
      ```


