<script src='/笔记/see/index.js'></script>
[toc]


#### 准备工作-包的引入
- 需要引入三个包 `Spring-core、Spring-context、Spring-beans`
- 具体引入
  ```xml
    <!-- https://mvnrepository.com/artifact/org.springframework/spring-core -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>5.3.1</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.1</version>
    </dependency>
    <!-- https://mvnrepository.com/artifact/org.springframework/spring-beans -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-beans</artifactId>
        <version>5.3.1</version>
    </dependency>
  ```




#### 准备工作-配置文件的框架
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    

</beans>
```


#### 准备工作-获取Spring创建出来的对象
- 引入配置文件，让其工作，然后根据配置创建对象
    ```java
    public class Spring {
        // 保存Spring的信息
        public static ApplicationContext spring;
        // 引入Spring配置文件，让其工作，根据配置，创建对象
        static {
            // 方法一、传入配置对象的路径，相对于target的路径（打包后的路径）
            spring = new ClassPathXmlApplicationContext("spring.xml");

            // 方法二、传入配置对象的路径，相对于项目文件的路径（没打包的路径）
            // spring = new FileSystemXmlApplicationContext("src/main/resources/spring.xml");
        }
    }
    ``` 
  - 根据配置文件信息，获取Spring创建的对象
    ```java
    public class Main {
        public static void main(String[] args) {
            // 获取Spring创建的对象（根据ID获取），需要造型
            Demo demo = (Demo)Spring.spring.getBean("demo");
            System.out.println(demo);
        }
    }
    ```






#### 创建对象-创建和获取对象（配置文件开发）
- 辅助类（让Spring创建对象，有可能需要自定义set方法，否则有可能会报错）
  ```java
    public class Demo {
        public String name;
        public int age;

        public void setName(String name) {
            this.name = name;
        }
        public void setAge(int age) {
            this.age = age;
        }
    }
  ```
- 配置文件中的示范配置（spring.xml）
  ```xml
    <!-- 创建一个对象 -->
    <!-- org.example.domian.Demo 类的路径 -->
    <bean class="org.example.domian.Demo" id="Demo">
        <property name="name" value="张三" />
        <property name="age" value="20" />
    </bean>
  ```

- 配置文件配置好后，就可以获取和使用Spring创建出的对象了（具体获取方式在上面介绍）
- 注意点：**如果辅助类中有有参构造函数，则需要使用constructor-arg，否则会报错**


#### 创建对象-利用有参构造函数构建对象
- 默认使用无参构造函数，构建对象
  - 对象构建完成后，就会使用`<property name="a" value="3"></property>`配置的信息，调用对应的`set`方法，给属性赋值


- 辅助类（让Spring创建对象，有可能需要自定义set方法，否则有可能会报错）
  ```java
    public class Demo {
        public String name;
        public int age;

        // 有参构造函数
        public Demo(String name, int age) {
            System.out.println("执行了");
            this.name = name;
            this.age = age;
        }
    }
  ```
- 配置文件中的示范配置（spring.xml）
  ```xml
  <!-- 创建一个对象 -->
  <!-- org.example.domian.Demo 类的路径 -->
  <bean id="demo" class="org.example.domian.Demo">
      <!--  构造函数的 第一个参数-->
      <constructor-arg type="int" value="3"></constructor-arg>
      <!--  构造函数的 第二个参数 -->
      <constructor-arg type="java.lang.String" value="张三"></constructor-arg>
  </bean>
  ```

- 配置文件配置好后，就可以获取和使用Spring创建出的对象了（具体获取方式在上面介绍）

- 注意
  - 对象构造完成后，还是可以使用`<property name="a" value="3"></property>`，进行赋值或者修改值
  - 这个放在`constructor-arg`的上面或者下面的作用是一样的
    - `<property> ` 给属性赋值，调用的是对应的set方法。而只有对象创建完成后，才能使用set方法，进行赋值。
    - 所以即使放在上面，也会最后执行
  - 比如
    ```xml
    <bean id="demo" class="org.example.domian.Demo">
        <constructor-arg type="int" value="18"></constructor-arg>
        <constructor-arg type="java.lang.String" value="张三"></constructor-arg>
        <!-- 上面创建对象的时候，age赋值了一个18，这里会调用set方法变成 3 -->
        <!--    由于它是调用set方法，进行赋值的，所以，放在上面或者下面都是一样的 -->
        <!--    并不是放在上面，就会失效（被constructor-arg替换），即使放在上面也会最后执行 -->
        <property name="age" value="3"></property>
    </bean>
    ```



#### 创建对象-value标签的使用（配置文件开发）
- 使用value标签可以给属性赋值一些复杂的变量（使用行间value属性是实现不了的）
  - 比如赋值 `<demo>`，如果行间赋值写成这样，就会出现问题（因为这是一个标签格式，写了就会有冲突）
  - 如果借助value标签，就可以完成赋值
- 因为，value标签，会把标签的字标签作为内容进行复制，这样就可以写很复杂的内容，而不用担心标签结构不匹配
- `constructor-arg` 和 `property` 这两个标签都可以使用value标签进行属性赋值
- **注意：**如果赋值奇怪的内容必须使用 `<![CDATA[数据]]>` 进行包裹
  - 比如：`<![CDATA[<abc>]]>`
  - 如果是简单的内容就不用使用它进行包裹了
- 示范配置代码如下
  ```xml
  <!-- 创建一个对象 -->
  <bean id="demo" class="org.example.domian.Demo">
      <!--  构造函数的 第一个参数-->
      <constructor-arg type="int" value="3"></constructor-arg>
      <!-- 这个东西和构造函数的参数顺序有关，所以不用指定name，但是要指定类型 -->
      <constructor-arg>
          <value type="java.lang.String">张三</value>
      </constructor-arg>

      <!-- 这个东西和set有关，所以需要指定name，决定调用那个set方法，
                name指定了，类型自然也就确定了，所以就不用指定类型了 -->
      <property name="name">
          <value>a<![CDATA[<张三>]]>b</value>
          <!-- 最终赋值成 a<张三>b（其他数据正常写，特殊数据用<![CDATA[]]>进行加装
                  并不是只处理<![CDATA[]]>内部的数据），
                  所以说不要敲回车，否则也会把回车作为数据的一部分  -->
      </property>
  </bean>
  ```



#### 创建对象-对象属性的赋值（配置文件开发）
- 方式一：借助ref进行赋值
  - ref指向另一个bean对象的id（就能把对应的bean对象赋值给该属性）
  - 示范代码
    ```xml
    <!-- 使用类C、创建一个对象 -->
    <bean id="c" class="C">
        <constructor-arg type="int" value="666"></constructor-arg>
    </bean>

    <!-- 使用类B、创建一个对象 -->
    <bean id="a" class="B">
        <property name="a" value="3"></property>
        <!-- a对象的属性c，赋值为c对象 -->
        <property name="c" ref="c"></property>
    </bean>
    ```


- 方式二：赋值私有化bean对象（内部bean）
  - 内部bean：程序通过Spring，无法获取该bean对象（上面的方式一，可以通过c获取，因为它是全局的）
  - 只能通过赋值后的属性，获取到内部bean对象
  - 示范代码
    ```xml
    <!-- 使用类B 创建一个对象 -->
    <bean id="a" class="B">
        <property name="a" value="3"></property>
        <!-- a对象的属性c，赋值为c对象 -->
        <property name="c">
            <!-- 依赖的对象内部化，外界获取不到这个对象 -->
            <bean class="C">
                <constructor-arg type="int" value="6666"></constructor-arg>
            </bean>
        </property>
    </bean>
    ```



#### 创建对象-给属性赋值为null（配置文件开发）
- 借助 `null` 标签，完成赋值
  - 如果通过value，赋值null，赋的是字符串null
- 基本类型不能复制为null，否则报错。引用类型可以，比如字符串
- 示范代码
  ```xml
  <!-- 使用类B 创建一个对象 -->
  <bean id="a" class="B">
      <constructor-arg type="int">
          <value>3</value>
      </constructor-arg>

      <!-- 这样的话，不会自动调用类创建对象，属性值直接为null -->
      <constructor-arg type="C">
          <null />
      </constructor-arg>
  </bean>
  ```




#### 创建对象-通过级联属性给对象属性中的属性赋值
- 给对象属性赋值：有普通的方式，有级联的方式

- 普通的方式，就是通过value，直接赋值（上面已经介绍过了）
  ```xml
  <!-- 使用类B 创建一个对象 -->
  <bean id="a" class="B">
      <constructor-arg type="int"><value>3</value></constructor-arg>
      <constructor-arg type="C">
          <bean class="C">
              <constructor-arg type="java.lang.String" value="3"></constructor-arg>
          </bean>
      </constructor-arg>
  </bean>
  ```


- 级联的方式
  - 也要先通过普通的方式，给对象属性赋值上一个对象
  - 然后在通过，级联的方式给对象属性中的属性赋值
  - 比如
    ```xml
    <!-- 使用类B 创建一个对象 -->
    <bean id="a" class="B">
        <constructor-arg type="int"><value>3</value></constructor-arg>
        <constructor-arg type="C">
            <bean class="C">
                <constructor-arg type="java.lang.String" value=""></constructor-arg>
            </bean>
        </constructor-arg>
        <!-- 通过级联的方式，设置c下的c的属性值   -->
        <property name="c.c" value="333"></property>
    </bean>
    ```




#### 创建对象-给List集合属性赋值（配置文件开发）
- 示范配置
  ```xml
    <!-- 使用类B 创建一个对象 -->
    <bean id="a" class="B">
        <!-- 往list集合中存放数据 -->
        <property name="a">
            <list>
                <!-- 第一个值 -->
                <bean class="C">
                    <property name="c" value="a"></property>
                </bean>
                <!-- 第二个值 -->
                <bean class="C">
                    <property name="c" value="b"></property>
                </bean>
            </list>
        </property>
    </bean>
  ```


#### 创建对象-给Map集合属性赋值（配置文件开发）
- 示范配置
  ```xml
    <!-- 使用类B 创建一个对象 -->
    <bean id="a" class="B">
        <!-- 往map集合中存放数据 -->
        <property name="a">
            <map>
                <!-- 第一个值 -->
                <entry key="a">
                    <bean class="C">
                        <property name="c" value="4"></property>
                    </bean>
                </entry>
                <!-- 第二个值，指定创建好的对象，需要注意的是，这个使用的是value-ref，而不是ref-->
                <entry key="b" value-ref="***"></entry>
            </map>
        </property>
    </bean>
  ```


#### 创建对象-集合的复用（配置文件开发）
- 示范配置
  ```xml
    <!-- 创建一个复用的对象 -->
    <bean class="C" id="c">
        <property name="c" value="b"></property>
    </bean>
    <!-- 创建一个复用的list集合 -->
    <util:list id="list">
        <ref bean="c"></ref>
        <ref bean="c"></ref>
    </util:list>

    <!-- 使用类B 创建一个对象 -->
    <bean id="a" class="B">
        <!-- 引入创建的list集合 -->
        <property name="a" ref="list"></property>
    </bean>
    
    <!-- 使用类B 创建一个对象 -->
    <bean id="a" class="B">
        <!-- 引入创建的list集合 -->
        <property name="a" ref="list"></property>
    </bean>
  ```



#### 创建对象-C和P命名空间（配置文件开发）
- 作用：
  - C简化constructor-arg的书写
  - P简化property的书写

- 示范配置
  ```xml
  <bean class="C" id="c">
      <property name="c" value="b"></property>
  </bean>
  <!-- 创建一个复用的list集合   -->
  <util:list id="list">
      <ref bean="c"></ref>
      <ref bean="c"></ref>
  </util:list>


  <!-- 使用类B 创建一个对象   a-ref代表的是引用 -->
  <bean id="a" class="B" p:a-ref="list" p:b="bbb" c:d="aaa" c:e="3">

      <!-- p:a-ref="list" p:b="bbb"就相当于下面的写法 -->
        <!-- <property name="a" ref="list"></property> -->
        <!-- <property name="b" value="bbb"></property> -->

      <!-- c:d="aaa" c:e="3"就相当于下面的写法 -->
        <!-- <constructor-arg type="java.lang.String" value="aaa"></constructor-arg> -->
        <!-- <constructor-arg type="int" value="3"></constructor-arg> -->

  </bean>
  ```




#### 创建对象-自动注入（配置文件开发）
- 自动注入的前提: 自动注入的数据，要提前创建好，并且基本数据无法自动注入
  - 因为自动注入需要提前创建好，并借助id实现自动注入（基本数据无法创建bean）

- 只要id名与属性名匹配起来，就会自动注入
- 也可以根据属性类型进行自动注入（会产生冲突问题）
  - 如果Spring中，一个属性匹配了多个结果，就会产生冲突


- 示范配置（自动注入）
  ```xml
    <!-- 创建一个用于自动注入的bean -->
    <bean class="C" id="demo">
        <property name="c" value="b"></property>
    </bean>

  
    <!-- byName就是根据属性名，自动匹配可以注入的对象 -->
    <!--   而对象中有一个属性，private C demo 刚好和上面的bean能匹配成功，于是就会自动注入上面的bean -->
    <bean id="a" class="B" autowire="byName"></bean>
  ```




#### 创建对象-使用EL进行赋值(可以动态运算赋值)
- EL中，可以写普通的表达式
  - 还可以调用一些Java自带的属性和方法
  - 甚至还可以从之前创建出来的bean对象中取出属性参与运算

- 比如
  ```xml
  <!-- 创建一个bean，供下面的EL使用 -->
  <bean id="b" class="C">
      <property name="c" value="#{'a'}"></property>
  </bean>

  <!-- 使用类B 创建一个对象   -->
  <bean id="a" class="B">
      <!-- 使用EL表达式给一个属性赋值，包含运算，从上面配置的对象中取值，以及引入一些Java自带的包中的一些属性    -->
      <!-- T(java.lang.Math).PI  就相当于java中的 Math.PI    -->
      <property name="b" value="#{'a' + 'b' + b.c + T(java.lang.Math).PI}"></property>
  </bean>
  ```


#### 创建对象-从配置文件中导入数据（配置文件开发）
- 引入的是Properties格式的配置文件，格式如下
  ```json
  a=1
  b=2
  ```
  - 就相当于，把一些常量提取到一个文件中，进行定义，这样便于修改


- 示范配置（引入数据配置文件）
  ```xml
  <!-- 引入配置文件 -->
  <context:property-placeholder location="conf"></context:property-placeholder>

  <bean class="C" id="demo">
      <!-- 使用配置文件中的常量 -->
      <!-- 配置文件的格式为  a=1   b=2 -->
      <property name="c" value="${b}"></property>
  </bean>

  <!-- 使用类B 创建一个对象   -->
  <bean id="a" class="B">
      <property name="demo" ref="demo"></property>
  </bean>
  ```



#### 创建对象-通过模版给属性赋值（配置文件开发）
- 该方式只适用于，多个类属性相同，要赋予的属性值也相同的情况
- 实现方式：先使用bean创建出一个模版，然后利用模版给具体的类进行赋值
  - 注意：**在使用时，只能获取具体的类，模版对象获取不到，会抛出异常**
- 示范配置
  ```xml
  <bean class="C" id="demo3">
      <property name="c" value="b"></property>
  </bean>

    <!-- 创建一个继承对象，abstract设置为ture，表示这个bean只提供模版，不能获取
           也就是说这个对象只能Spring使用，外界是用不到的 -->
    <bean id="demo2" abstract="true">
        <property name="hehe" ref="demo3"></property>
        <property name="cc" vaue="cc"></property>
    </bean>

    <!-- 使用类B 创建一个对象，属性为继承对象的对应属性值   -->
    <bean id="demo" class="B" parent="demo2">
        <!-- 就相当于在内部写了-->
        <!--   <property name="hehe" ref="hehe"></property>
               <property name="cc" vaue="cc"></property>  -->
        <!-- 只不过把这一部分进行了提取（多个类相同，提取出来，后续定义bean对象就方便了很多） -->
    </bean>
  ```




#### 创建对象-给Properties类型的属性赋值
- `Properties`类型的数据格式为：`{b=2, a=1}`
  - 和配置文件差不多，也是 `key=value` 的格式
- 辅助对象
  ```java
  public class Demo {
      public String name;
      public Properties pro;

      public void setPro(Properties pro) {
          this.pro = pro;
      }
      public void setName(String name) {
        this.name = name;
    }
  }
  ```

- 示范配置
  ```xml
  <bean id="demo" class="org.example.domian.Demo">
      <property name="name" value="张三"></property>
      <!-- 给Properties类型的属性赋值 -->
      <property name="pro">
          <props>
              <prop key="a">1</prop>
              <prop key="b">2</prop>
          </props>
      </property>
  </bean>
  ```


- `Properties`属性的使用
  ```java
  public class Main {
      public static void main(String[] args) {
          // 获取Spring创建的对象（根据ID获取），需要造型
          Demo demo = (Demo)Spring.spring.getBean("demo");
          System.out.println(demo.pro.getProperty("a"));  // 表现形式为：1
          System.out.println(demo.pro.getProperty("b"));  // 表现形式为：2
      }
  }
  ```





#### 创建对象-改变创建对象的方式（改变单例模式）
- Spring默认是一开始就创建出对象，并且只创建一个对象（单例）
  - 也就是说：
    - 执行`new ClassPathXmlApplicationContext("spring.xml")`的时候（解析配置文件），就会根据配置开始创建对象
    - 通过 `spring.getBean(id)`，根据ID获取对象，获取的永远是同一个对象（因为单例）
- 这种创建对象的方式，是可以改变的

- 示范配置如下
  ```xml
  <bean id="a" class="B" scope="prototype"></bean>
  ```
  - 只要加上了 `scope="prototype"`
    - 就会在解析的时候，先不创建对象
    - 然后，通过 `spring.getBean(id)`，根据ID获取对象的时候，在创建出一个对象
      - 并且是，调用一次就创建一次（每次得到的对象都是新的，不是单例模式）
  - 那些没有配置这个属性的bean，正常创建（开始就创建并且是单例）




#### 创建对象-工厂模式（通过函数构建bean对象）
- 定义一个工厂
  - 会以返回值作为bean对应的对象（所以，工厂要返回一个对象）

- 工厂定义的示范代码
  - 经过工厂的加工，得到一个Demo对象
  ```java
  public class Demo2 {
      // 无参数工厂
      public Demo demo1() {
          System.out.println("执行了");
          Demo demo = new Demo();
          demo.name = "张三";
          return demo;
      }

      // 有参数工厂
      public Demo demo2(String name, int age) {
          System.out.println("执行了");
          Demo demo = new Demo();
          demo.name = name;
          demo.age = age;
          return demo;
      }

      // 静态工厂
      public static Demo demo3() {
          System.out.println("执行了");
          Demo demo = new Demo();
          demo.name = "张三";
          return demo;
      }
  }
  ```

- 使用工厂，创建对象（无参数工厂）
  ```xml
  <!-- 先创建一个工厂对象，然后才能使用内部的工厂方法，创建对象 -->
  <bean id="demo2" class="Demo2"></bean>
  <!-- factory-bean：指定工厂  factory-method：指定调用工厂的那个方法，然后返回值作为bean对应的对象 -->
  <bean id="demo" factory-bean="demo2" factory-method="demo1"></bean>
  ```


- 使用工厂，创建对象（有参数工厂）
  ```xml
  <!-- 先创建一个工厂对象，然后才能使用内部的工厂方法，创建对象 -->
  <bean id="demo2" class="Demo2"></bean>
  <!-- factory-bean：指定工厂  factory-method：指定调用工厂的那个方法，然后返回值作为bean对应的对象 -->
  <bean id="demo" factory-bean="demo2" factory-method="demo2">
      <!-- 工厂方法的第一个参数 -->
      <constructor-arg value="李四"></constructor-arg>
      <!-- 工厂方法的第二个参数 -->
      <constructor-arg value="20"></constructor-arg>
  </bean>
  ```

- 使用工厂，创建对象（静态工厂）
  ```xml
  <!-- 会根据class，调用它的静态方法（demo3），然后返回值对象，作为bean对应的对象 -->
  <bean id="demo" class="Demo2" factory-method="demo3"></bean>
  ```







#### 注解开发-配置文件的配置（准备工作）
- 示范配置（spring.xml）
  ```xml
  <!-- 扫描整个controller包下的文件 -->
  <context:component-scan base-package="controller"></context:component-scan>
  ```
- 配置文件配置后，还需要引入，Spring才能进行解析，构建对象（引入方式和配置文件开发，配置文件的引入方式一样）
  ```java
  public class Spring {
      // 保存Spring的信息
      public static ApplicationContext spring;
      static {
          spring = new ClassPathXmlApplicationContext("spring.xml");
      }
  }
  ```



#### 注解开发-创建对象
- 在类上面顶一个 `@Component` 注解，当Spring扫描到这个类的时候，就会创建出一个bean
  - 比如
    ```java
    @Component
    public class Demo2 {
        public void a() {
            System.out.println("a");
        }
    }
    ```
- 获取注解创建的对象
  - 和配置文件开发的获取方式一样，也是利用id，进行获取（注解的默认id就是类名称）
  - 比如
    ```java
    public class Main {
        public static void main(String[] args) {
            // 获取Spring创建的对象（根据ID获取），需要造型
            Demo2 demo2 = (Demo2)Spring.spring.getBean("demo2");
            demo2.a();
        }
    }
    ```



#### 注解开发-创建对象（自定义bean的id）
- 上面介绍，通过注解创建的bean对象的id，默认是类的名称
- 除了默认，还可以实现自定义
  - 比如
    ```java
    @Component("zdy")
    public class Demo3 {
        public void demo() {
            System.out.println("demo3");
        }
    }
    ```

- 获取注解创建的对象
  ```java
  public class Main {
      public static void main(String[] args) {
          // 获取Spring创建的对象（根据ID获取），需要造型
          Demo3 demo3 = (Demo3)Spring.spring.getBean("zdy");
          demo3.demo();
      }
  }
  ```


#### 注解开发-属性值的注入
- 在属性上顶一个注解就可以，当创建对象的时候，就会把注解中的值赋给对应的属性
- 比如
  ```java
  @Component
  public class Demo {
      @Value("张三")
      private String name;

      @Value("18")
      private int age;

      // 赋值一个数组
      @Value("1, 2, 3")
      private int[] _int;

      // 赋值一个list
      @Value("#{ {1, 2, 3} }")
      private List<Integer> list;

      // 赋值一个map集合
      @Value("#{ {name: '李四', age: 30} }")
      private Map<String, Object> map;

      public void demo() {
          System.out.println(name);               // 表现形式：张三
          System.out.println(_int[1]);            // 表现形式：2
          System.out.println(list.get(1));        // 表现形式：2
          System.out.println(map.get("name"));    // 表现形式：李四
          System.out.println(map.get("age"));     // 表现形式：30
      }
  }
  ```

- 主函数测试
  ```java
  public class Main {
      public static void main(String[] args) {
          // 获取Spring创建的对象（根据ID获取），需要造型
          Demo demo = (Demo)Spring.spring.getBean("demo");
          demo.demo();
      }
  }
  ```



#### 注解开发-读取数据配置文件
- 数据配置文件，作用就是提取一些数据，比如密码、账号啥的，这样以后修改起来方便
  - 找到配置文件修改一下数据就可以了，就不用在费劲的找具体的实现代码了
- 数据配置文件中全是 `k=v` 格式的数据
- 比如：配置文件中的数据（文件名为：ds.properties）
  ```js
  name=张三
  age=24
  ```
- Spring注解中获取配置文件中数据的示范代码
  ```java
  @Component
  // 引入数据配置文件
  @PropertySource(value = "classpath:ds.properties")
  public class Demo2 {
      // 使用数据配置文件中的数据
      @Value("${name}")
      private String name;

      @Value("${age}")
      private int age;
      public void d2() {
          System.out.println(name);
          System.out.println(age);
      }
  }
  ```

- 主函数测试
  ```java
  public class Main {
      public static void main(String[] args) {
          // 获取Spring创建的对象（根据ID获取），需要造型
          Demo2 demo2 = (Demo2)Spring.spring.getBean("demo2");
          demo2.d2();
      }
  }
  ```


- 解决控制台中文乱码的问题
  - 第一个：在引入配置文件的注解中，加入编码格式 
    - 比如：`@PropertySource(value = "classpath:ds.properties", encoding = "UTF-8")`
  - 第二个：编辑器的编码格式，不是utf-8（这样文件看似写的是中文，但是用utf-8一解析，就会乱码了）
    - 修改方式：在设置中找到 `File encodings`
      - 把 `Global Encoding`：改成 `UTF-8`
      - 把 `Project Encoding`：改成 `UTF-8`
      - 把 `Default encoding for properties files`：改成 `UTF-8`
    - 然后点击下 `apply` 让修改配置生效，然后点击 `OK` 就可以了
      - 改完之后，就会发现配置文件中书写的中文，就是乱码格式了，重新修改下，控制台打印的就是中文了





#### 注解开发-自动注入
- 含有自动注入的类，也需要交给Spring管理，这样Spring才能进行自动注入
- 自动注入：借助注解`@Autowired`实现
- 自动注入流程
  - 先根据类路径或者实现接口的类进行匹配（不是根据类名称进行的匹配，而是根据路径进行的匹配）
    - 如果匹配一个，则直接赋值
    - 如果匹配多个，则根据属性名进行匹配（属性名对应ID）
      - 因为id不可能重复
      - 如果没有匹配成功（没有这个id），则就会报错
    - 如果是 `Object` 则所有的都能匹配成功（这就是对应多个bean的现象了，就会根据属性名进行查找）
    - 如果类名称相同，但是路径不同（所处的包不同），则不同的不会匹配成功（不会形成匹配多个bean的现象）


- 示范代码（正常匹配，一一对应）
  ```java
  // 自动注入，也要交给Spring管理
  @Component
  public class Demo {
      // 自动注入
      @Autowired
      private Demo3 demo3;

      public void demo() {
          System.out.println(demo3);  // 打印
      }
  }

  // 即使自定义了id，但是会先根据类进行匹配（所以可以自动注入到上面）
  @Component("zdy")
  public class Demo3 {
      public void demo() {
          System.out.println("ok");
      }
  }
  ```

- 示范代码（一对多匹配，一个类创建多个bean）
  - 只能借助配置文件，才能一个类创建出多个bean（注解只能创建出一个bean）
    ```xml
    <!-- 创建多个bean -->
    <bean id="c1" class="org.example.domian.Demo3"></bean>
    <bean id="c2" class="org.example.domian.Demo3"></bean>

    <!-- 扫描包中的所有的类，解析注解 -->
    <context:component-scan base-package="org.example.domian,org.example.dain"></context:component-scan>
    ```
  - 注解实现自动注入
    ```java
    @Component
    public class Demo {
        // 根据类，能找到多个bean，于是就会根据属性名，查找对应bean的id，找到就注入，找不到就报错
        @Autowired
        private Demo3 c1;
        
        public void demo() {
            System.out.println(c1);
        }
    }
    ```

- 示范代码（一对多匹配，一个接口对应多个实现类）
  - 定义一个接口
    ```java
    public interface Demo5 {
        public void demo();
    }
    ```

  - 接口的实现类
    ```java
    @Component
    public class Demo3 implements Demo5 {
        public void demo() {
            System.out.println("demo3");
        }
    }

    @Component
    public class Demo4 implements Demo5 {
        public void demo() {
            System.out.println("demo4");
        }
    }
    ```

  - 自动注入测试
    ```java
    @Component
    public class Demo {
        // 先根据类进行查找，发现这是一个接口，于是就找对应的实现类，能找到多个bean
        //    于是就会根据属性名，查找对应bean的id，找到就注入，找不到就报错
        @Autowired
        private Demo5 demo3;   // 类名字，默认就是bean的id
        
        public void demo() {
            System.out.println(demo3);
        }
    }
    ```





#### 注解开发-自动注入（@Qualifier的使用）
- 在自动注入中介绍，如果匹配到了多个bean，就会产生冲突问题
  - 于是就会根据属性名（属性名对应bean的id），查找对应的bean对象，完成自动注入
    - 如果匹配不上就会报错
  - 其实除了属性对应bean的id的id外，还可以借助 `@Qualifier` 注解，从匹配成功的多个bean中找出对应的bean
- `@Qualifier`的使用：也是根据id查找对应的bean对象

- 比如
  - 配置文件创建出多个bean
    ```xml
    <!-- 创建多个bean -->
    <bean id="c1" class="org.example.domian.Demo3"></bean>
    <bean id="c2" class="org.example.domian.Demo3"></bean>

    <!-- 扫描包中的所有的类，解析注解 -->
    <context:component-scan base-package="org.example.domian,org.example.dain"></context:component-scan>
    ```
  - 注解实现自动注入
    ```java
    @Component
    public class Demo {
        // 根据类，能找到多个bean（c1和c2）
        //    想要得到 c2，除了把属性名定义成 c2，还可以利用 @Qualifier 进行获取
        //    如果属性名为 c1，@Qualifier注解中是 c2，则已 @Qualifier 为准，也就是注入的是 c2
        //    如果没加 @Qualifier、属性名也对应不上，则Spring就不知道注入那个对象了，于是就会报错
        @Autowired
        @Qualifier("c2")
        private Demo3 c1;
        
        public void demo() {
            System.out.println(c1);
        }
    }
    ```


#### 注解开发-自动注入（list）
- 如果自动注入的属性是一个list集合，则无论匹配多少个，都会存入list集合中（不存在多个冲突问题）
- 比如
  ```java
  @Component
  public class Demo {
      // 如果匹配到一个，则list集合中就一个，如果匹配到多个，则list集合中就有多个
      @Autowired
      private List<Demo3> c1;
      
      public void demo() {
          System.out.println(c1);
      }
  }
  ```

- 还可以使用 `@Qualifier` 进行限制
  - 比如
    ```java
    @Component
    public class Demo {
        // 如果匹配到一个，则list集合中就一个 c2
        //    无法做到，指定多个（比如，list中就存入 c1 和 c2），要么就存一个，要么全存
        @Autowired
        @Qualifier("c2")
        private List<Demo3> c1;
        
        public void demo() {
            System.out.println(c1);
        }
    }
    ```




#### 注解开发-取消单例模式（每次都创建新的对象） 
- 示范代码
  ```java
  @Component
  // 设置是否是单例模式，prototype表示设置成多例
  @Scope("prototype")
  public class Demo {
      public void demo() {
          System.out.println("ok");
      }
  }
  ```

- 主函数测试
  ```java
  public class Main {
      public static void main(String[] args) {
          Demo d1 = (Demo)Spring.spring.getBean("demo");
          Demo d2 = (Demo)Spring.spring.getBean("demo");
          
          // 去掉 @Scope("prototype") 打印 true，说明是单例模式，只创建一次对象
          // 加上 @Scope("prototype") 打印 false，说明每次都获取的是不同的对象
          System.out.println(d1 == d2);
      }
  }
  ```
    

#### 注解开发-按需加载的配置
- Spring的工作机制是，默认立即创建出一个单例的对象
- 如果想要取消立即加载，而是在使用到的时候，在进行加载，需要利用到下面的注解
  - 如果是单例，则按需加载后，就不再加载了
- 示范代码
  ```java
  @Component
  // 设置是立即加载还是按需加载，true表示按需加载
  @Lazy(true)
  public class Demo {
      public Demo() {
          System.out.println("对象创建了");
      }
      public void demo() {
          System.out.println("ok");
      }
  }
  ```

- 主函数测试
  ```java
  public class Main {
      public static void main(String[] args) {
          // 由于开启了按需加载，所以只要当获取对象的时候，上面的构造函数才会执行（说明确实是按需加载的）
          Demo d1 = (Demo)Spring.spring.getBean("demo");
      }
  }
  ```



#### 注解开发-工厂模式（利用函数创建bean）
- Spring创建bean对象，有两种模式，一种是立即创建，一种是按需创建
  - 则对应的，使用函数创建bean对象，也有两种模式，一种是立即执行，创建出bean，一种是按需执行创建bean

- 由于工厂函数是Spring调用的，并且不像配置文件一样，灵活的注入数据
  - **所以，Spring的参数只能接收对象，并且对象是bean对象**
  - 也就是说，参数只能是Spring创建的对象，这样Spring在调用工厂的时候，才能进行传入

- 示范工厂的代码（无参数）
  ```java
  // @Configuration：这个注解，表示内部的方法有bean加工的方法
  @Configuration
  public class Demo2 {
      // @Bean：这个注解，表示方法返回值，会作为一个bean对象
      @Bean
      // 不加下面的注解，表示是立即执行创建bean，加上这个注解，表示按需加载（需要的时候在执行函数，创建bean对象）
      @Scope("prototype")
      public Demo3 d2_gc() {
          System.out.println("工厂启动了");
          return new Demo3();
      }
  }
  ```

- 示范工厂的代码（有参数）
  ```java
  // @Configuration：这个注解，表示内部的方法有bean加工的方法
  @Configuration
  public class Demo2 {
      // @Bean：这个注解，表示方法返回值，会作为一个bean对象
      @Bean
      // 不加下面的注解，表示是立即执行创建bean，加上这个注解，表示按需加载（需要的时候在执行函数，创建bean对象）
      @Scope("prototype")

      // 接收的参数，是bean对象（Spring会自动注入对应的bean对象，注入规则和 Autowired 一样）
      //    也就是，工厂一执行，Spring就会把下面的两个类对应的对象进行传入
      public Demo3 d2_gc(Demo4 demo, Demo5 demo5) {
          System.out.println("工厂启动了");
          demo.d4();
          demo5.d5();

          return new Demo3();
      }
  }


  // 用于自动注入的类
  @Component
  public class Demo4 {
      public void d4() {
          System.out.println("demo4");
      }
  }
  @Component
  public class Demo5 {
      public void d5() {
          System.out.println("demo5");
      }
  }
  ```


- 获取工厂创建的类
  - 默认工厂的函数名，会作为所创建的bean的id
  - 如果 `@Bean` 有参数（比如 `@Bean(zdy)`），则参数作为所创建的bean对象的id（比如：`zdy`）
  - 这样，就可以根据id获取工厂创建的bean了
    ```java
    @Component
    public class Demo {
        // 自动注入，没有找到Demo3对应的bean，于是就会根据属性名进行查找
        //   正好找到，工厂创建的bean，于是就把工厂创建的bean注入进来了
        //   （也就是工厂函数的返回值对象，即：new Demo3()）
        @Autowired
        private Demo3 d2_gc;

        public void demo() {
            d2_gc.d();
        }
    }
    ```
  


#### 注解开发-取消配置文件
- 注解开发，也是需要利用配置文件的（需要在配置文件中进行所扫描包的配置）
  - 因为：Spring需要根据定义的包路径，扫描下面的所有类，然后获取注解，根据注解信息创建bean
  - Spring不扫描，bean对象是创建不出来的，因为java不认识这些注解，不会创建bean对象

- 如果采用注解开发，则配置文件中可能只有一个定义扫描包的配置
  - 如果是这样，**则配置文件完全可以省略，因为注解也能定义所扫描的位置**
  - 只要Spring能看到这个注解，就能扫描对应的包，构建bean对象

- 示范代码
  - 带有扫包注解信息的类
    ```java
    // 扫描什么包下的类（路径一定要相对于main）
    @ComponentScan({"org.example.domian", "org.example.dain"})
    public class SpringZj {}
    ```
  - Spring引入扫包注解信息的类（这样Spring就会解析注解，构建bean对象）
    ```java
    public class Spring {
        public static BeanFactory spring;
        static {
            // 把带有扫包信息的类，告诉Spring
            spring = new AnnotationConfigApplicationContext(SpringZj.class);

            // 如果有多个类含有扫包信息的话，还可以传递多个
            // spring = new AnnotationConfigApplicationContext(SpringZj.class, Demo.class);
        }
    }
    ```
  - 获取bean对象的示范代码（和配置文件的方式一样，也是根据id获取）
    ```java
    public class Main {
        public static void main(String[] args) {
            // 获取Spring创建的对象（根据ID获取），需要造型
            Demo demo = (Demo)Spring.spring.getBean("demo");
            demo.demo();
        }
    }
    ```



#### AOP(切面)-在方法前面插入切面
- 需要额外引入的包
  ```xml
  <dependency>
      <groupId>org.aspectj</groupId>
      <artifactId>aspectjweaver</artifactId>
      <version>1.9.6</version>
  </dependency>
  ```

- 辅助类
  - 提供切面方法
    ```java
    public class Demo2 {
        // 方法一
        public void a() {
            System.out.println("a");
        }
        
        // 方法二
        public void b() {
            System.out.println("b");
        }

        // 方法三
        public void c() {
            System.out.println("c");
        }
    }
    ```
  - 测试类（把切面方法插入这个类中的某个方法前面）
    ```java
    public class Demo {
        public void demo() {
            System.out.println("demo");
        }
    }
    ```


- 切面的实现配置（把方法插到前面执行）
  ```xml
  <!-- 创建一个对象，调用内部的方法，看看切面是否正常实现 -->
  <bean id="demo" class="org.example.domian.Demo"></bean>

  <!-- 创建一个对象，提供切面用到的方法 -->
  <bean id="demo2" class="org.example.domian.Demo2"></bean>

  <!-- 进行切面配置 -->
  <aop:config>
      <!-- 实现一个切面（demo2对应上面创建的切面对象） -->
      <aop:aspect id="q1" ref="demo2">
          <!-- 往那个方法的前面插入，* org.example.domian.Demo.demo()
                  *：返回值任意
                  org.example.domian.Demo.demo：方法路径
                  (String, Integer)：形参类型（没有就不写） -->
          <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>
          
          <!-- 要插入的方法（比如插入 a，b，c） -->
          <aop:before method="a" pointcut-ref="d1"></aop:before>
          <aop:before method="b" pointcut-ref="d1"></aop:before>
          <aop:before method="c" pointcut-ref="d1"></aop:before>
      </aop:aspect>

      <!-- 在实现一个切面（demo2对应上面创建的切面对象） -->
      <aop:aspect id="q2" ref="demo2">
          <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>
          <aop:before method="a" pointcut-ref="d1"></aop:before>
          <aop:before method="b" pointcut-ref="d1"></aop:before>
      </aop:aspect>
  </aop:config>
  ```

- 插入规律（不是按照切片中方法的顺序插入的，也就是说执行顺序并不是：`a、b、c、a、b`）
  - 先插入第一个（a、a）
  - 然后，在插入第二个（b、b）
  - 然后，在插入第三个（c）
  - 最终的插入顺序：
    `a、a、b、b、c`
  - 所以，`demo.demo();`，看似只执行了 `demo` 方法，但是实际执行效果是
    - `a、a、b、b、c、demo`
    - 先把切面方法执行完，在执行demo


  



#### AOP(切面)-环绕方法插入切面
- 需要额外引入的包
  ```xml
  <dependency>
      <groupId>org.aspectj</groupId>
      <artifactId>aspectjweaver</artifactId>
      <version>1.9.6</version>
  </dependency>
  ```

- 辅助类
  - 提供切面方法
    ```java
    public class Demo2 {
        // 方法1
        public void a(ProceedingJoinPoint pjp) throws Throwable {
            System.out.println("a_1");
            // 继续执行后面的代码（放行）
            pjp.proceed();
            System.out.println("a_2");
        }

        // 方法2
        public void b(ProceedingJoinPoint pjp) throws Throwable {
            System.out.println("b_1");
            // 继续执行后面的代码（放行）
            pjp.proceed();
            System.out.println("b_2");
        }
    }
    ```
  - 测试类（把切面方法插入这个类中的某个方法前面）
    ```java
    public class Demo {
        public void demo() {
            System.out.println("demo");
        }
    }
    ```


- 切面的实现配置（环绕插入）
  ```xml
  <!-- 创建一个对象，调用内部的方法，看看切面是否正常实现 -->
  <bean id="demo" class="org.example.domian.Demo"></bean>

  <!-- 创建一个对象，提供切面用到的方法 -->
  <bean id="demo2" class="org.example.domian.Demo2"></bean>

  <!-- 进行切面配置 -->
  <aop:config>
      <!-- 实现一个切面（demo2对应上面创建的切面对象） -->
      <aop:aspect id="q1" ref="demo2">
          <!-- 往那个方法的前面插入，* org.example.domian.Demo.demo()
                  *：返回值任意
                  org.example.domian.Demo.demo：方法路径
                  (String, Integer)：形参类型（没有就不写） -->
          <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>
          
          <!-- 要插入的方法（比如插入 a，b） -->
          <aop:around method="a" pointcut-ref="d1"></aop:around>
          <aop:around method="b" pointcut-ref="d1"></aop:around>
      </aop:aspect>

      <!-- 在实现一个切面（demo2对应上面创建的切面对象） -->
      <aop:aspect id="q2" ref="demo2">
          <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>
          <aop:around method="a" pointcut-ref="d1"></aop:around>
      </aop:aspect>
  </aop:config>
  ```

- 插入规律（不是按照切片中方法的顺序插入的，也就是说执行顺序并不是：`a、b、a`）
  - 先插入第一个（a、a）
  - 然后，在插入第二个（b）
  - 最终的插入顺序：
    ```js
    `a_1、a_1、b_1、demo、b_2、a_2、a_2`
      |    |   |         |    |   |
      |    |   | b（环绕） |    |   |
      |    |____ a（环绕） _____|   |
      |_________ a（环绕） _________｜
    ```
    




#### AOP(切面)-在方法后面插入切面

- 需要额外引入的包
  ```xml
  <dependency>
      <groupId>org.aspectj</groupId>
      <artifactId>aspectjweaver</artifactId>
      <version>1.9.6</version>
  </dependency>
  ```

- 辅助类
  - 提供切面方法
    ```java
    public class Demo2 {
        // 方法一
        public void a() {
            System.out.println("a");
        }
        
        // 方法二
        public void b() {
            System.out.println("b");
        }

        // 方法三
        public void c() {
            System.out.println("c");
        }
    }
    ```
  - 测试类（把切面方法插入这个类中的某个方法前面）
    ```java
    public class Demo {
        public void demo() {
            System.out.println("demo");
        }
    }
    ```


- 切面的实现配置（把方法插到后面执行）
  ```xml
  <!-- 创建一个对象，调用内部的方法，看看切面是否正常实现 -->
  <bean id="demo" class="org.example.domian.Demo"></bean>

  <!-- 创建一个对象，提供切面用到的方法 -->
  <bean id="demo2" class="org.example.domian.Demo2"></bean>

  <!-- 进行切面配置 -->
  <aop:config>
      <!-- 实现一个切面（demo2对应上面创建的切面对象） -->
      <aop:aspect id="q1" ref="demo2">
          <!-- 往那个方法的最后插入，* org.example.domian.Demo.demo()
                  *：返回值任意
                  org.example.domian.Demo.demo：方法路径
                  (String, Integer)：形参类型（没有就不写） -->
          <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>
          
          <!-- 要插入的方法（比如插入 a，b） -->
          <aop:after-returning method="a" pointcut-ref="d1"></aop:after-returning>
          <aop:after-returning method="b" pointcut-ref="d1"></aop:after-returning>
      </aop:aspect>

      <!-- 在实现一个切面（demo2对应上面创建的切面对象） -->
      <aop:aspect id="q2" ref="demo2">
          <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>
          <aop:after-returning method="a" pointcut-ref="d1"></aop:after-returning>
          <aop:after-returning method="b" pointcut-ref="d1"></aop:after-returning>
          <aop:after-returning method="c" pointcut-ref="d1"></aop:after-returning>
      </aop:aspect>

       <!-- 在实现一个切面（demo2对应上面创建的切面对象） -->
      <aop:aspect id="q3" ref="demo2">
          <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>
          <aop:after-returning method="b" pointcut-ref="d1"></aop:after-returning>
      </aop:aspect>
  </aop:config>
  ```

- 插入规律
  - 需要注意的是：它是倒着插入的（从下往上）
  - 先，插入所有切片的第一个（b、a、a）
  - 然后，在插入所有切片的第二个（b、b）
  - 然后，在插入所有切片的第三个（c）
  - 最终的插入顺序：
    `demo、b、a、a、b、b、c`

  




  


#### AOP(切面)-在方法最后插入切面
- 需要额外引入的包
  ```xml
  <dependency>
      <groupId>org.aspectj</groupId>
      <artifactId>aspectjweaver</artifactId>
      <version>1.9.6</version>
  </dependency>
  ```

- 辅助类
  - 提供切面方法
    ```java
    public class Demo2 {
        // 方法一
        public void a() {
            System.out.println("a");
        }
        
        // 方法二
        public void b() {
            System.out.println("b");
        }

        // 方法三
        public void c() {
            System.out.println("c");
        }
    }
    ```
  - 测试类（把切面方法插入这个类中的某个方法前面）
    ```java
    public class Demo {
        public void demo() {
            System.out.println("demo");
        }
    }
    ```


- 切面的实现配置（把方法插到最后执行）
  ```xml
  <!-- 创建一个对象，调用内部的方法，看看切面是否正常实现 -->
  <bean id="demo" class="org.example.domian.Demo"></bean>

  <!-- 创建一个对象，提供切面用到的方法 -->
  <bean id="demo2" class="org.example.domian.Demo2"></bean>

  <!-- 进行切面配置 -->
  <aop:config>
      <!-- 实现一个切面（demo2对应上面创建的切面对象） -->
      <aop:aspect id="q1" ref="demo2">
          <!-- 往那个方法的最后插入，* org.example.domian.Demo.demo()
                  *：返回值任意
                  org.example.domian.Demo.demo：方法路径
                  (String, Integer)：形参类型（没有就不写） -->
          <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>
          
          <!-- 要插入的方法（比如插入 a，b） -->
          <aop:after method="a" pointcut-ref="d1"></aop:after>
          <aop:after method="b" pointcut-ref="d1"></aop:after>
      </aop:aspect>

      <!-- 在实现一个切面（demo2对应上面创建的切面对象） -->
      <aop:aspect id="q2" ref="demo2">
          <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>
          <aop:after method="a" pointcut-ref="d1"></aop:after>
          <aop:after method="b" pointcut-ref="d1"></aop:after>
          <aop:after method="c" pointcut-ref="d1"></aop:after>
      </aop:aspect>

       <!-- 在实现一个切面（demo2对应上面创建的切面对象） -->
      <aop:aspect id="q3" ref="demo2">
          <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>
          <aop:after method="b" pointcut-ref="d1"></aop:after>
      </aop:aspect>
  </aop:config>
  ```

- 插入规律
  - 需要注意的是：它是倒着插入的（从下往上）
  - 先，插入所有切片的第一个（b、a、a）
  - 然后，在插入所有切片的第二个（b、b）
  - 然后，在插入所有切片的第三个（c）
  - 最终的插入顺序：
    `demo、b、a、a、b、b、c`

  



  



#### AOP(切面)-插入报错后执行的代码
- 只有代码执行报错了，插入的报错后执行的代码才会执行
  - 不报错不会执行
  - 注意：这并不是错误处理函数（不是说写了这个错误就不存在了）
    - 只是单纯的执行函数，错误依旧存在
    - 要想进行错误处理：可以在外面进行错误处理，如果在方法内部进行错误处理，则方法就会运行正常，不会进行错误抛出
      - 如果没有错误产生，则插入的方法就不会执行

.
- 报错后，所有`:after-returning`（后面插入的方法）不在执行，所有`:after`（最后插入的方法）正常执行
  - 所有环绕切入的方法，后面的也不会在执行

.
- 需要额外引入的包
  ```xml
  <dependency>
      <groupId>org.aspectj</groupId>
      <artifactId>aspectjweaver</artifactId>
      <version>1.9.6</version>
  </dependency>
  ```

- 辅助类
  - 提供切面方法
    ```java
    public class Demo2 {
        // 方法一
        public void a() {
            System.out.println("a");
        }
        
        // 方法二
        public void b() {
            System.out.println("b");
        }

        // 方法三
        public void c() {
            System.out.println("c");
        }
    }
    ```
  - 测试类（故意抛出错误）
    ```java
    public class Demo {
        public void demo() {
            int[] a = {1};
            System.out.println(a[1]);
        }
    }
    ```


- 切面的实现配置
  ```xml
  <!-- 创建一个对象，调用内部的方法，看看切面是否正常实现 -->
  <bean id="demo" class="org.example.domian.Demo"></bean>

  <!-- 创建一个对象，提供切面用到的方法 -->
  <bean id="demo2" class="org.example.domian.Demo2"></bean>

  <!-- 进行切面配置 -->
  <aop:config>
      <!-- 实现一个切面（demo2对应上面创建的切面对象） -->
      <aop:aspect id="q1" ref="demo2">
          <!-- 往那个方法的最后插入，* org.example.domian.Demo.demo()
                  *：返回值任意
                  org.example.domian.Demo.demo：方法路径
                  (String, Integer)：形参类型（没有就不写） -->
          <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>
          
          <!-- 要插入的方法（:after-throwing是插入报错） -->
          <aop:after method="b" pointcut-ref="d1"></aop:after>
          <aop:after-returning method="a" pointcut-ref="d1"></aop:after-returning>
          <aop:after-throwing method="c" pointcut-ref="d1"></aop:after-throwing>
      </aop:aspect>
  </aop:config>
  ```

- 执行顺序：`a、c`






#### AOP(切面)-分析切面的插入顺序（执行规律）
- 尽量不要一个方法，用多个切片进行插入，尽量不要打断顺序进行插入
  - 因为插入的方法，执行顺序不好估算（尤其是环绕插入的后半部分的执行时间）
  - 比如
    ```xml
    <aop:aspect id="q2" ref="demo2">
        <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>


        <aop:before method="a" pointcut-ref="d1"></aop:before>
        <aop:before method="b" pointcut-ref="d1"></aop:before>
        <aop:before method="c" pointcut-ref="d1"></aop:before>
        <aop:around method="h2" pointcut-ref="d1"></aop:around>
        <aop:around method="h1" pointcut-ref="d1"></aop:around>

        <aop:after-returning method="b" pointcut-ref="d1"></aop:after-returning>
        <aop:after method="c" pointcut-ref="d1"></aop:after>
        <aop:after method="d" pointcut-ref="d1"></aop:after>
        <aop:after method="a" pointcut-ref="d1"></aop:after>
        <aop:after-throwing method="a" pointcut-ref="d1"></aop:after-throwing>
    </aop:aspect>
    ```
    - 执行顺序：`a、b、c、h2、h1、demo、h1、h2、b、c、d、a`
  
.
- `:after-returning` 和 `:after` 和 `:after-throwing` 的插入时机一样
  - 可以看成一个分析，然后根据demo是否报错，来决定是否执行
  - 都是后面执行
    - 区别就是报错后 `:after-returning` 不会执行，不报错 `:after-throwing` 不会执行
  - 比如（示范插入）
    ```xml
    <!-- 先创建一个工厂对象，然后才能使用内部的工厂方法，创建对象 -->
    <bean id="demo" class="org.example.domian.Demo"></bean>
    <bean id="demo2" class="org.example.domian.Demo2"></bean>

    <aop:config>
        <!-- 创建一个切面类 -->
        <aop:aspect id="q1" ref="demo2">
            <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>

            <aop:after-returning method="a" pointcut-ref="d1"></aop:after-returning>
            <aop:after method="b" pointcut-ref="d1"></aop:after>
            <aop:after-throwing method="c" pointcut-ref="d1"></aop:after-throwing>
        </aop:aspect>

        <!-- 创建一个切面类 -->
        <aop:aspect id="q2" ref="demo2">
            <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>

            <aop:after-returning method="a" pointcut-ref="d1"></aop:after-returning>
            <aop:after-returning method="b" pointcut-ref="d1"></aop:after-returning>
            <aop:after method="c" pointcut-ref="d1"></aop:after>
            <aop:after-throwing method="e" pointcut-ref="d1"></aop:after-throwing>
        </aop:aspect>

        <aop:aspect id="q3" ref="demo2">
            <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>

            <aop:after method="b" pointcut-ref="d1"></aop:after>
            <aop:after method="e" pointcut-ref="d1"></aop:after>
            <aop:after method="a" pointcut-ref="d1"></aop:after>
        </aop:aspect>

        <aop:aspect id="q4" ref="demo2">
            <aop:pointcut id="d1" expression="execution(* org.example.domian.Demo.demo())"/>
            <aop:after method="d" pointcut-ref="d1"></aop:after>
        </aop:aspect>
    </aop:config>
    ```
    - 分析（由于是最后，所以倒着插入）
      - 先，插入所有切片的第一个（d、b、a、a）
      - 在，插入所有切片的第二个（e、b、b）
      - 在，插入所有切片的第三个（a、c、c）
      - 在，插入所有切片的第四个（e）
      - 如果报错执行（returning忽略），则执行顺序就是：`d、b、  e、b、  a、c、c、  e`
      - 如果不报错执行（throwing忽略），则执行顺序就是：`d、b、a、a、  e、b、b、  a、c`



#### 集成功能-定时器的使用（定时执行某段代码）
- 需要额外引入的包
  ```xml
  <!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz -->
  <dependency>
      <groupId>org.quartz-scheduler</groupId>
      <artifactId>quartz</artifactId>
      <version>2.3.2</version>
  </dependency>
  <!-- https://mvnrepository.com/artifact/org.springframework/spring-context-support -->
  <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context-support</artifactId>
      <version>5.3.4</version>
  </dependency>
  <!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api -->
  <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
      <version>2.0.0-alpha1</version>
  </dependency>
  <!-- https://mvnrepository.com/artifact/org.springframework/spring-tx -->
  <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-tx</artifactId>
      <version>5.3.3</version>
  </dependency>
  ```

- 示范配置
  ```xml
  <!-- 创建一个对象，定义定时执行的函数 -->
  <bean name="demo" class="Demo"></bean>

  <!-- 创建一个定时器 -->
  <bean id="time" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
      <!-- 指定对象 -->
      <property name="targetObject" ref="demo"></property>
      <!-- 时间到了，执行指定对象的指定方法（也就是demo.a方法） -->
      <property name="targetMethod" value="a"></property>
  </bean>

  <!-- 给定时器添加定时规则（多久触发一次） -->
  <bean name="cron" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean">
      <!-- 给那个定时器添加规则 -->
      <property name="jobDetail" ref="time"></property>
      <!-- 添加什么定时规则 -->
      <property name="cronExpression" value="0/5 48 18 * * ?"></property>
  </bean>

  <!-- 启动定时器 -->
  <bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
      <property name="triggers">
          <!-- 格式是list，说明可以启动多个定时器 -->
          <list>
              <!-- 启动那个定时器 -->
              <ref bean="cron" />
          </list>
      </property>
  </bean>
  ```
- 只要引入Spring的xml配置文件，什么也不用操作，计时器就会工作

.
- 常用的定时规则
  - "0 0 12 * * ?"：每天中午 12 点触发
  - "0 15 10 ? * *"：每天上午 10:15 触发
  - "0 15 10 * * ?"：每天上午 10:15 触发
  - "0 15 10 * * ? *"：每天上午 10:15 触发
  - "0 15 10 * * ? 2005"：2005 年的每天上午 10:15 触发
  - "0 * 14 * * ?"：在每天下午 2 点到下午 2:59 期间的每 1 分钟触发
  - "0 0/5 14 * * ?"：在每天下午 2 点到下午 2:55 期间的每 5 分钟触发
  - "0 0/5 14,18 * * ?"：在每天下午 2 点到 2:55 期间和下午 6 点到 6:55 期间的每 5 分钟触发
  - "0 0-5 14 * * ?"：在每天下午 2 点到下午 2:05 期间的每 1 分钟触发
  - "0 10,44 14 ? 3 4"：每年三月的星期三的下午 2:10 和 2:44 触发
  - "0 15 10 ? * MON-FRI"：周一至周五的上午 10:15 触发
  - "0 15 10 15 * ?"：每月 15 日上午 10:15 触发
  - "0 15 10 L * ?"：每月最后一日的上午 10:15 触发
  - "0 15 10 ? * 6L"：每月的最后一个星期五上午 10:15 触发
  - "0 15 10 ? * 6L 2002-2005"：2002 年至 2005 年的每月的最后一个星期五上午 10:15触发
  - "0 15 10 ? * 6#3"：每月的第三个星期五上午 10:15 触发





#### 集成功能-操作数据库
- 利用Spring配置，让Spring创建出一个操作数据库的工厂
- 然后在Java程序中，就可以利用这个工厂，对数据库进行操作

.
- 既然要操作数据库，就需要引入操作数据的包，Spring中是不自带这些包的
  ```xml
  <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-jdbc</artifactId>
      <version>5.3.5</version>
  </dependency>
  <!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
  <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.23</version>
  </dependency>
  ```

- 创建工厂的示范代码（配置文件Spring.xml）
  ```xml
  <!-- 创建一个数据源对象（连接数据库） -->
  <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
      <!-- 数据库驱动类 -->
      <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
      <!-- 数据库的URL -->
      <property name="url" value="jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8"></property>
      <!-- 数据库的用户名 -->
      <property name="username" value="root"></property>
      <!-- 数据库的密码 -->
      <property name="password" value="root"></property>
  </bean>

  <!-- 创建一个工厂 -->
  <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
      <!-- 配置数据源 -->
      <property name="dataSource" ref="dataSource"></property>
  </bean>
  ```


- Java中使用Spring创建的工厂，操作数据库
  ```java
  public class Demo {
      // 解析配置文件
      private static ApplicationContext spring = new ClassPathXmlApplicationContext("demo.xml");
      public static void main(String[] str) {
          // 根据id获取工厂
          JdbcTemplate template = (JdbcTemplate)spring.getBean("jdbcTemplate");

          // 这样就可以使用，template操作数据库了(增删改查)
          // 第一个参数，传sql指令，后面参数传递，替换 ？的数据
          int ins = template.update("insert into h values(?)", "xxx");
          System.out.println(ins);
          // 删除数据
          int dele = template.update("delete from h where v = ?", "he");
          System.out.println(dele);
          // 修改数据
          int up = template.update("update demo set xingBie = ? where name = ?", "男", "张三");
          System.out.println(up);

          // 查询数据，一行(映射到domain中对应的类，便于操作)
          B b = template.queryForObject("select * from demo where name = ?", new RowMapper<B>() {
              public B mapRow(ResultSet resultSet, int i) throws SQLException {
                  B b = new B();
                  b.setName( resultSet.getString("name"));
                  b.setAge( resultSet.getInt("age"));
                  b.setXingBie( resultSet.getString("xingBie"));
                  b.setBanJi(resultSet.getString("banJi"));
                  b.setId(resultSet.getInt("id"));
                  return b;
              }
          },  "张三");
          System.out.println(b);


          // 查询数据，多行（自动构建一个list，不便于操作）
          List list = template.queryForList("select * from demo");
          System.out.println(list);

          // 查询数据，多行，可以手动构建集合(映射到domain中对应的类，便于操作)
          List<B> li = template.query("select * from demo", new RowMapper<B>() {
              public B mapRow(ResultSet resultSet, int i) throws SQLException {
                  B b = new B();
                  b.setName( resultSet.getString("name"));
                  b.setAge( resultSet.getInt("age"));
                  b.setXingBie( resultSet.getString("xingBie"));
                  b.setBanJi(resultSet.getString("banJi"));
                  b.setId(resultSet.getInt("id"));
                  return b;
              }
          });
          System.out.println(li);
      }
  }
  ```




#### 集成功能-发送邮
- 需要借助两个包
  ```xml
  <!-- https://mvnrepository.com/artifact/org.springframework/spring-context-support -->
  <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context-support</artifactId>
      <version>5.3.4</version>
  </dependency>
  <!-- https://mvnrepository.com/artifact/javax.mail/mail -->
  <dependency>
      <groupId>javax.mail</groupId>
      <artifactId>mail</artifactId>
      <version>1.4.7</version>
  </dependency>
  ```


- Spring的配置
  ```xml
  <bean id="sendEail" class="org.springframework.mail.javamail.JavaMailSenderImpl">
      <!-- 什么格式的邮件 -->
      <property name="host" value="smtp.qq.com"></property>
      <!-- 邮箱号 -->
      <property name="username" value="2499302263@qq.com"></property>
      
      <!-- 配置认证号(获取在下面的原生中进行了说明) -->
      <!-- 认证码的获取，登陆邮箱后，点击邮箱名(设置)，找到POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务
          然后，随便找到一个服务，点击开启，按照提示的东西操作，就会得到一个认证码(授权码)
          如果已经开启，则认证码是之前得到的(最好做一下保存) -->
      <property name="password" value="tpywohqoimbfdjdf"></property>
      <!-- 配置字符集 -->
      <property name="defaultEncoding" value="UTF-8"></property>
      <!-- 配置端口号 -->
      <property name="port" value="465"></property>
      <!-- 多余的配置 -->
      <property name="javaMailProperties">
          <props>
              <prop key="mail.smtp.auth">true</prop>
              <prop key="mail.smtp.ssl.enable">true</prop>
          </props>
      </property>
  </bean>
  ```


- 使用Spring中的配置，发送邮件
  ```java
  public class Demo {
      private static ApplicationContext spring = new ClassPathXmlApplicationContext("demo.xml");

      public static void main(String[] str) throws MessagingException {
          // 获取Spring中配置的对象
          JavaMailSenderImpl session = (JavaMailSenderImpl)spring.getBean("sendEail");
          // 创建邮箱对象
          MimeMessage message = session.createMimeMessage();
          // 创建发送邮件工具
          MimeMessageHelper helper = new MimeMessageHelper(message);
          // 设置发件人
          helper.setFrom("2499302263@qq.com");
          // 设置收件人(三种模式：TO收件人，CC抄送人，BCC密送)
          helper.setTo("2499302263@qq.com");
          // 设置发送的主题
          helper.setSubject("这是主题");
          // 设置发送的内容
          helper.setText("这是内容");
          // 进行发送
          session.send(message);
      }
  }
  ```
