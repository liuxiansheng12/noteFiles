<script src='/笔记/see/index.js'></script>
[toc]



#### 准备工作-搭建项目
- 首先创建项目的时候，需要选择创建 `web` 项目
  - 在创建项目的流程中，选中 maven-archetype-webapp （作用：创建一个web服务的项目，便于快速的创建出一个web项目）

- 项目建立完成后，需要建立项目结构（文件目录）
  - 共四个文件
    - src/main/java（存放源代码）
    - src/main/resources（存放配置文件）
    - src/test/java
    - src/test/resources
    - 其实 `src/main/java` 和 `src/main/resources` 只是开发环境下的目录结构
      - 运行的时候，两个文件夹下的内容会全部放到src下
      - 开发环境为什么要搞这两个目录结构，目的就是为了区分源代码和配置文件（便于管理）
  - 有些编辑器，右击src，选择创建文件，会自动提示创建出这四个文件
    - <img src='https://lsz.net.cn/node/imgs/ca7744c6d678d3c1cac54631924400ad.png' />
    - 选中这四个文件夹就可以一次性创建成功
  - 如果是手动创建的这四个文件，需要设置文件的属性（具体属性在上方图片中可以看出来）
    - 设置方式：右击文件夹，找到 `Mark Directory as`，然后选中对应的属性就可以了



#### 准备工作-项目引入SpringBoot开发环境
- 引入 SpringBoot 的项目依赖包（在 `pom.xml` 文件中加入下方的配置）
  ```xml
    <!--超级父pom  是springboot父依赖   声明版本号-->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.8.RELEASE</version>
    </parent>

    <dependencies>
        <!--web项目需要使用的-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <!-- 去掉tomcat，使用下面的jetty启动项目 -->
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-tomcat</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jetty</artifactId>
        </dependency>
    </dependencies>
    ```



#### 准备工作-主函数的定义
- 由于没有使用编辑器的tocmat，所以主函数就需要自己定义一个
  - 这也是SpringBoot的作用：自己实现主函数，不借助外界的主函数

- 注意：必须要在java下建立一个文件夹，所有的项目代码都写在该文件夹下（包括主函数）
  - 如果主函数所在的类直接在java下定义，则启动SpringBoot的时候，就会报错


- 主函数的实现
  ```java
    // 这个注解，表示启动的是一个 SpringBoot项目
    @SpringBootApplication
    public class SpringMain {
        public static void main(String[] args) {
            // SpringApplication.run 表示启动SpringBoot
            // SpringMain.class设置的是扫包路径
            SpringApplication.run(SpringMain.class, args);
        }
    }
  ```
  - 因为SpringBoot也是Spring，也是需要构建bean的，而SpringBoot中全是注解开发，所以就需要设置一个扫包的路径
    - 这样SpringBoot在启动的时候，才会根据路径扫描下面所有的类，根据注解实现对应的功能
    - `SpringMain.class`表示的就是扫描，主函数所在路径下的所有的包


#### 准备工作-自定义启动端口
- 默认启动的端口是：`8080`
- 可以通过配置文件进行修改（配置文件在 `resources` 中进行定义）
  - 在默认配置文件 `application.yml` 中进行配置（如果没有该文件，手动创建一个）
- 配置接口的示范配置
  ```yml
    # 配置端口
    server:
        port: 10086
  ```

- 除了 `.yml` 类型的配置文件，还有一种配置文件 `.properties`
  - 并且 `.properties` 的优先级高于 `.yml`
  - 比如：默认配置文件 `application.properties`
  
- 在 `application.properties` 中配置端口的示范配置
  ```conf
  # 配置端口
  server.port=10087
  ```
  - `.`在 `yml` 中就是换行（表现形式看上方的示范配置）
  - 由于`.properties` 的优先级高于 `.yml`，如果和上面的配置文件共存的情况下，开启的端口就是 `10087`
  



#### 定义接口
- 需要利用 `@Controller` 注解，表示这个类需要处理请求，其他的和SpringMVC中的使用方式完全一样
- 示范代码
  ```java
    @Controller
    public class Demo {
        @RequestMapping(value = "/demo", method = RequestMethod.GET)
        @ResponseBody
        public String demo() {
            System.out.println("访问了demo接口");
            return "ok";
        }
    }
  ```
  - 访问：`http://localhost:8080/demo`就能看到接口返回数据



#### 四大请求方式的简写
- 使用对应的注解直接搞定
  - 不用在使用 RequestMapping(method=RequestMethod.XXX)，来指定对应的请求方式


- 示范代码
  ```java
  @Controller
  public class A {
      // 接收 get 请求，查询数据
      @GetMapping("/hello")
      // GetMapping 就相当于 下面的写法
      // @RequestMapping("/hello", method=RequestMethod.GET)
      @ResponseBody()
      public String helloGet(){
          System.out.println("get请求");
          return "ok";
      }

      // 接收 post 请求，增加数据
      @PostMapping("/hello")
      @ResponseBody()
      public String helloPost(){
          System.out.println("post请求");
          return "ok";
      }

      // 接收 put 请求，修改数据
      @PutMapping("/hello")
      @ResponseBody()
      public String helloPut(){
          System.out.println("put请求");
          return "ok";
      }

      // 接收 delete 请求，删除数据
      @DeleteMapping("/hello")
      @ResponseBody()
      public String helloDelete(){
          System.out.println("delete请求");
          return "ok";
      }
  }
  ```



#### 数据配置文件的使用
- 在自定义端口中就使用到了这种类型的配置文件
- 共分为两种：一种后缀是`.properties`，一种后缀是 `.yml`
  - 并且：`.properties` 的优先级高于 `.yml`

- 配置文件的示范代码
  - `.properties`中类型的示范代码
    ```conf
    # 配置端口
    server.port=8095

    # 配置普通数据（中文可能会乱码，要注意编辑器的编码格式，Spring中有介绍编码的设置方式）
    poot.name=张三
    poot.age=8095

    # 还可以引用本配置文件中的数据，如果没有就表现成 ${poot.name}，有数据就进行替换
    # ${poot.name}
    # 甚至还可以执行一些函数
    # ${random.int}

    # 比如
    poot.demo=姓名：${poot.name}，年龄：${random.int}
    ```
  - `.yml`中类型的示范代码（和上面比：.的表现形式是换行缩进）
    ```yml
    # 配置端口
    server:
        port: 8095

    # 配置普通数据
    name: 李四
    poot:
        age: 20

    # 配置数组结构
    arr: 
        - a
        - b
        - c
    ```


- 获取配置文件中的数据（默认配置文件）
  - 默认配置文件，Spring是会自动引入的（无非手动引入，可以直接使用）
    - 默认配置文件名：`application.properties`、`application.yml`
  - 获取数据
    ```java
    @Controller
    public class Demo {
        // 获取配置文件中的数据
        @Value("${name}")
        private String name;

        @Value("${poot.age}")
        private int age;

        @RequestMapping(value = "/demo", method = RequestMethod.GET)
        @ResponseBody
        public String demo() {
            System.out.println("访问了demo接口");
            System.out.println(name);
            System.out.println(age);
            return "ok";
        }
    }
    ```




- 获取配置文件中的数据（自定义配置文件）
  - 比如配置文件（demo.yml）
    ```yml
    fileName: demo.yml
    ```
  - 获取配置文件中的数据，需要借助一个注解 `@PropertySource`
    ```java
    @Controller
    // 引入自定义配置文件
    @PropertySource("classpath:demo.yml")
    public class Demo {
        // 如果上方不引入自定义配置文件，则这个属性就找不到，于是SpringBoot启动的时候就会报错
        @Value("${fileName}")
        private String name;

        @Value("${poot.age}")
        private int age;

        @RequestMapping(value = "/demo", method = RequestMethod.GET)
        @ResponseBody
        public String demo() {
            System.out.println("访问了demo接口");
            System.out.println(name);
            System.out.println(age);
            return "ok";
        }
    }
    ```


- 获取配置文件中的数据（借助类对象进行映射）
  - 作用：不用一个一个的手动引入了，只需要建立一个对应的辅助类，在借助一个注解，就会自动根据属性进行数据映射
  - 前提：要映射的配置文件中的数据，必须有一个节点（比如 `poot`）
    - 因为映射的时候，需要根据根节点进行查找
    ```yml
    poot:
        name: 李四
        age: 20
    ```
  - 示范代码（映射数据的辅助类）
    ```java
    @Configuration
    // prefix 指定一级目录
    @ConfigurationProperties(prefix = "demo")
    // 还可以指定配置文件，如果没有指定，就从默认配置文件中获取数据
    // @PropertySource("classpath:demo.yml")
    // set函数不定义，赋不了值
    public class Demo2 {
        public String name;
        public int age;

        public void setName(String name) {
            this.name = name;
        }

        public void setAge(int age) {
            this.age = age;
        }
    }
    ```
  - 获取上方的映射类（直接采用自动注入就行）
    - 上方的类也是交给Spring进行管理，创建出一个bean
    ```java
    @Controller
    public class Demo {
        // 自动注入数据辅助类
        @Autowired
        private Demo2 demo2;

        @RequestMapping(value = "/demo", method = RequestMethod.GET)
        @ResponseBody
        public String demo() {
            System.out.println("访问了demo接口");
            System.out.println(demo2.name);
            System.out.println(demo2.age);
            return "ok";
        }
    }
    ```


- `.yml` 和 `.properties` 的区别
  - 首先：`.yml`中的内容层级分明，便于阅读
  - 其次：`.yml`中可以分段（一次性定义多套内容，然后每个内容起一个名字，根据名字来决定启动那一套数据）
    - 比如
      ```yml
        # 这个表示使用那一段配置
        spring:
            profiles:
                active: prod # 指定对应的名称，类似指定对应的配置文件名

        # 三个横杠表示分段，下面的配置是一块的，直到下一个分段符号
        ---
        spring:
            profiles: dev # 分段的名称
        
        # 数据内容
        server:
            port: 8090
        name: 张三
        poot:
            age: 20

        # 三个横杠表示分段，下面的配置是一块的
        ---
        spring:
            profiles: prod # 分段的名称

        # 数据内容
        server:
            port: 10086
        name: 李四
        poot:
            age: 18
      ```



#### 响应JSON格式的数据
- SpringBoot中集成了对JSON数据的处理，所以可以直接开发，不用在手动引入依赖，进行配置了

- 响应JSON格式的数据
  - 直接响应一个对象，SpringBoot一看不是string，就会自定转换成Json格式的数据
  - 响应辅助类（构建响应对象）
    ```java
    @Component
    public class Demo1 {
        @Value("${demo.name}")
        public String name;
        @Value("${demo.age}")
        public int age;
    }
    
    @Configuration
    // prefix 指定一级目录
    @ConfigurationProperties(prefix = "demo")
    public class Demo2 {
        public String name;
        public int age;

        public void setName(String name) {
            this.name = name;
        }

        public void setAge(int age) {
            this.age = age;
        }
    }
    ```
  - 接口示范代码
  ```java
    @Controller
    public class Demo {
        @Autowired
        private Demo2 demo2;

        @Autowired
        private Demo1 demo1;

        @RequestMapping(value = "/demo", method = RequestMethod.GET)
        @ResponseBody
        public Demo1 demo() {
            System.out.println("访问了demo接口");
            return demo1;
        }
    }
  ```
  - 需要注意的是，不能直接响应数据配置文件的映射类（映射类：看数据配置文件的使用）
    - 否则会报错
    - 比如上例中的 `Demo2`
  - 如果是通过 `@Value` 给对象赋数据配置文件中的数据，这没有问题（因为这不是映射类），响应可以直接解析成功JSON
    - 比如上例中的 `Demo1`



#### 数据加密-jasypt

- 需要额外引入一个包
  ```xml
    <dependency>
        <groupId>com.github.ulisesbocchio</groupId>
        <artifactId>jasypt-spring-boot-starter</artifactId>
        <version>2.0.0</version>
    </dependency>
  ```

- 数据加密
  ```java
    public class Demo {
        public static void main(String[] args) {
            // 创建加密工具
            BasicTextEncryptor encryptor = new BasicTextEncryptor();
            // 传入密钥
            encryptor.setPassword("123456!@#");

            // 加密数据
            String username = encryptor.encrypt("root");
            // 加密数据
            String password = encryptor.encrypt("1234");
            
            System.out.println(username);
            System.out.println(password);
        }
    }
  ```

- 数据解密
  ```java
    public class DemoApplication {
        public static void main(String[] args) {
            // 创建加密工具
            BasicTextEncryptor encryptor = new BasicTextEncryptor();
            // 传入密钥（加密时使用的密钥）
            encryptor.setPassword("123456!@#");

            // 解密某个加密的数据
            String password = encryptor.decrypt("8wo6Osrhkx7ZMxa6/CkUkQ==");

            System.out.println(password);
        }
    }
  ```

- 数据解密（利用配置文件进行解密）
  - 不够灵活，只能解密固定的加密数据（因为它需要写死，而不能动态传入）
  - 数据配置文件示范配置（application.yml：默认配置文件）
    ```yml
    # 加密数据使用的密钥
    jasypt:
    encryptor:
        password: 123456!@#

    # 解密数据，用ENC包裹加密的数据，SpringBoot启动的时候，就会对加密数据进行解密
    #  这样在获取下面的数据的时候就是解密好的数据
    username: ENC(M2T4NtBMmPEmcyIPyq/vmw==)
    password: ENC(k1q3uc6pPqmg+98dXkmu/Q==) 
    ```
  - 获取数据（看看是不是解密后的数据）
    ```java
    @Controller
    public class Demo {
        // 注入数据，看看是不是解密后的数据（打印后发现是解密后的数据，说明配置文件起作用了）
        @Value("${username}")
        private String username;

        @Value("${password}")
        private String password;

        @RequestMapping(value = "/demo", method = RequestMethod.GET)
        @ResponseBody
        public String demo() {
            System.out.println(username);
            System.out.println(password);
            return "ok";
        }
    }
    ```



#### 模版引擎-freemarker
- 利用转发，响应一个模版文件（和jsp类似），然后利用转发携带的数据，替换模版文件中的模版标记

- 需要引入的依赖
  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-freemarker</artifactId>
  </dependency>
  ```

- 模版文件的创建示范（模版取值）
  - 模版文件必须位于：`resources/templates`中
    - 也就是在存放配置文件的地方，建立一个templates文件夹，内部用于存放模版文件
    - 不能放在`webapp`中
  - 模版的后缀名必须是 `ftl`（比如：`demo.ftl`）
  ```html
  <body>
      <!-- 三种取值方式 -->
      
      现在时间是：${now}
      <br>
      ${"现在时间是：${now}"}
      <br>
      ${"现在时间是：" + now}
  </body>
  ```


- 模版文件的响应（转发并携带替换的模板数据）
  ```java
  @Controller
  public class Demo {
      @RequestMapping(value = "/template", method = RequestMethod.GET)
      public String demo(Model model) {
          // 转发传递数据（模版中用到的替换数据）
          model.addAttribute("now", new Date().toString());
          // 进行转发，读取模版文件
          return "/demo";
      }
  }
  ```
  - 转发地址：不能携带文件后缀和根文件路径`templates`
  - 这样，当访问 `/template` 的时候，SpringBoot就会转发到 `demo`（响应上方的模版文件）
    - SpringBoot一看响应的是 `ftl` 文件，就会自动进行解析，然后把解析后的数据，进行响应




#### 模版引擎-thymeleaf

- - 模版引擎，就是传入一个模版（字符串）
  - 把里面的内容，替换成真实的数据
  - 根据数据的不同，一个模版，体现出多个结果

- thymeleaf 模版引擎，搭建页面，需要使用 转发
  - 和 jsp 差不多
  - 转发对应模版的地址，然后传入模版中需要的数据
    - 转发，数据的传递，可以使用 **Model 或 ModelMap 或者 ModelAndView**，具体看 SpringMVC中的使用介绍
  - 这样就会把，解析后的模版，响应给客户端


依赖的引入
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
<dependency>
    <groupId>nz.net.ultraq.thymeleaf</groupId>
    <artifactId>thymeleaf-layout-dialect</artifactId>
</dependency>
```

在resources中，建立一个 **templates** 文件夹，存放模版
- 所有的模版文件，都会去该文件夹下找

controller 中的处理代码
```java
@Controller
public class A {

    @RequestMapping("/hello")
    public String hello(Model model){
        // 转发传递数据
        model.addAttribute("now", new Date().toString());
        // 进行转发，读取模版文件
        return "/index";
    }

}
```
- 当请求的是 /hello 的时候，就会转发
  - 读取的实际是 templates/index.html
  - **所以 templates 必须是 模版文件的根文件夹**
  - 否则，会出现 404 的错误，找不到

- 如果thymeleaf 和 freemarker 共同存在
  - 转发路径写的是 /index 自动添加后缀，默认先找 .ftl
  - 没有.ftl，然后在找 .html
  - **所以，如果名字冲突，转发的路径，最好带上后缀**
    - 比如: "/index.html";
    - **freemarker 的转发路径，是不能添加后缀的**



- 模版的实现，都是依靠插件，如果对应的插件没有下载下来，依旧出现 404 错误
  - 比如，只有 freemarker 模版引擎，但是转发的路径是 "/index.html"，此时并没有 thymeleaf ，就会出现 404 



.
- 模版的用法
- **获取 model 中传入的 普通数据 (转发的时候存入的)**
```html
<!-- text 不会解析标签  传什么就展示什么 -->
<p th:text="${name}" >name</p>
<!-- utext 会解析标签，相当于 innerHTML  -->
<p th:utext="${name}" >name</p>

<!-- 替换规则，替换第一个子节点标签前面的文本内容，如果直接是一个标签，则替换空文本 -->
<!-- 
    <p th:utext="${name}" ><div>name</div></p>
    <p th:utext="${name}" >
        desho
        <div>name</div>
    </p> 
    第一个替换空，第二个替换 desho 
    只会替换文本内容，并且是子节点前面的，后面的不管
-->
```


- **获取 model 中传入的  对象数据(转发的时候存入的)**
```html
<!-- 一种是这样获取 -->
<p th:text="${restaurant.boss}" >restaurant boss</p>
<p th:text="${restaurant.chef}" >restaurant chef</p>

<!-- 一种是这样获取 -->
<div th:object="${restaurant}">
    <!-- 内部可以这样写，获取子属性 -->
    <p>boss: <span th:text="*{boss}">boss</span>.</p>
    <!-- 内部还可以这样写 -->
    <p>chef: <span th:text="${restaurant.chef}">chef</span>.</p>
</div>


<!-- 替换规则，替换第一个子节点标签前面的文本内容，如果直接是一个标签，则替换空文本 -->
<!-- 
    <p th:utext="${name}" ><div>name</div></p>
    <p th:utext="${name}" >
        desho
        <div>name</div>
    </p> 
    第一个替换空，第二个替换 desho 
    只会替换文本内容，并且是子节点前面的，后面的不管
-->
```



- **a标签链接(model中传入) 和 配置文件中数据 的使用**
```html
<!-- 存入的转发路径，model.addAttribute("welcome", "/dt"); -->
<a th:href="${welcome}">welcome</a>

<!-- 只能读取默认配置文件 messages.properties 中的数据
     yml中的使用不了 -->
<p th:text="#{a}"> message</p>
<p th:text="#{a.b}"> message</p>
```



- **复制另一个html文件中的内容，进行替换**
```html
<!-- 文件整个节点，插入到内部 -->
<div th:insert="footer :: copy"></div>
<!-- 文件整个节点，替换该标签 -->
<div th:replace="footer :: copy"></div>
<!-- 文件父节点中的子节点，插入到内部 -->
<div th:include="footer :: copy"></div>


<!-- footer 就是文件的路径，内部只有一个根节点，有点类似 React 中的组件  -->

<!-- footer 中的组件内容 -->
<div>
    <h4>张三</h4>
    <h4>李四</h4>
</div>
```

- **运算符的使用**
```html
<!-- 只能使用简单的运算符，只能做数字运算与比较 -->
<div th:text="${ 1 + 1 }">运算符</div>
<div th:text="${ 1 + 1 > 1 }">运算符</div>
```









#### 辅助类自动注入一些常用的方法-比如set和get
- 作用：简化辅助类内部的书写
  - 后期修改方便，只需要修改个属性名就可以，不需要在修改set和get
    - 因为没有这两个方法，是自动根据属性名生成的

- 依赖的引入
  ```xml
  <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <version>1.18.10</version>
      <scope>provided</scope>
  </dependency>
  ```

- 编辑器的配置（取消报错）
  - 由于 lombok 是编译的时候，才会自动加入一些方法，所以在开发的时候，会出现警告问题，因为此时还没有对应的方法
    - 实际运行的时候是可以执行的，应为实际运行的时候，已经有对应的方法了
  - 要想消除该问题，需要配置编辑器的两个地方
    - 安装一个插件
      - 点击 IntelliJ IDEA ———— 点击 Preferences ———— 点击 Plugins 
      - 在 Marketplace 中，搜索 Lombok，点击 install 下载，就可以了
      - 如果已经下载，则没有install，而是更新
    - 让注解在开发的时候，就起作用
      - 点击 Build,Execution,Deployment ———— 点击 compiler ———— 点击 Annotation Processors
      - 勾中 Enable annotation arocessing
      - 点击 ok，就可以了
  - 配置完成后，需要进行重启，配置才会生效

.
- 具体的工作原理
  - 存放数据的类，通常要加上set和get方法
    - 虽然有快捷键，但是后期修改起来比较麻烦
  - 而借助`lombok`中提供的注解，只需要写上私有属性即可
    - 在编译的时候，生成class文件，会自动加上set和get方法，以及其他的一些基础的方法
    - 源文件是不会发生变化的，这样，后期修改只需要修改下属性，就可以了，非常方便
    - 如果自定义了，则使用自定义的，没有自定义的方法，才会自动添加上

.
- 辅助类的示范定义代码
  ```java
  // 只添加 set 和 get 方法
  // 这是两个注解，可以单独使用，比如只添加 get 方法
  @Setter@Getter
  public class Conf {
      private String name;
      private String age;
      private String ceshi;
      
      public Conf() {
          System.out.println("执行了");
      }
  }


  // 这个注解比较强大，会添加所有的常用方法
  //    比如有参数构造方法，无参数构造方法，set 和 get 等等
  //    由于自定义了，无参数构造方法，则使用自定义的，不会发生替换现象
  @Data
  public class Conf {
      private String name;
      private String age;
      private String ceshi;
      
      public Conf() {
          System.out.println("执行了");
      }
  }
  ```




#### 操作数据库-jpa包
- 使用该包操作数据库的使用场景：简单的操作数据库，也就是说sql指令比较简单，并且常用
  - 如果，操作数据库的指令比较复杂，就需要使用 `Mybatis` 了
  - 原因：该包中定义好了一些sql指令，都是常用的，只能使用这些固定的功能指令操作数据库
    - 所以说：该包操作数据库，只能实现一些比较简单常用的功能

- 需要引入的依赖
  ```xml
  <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <scope>runtime</scope>
  </dependency>
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
  </dependency>
  ```
- 流程（具体步骤看后面）：建立连接 --> dao接口的定义 --> 工具辅助类的定义 --> 操作数据库

.
- 数据库的连接（在默认配置文件`application.yml`中配置连接信息）
  - 既然要操作数据库，就需要连接数据库
  ```yml
  # 连接数据库的配置
  spring:
    datasource:
      url: jdbc:mysql://localhost:3306/test
      username: root
      password: root
    
    # jpa功能的配置
    jpa:
      #自动创建|更新|验证数据库表结构
      hibernate:
        ddl-auto: update
      #设置数据库引擎为InnoDB
      database-platform: org.hibernate.dialect.MySQL5InnoDBDialect
      #打印sql语句，方便调试
      show-sql: true
  ```
  - 在启动项目的时候，就会进行连接，如果连接出错，则服务器就会启动不起来


- dao层的示范代码（使用 `jpa` 操作数据库）
  ```java
  // dao中，定义的操作 工具类对应数据库的 接口
  //   操作的是 student 这个表
  //   全靠 <Student, Long> 中的 Student 指定操作 student 这个表
  //   所以，要存在一个工具类，并且名称要与表的名字对应
  @Component
  public interface Ce extends JpaRepository<Student, Long> {
  }
  ```
  - 注意点：
    - dao层代码定义成一个接口就可以，并且啥也不用写，因为jpa中都已经写好了一些常用的（sql指令操作数据库），直接继承就可以
    - 必须是：一个表，对应一个接口类
      - 对该表的所有操作，都是通过该接口（调用该接口继承的jpa中的方法，操作该表）
    

- 工具类的定义（jpa辅助类，并且类的名字要与表的名字一样）
  - 因为jpa中，定义好了一堆操作数据库的sql指令，然后接口通过继承的方式就能实现对表的操作
  - 但是jpa怎么知道要操作那个表（就是全靠这个工具类的类名字，类名字就是要操作的数据库表）
    - 上面接口的定义中，就给jpa传入了对应的工具类
    - 所以，工具类是必须的
  - 比如：（Student.java：和上面接口用到的工具类对应）
    ```java
    // 工具类
    @Entity  // 这个注解，表示是 jpa 使用的工具类
    @Data
    @AllArgsConstructor   // 产生 有参构造函数
    @NoArgsConstructor    // 产生 无参构造函数

    // implements Serializable 实现序列化
    public class Student implements Serializable {
        // 主键
        @Id
        private Long id;

        // 数据列
        @Column
        private String name;
        @Column
        private String banji;
        @Column
        private String xingbie;
    }
    ```


- 操作数据库的示范代码
  ```java
  @Controller
  public class A {
      // 自动注入，对应 dao 中操作数据库的接口类
      @Autowired
      private Ce ce;

      @RequestMapping("/demo")
      @ResponseBody()
      public List<Student> DemoGet(){
          // 查询表中所有的数据（调用的是jpa中的方法，完成对数据库的操作）
          return ce.findAll();
      }
  }
  ```



#### 操作数据库-mybatis包
- 其他操作和mybatis中介绍的一样，但是一些配置不同（简化了mybatis的配置和使用）

- 引入需要的依赖
  ```xml
  <!-- Mybatis需要的依赖 -->
  <dependency>
      <groupId>org.mybatis.spring.boot</groupId>
      <artifactId>mybatis-spring-boot-starter</artifactId>
      <version>2.1.0</version>
  </dependency>
  <dependency>
      <groupId>tk.mybatis</groupId>
      <artifactId>mapper-spring-boot-starter</artifactId>
      <version>2.1.5</version>
  </dependency>
  <!-- 操作数据库 需要的依赖，
      mysql-connector-java 必须要这样引入，不能指定对应的版本 -->
  <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <scope>runtime</scope>
  </dependency>
  ```

- 数据库连接的配置
  - 在默认配置文件中 `application.yml` 配置上相关的连接信息
  - 在启动项目的时候，就会自动进行连接，如果连接出错，服务器就会启动不起来
  ```yml
  # 连接数据库的配置
  spring:
    datasource:
      url: jdbc:mysql://localhost:3306/test
      username: root
      password: root

    jpa:
      #自动创建|更新|验证数据库表结构
      hibernate:
        ddl-auto: update
      #设置数据库引擎为InnoDB
      database-platform: org.hibernate.dialect.MySQL5InnoDBDialect
      #打印sql语句，方便调试
      show-sql: true
  ```

- dao接口定义的示范
  - 读操作
    ```java
    // dao层操作数据库的示范代码
    @Component
    public interface Ce {
        // 读操作
        @Select("select * from student")
        public List<Student> getData();
    }
    ```
  - 辅助类（读数据需要借助辅助类进行数据的存放）
    ```java
    // 自动构建set和get方法，构建有参无参构造方法
    @Entity
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public class Student implements Serializable {
        // 这个注解表示主键
        @Id
        private Long id;

        // 这个注解表示普通列
        @Column
        private String name;
        @Column
        private String banji;
        @Column
        private String xingbie;
    }
    ```


- 主函数的扫包配置（不扫包，dao注解不起作用，要经过解析才可以）
  ```java
  // 该注解，表示需要启动一个boot
  @SpringBootApplication
  // 路径是相对于 java 文件夹的，路径写错，项目启动不了
  @MapperScan("demo/controller")
  public class DemoApplication {
      public static void main(String[] args) {
          SpringApplication.run(DemoApplication.class, args);
      }
  }
  ```


- 使用dao接口操作数据库
  ```java
  @Controller
  public class A {
      // 自动注入 dao
      @Autowired
      private Ce ce;

      @RequestMapping("/hello")
      @ResponseBody()
      public List<Student> helloGet(){
          // 使用dao方法，完成对数据库的操作
          return ce.getData();
      }
  }
  ```
  - dao定义好和辅助类定义好后，dao接口就可以直接拿来使用，完成对数据库的操作（前提是上面的配置都配置完成）
    - 不需要很复杂的准备工作（SpringBoot已经把复杂的流程做好了）




#### 操作数据库-mybatis包配合插件(tk)
- 可以简化 mybatis 的书写
  - 把一些常用的 sql 指令，封装起来，这样的话，就可以直接使用
  - 不用，每使用一条sql，就要定义一个方法
  - 和 jpa 的用法一样，也是继承一个类
- mybatis 使用了插件，也是可以自定义 sql 的

- tk.mybatis 插件
  - 该插件，在引入 mybatis 的时候，就需要引入
  - 需要的插件
    ```xml
    <!-- 都是一些基础的插件 -->
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>2.1.0</version>
    </dependency>
    <dependency>
        <groupId>tk.mybatis</groupId>
        <artifactId>mapper-spring-boot-starter</artifactId>
        <version>2.1.5</version>
    </dependency>
    <!-- 操作数据库 需要的依赖 -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    ```



- 连接数据库，看之前的介绍

具体的操作流程
- 大部分和 mybatis 自定义 sql 的用法一样
- 只有，dao层，稍微有些变化，不用自己写 sql 了
- 也需要扫包，注解名一样，但是 要注意引入的路径
  - **MapperScan要引 tk 中的**
  - 自定义sql中的 扫包，也有一个这个注解，所以不要引入错误，否则使用不了

```java
// 扫包代码

// 该注解，表示需要启动一个boot
@SpringBootApplication

// 路径是相对于 java 文件夹的，路径写错，项目启动不了
//    要注意 引入的 路径
@MapperScan("abc/controller")
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```
 
```java
// dao层操作数据库的示范代码

// 不用手写 sql ，直接继承，这样基础的 sql 操作就能实现
//    Student 要注意，是工具类(与表相对应的存放数据的类)，对应 要操作那个表，和 jpa 一样
//    这里表示操作的是 student 这张表
//    所以要注意，名称要对应上，并且存在一个 Student 类
@Component
public interface Ce extends Mapper<Student> {
    // 直接完事，内部 啥也不用写
}
```


```java
// 存放数据的类(与表相关联的类)，没有什么注解，只有增加一些基础方法的注解


@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student implements Serializable {
    private Long id;
    private String name;
    private String banji;
    private String xingbie;
}
```


```java
// 使用 dao层中的代码，操作数据库

@Controller
public class A {
    // 自动注入 dao
    @Autowired
    private Ce ce;

    @RequestMapping("/hello")
    @ResponseBody()
    public List<Student> helloGet(){
        // 直接使用 tk 提供好的方法，进行操作 
        return ce.selectAll();
    }
}

```





#### 操作数据库-mybatis包配合插件(plus)
- 可以简化 mybatis 的书写
  - 把一些常用的 sql 指令，封装起来，这样的话，就可以直接使用
  - 不用，每使用一条sql，就要定义一个方法
  - 和 jpa 的用法一样，也是继承一个类
  

引入的插件
```xml
<!-- 都是一些基础的插件 -->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.1.0</version>
</dependency>
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.2.0</version>
</dependency>
<!-- 操作数据库 需要的依赖 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
```





- 连接数据库，看之前的介绍

具体的操作流程
- 大部分和 mybatis 自定义 sql 的用法一样
- 只有，dao层，稍微有些变化，不用自己写 sql 了
- 也需要扫包，注解名一样，但是 要注意引入的路径
  - **MapperScan要引 mybatis 中的，不是 tk中的，与 tk 区分开**

```java
// 扫包代码

// 该注解，表示需要启动一个boot
@SpringBootApplication

// 路径是相对于 java 文件夹的，路径写错，项目启动不了
//    要注意 引入的 路径
@MapperScan("abc/controller")
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```
 
```java
// dao层操作数据库的示范代码

// 不用手写 sql ，直接继承，这样基础的 sql 操作就能实现
//    Student 要注意，是工具类(与表相对应的存放数据的类)，对应 要操作那个表，和 jpa 一样
//    这里表示操作的是 student 这张表
//    所以要注意，名称要对应上，并且存在一个 Student 类
@Component
public interface Ce extends BaseMapper<Student> {
    // 直接完事，内部 啥也不用写
}
```


```java
// 存放数据的类(与表相关联的类)
//    没有什么注解，只有增加一些基础方法的注解


@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student implements Serializable {
    private Long id;
    private String name;
    private String banji;
    private String xingbie;
}
```


```java
// 使用 dao层中的代码，操作数据库

@Controller
public class A {
    // 自动注入 dao
    @Autowired
    private Ce ce;

    @RequestMapping("/hello")
    @ResponseBody()
    public List<Student> helloGet(){
        // 直接使用 plus 提供好的方法，进行操作 
        return ce.selectList(null);
    }
}

```





#### 操作数据库-开启事务
- 操作数据库，为了安全性，可以开启事务
  - 比如
    - 前面修改或者增加数据
    - 后面代码执行，报错，并没有给 客户端正确的响应
    - 如果，此时，数据库已经进行了修改，就有可能造成信息的不正确性
  - 如果，不开启事务，操作数据库的代码执行完成，数据库就立马发生了变化，根本不管后续的代码是否正常执行
  - 开启事务
    - 只有当整个函数执行完成，没有报错，才会真正的提交事务，修改数据库
    - 如果发生错误，就不进行事务的提交，数据库自然不会发生变化

.
- ssm整合也介绍了事务的开启，但是那个过程过于麻烦（需要配置很多东西）
- SpringBoot中集成了事务的开启操作，只需要加个注解`@Transactional`就可以实现，不需要过多的操作
  - 通常把这个注解，加在 `controller` 的函数的前面
  - 因为，只要 `controller` 函数执行完，就意味着后端业务处理结束，并且代码没有发生错误，可以给予客户端正常的响应
  - 此时，就可以进行事务的提交，修改数据库了

.
- 示范代码
  ```java
  @Controller
  public class A {
      // 获取数据
      @Autowired
      private Ce ce;

      @RequestMapping("/hello")
      // 开启事务
      @Transactional
      @ResponseBody()
      public List<Student> helloGet(){
          // 操作数据库
          List<Student> list = ce.getData();
          // 手动发出一个错误
          int a = 12 / 0;
          return list;
      }
  }
  // 由于发生了错误，并且开启了事物，所以数据库不会发生变化
  ```







#### 操作数据库-连接多个数据库

- 一个数据源，就相当于一个数据库，内部有很多表格
- 但是，一个项目可能有多个数据源
- 这样的话，默认配置文件`application.yml`，连接数据库的配置，就需要，进行一定的修改


连接多个数据库（多个数据源）的操作如下
```yml
spring:
  datasource:
    # 第一个数据源  test
    db1:
      jdbc-url: jdbc:mysql://localhost:3306/test
      username: root
      password: root123456
    # 第二个数据源  test_1
    db2:
      jdbc-url: jdbc:mysql://localhost:3306/test_1
      username: root
      password: root123456
```
- 由于，配置文件连接数据库的配置进行了修改
  - 但是，这种修改，springBoot 不会自动识别，所以也就不会自动连接数据库
  - 此时，就需要手动，创建一个类，进行数据库的连接
    - 然后，利用该类，操作该数据库
    - 因为，一个类，对应一个数据源，所以使用该类，只能操作对应的数据源
    - 其他的数据源，定义其他的连接类，然后使用该类进行操作
    - **这样，使用不同数据库，对应的连接类，就能操作不同的数据库**

- **扫包，是在创建连接的时候，进行扫包，主函数不用进行扫包**


连接类
- @MapperScan(basePackages = "abc/controller")
  - 指定那个文件夹下的代码，使用的是该数据源中的表格
  - 操作表，直接写的是表的名字，无法分清是那个数据源下的，所以全靠该方式
```java
@Configuration
public class LianJie {
    // 连接第一个数据库
    @Bean(name="db1")  // 对象名字，便于自动注入
    @ConfigurationProperties("spring.datasource.db1")  // 配置文件中，对应数据库的配置
    public DataSource datasource(){
        return DataSourceBuilder.create().build();
    }

    // 连接第二个数据库
    @Bean(name="db2") // 对象名字，便于自动注入
    @ConfigurationProperties("spring.datasource.db2") // 配置文件中，对应数据库的配置
    public DataSource datasource_2(){
        return DataSourceBuilder.create().build();
    }
}

// test 的 连接类（此处进行扫包）

@Configuration
// basePackages 就是 要扫包的路径
//    只要是使用到该数据库的，都要扫到
// sqlSessionFactoryRef
//    是下面函数的名字
@MapperScan(basePackages = "abc/controller_1", sqlSessionFactoryRef = "sqlSessionFactory1")
public class LianJie_1 {

    @Autowired
    // 自动注入，上面创建的对应操作数据库的对象
    @Qualifier("db1")  // db1就是上面设置的名字
    private DataSource dataSource;

    @Bean
    public SqlSessionFactory sqlSessionFactory1() throws Exception {
        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
        factoryBean.setDataSource(dataSource);
        return factoryBean.getObject();
    }

    @Bean
    public SqlSessionTemplate sqlSessionTemplate1() throws Exception {
        SqlSessionTemplate template = new SqlSessionTemplate(sqlSessionFactory1());
        return template;
    }
}





// test_1 的 连接类（此处进行扫包）
@Configuration
// basePackages 就是 要扫包的路径
//    只要是使用到该数据库的，都要扫到
// sqlSessionFactoryRef
//    是下面函数的名字
@MapperScan(basePackages = "abc/controller_2", sqlSessionFactoryRef = "sqlSessionFactory1")
public class LianJie_2 {

    @Autowired
    // 自动注入，上面创建的对应操作数据库的对象
    @Qualifier("db2")  // db1就是上面设置的名字
    private DataSource dataSource;

    @Bean
    public SqlSessionFactory sqlSessionFactory1() throws Exception {
        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
        factoryBean.setDataSource(dataSource);
        return factoryBean.getObject();
    }

    @Bean
    public SqlSessionTemplate sqlSessionTemplate1() throws Exception {
        SqlSessionTemplate template = new SqlSessionTemplate(sqlSessionFactory1());
        return template;
    }
}

// 其他的都一样，就是名字不一样
```

- 只是创建，对应的类，然后交给 Spring 管理。
  - 其他地方（dao）不需要引入（LianXi_1，LianXi_2），扫包的时候，已经对应上了



- 其他的都一样，但是操作数据库的 dao 层，必须使用自定义 sql，不能使用之前的两个依赖
```java
@Component
public interface Ce {
    // 该文件位于 controller_1，所以操作的是 test 中的 student 表格 (由上面的扫包决定)
    @Select("select * from student")
    public List<Student> getData();
}
```






#### 自定义事件(回调)
- 采用的是 发布订阅者模式
  - 先写好订阅器订阅事件
  - 当使用发布器发布事件的时候
    - 就会遍历得到所有，订阅该事件的订阅器
    - 然后挨个执行
    - **所以，一个事件可以多次订阅，然后发布的时候会依次执行**
- 其中，订阅事件的方式有四种

> 创建自定义事件
```java
// 自定义事件
public class EventCall extends ApplicationEvent {
    public EventCall(Object source) {
        super(source);
    }

    // 重写该方法，订阅器执行的就是该方法
    public void printMessage(String msg) {
        System.out.println("自定义事件，打印信息：" + msg);
    }
}
```


> 发布事件
```java
@Controller
public class Demo {
    // 自动注入自定义事件的事件发布器，用来发布事件
    @Autowired
    private ApplicationEventPublisher publisher;

    @RequestMapping("/demo")
    @ResponseBody
    public String getDemo() {
        // 发布 EventCall 事件，这样所有订阅该事件的订阅器，就会立即执行
        publisher.publishEvent(new EventCall(this));

        System.out.println("ok");
        return "abc";
    }
}
```



> 订阅自定义事件--方式一（主函数注入订阅器）
```java
// 订阅一个事件
//   ApplicationListener<EventCall> 表示订阅 一个事件
//       EventCall 为订阅的事件
public class Event_1 implements ApplicationListener<EventCall> {
    // 当使用发布器，发布 EventCall后 (所订阅的事件)，该方法就会执行
    //    从而执行发布的事件
    //    什么时候发布什么时候执行
    @Override
    public void onApplicationEvent(EventCall event) {
        // 执行事件的 printMessage 方法
        event.printMessage("CustomListener1监听到了");
    }
}


// 主函数
// 该注解，表示需要启动一个boot
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(DemoApplication.class, args);
        // 注入创建的订阅器
        context.addApplicationListener(new Event_1());
    }
}
```



> 订阅自定义事件--方式二（采用注解的方式注入订阅器）
- 加上一个 @Component 注解就OK
```java
// 订阅一个事件
//   ApplicationListener<EventCall> 表示订阅 一个事件
//       EventCall 为订阅的事件
@Component
public class Event_2  implements ApplicationListener<EventCall> {
    @Override
    public void onApplicationEvent(EventCall event) {
        event.printMessage("CustomListener2监听到了");
    }
}
```




> 订阅自定义事件--方式三（采用注解的方式注入订阅器，并且不再继承）
```java
// 订阅一个事件
//   ApplicationListener<EventCall> 表示订阅 一个事件
//       EventCall 为订阅的事件
@Component
public class Event_3 {
    // 这个注解就表示，订阅器触发的时候，执行的函数
    //    不再是继承重写了，可以实现自定义
    @EventListener
    public void demo(EventCall event){
        event.printMessage("CustomListener3监听到了");
    }
}
```




> 订阅自定义事件--方式四（通过配置文件中的配置，进行注入）
```java
// 必须采用继承的方式，否则启动不了
public class Event_4 implements ApplicationListener<EventCall> {
    @Override
    public void onApplicationEvent(EventCall event) {
        event.printMessage("CustomListener4监听到了");
    }
}
```

- 配置文件
```yml
server:
  port: 8090

# 订阅器的路径
context:
  listener:
    classes: abc.controller.Event_4
```


- **如果一个事件，同时使用了上面四种方式进行了订阅，则四个的触发先后顺序为 4、3、2、1**




#### web容器(开发接口)
- 依赖的引入
```xml
<dependencies>
    <!--这个要注释掉，不能共存-->
<!--        <dependency>-->
<!--            <groupId>org.springframework.boot</groupId>-->
<!--            <artifactId>spring-boot-starter-web</artifactId>-->
<!--            <exclusions>-->
<!--                <exclusion>-->
<!--                    <groupId>org.springframework.boot</groupId>-->
<!--                    <artifactId>spring-boot-starter-tomcat</artifactId>-->
<!--                </exclusion>-->
<!--            </exclusions>-->
<!--        </dependency>-->

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jetty</artifactId>
    </dependency>
   <!-- 引入依赖 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>

</dependencies>

```


- 接口的创建
```java
// 这三个依赖的引入要注意，快捷键引入不了
import static org.springframework.web.reactive.function.server.RequestPredicates.GET;
import static org.springframework.web.reactive.function.server.RouterFunctions.route;
import static org.springframework.web.reactive.function.server.ServerResponse.ok;

@Controller
public class Demo_2 {
    // 创建 /demos 接口
    @Bean
    public RouterFunction<ServerResponse> a(){
        return route(GET("/demos"),
                request -> ok().body(Mono.just( new D() ), D.class));
    }

    // 创建 /hello 接口
    @Bean
    public RouterFunction<ServerResponse> B(){
        return route(GET("/hello"),
                request -> ok().body(Mono.just( "hello" ), String.class));
    }
}
```






#### 过滤器
> - 注意，上一章介绍的响应式接口，无法使用过滤器
- 方式一，使用注解注入过滤器
```java
import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import java.io.IOException;

// urlPatterns 设置的是 过滤请求的路径
@WebFilter(filterName = "filter_1",urlPatterns = {"/*"})
public class Filter_1 implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("初始化");
    }

    @Override
    public void destroy() {
        System.out.println("销毁，服务器停止的时候");
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("过滤请求");
        // 符合条件的，执行下面的放行操作
        filterChain.doFilter(servletRequest, servletResponse);
    }
}



@SpringBootApplication
// 需要在主函数上，加上该注解，才能扫描filter注解
@ServletComponentScan
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

- 方式二，借助一个类，注入过滤器
  - 主函数上不用加扫包注解 @ServletComponentScan
```java
// 过滤器 Filter_1 如上

// 设置一个配置类
@Configuration
public class Filter_config {
    @Bean
    public FilterRegistrationBean<Filter_1> filterRegistrationBean(){
        // 创建过滤
        FilterRegistrationBean<Filter_1> filterFilterRegistrationBean=
                new FilterRegistrationBean<>();
        // 加入过滤器处理对象
        filterFilterRegistrationBean.setFilter(new Filter_1());
        // 设置拦截的路径
        filterFilterRegistrationBean.addUrlPatterns("/*");
//        filterFilterRegistrationBean.setOrder(0); //决定注册的优先级
        return filterFilterRegistrationBean;
    }
}
```



#### 拦截器
- 先通过过滤，然后才走到拦截，进行处理

实现方式
```java
// 自定义一个拦截器
@Service
public class CustomInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("开始");
        // 放行
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {
        System.out.println("放行后，controller执行完成后，执行的代码");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {
        System.out.println("最后执行的代码（响应的时候）");
    }
}


// 注册拦截器，并确定拦截的路径

@Configuration
public class InterceptorConfig implements WebMvcConfigurer {

    // 获取创建的自定义拦截器对象
    @Autowired
    private CustomInterceptor customInterceptor;

    /**
     * 注册自定义的拦截器，并且定义拦截规则
     * @param registry
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 配置拦截的请求
        registry.addInterceptor(customInterceptor).addPathPatterns("/**");
    }
}
```




#### 校验对象中存入的数据是否合理
- 利用 Hibernate Validator 进行检查
  - JSR-303 是JAVA EE 6 中的一项子规范，叫做Bean Validation，Hibernate Validator 是 Bean Validation 的参考实现 . Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint

.
- 原生的方式，验证一个对象中的数据是否合理（符合规则）
- 验证规则，在类中定义好
    ```java
    import lombok.AllArgsConstructor;
    import lombok.Data;
    import javax.validation.constraints.NotBlank;
    @Data @AllArgsConstructor
    public class Guest {
        // message，自定义，得到的错误信息
        @NotBlank(message = "不能为空")
        private String name;
        // 如果没有自定义错误信息，使用的是默认的
        @NotBlank
        private String role;
    }
    ```

- 完全验证（可以得到所有的不符合规则的验证信息）
  - Validator 这个包容易引错，要注意
  ```java
    import javax.validation.ConstraintViolation;
    import javax.validation.Validation;
    import javax.validation.Validator;
    import java.util.Set;

    public class Demo {
        public static void main(String[] args) {
            // 创建验证工具
            Validator validator = (Validator) Validation.buildDefaultValidatorFactory().getValidator();

            //创建一个不符合要求的bean
            Guest guest = new Guest("", "");
            
            //开始验证，接收验证结果
            Set<ConstraintViolation<Guest>> violationSet = validator.validate(guest);
            for (ConstraintViolation violation : violationSet) {
                // 获取产生错误信息的对象属性
                String prop = violation.getPropertyPath();
                // 获取错误信息
                String value = violation.getMessage();

                System.out.println( prop + "," + value );
            }
        }
    }
  ```

- 快速验证（只要有一个不符合，就退出验证，返回验证信息）
  - Validator 这个包容易引错，要注意
  ```java
    import javax.validation.ConstraintViolation;
    import javax.validation.Validation;
    import javax.validation.Validator;
    import java.util.Set;

    public class Demo {
        public static void main(String[] args) {
            //创建一个快速失败模式的实例
            Validator validatorFastFail = (Validator) Validation.byDefaultProvider().configure()
                    .addProperty("hibernate.validator.fail_fast", "true").
                            buildValidatorFactory().getValidator();

            //创建一个不符合要求的bean
            Guest guest = new Guest("", "");

            //开始验证，接收验证结果
            Set<ConstraintViolation<Guest>> violationFastFailSet = validatorFastFail.validate(guest);
            for (ConstraintViolation violation : violationFastFailSet) {
                // 获取产生错误信息的对象属性
                String prop = violation.getPropertyPath();
                // 获取错误信息
                String value = violation.getMessage();

                System.out.println( prop + "," + value );
            }
        }
    }
  ```


.
- controller中验证（验证接口传入的数据是否合理）
- 很好配置，只需要使用一个注解，就可以自动进行验证
- 验证结果，会作为最后一个参数传进来
  - **如果没有接收最后一个参数，如果验证不通过，则相应错误集合，状态码为400**
  - **验证方式，为全部验证**

- 验证规则，在类中定义好
  ```java
    import lombok.AllArgsConstructor;
    import lombok.Data;
    import javax.validation.constraints.NotBlank;
    @Data @AllArgsConstructor
    public class Guest {
        // message，自定义，得到的错误信息
        @NotBlank(message = "不能为空")
        private String name;
        // 如果没有自定义错误信息，使用的是默认的
        @NotBlank
        private String role;
    }
  ```

- controller 中的示范代码
  ```java
    @Controller
    public class Demo {
        @RequestMapping("/demo")
        @ResponseBody
        // result 接收的就是验证错误的信息集合
        // 在对象前，加一个 @Valid 注解，表示对该对象进行验证
        public String getDemo(@Valid Guest guest, BindingResult result){
            // 如果错误信息存在，则处理错误信息
            if(result.getErrorCount() > 0){
                List<FieldError> fieldErrorList = result.getFieldErrors();
                StringBuffer stringBuffer = new StringBuffer();
                for(FieldError fieldError : fieldErrorList){
                    // 获取没有通过验证的属性名
                    String name = fieldError.getField();
                    // 获取错误信息
                    String value = fieldError.getDefaultMessage();
                    System.out.println(name + "--" + value);
                }
                return "属性错误";
            }

            return "全部验证正确";
        }
    }
  ```


**通常，把自定义错误信息，放在默认配置文件中，便于管理**
  - 获取方式
  ```java
    @Data @AllArgsConstructor
    public class Guest {
        // 自动注入配置文件中的对应数据
        @NotBlank(message = "{guest.name.notblank}")
        private String name;
        @NotBlank
        private String role;
    }
  ```




#### 指派错误页(比如404页面)
- 一共有四种方式
  - 一二种，自动读取对应的错误页面进行响应（简单）
  - 三四种，写对应的java拦截，指派对应的错误页面（灵活强大）

- 第二、第三、第四种方式，是把错误页面，放在templates下，所以需要使用模版引擎 thymeleaf，否则不起作用
  ```xml
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-thymeleaf</artifactId>
    </dependency>
  ```

.
- 第一种
- 在 resources 下的 public 下的 error 中，建立对应的错误页面。
  - 比如: 404.html
  - 比如: 4xx.html
  - 当监听到 404 的状态码，响应 404.html
  - 如果没有找到 404.html，则响应 4xx.html
    - 即：具体的比广泛的级别高，如果没有具体的在使用广泛的


.
- 第二种
- 在 resources 下的 templates 下的 error 中，建立对应的错误页面。
  - 比如: 404.html
  - 比如: 4xx.html
  - 当监听到 404 的状态码，响应 404.html
  - 如果没有找到 404.html，则响应 4xx.html
    - 即：具体的比广泛的级别高，如果没有具体的在使用广泛的
- template 中的错误页，可以动态插入一些数据，比如错误信息
  - public 中的页面文件是做不到的
  ```html
    <!DOCTYPE html>
        <html lang="en" xmlns:th="http://www.thymeleaf.org">
        <head>
            <meta charset="UTF-8">
            <title>404</title>
        </head>
        <body>
            <!-- 动态插入数据 -->
            <p th:text="${timestamp}">timestamp </p>
            <p th:text="${status}">status </p>
            <p th:text="${message}">message </p>
        </body>
    </html>
  ```

.
- 第三种
- 自定义拦截器，如果发现错误的状态码，进行一些处理
  - 200 的时候，是不进行触发的
  - 如果发生错误，但是没有进行转发处理，也就是返回了null，**会继续走默认的指派**
    - 比如下面，只拦截了 404，没有拦截 400
    - 如果状态码为 400 的时候，就使用默认的指派，查找 400.html 或者 4xx.html

  ```java
    /**
      * 重要：需要是一个bean  能够被spring容器处理  才会生效
      * 所以要加上@Component注解
      */
    @Component
    public class MyErrorViewResolver implements ErrorViewResolver {

        @Override
        public ModelAndView resolveErrorView(HttpServletRequest request,
                                            HttpStatus status,
                                            Map<String, Object> model) {
            // 拦截 404 请求
            if(status.equals(HttpStatus.NOT_FOUND)){
                ModelAndView modelAndView = new ModelAndView();
                // 转发到对应的错误页
                modelAndView.setViewName("/resolver404");
                // 注入一些数据
                modelAndView.addObject("message", "自定义数据");
                return modelAndView;
            }

            return null;
        }
    }
  ```
- 由于，使用的是 modelAndView，可以存放一些数据
  - 所以错误页，存放在 resources 下的 templates 中
  ```html
    <!DOCTYPE html>
    <html lang="en" xmlns:th="http://www.thymeleaf.org">
    <head>
        <meta charset="UTF-8">
        <title>ERROR</title>
    </head>
    <body>

        <!-- 获取注入的错误信息 -->
        <p th:text="${message}">message</p>

    </body>
    </html>
  ```

.
- 第四种
- 创建一个拦截器，转发到一个 controller 接口，然后再由 controller 中对应的接口，转发到错误页
  ```java
    @Configuration
    public class MyCustomizer {
        @Bean
        public WebServerFactoryCustomizer<ConfigurableWebServerFactory> customizer() {
            return new WebServerFactoryCustomizer<ConfigurableWebServerFactory>() {
                @Override
                public void customize(ConfigurableWebServerFactory factory) {
                    ErrorPage errorPage = new ErrorPage(HttpStatus.NOT_FOUND, "/error404");
                    factory.addErrorPages(errorPage);
                }
            };
        }
    }
  ```
- 对应的 controller 接口
  ```java
    @Controller
    public class ErrorCon {
        @RequestMapping("/error404")
        public String error404(){
            return "error404";
        }
    }
  ```
- 对应的错误页
  - 由于是controller转发，所以可以更加灵活的处理，存放一些数据
  - 所以错误页，存放在 resources 下的 templates 中
  ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
        错误页面
    </body>
    </html>
  ```



#### 全局错误处理
- 核心，利用切面的概念，写一个拦截器，最终所有的错误，都会被该拦截器拦截，进行错误的处理

- 具体的示范代码
```java
@ControllerAdvice
public class MyExceptionHandler {
    // 根据注解中指定的类，拦截对应的错误
    @ExceptionHandler(Exception.class)

    public ModelAndView handler(Exception e){
        // 对错误进行一些处理，比如转发，这样请求就会恢复正常
        ModelAndView mv = new ModelAndView();
        mv.setViewName("/errorCon");
        mv.addObject("message", e.getMessage());
        return mv;
    }
}
```




#### 修改静态资源服务器读取的路径
- 默认读取的是 resources 下的 static 文件夹中的内容
- 要想修改默认读取位置，换成一个绝对路径，需要借助下面的类
```java
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;

@Configuration
public class FileStaticConfig extends WebMvcConfigurerAdapter {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        /**
         *  /statics/xxx   指文件的访问方式  如：localhost:8080/statics/demo
         *  file:/root/java_demo/statics/  指静态文件存放在服务器上的位置
         */
        registry.addResourceHandler("/imgs/**").addResourceLocations("file:"+"/root/java_demo/images/");
        registry.addResourceHandler("/statics/**").addResourceLocations("file:"+"/root/java_demo/statics/");
    }
}
```
- 此时
  - 带有 statics/ 的静态请求，就会从 /root/java_demo/statics/ 中读取相应的文件，然后返回
  - 带有 imgs/ 的静态请求，就会从 /root/java_demo/images/ 中读取相应的文件，然后返回





#### 常见错误-启动后报错
- 主函数不能直接位于java文件夹下，否则启动的时候会报错
- 如果想要使用配置文件（resources下的配置文件，比如连接数据库）
  - resources文件夹的类型设置为resources root就可以正常启动项目了
  - 否则会出现错误，导致项目启动失败
    - 错误为：`Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.`
