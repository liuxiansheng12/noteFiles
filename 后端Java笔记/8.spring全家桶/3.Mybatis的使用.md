<script src='/笔记/see/index.js'></script>
[toc]


#### 准备工作-需要的jar包
```xml
<!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.3</version>
</dependency>
<!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.21</version>
</dependency>
```


#### 准备工作-核心配置文件（配置文件开发）
- 如果是借助maven开发，配置文件必须位于 resources 下面

- 示范核心配置文件的配置
    ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
    <configuration>
        <environments default="development">
            <!-- 连接数据库（连接的是test这个包） -->
            <environment id="development">
                <transactionManager type="JDBC"></transactionManager>
                <dataSource type="POOLED">
                    <property name="driver" value="com.mysql.jdbc.Driver"></property>
                    <property name="url" value="jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8"></property>
                    <property name="username" value="root"></property>
                    <property name="password" value="root"></property>
                </dataSource>
            </environment>
        </environments>

        <!-- 引入对应的sql指令的配置文件 -->
        <mappers>
            <mapper resource="mapper/StudentMapper.xml"></mapper>
        </mappers>
    </configuration>
    ```



#### 准备工作-核心配置文件（注解开发）
- 如果是借助maven开发，配置文件必须位于 resources 下面

- 示范核心配置文件的配置
    ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
    <configuration>
        <environments default="development">
            <!-- 连接数据库（连接的是test这个包） -->
            <environment id="development">
                <transactionManager type="JDBC"></transactionManager>
                <dataSource type="POOLED">
                    <property name="driver" value="com.mysql.jdbc.Driver"></property>
                    <property name="url" value="jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8"></property>
                    <property name="username" value="root"></property>
                    <property name="password" value="root"></property>
                </dataSource>
            </environment>
        </environments>

        <!-- 引入所有带有注解操作数据库的接口类，如果这个地方不引入，则使用注解操作数据库的时候就会报错 -->
        <!-- 报错信息：Type interface dao.StudentDao is not known to the MapperRegistry. -->
        <mappers>
            <mapper class="dao.StudentDao"></mapper>
        </mappers>
    </configuration>
    ```



#### 准备工作-核心配置文件中引入参数配置文件
- 可以把一些容易变化的数据，单独提出来，放在一个参数文件中。这样后期如果发生变化，比较容易改（就不用动核心配置文件了）
- 比如：数据库的密码、账号，这一类的东西就可以放在参数文件中
- 示范配置（核心配置文件中的内容）
  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
  <configuration>
      <!-- 引入对应配置文件 -->
      <properties resource="database_config.properties"></properties>

      <environments default="development">
          <environment id="development">
              <transactionManager type="JDBC"/>
              <dataSource type="POOLED">
                  <!-- 使用配置文件中配置的参数 -->
                  <property name="driver" value="${driver}"/>
                  <property name="url" value="${url}"/>
                  <property name="username" value="${username}"/>
                  <property name="password" value="${password}"/>
              </dataSource>
          </environment>
      </environments>
      
      <mappers>
          <mapper resource="mapper/StudentMapper.xml"/>
      </mappers>
  </configuration>
  ```
- 参数配置文件中的配置（database_config.properties）
  ```java
  driver=com.mysql.jdbc.Driver
  url=jdbc:mysql://localhost:3306/testmybatis?useSSL=false
  username=root
  password=root
  ```



#### 准备工作-sql指令配置文件（配置文件开发，示范）
- 如果是借助maven开发，配置文件必须位于 resources 下面
- 示范配置
    ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    <!-- namespace 通常是包名加类名便于维护 -->
    <mapper namespace="a">
        <!-- 通过id，可以使用该sql指令，进行数据库对应的操作（新增数据） -->
        <insert id="insert">
            insert into cs values(7);
        </insert>
    </mapper>
    ```

#### 准备工作-创建一个连接数据库工厂（配置文件开发）
- 通过核心配置文件，创建一个连接对应数据库的工厂
- 通过该工厂，然后使用sql指令配置文件中配置的指令，就可以实现对数据库的操作
- 如果利用的是SM整合，则Mybatis-Spring中提供了一个类，然后Spring利用该类就可以通过配置文件创建出一个工厂，安全方便
  - 具体看SSM整合

- 示范代码
    ```java
    import org.apache.ibatis.session.SqlSession;
    import org.apache.ibatis.session.SqlSessionFactory;
    import org.apache.ibatis.session.SqlSessionFactoryBuilder;
    import java.io.InputStream;

    public class Connect {
        // 封装一个连接函数（工厂）
        public static SqlSession connect() {
            //创建工人对象
            SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
            // 读取配置文件，创建操作数据库的对象（核心配置文件）
            InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("mybatis-config.xml");
            // 然后，工人利用配置文件中的配置信息，创建出一个操作数据库的工人
            SqlSessionFactory factory = builder.build(inputStream);

            // 开启一个连接（工人创建一个连接数据库的通道，别人就可以通过这个通道操作数据库了，可以多开几个通道）
            // true为自动开启事务，自动提交， 默认false，自动开启事务，不提交
            SqlSession sqlSession = ((SqlSessionFactory) factory).openSession(true);

            return sqlSession;
        }
    }
    ```

#### 准备工作-创建一个连接数据库工厂（注解开发）
- 通过核心配置文件，创建一个连接对应数据库的工厂
- 通过该工厂，就可以利用对应方法上面配置的注解，实现对数据库的操作
- 如果利用的是SM整合，则Mybatis-Spring中提供了一个类，然后Spring利用该类就可以通过配置文件创建出一个工厂，安全方便
  - 具体看SSM整合

- 示范代码
    ```java
    public class Connect {
        public static SqlSession sqlSession;
        // 创建连接
        static {
            //创建工人对象
            SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
            // 读取配置文件，创建操作数据库的对象（核心配置文件）
            InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("mybatis-config.xml");
            // 然后，工人利用配置文件中的配置信息，创建出一个操作数据库的工人
            SqlSessionFactory factory = builder.build(inputStream);

            // 开启一个连接（工人创建一个连接数据库的通道，别人就可以通过这个通道操作数据库了，可以多开几个通道）
            // true为自动开启事务，自动提交， 默认false，自动开启事务，不提交
            sqlSession = ((SqlSessionFactory) factory).openSession(true);
        }
        // 获取创建代理的方法，由于传递的接口类不确定，所以使用范型
        //    传递那个接口类，返回值就是那个接口类的类型
        // 利用这个函数，加工一下带有注解操作数据库的类，则内部的操作数据库的方法，就能被加工成真正的操作数据库的方法
        public static <T>T getMapper(Class<T> clazz) {
            return sqlSession.getMapper(clazz);
        }
    }
    ```


#### 准备工作-手动进行事务的提交
- 上面介绍，创建工厂的时候，最后使用 openSession 创建一个连接的时候，可以传入一个boolean值
  - true：开启事务，自动提交
  - false：开启事务，不自动提交，也是默认值
- 如果设置成false，则操作完数据库，如果不进行手动提交，数据库是不会发生变化的，也就是无效操作
- 手动提交的方式（示范代码）
    ```java
    public class Main {
        public static void main(String[] args) {
            // 获取连接
            SqlSession sqlSession = Connect.connect();
            // 操作数据库
            sqlSession.insert("insert");
            
            // 提交事务
            sqlSession.commit();
        }
    }
    ```

- 这样，前面就可以进行很复杂的数据库操作（比如多次修改数据库，但是这多次修改都是相关联的，如果某个失败，之前的操作也不能成功）
  - 这种情况，如果使用的是true，由于之前的操作是成功的，所以数据已经发送变化了，这样就造成了数据不同步
  - 这种情况，就需要设置成false，最后统一进行事务提交，完成对数据库的修改
    - 如果中间发生了错误，则代码执行不到事务的提交位置，即数据库数据没有发生变化
  - 但是使用false，也有小缺陷，万一最后忘记对事务的提交，就很尴尬了
  - **SSM整合，利用AOP，完美解决了这种情况**，具体看SSM整合中的介绍



#### 配置文件开发-使用配置的sql指令（示范）
```java
public class Main {
    public static void main(String[] args) {
        // 使用封装的工厂，获取一个连接
        SqlSession sqlSession = Connect.connect();
        // 操作数据库，insert 就是sql配置文件中配置的对应sql的id
        sqlSession.insert("insert");
        // 如果重名，可以带上父级的namespace，比如
        // sqlSession.insert("a.insert");
    }
}
```

#### 配置文件开发-实现Sql指令的数据注入
- 利用一个对象，进行注入
- 执行操作数据库的方法，传入对应的对象就可以了，如果对象中有该属性，则就会把对应的数据进行注入
- Mybatis中提供了两种，相当于 ? 功能的东西，一种是 #{}、一种是 ${} 
  - #{} 和 ${} 的区别
    - #{} 底层会进行类型判断，如果是字符串类型的，就自动在两侧拼接一个 ''，防止sql注入
    - ${} 底层是直接进行替换，可以用来传递一些sql指令
    
- 比如（示范代码）
  - sql指令配置文件中的配置（获取注入的数据）
    ```xml
    <!-- 通过id，可以使用该sql指令，进行数据库对应的操作（新增数据） -->
    <insert id="insert">
        insert into lx values(#{id});
    </insert>
    ```
  - 使用sql配置中的sql指令，进行数据注入，完成对数据的操作
    ```java
    // Student类
    public class Student {
        public int id;

        public void setId(int id) {
            this.id = id;
        }
    }

    // 使用（sql数据的注入）
    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();
            
            // 创建一个用于注入数据的对象
            Demos demos = new Demos();
            demos.setId(9);

            // 把对象传进去，进行数据的注入（id的注入）
            sqlSession.insert("a.insert", demos);
        }
    }
    ```
- 如果没有找到对应属性，或者对应属性没有值，则注入空（NULL）

.
- 注意点：
  - 如果使用 #{}。如果是字符串，就不用手动在 sql指令上加 ''，因为解析的时候会自动添加。
    - 如果加了反而会报错
    - 比如：`insert into demo values(null,'#{name}',#{ages},#{time});`
    - 会报出：Parameter index out of range (3 > number of parameters, which is 2). 的错误
      - 意思是：注入了三个数据，但是只有两个，因为有一个加了 ''，就打破了规则
      - 所以，就报出多了一个数据的错误
  - 如果使用的是 ${}，因为这个东西会直接替换，不会进行解析，所以必须加 ''。

.
- 借助 ${} 可以注入一些 sql 指令
  - 因为 ${} 不会进行解析，会直接替换
  - 比如：`insert ${a} ${b} ${c}(3);`
    - 如果注入的数据是 `{a: into, b: demo, c: values}`
    - 最终替换完，sql指令就是：insert into demo values(3)
    - 这样替换完，就是一个正常的sql指令。

.
- 如果只注入一个数据比如id、name、age。可以不借助对象，直接传入普通的数据
  - 因为：Sql命令中只有一条数据注入，所以可以不用找映射，直接使用传入的值
  - 如果传入的是对象，就会根据映射查找数据



#### 配置文件开发-主键自增如何新增数据
- 主键自增，数据不用给，赋值为null，就可以
- 比如
  - sql指令配置
    ```xml
    <insert id="insert">
        insert into demo values(null, #{name}, #{age}, #{time});
    </insert>
    ```




#### 配置文件开发-读数据（获取一条数据，单表查询）
- 建立一个与数据表对应的类，属性和属性类型与表的列相同。
  - 这样读取的时候，把类传入，就会自动创建一个对象，或者对象集合。然后把对应的列数据填充为属性数据。
  - 然后把对象或者对象集合抛出，这样就获取到了表中的数据

- 示范代码
  - sql配置文件中sql指令的配置
    ```xml
    <mapper namespace="demo">
        <!-- 查询单条数据，获取所有列 -->
        <select id="selectOne_1" resultType="domain.Demos">
            select * from demo where id = 3;
        </select>

        <!-- 获取指定的列，传入下面自定义的映射规则，然后就把数据存进去，只存映射规则指定的数据，并且按照指定的映射规则存 -->
        <select id="selectOne_2" resultMap="selectPerson">
            select * from demo where id = 3;
        </select>
        <!-- 自定义的映射规则 -->
        <resultMap id="selectPerson" type="domain.Demos">
            <!-- id标签，通常用来映射主键，映射其他的也可以 -->
            <!-- property表示类名，column表示映射的列名 -->
            <id property="id" column="id"></id>
            <result property="name" column="name"></result>
            <result property="age" column="age"></result>
            <result property="age_zdy" column="age"></result>
        </resultMap>
    </mapper>
    ```

  - 使用配置的sql指令，读取数据
    ```java
    // 存放数据的类
    public class Demos {
        public int id;
        public String name;
        public int age;
        public String time;
        public int age_zdy;
    }

    // 读取数据操作
    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 调用sql，获取一条数据
            Demos demos_1 = sqlSession.selectOne("demo.selectOne_1");
            System.out.println(demos_1.name);

            // 调用sql，获取一条数据，指定固定的列
            Demos demos_2 = sqlSession.selectOne("demo.selectOne_2");
            System.out.println(demos_2.age_zdy);
        }
    }
    ```



#### 配置文件开发-读数据（获取多条数据，单表查询）
- 建立一个与数据表对应的类，属性和属性类型与表的列相同。
  - 这样读取的时候，把类传入，就会自动创建一个对象，或者对象集合。然后把对应的列数据填充为属性数据。
  - 然后把对象或者对象集合抛出，这样就获取到了表中的数据

- 示范代码
  - sql配置文件中sql指令的配置
    ```xml
    <mapper namespace="demo">
        <!-- 查询单条数据，获取所有列 -->
        <select id="select_1" resultType="domain.Demos">
            select * from demo;
        </select>

        <!-- 获取指定的列，传入下面自定义的映射规则，然后就把数据存进去，只存映射规则指定的数据，并且按照指定的映射规则存 -->
        <select id="select_2" resultMap="selectPerson">
            select * from demo;
        </select>
        <!-- 自定义的映射规则 -->
        <resultMap id="selectPerson" type="domain.Demos">
            <!-- id标签，通常用来映射主键，映射其他的也可以 -->
            <!-- property表示类名，column表示映射的列名 -->
            <id property="id" column="id"></id>
            <result property="name" column="name"></result>
            <result property="age" column="age"></result>
            <result property="age_zdy" column="age"></result>
        </resultMap>
    </mapper>
    ```

  - 使用配置的sql指令，读取数据
    ```java
    // 存放数据的类
    public class Demos {
        public int id;
        public String name;
        public int age;
        public String time;
        public int age_zdy;
    }

    // 读取数据操作
    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 调用sql，获取多条数据
            List<Demos> demos_1 = sqlSession.selectList("demo.select_1");
            System.out.println(demos_1.get(0).name);

            // 调用sql，获取多条数据，指定固定的列
            List<Demos> demos_2 = sqlSession.selectList("demo.select_2");
            System.out.println(demos_2.get(0).age_zdy);
        }
    }
    ```


#### 配置文件开发-读数据（聚合查询，单表查询）
- 不需要辅助类，得到的就是一个单个数据
  - 也可以使用辅助类，里面有属性存对应的值就行（下面示例，属性为：ct），具体看下面示例

- 示范代码（直接获取）
  - sql配置文件中sql指令的配置
    ```xml
    <mapper namespace="demo">
        <!-- 得到的是单个数据 -->
        <select id="selectCount" resultType="int">
            select count(*) as ct from demo
        </select>
    </mapper>
    ```

  - 使用配置的sql指令，读取数据
    ```java
    // 读取数据操作
    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 调用sql
            int cz = sqlSession.selectOne("demo.selectCount");
            System.out.println(cz);
        }
    }
    ```


- 示范代码（用辅助类获取）
  - sql配置文件中sql指令的配置
    ```xml
    <mapper namespace="demo">
        <!-- 得到的是单个数据 -->
        <select id="selectCount" resultType="domain.Demos">
            select count(*) as ct from demo
        </select>
    </mapper>
    ```

  - 使用配置的sql指令，读取数据
    ```java
    // 存放数据的类
    public class Demos {
        public int ct;
    }

    // 读取数据操作
    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 调用sql
            Demos demos = sqlSession.selectOne("demo.selectCount");
            System.out.println(demos.ct);
        }
    }
    ```




#### 配置文件开发-读数据（获取单个数据，单表查询）
- 获取某个一列的某个一个值

- 不需要辅助类，得到的就是一个单个数据
  - 也可以使用辅助类，里面有属性存对应的值就行（下面示例，属性为：name），具体看下面示例

- 示范代码（直接获取）
  - sql配置文件中sql指令的配置
    ```xml
    <mapper namespace="demo">
        <!-- 得到的是单个数据 -->
        <select id="selectName" resultType="string">
            select name from demo where id = 4;
        </select>
    </mapper>
    ```

  - 使用配置的sql指令，读取数据
    ```java
    // 读取数据操作
    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 调用sql
            String name = sqlSession.selectOne("demo.selectName");
            System.out.println(name);
        }
    }
    ```


- 示范代码（用辅助类获取）
  - sql配置文件中sql指令的配置
    ```xml
    <mapper namespace="demo">
        <!-- 得到的是单个数据 -->
        <select id="selectName" resultType="domain.Demos">
            select name from demo where id = 4;
        </select>
    </mapper>
    ```

  - 使用配置的sql指令，读取数据
    ```java
    // 存放数据的类
    public class Demos {
        public String name;
    }

    // 读取数据操作
    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 调用sql
            Demos demos = sqlSession.selectOne("demo.selectName");
            System.out.println(demos.name);
        }
    }
    ```



#### 配置文件开发-读数据（用Map存放数据，单表查询）
- 用Map接收数据，就不用定义辅助类，接收数据了。
  - 因为列名会作为key，列值作为value
  - 既然列名作为key（可以看成字符串String），列值作为value（类型不确定，可以用Object）
    - 所以定义的时候，可以定义成`HashMap<String, Object> hashMap`
    - 其实，类型是可以随意定义的，只不过不生效，比如定义`<Integer, Object>`
      - 虽然key定义成Integet，但是存值的时候key存的还是字符串

- 优缺点
  - 优点：不用管表结构，不用定义专门的类用来接收数据
  - 缺点：丢失对应关系（不知道表中有哪些列，不知道表中有哪些数据），到时候维护的时候还要现查表结构


- 示范代码
  - sql配置文件中sql指令的配置
    ```xml
    <mapper namespace="demo">
       <!-- 要注意，类型指定为hashmap，hashmap其实是HashMap的别名，别名的定义后面会介绍 -->
       <!-- 也可以指定为具体的类路径：java.util.HashMap，但是这玩意不好记，所以就搞了个别名 -->
       <select id="selectMap" resultType="hashmap">
            select * from demo where id = 4;
        </select>
    </mapper>
    ```

  - 使用配置的sql指令，读取数据
    ```java
    // 读取数据操作
    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 调用sql
            HashMap<String, Object> hashMap = sqlSession.selectOne("demo.selectMap");
            System.out.println(hashMap.toString());
        }
    }
    ```


#### 配置文件开发-给类起别名（简化Sql配置的书写）
- 比如一个类的路径是 demo1.demo2.demo3.Demo，这个玩意过长，应用在Sql命令配置文件中，不太好写
  - 要写成 `<select id="demo" resultType="demo1.demo2.demo3.Demo">select * from demo1;</select>`
  - resultType：这个东西写起来，就有点复杂麻烦了
  - 这样，就可以给这个类起一个别名

- 起别名示范代码（在核心配置文件（mybatis-config.xml）中，进行定义）
  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">

  <configuration>
      <!-- 起的别名是 demo -->
      <typeAliases>
          <typeAlias type="demo1.demo2.demo3.Demo" alias="demo"></typeAlias>
      </typeAliases>
  </configuration>
  ```
  - 这样的话，再使用 `demo1.demo2.demo3.Demo` 的时候，就可以写成 `demo`
    - 比如：`<select id="demo" resultType="demo">select * from demo1;</select>`
    - 这样的话，就一定程度上简化了书写
  
- Mybatis中就已经提前定义好了很多类路径的别名
  - 比如：`string --> java.lang.String`
  - 在比如上面使用的 `hashmap --> java.lang.HashMap`
      




#### 配置文件开发-读数据（一对一，联合查询）
- 一个Sql完成查询

.
- 一对一，主表的一条数据，对应另一个表的一条数据。这就是一对一关系
  - 另一个表的关联键（外键）要唯一，才能保证一对一
  - 反过来可能是一对一，也可能是一对多，看关联键是否唯一

- 获取数据库数据，靠类进行存储，多表查询，其实就是外键属性，变成一个对象属性，用来存放另一个表的数据映射出来的对象（来表达一对一关系）
  - 保证一个表对应一个类

- 注意点
  - 必须手动定义映射规则，否则外键对应的那个属性，会自动赋值成null
    - 外键属性的类型如果是当前表对应列的类型，则直接赋值成当前列对应的值
    - 只有，外键属性指向另一个表对应的对象时，才会被赋值成null
  - 因为：一条语句联合查询，得到的是一张合并后的表，如果不定义映射规则，只会进行浅映射（只映射表象，如果一个属性指向的是另一个集合，这默认就办不到了）
    - 由于关联查询，最后查询出的是一个表，相当于单表查询查出来一张表进行数据映射
    - 这样是可以把关联表中的数据，存到当前类中，只要属性名和列相同，就能进行映射
  - 比如
    - sql指令配置成（没有使用自定义映射规则，则映射表就为null） 
      ```xml
      <select id="selectUnionOne" resultType="domain.Demo1">
        select * from demo1 inner join demo2 on demo1.bj = demo2.bj;
      </select>
      ```
    - 辅助类的定义：在下面示例中
    - 读表的时候，得到的就是：[{id=1, name='张三', age=18, bj=null}]
    - bj就是外键属性，但是由于没有使用自定义规则，所以直接赋值成了null



- 示范代码（一对一的正确查法）
  - sql配置文件中sql指令的配置
    ```xml
    <mapper namespace="demo">
        <!-- 因为有两个id，所以要给另一个id，起一个别名，否则映射的时候会默认取第一个id -->
        <select id="selectUnionOne" resultMap="selectPerson">
            select *, demo2.id as ids from demo1 inner join demo2 on demo1.bj = demo2.bj;
        </select>
        <!-- 自定义映射规则（一对一读取必须的） -->
        <resultMap id="selectPerson" type="domain.Demo1">
            <id property="id" column="id"></id>
            <result property="name" column="name"></result>
            <result property="age" column="age"></result>
            <!-- 外键属性的映射，映射成另一个表（另一个对象） -->
            <association property="bj" javaType="domain.Demo2">
                <id property="id" column="ids"></id>
                <result property="bzr" column="bzr"></result>
                <result property="age" column="age"></result>
                <result property="bj" column="bj"></result>
            </association>
        </resultMap>
    </mapper>
    ```

  - 使用配置的sql指令，读取数据
    ```java
    // 辅助类
    public class Demo1 {
        public int id;
        public String name;
        public int age;
        // 外键，存放另一个表的关联数据对象
        public Demo2 bj;
    }
    // 辅助类（关联表）
    public class Demo2 {
        public int id;
        public String bzr;
        public int age;
        public String bj;
    }

    // 读取数据操作
    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 调用sql
            List<Demo1> demo1 = sqlSession.selectList("demo.selectUnionOne");
            // 获取一条数据，用 selectOne()，单表查询中有介绍
            System.out.println(demo1.toString());
        }
    }
    ```



#### 配置文件开发-读数据（一对一，联合查询）
- 两个Sql完成查询
- 也需要自定义映射规则
- 注意点：可能会造成查询压力过大
- 原因以及原理：
  - 第一条sql先把数据都查出来
  - 然后，在一条一条的查询与之关联的数据
  - 如果，第一条Sql共查出来 N 条数据
    - 但是，第二条Sql，则是每条数据都查询一次与这条数据相关的数据
    - 这就要查N次
  - 所以，最后的查询次数就是 N + 1
    - 如果 N 过大，几十万条数据，则查询就有可能崩掉
- 为了防止N过大，查询过载。可以配置懒查询
  - 但是懒查询，并不治本
  - 懒查询的作用是，先查出来 N 条数据
    - 然后如果用到某条数据的关联数据，在使用第二条sql进行查询
    - 但是如果，每条数据都用到了关联数据，则查询的次数还是 N + 1
    - 所以并不治本，所以这种方式不常用，通常用上面的一条Sql进行查询



- 示范代码
  - sql配置文件中sql指令的配置
    ```xml
    <mapper namespace="demo">
        <!-- 第一条查询语句 -->
        <select id="selectUnionOne" resultMap="selectPerson">
            select * from demo1;
        </select>
        <resultMap id="selectPerson" type="domain.Demo1">
            <id property="id" column="id"></id>
            <result property="name" column="name"></result>
            <result property="age" column="age"></result>
            <!-- 外键属性，调用第二条Sql进行查询，获取关联数据，
                column为注入的数据，把查出来的对应的列数据进行注入，然后作为条件，筛选出与之相关的数据 -->
            <association property="bj" javaType="domain.Demo2" select="selectIDCardForPerson" column="bj"></association>
        </resultMap>
        <!-- 第二条Sql查询语句 -->
        <select id="selectIDCardForPerson" resultType="domain.Demo2">
            select * from demo2 where bj = #{bj}
        </select>
    </mapper>
    ```

  - 使用配置的sql指令，读取数据
    ```java
    // 辅助类
    public class Demo1 {
        public int id;
        public String name;
        public int age;
        // 外键，存放另一个表的关联数据对象
        public Demo2 bj;
    }
    // 辅助类（关联表）
    public class Demo2 {
        public int id;
        public String bzr;
        public int age;
        public String bj;
    }

    // 读取数据操作
    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 调用sql
            List<Demo1> demo1 = sqlSession.selectList("demo.selectUnionOne");
            // 获取一条数据，用 selectOne()，单表查询中有介绍
            System.out.println(demo1.toString());
        }
    }
    ```

- 开启懒加载的配置方式
  - 在核心配置文件中（mybatis-config.xml），加入下面的配置，就OK了
  - 该配置加不加都对其他的sql没有影响，所以通常就默认加上了
    ```xml
    <!-- 这是根标签 -->
    <configuration>
        <!-- 懒加载的配置 -->
        <settings>
            <!--开启延迟加载的机制 关联的对象可以延迟加载-->
            <setting name="lazyLoadingEnabled" value="true"/>
            <!--aggressive 攻击性 侵略性 关闭对象的侵略性 不用就不需要加载 用到了关联对象的任意属性 就加载-->
            <setting name="aggressiveLazyLoading" value="false"/>
        </settings>
    </configuration>
    ```




#### 配置文件开发-读数据（一对多，联合查询）
- 一个Sql完成查询

.
- 一对多，主表的一条数据，对应另一个表的多条数据

- 获取数据库数据，靠类进行存储，多表查询，其实就是外键属性，变成一个对象属性，用来存放另一个表的数据映射出来的对象（来表达一对多关系）
  - 保证一个表对应一个类
  - 既然是一对多，所以外键属性，要定义成list集合，来存储多条数据（具体看下面辅助类定义）

- 注意点
  - 必须手动定义映射规则，否则外键对应的那个属性，会自动赋值成null
    - 外键属性的类型如果是当前表对应列的类型，则直接赋值成当前列对应的值
    - 只有，外键属性指向另一个表对应的对象时，才会被赋值成null
  - 因为：一条语句联合查询，得到的是一张合并后的表，如果不定义映射规则，只会进行浅映射（只映射表象，如果一个属性指向的是另一个集合，这默认就办不到了）
    - 由于关联查询，最后查询出的是一个表，相当于单表查询查出来一张表进行数据映射
    - 这样是可以把关联表中的数据，存到当前类中，只要属性名和列相同，就能进行映射
      - 但是这样是有问题的：
        - 如果没有自定义映射规则，由于是一对多关系，就会多出来几条数据
          - 比如：张三对应李老师、王老师。为了体现一对多关系，则就会产生两条数据
            - 张三 - 李老师、张三 - 王老师
        - 如果自定义了映射关系，由于集合已经体现出了一对多关系，所以不会产生多条数据，但是只会取第一条关联数据，存到主表中
          - 比如（主表存了老师名称）：`张三 - 李老师，list: [李老师、王老师]`
  - 比如
    - sql指令配置成（没有使用自定义映射规则，则映射表就为null） 
      ```xml
      <select id="selectUnionOne" resultType="domain.Demo1">
        select * from demo1 inner join demo2 on demo1.bj = demo2.bj;
      </select>
      ```
    - 辅助类的定义：在下面示例中
    - 读表的时候，得到的就是：[{id=1, name='张三', age=18, bj=null}]
    - bj就是外键属性，但是由于没有使用自定义规则，所以直接赋值成了null



- 示范代码（一对多的正确查法）
  - sql配置文件中sql指令的配置
    ```xml
    <mapper namespace="demo">
        <!-- 因为有两个id，所以要给另一个id，起一个别名，否则映射的时候会默认取第一个id -->
        <select id="selectUnionOne" resultMap="selectPerson">
            select *, demo2.id as ids from demo1 inner join demo2 on demo1.bj = demo2.bj;
        </select>
        <!-- 自定义映射规则（一对一读取必须的） -->
        <resultMap id="selectPerson" type="domain.Demo1">
            <id property="id" column="id"></id>
            <result property="name" column="name"></result>
            <result property="age" column="age"></result>
            <!-- 外键属性的映射，映射成另一个表（另一个对象）
                javaType：list，表示外键是一个list集合（一对多，多条数据，所以要指定list集合 -->
            <collection property="bj" ofType="domain.Demo2" javaType="list">
                <id property="id" column="ids"></id>
                <result property="bzr" column="bzr"></result>
                <result property="age" column="age"></result>
                <result property="bj" column="bj"></result>
            </collection>
        </resultMap>
    </mapper>
    ```

  - 使用配置的sql指令，读取数据
    ```java
    // 辅助类
    public class Demo1 {
        public int id;
        public String name;
        public int age;
        // 外键，由于是一对多关系（可能查出来多条关联数据，所以类型要定义成List集合）
        public List<Demo2> bj;
    }
    // 辅助类（关联表）
    public class Demo2 {
        public int id;
        public String bzr;
        public int age;
        public String bj;
    }

    // 读取数据操作
    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 调用sql
            List<Demo1> demo1 = sqlSession.selectList("demo.selectUnionOne");
            // 获取一条数据，用 selectOne()，单表查询中有介绍
            System.out.println(demo1.toString());
        }
    }
    ```



#### 配置文件开发-读数据（一对多，联合查询）
- 两个Sql完成查询
- 也需要自定义映射规则
- 注意点：可能会造成查询压力过大（共发 N + 1 个查询）
- 原因以及原理：看一对一查询介绍
- 可以通过开启懒加载，优化查询压力


- 示范代码
  - sql配置文件中sql指令的配置
    ```xml
    <mapper namespace="demo">
        <!-- 第一条查询语句 -->
        <select id="selectUnionOne" resultMap="selectPerson">
            select * from demo1;
        </select>
        <resultMap id="selectPerson" type="domain.Demo1">
            <id property="id" column="id"></id>
            <result property="name" column="name"></result>
            <result property="age" column="age"></result>
            <!-- 外键属性，调用第二条Sql进行查询，获取关联数据，
                column为注入的数据，把查出来的对应的列数据进行注入，然后作为条件，筛选出与之相关的数据
                javaType：list，表示外键是一个list集合（一对多，多条数据，所以要指定list集合）  -->
            <association property="bj" javaType="list" select="selectIDCardForPerson" column="bj"></association>
        </resultMap>
        <!-- 第二条Sql查询语句 -->
        <select id="selectIDCardForPerson" resultType="domain.Demo2">
            select * from demo2 where bj = #{bj}
        </select>
    </mapper>
    ```

  - 使用配置的sql指令，读取数据
    ```java
    // 辅助类
    public class Demo1 {
        public int id;
        public String name;
        public int age;
        // 外键，由于是一对多关系（可能查出来多条关联数据，所以类型要定义成List集合）
        public List<Demo2> bj;
    }
    // 辅助类（关联表）
    public class Demo2 {
        public int id;
        public String bzr;
        public int age;
        public String bj;
    }

    // 读取数据操作
    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 调用sql
            List<Demo1> demo1 = sqlSession.selectList("demo.selectUnionOne");
            // 获取一条数据，用 selectOne()，单表查询中有介绍
            System.out.println(demo1.toString());
        }
    }
    ```

- 开启懒加载的配置方式
  - 在核心配置文件中（mybatis-config.xml），加入下面的配置，就OK了
  - 该配置加不加都对其他的sql没有影响，所以通常就默认加上了
    ```xml
    <!-- 这是根标签 -->
    <configuration>
        <!-- 懒加载的配置 -->
        <settings>
            <!--开启延迟加载的机制 关联的对象可以延迟加载-->
            <setting name="lazyLoadingEnabled" value="true"/>
            <!--aggressive 攻击性 侵略性 关闭对象的侵略性 不用就不需要加载 用到了关联对象的任意属性 就加载-->
            <setting name="aggressiveLazyLoading" value="false"/>
        </settings>
    </configuration>
    ```







#### 配置文件开发-读数据（多对多，联合查询）
- 一个Sql完成查询

.
- 多对多，主表的一条数据，对应另一个表的多条数据。另一个表中的数据也对应多条主表中的数据
  - **多对多关系，需要借中间表来实现**
  - 如果没有中间表，只能一对一或者一对多，但是也能进行多对多，但是不太好管理，可能需要添加额外的外键。
    - 比如：
    
        |  表一外键   | 表二外键  |
        | ----   |  ----  |
        | 张三  | 张三 |
        | 张三  | 张三 |
        - 表一对应多个表二数据，表二对应多个表一数据（多对多关系）
    - 但是忽然有一天表一的第二个张三，不想与表二的第一个张三建立联系了
      - 这样，要么所有的外键数据重新规划，要不然单独在建立一个映射关系（增加外键）
      - 这样就超级麻烦了
    - 如果存在中间表就不一样了，直接更该中间表的映射关系就OK
      - 比如
        |  表一  |  表一外键  |  表二外键  | 表二  |
        | ----   |  ----  | ----   |  ----  |
        | 张三  | 1 | 1  | 张三 |
        | 张三  | 2 | 2  | 张三 |
      - 中间表
         |  表一外键  |  表二外键 |
         | ----   |  ----  |
         | 1  | 1 |
         | 1  | 2 |
         | 2  | 1 |
         | 2  | 2 |
      - 如果忽然有一天表一的第二个张三，不想与表二的第一个张三建立联系了
        - 只需要把中间表的 2 -> 1 这条数据删掉就OK了，简单快速


.
- 获取数据库数据，靠类进行存储，多表查询，其实就是外键属性，变成一个对象属性，用来存放另一个表的数据映射出来的对象（来表达多对多关系）
  - 保证一个表对应一个类
  - 既然是多对多，所以两个类都需要搞一个外键属性（指向另一个对象）
    - A 对应多条 B，所以A存在一个list集合存放B
    - 但是 B 也对应多条 A，所以B也要存在一个list集合存放A
    - 以此来表达多对多的关系
    - 所以需要两个类中都存在一个list集合（当然也可以不存在）

.
- 注意点：必须手动定义映射规则，否则外键对应的那个属性，会自动赋值成null

- 虽然：多对多两个类都有list集合，分别指向对方
  - 但是在查询的时候，有一个是为 null 的
    - 无法：A的list里存着相关的B。B的list里又同时存着相关的A
  - 以映射基数为准
    - 比如；A作为基础表，则A的list里存着相关的B，B的list为null
    - 比如；B作为基础表，则B的list里存着相关的A，A的list为null
    - 硬通过 collection 加映射也没有，加上也只会取当前的数据（只有一条）
  - 而两个类中都有list的原因
    - 一是体现多对多关系
    - 二是存数据方便，如果有一个没有，万一以他作为基础存数据，到时候缺少list存放相关的数据，还要现加
    - 所以，在声明类的时候就都加上了
    - 其实多对多查询就是一对多查询
    

.
- 示范代码（多对多的正确查法）
  - sql配置文件中sql指令的配置
    ```xml
    <mapper namespace="demo">
        <!-- 因为有两个id，所以要给另一个id，起一个别名，否则映射的时候会默认取第一个id -->
        <select id="selectUnionOne" resultMap="selectPerson">
            select *, demo2.id as ids from demo1,demo2,zjb where demo1.id = zjb.demo1_id and zjb.demo2_id = demo2.id;
        </select>
        <!-- 自定义映射规则（多对多读取必须的） -->
        <resultMap id="selectPerson" type="domain.Demo1">
            <id property="id" column="id"></id>
            <result property="name" column="name"></result>
            <result property="age" column="age"></result>
            <!-- 外键属性的映射，映射成另一个表（另一个对象）
                javaType：list，表示外键是一个list集合（多对多，多条数据，所以要指定list集合 -->
            <collection property="bj" ofType="domain.Demo2" javaType="list">
                <id property="id" column="ids"></id>
                <result property="bzr" column="bzr"></result>
                <result property="age" column="age"></result>
                <result property="bj" column="bj"></result>
            </collection>
        </resultMap>
    </mapper>
    ```

  - 使用配置的sql指令，读取数据
    ```java
    // 辅助类
    public class Demo1 {
        public int id;
        public String name;
        public int age;
        // 外键
        public List<Demo2> bj;
    }
    // 辅助类（关联表）
    public class Demo2 {
        public int id;
        public String bzr;
        public int age;
        public String bj;
        // 外键（体现多对多关系）
        public List<Demo1> demo1;
    }

    // 读取数据操作
    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 调用sql
            List<Demo1> demo1 = sqlSession.selectList("demo.selectUnionOne");
            // 获取一条数据，用 selectOne()，单表查询中有介绍
            System.out.println(demo1.toString());
        }
    }
    ```



#### 配置文件开发-读数据（多对多，联合查询）
- 两个Sql完成查询
- 也需要自定义映射规则
- 注意点：可能会造成查询压力过大（共发 N + 1 个查询）
- 原因以及原理：看一对一查询介绍
- 可以通过开启懒加载，优化查询压力


- 示范代码
  - sql配置文件中sql指令的配置
    ```xml
    <mapper namespace="demo">
        <!-- 第一条查询语句 -->
        <select id="selectUnionOne" resultMap="selectPerson">
            select * from demo1;
        </select>
        <resultMap id="selectPerson" type="domain.Demo1">
            <id property="id" column="id"></id>
            <result property="name" column="name"></result>
            <result property="age" column="age"></result>
            <!-- 外键属性，调用第二条Sql进行查询，获取关联数据，
                column为注入的数据，把查出来的对应的列数据进行注入，然后作为条件，筛选出与之相关的数据
                javaType：list，表示外键是一个list集合（多对多，其实就是一对多，多条数据，所以要指定list集合）  -->
            <association property="bj" javaType="list" select="selectIDCardForPerson" column="id"></association>
        </resultMap>
        <!-- 第二条Sql查询语句 -->
        <select id="selectIDCardForPerson" resultType="domain.Demo2">
            select * from demo2,zjb where zjb.demo2_id = demo2.id and zjb.demo1_id = #{id}
        </select>
    </mapper>
    ```

  - 使用配置的sql指令，读取数据
    ```java
    // 辅助类
    public class Demo1 {
        public int id;
        public String name;
        public int age;
        // 外键
        public List<Demo2> bj;
    }
    // 辅助类（关联表）
    public class Demo2 {
        public int id;
        public String bzr;
        public int age;
        public String bj;
        // 外键（体现多对多关系）
        public List<Demo1> demo1;
    }

    // 读取数据操作
    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 调用sql
            List<Demo1> demo1 = sqlSession.selectList("demo.selectUnionOne");
            // 获取一条数据，用 selectOne()，单表查询中有介绍
            System.out.println(demo1.toString());
        }
    }
    ```

- 开启懒加载的配置方式
  - 在核心配置文件中（mybatis-config.xml），加入下面的配置，就OK了
  - 该配置加不加都对其他的sql没有影响，所以通常就默认加上了
    ```xml
    <!-- 这是根标签 -->
    <configuration>
        <!-- 懒加载的配置 -->
        <settings>
            <!--开启延迟加载的机制 关联的对象可以延迟加载-->
            <setting name="lazyLoadingEnabled" value="true"/>
            <!--aggressive 攻击性 侵略性 关闭对象的侵略性 不用就不需要加载 用到了关联对象的任意属性 就加载-->
            <setting name="aggressiveLazyLoading" value="false"/>
        </settings>
    </configuration>
    ```





#### 配置文件开发-动态sql（动态生成where）
- 在sql指令配置文件中进行配置
- 动态sql，要注入数据，然后根据判断，合成不同的sql指令
- 示范配置如下
    ```xml
    <mapper namespace="demo">
      <!-- 第一条查询语句 -->
      <select id="selectUnionOne" resultType="domain.Demo1">
          select * from demo1
          <!-- 动态拼接where -->
          <where>
              <!-- 条件判断，如果为真，就拼接在sql后面 -->
              <!-- where条件判断，第一个and会忽略，所以 and、or 该加就得加 -->
              <if test="bj == '一班'">
                  and bj = #{bj}
              </if>
              <if test="bj == '一班' and age == 18">
                  and age = #{age}
              </if>
          </where>
      </select>
    </mapper>
    ```
- 具体的使用（调用配置的sql指令，完成对数据库的操作）
    ```java
    // 辅助类
    public class Demo1 {
        public int id;
        public String name;
        public int age;
        public String bj;
    }

    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();
            
            // 创建一些数据，用于sql条件判断，动态合成sql
            Demo1 _demo1 = new Demo1();
            _demo1.bj = "一班";
            _demo1.age = 18;

            // 调用sql
            List<Demo1> demo1 = sqlSession.selectList("demo.selectUnionOne", _demo1);
            System.out.println(demo1.toString());
        }
    }
    ```




#### 配置文件开发-动态sql（动态生成where和order）
- 在sql指令配置文件中进行配置
- 动态sql，要注入数据，然后根据判断，合成不同的sql指令
- 示范配置如下
    ```xml
    <mapper namespace="demo">
      <!-- 第一条查询语句 -->
      <select id="selectUnionOne" resultType="domain.Demo1">
          select * from demo1
          <!-- 动态拼接where -->
          <where>
              <!-- 条件判断，如果为真，就拼接在sql后面 -->
              <!-- where条件判断，第一个and会忽略，所以 and、or 该加就得加 -->
              <if test="bj == '一班'">
                  and bj = #{bj}
              </if>
              <if test="bj == '一班' and age == 18">
                  and age = #{age}
              </if>
          </where>
          <!-- 上面的where经过判断，拼接完成后，紧接着拼接下面的内容 -->
          order by age
          <!-- 上面的内容拼接完成后，紧接着进行下面的判断，继续拼接，最终得到一个完整的sql -->
          <choose>
              <when test=" order == 'desc' ">
                  desc
              </when>
              <when test=" order =='asc' ">
                  asc
              </when>
          </choose>
      </select>
    </mapper>
    ```
- 具体的使用（调用配置的sql指令，完成对数据库的操作）
    ```java
    // 辅助类
    public class Demo1 {
        public int id;
        public String name;
        public int age;
        public String bj;
        public String order;
    }

    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 创建一些数据，用于sql条件判断，动态合成sql
            Demo1 _demo1 = new Demo1();
            _demo1.bj = "一班";
            _demo1.order = "desc";

            // 调用sql
            List<Demo1> demo1 = sqlSession.selectList("demo.selectUnionOne", _demo1);
            System.out.println(demo1.toString());
        }
    }
    ```
  


#### 配置文件开发-动态sql（循环的使用）
- 注入的数据，必须是一个集合，这样才能使用循环
- 示范配置如下
    ```xml
    <mapper namespace="demo">
        <insert id="insertFor">
            insert into demo1 values
            <!-- 循环的使用 -->
            <!-- separator：表示循环中间拼接什么内容，相当于 join(",") -->
            <foreach collection="list" item="e" index="i" separator=",">
                ( #{e.id}, #{e.name}, #{e.bj}, #{e.age} )
            </foreach>
        </insert>
    </mapper>
    ```
- 具体的使用（调用配置的sql指令，完成对数据库的操作）
    ```java
    // 辅助类
    public class Demo1 {
        public Integer id;
        public String name;
        public int age;
        public String bj;

        public Demo1() {
        }

        public Demo1(Integer id, String name, int age, String bj) {
            this.id = id;
            this.name = name;
            this.age = age;
            this.bj = bj;
        }
    }

    public class Main {
        public static void main(String[] args) {
            // 使用封装的工厂，获取一个连接
            SqlSession sqlSession = Connect.connect();

            // 创建sql动态拼接，需要的数据
            List<Demo1> list = new ArrayList<>();
            list.add(new Demo1(null, "马六", 60, "二班"));
            list.add(new Demo1(null, "赵七", 60, "二班"));

            // 调用sql，并动态拼接sql，由于内部使用的是循环拼接，所以参数要传个数组集合
            sqlSession.insert("demo.insertFor", list);
        }
    }
    ```
  






#### 配置文件开发-动态sql（总结）
- 在sql指令中间，随便找个地方，就可以写循环判断，动态插入这个位置的内容。
- 比如
  ```xml
  <insert id="insert">
      insert into student values(
          <if test="id != null">#{id}</if>,
          <if test="name != null">#{name}</if>,
          <if test="xingbie != null">#{xingbie}</if>,
          <if test="banji != null">#{banji}</if>
      )
      <!-- 最终会拼接成 insert into student values(5, "赵武", "男", "高三二班") -->
  </insert>
  ```



#### 配置文件开发-dao接口化（注解开发的基础）
- 注解开发，dao就变成了一个一个的接口
- 原理：用一个函数加工一下，重写dao方法（变成真正操作数据库的方法）
  - 接口啥用都没有，只有重写后才有效
- 要想dao接口化，就需要使用上面的 `准备工作-创建一个连接数据库工厂（注解开发）`，创建工厂
  - 因为它提供，接口的重写方法，完成对dao接口的重写
- 要想使用dao接口化，sql配置文件的书写必须符合一定的条件（具体看下面的dao接口化原理）

- 示范代码
  - sql配置文件的sql指令配置
  ```xml
  <mapper namespace="dao.StudentDao">
      <select id="select" resultType="domain.Demo1">
          select * from demo1;
      </select>
  </mapper>
  ```
  - dao接口化的实现和使用示范
  ```java
  // 辅助类
  public class Demo1 {
      public Integer id;
      public String name;
      public int age;
      public String bj;
  }
  
  // 使用接口操作数据库
  public class Main {
      public static void main(String[] args) {
          // 使用工厂提供的方法，包装dao接口，实现内部的方法，使其可以真正的操作数据库
          StudentDao studentDao = Connect.getMapper(StudentDao.class);
          // 使用dao接口中提供的方法（重写后），操作数据库
          List<Demo1> demo1 = studentDao.select();
          System.out.println(demo1.toString());
      }
  }
  ```



#### 配置文件开发-dao接口化（原理）
- 从上面示例中可以看出，dao接口，就是一个简单的接口，并没有与sql指令配置文件相关的信息
  - 那么dao接口是如果知道调用那个sql指令，完成对数据库的操作的呢

- 正常使用sql配置文件中配置的sql指令的方式如下
  - `List<Demo1> demo1 = sqlSession.selectList("demo.selectUnionOne");`
  - dao接口并没有相关的信息，它是如何知道该使用`selectList`方法，用id为selectUnionOne的sql指令操作数据库的呢

- 具体原理如下
  - dao接口，能获取接口路径，以及接口方法名，以及返回值的数据类型，根据这三个信息，就能得到上面的信息。
  - 比如：
    - 使用dao.Demo1接口中的selectDemo方法，操作数据库，并且得到的是一个list集合
    - 根据这些信息，最终调用的方法就是 `sqlSession.selectList("dao.Demo1.select");`
      - 返回值决定使用 selectList 还是 selectOne（这里的返回值是list，所以使用 selectList 方法）
      - 方法名决定使用的sql指令的id
      - 接口路径觉得的是 namespace
    - 所以，只要sql指令配置文件配置成如下样子，就能找到对应的sql指令，然后操作数据库
      - 如果没有按照这个方式定义，就找不到对应的sql指令，于是就会报错
      ```xml
      <mapper namespace="dao.Demo1">
          <select id="select" resultType="domain.Demo1">
              select * from demo1;
          </select>
      </mapper>
      ```

- 所以，使用代理时，sql配置文件必须要注意定义规则，与接口对应上，不要随便写，否则就会报错





#### 注解开发-实现增删改（示范）
- 因为操作数据库，全靠注解的配置，然后利用工厂，加工成真正的操作数据库的方法（重写）
- 所以，注解开发，操作数据库的类，要定义成接口的形式

.
- 操作数据库的dao接口
    ```java
    public interface StudentDao {
        // 新增学生信息
        @Insert("insert into student values(8, '测试', '男', '测试')")
        public void insert();
        // 修改学生信息
        @Update("update student set banji = '高三四班' where id=3")
        public void update(Student student);
        // 删除学生信息
        @Delete("delete from student where id=3")
        public void delete(Student student);
    }
    ```

.
- 使用定义的dao接口，操作数据库的方式
    ```java
    public class Main {
        public static void main(String[] args) {
            // 使用工厂，加工一下
            StudentDao studentDao = Connect.getMapper(StudentDao.class);

            // 使用工厂重写后的方法，操作数据库
            studentDao.insert();
            studentDao.update();
            studentDao.delete();
        }
    }
    ```


#### 注解开发-实现Sql指令的数据注入
- 利用一个对象，进行注入
- 执行重写后带有Sql注解的方法，传入对应的对象就可以了，如果对象中有该属性，则就会把对应的数据进行注入
- Mybatis中提供了两种，相当于 ? 功能的东西，一种是 #{}、一种是 ${} 
  - #{} 和 ${} 的区别
    - #{} 底层会进行类型判断，如果是字符串类型的，就自动在两侧拼接一个 ''，防止sql注入
    - ${} 底层是直接进行替换，可以用来传递一些sql指令

- 比如（示范代码）
    ```java
    // dao接口类
    public interface StudentDao {
        // 修改学生信息（接收一个对象，如果对象中有id属性，则就把对应的数据注入进来）
        @Update("update student set banji = '高三四班' where id=#{id}")
        public void update(Student student);
    }

    // Student类
    public class Student {
        public int id;

        public void setId(int id) {
            this.id = id;
        }
    }

    // 使用（sql数据的注入）
    public class Main {
        public static void main(String[] args) {
            // 使用工厂，加工一下
            StudentDao studentDao = Connect.getMapper(StudentDao.class);
            
            // 创建一个对象
            Student student = new Student();
            student.setId(8);

            // 把对象传进去，进行数据的注入（id的注入）
            studentDao.update(student);
        }
    }
    ```
- 如果没有找到对应属性，或者对应属性没有值，则注入空（NULL）

.
- 注意点：
  - 如果使用 #{}。如果是字符串，就不用手动在 sql指令上加 ''，因为解析的时候会自动添加。
    - 如果加了反而会报错
    - 比如：`insert into demo values(null,'#{name}',#{ages},#{time});`
    - 会报出：Parameter index out of range (3 > number of parameters, which is 2). 的错误
      - 意思是：注入了三个数据，但是只有两个，因为有一个加了 ''，就打破了规则
      - 所以，就报出多了一个数据的错误
  - 如果使用的是 ${}，因为这个东西会直接替换，不会进行解析，所以必须加 ''。

.
- 借助 ${} 可以注入一些 sql 指令
  - 因为 ${} 不会进行解析，会直接替换
  - 比如：`insert ${a} ${b} ${c}(3);`
    - 如果注入的数据是 `{a: into, b: demo, c: values}`
    - 最终替换完，sql指令就是：insert into demo values(3)
    - 这样替换完，就是一个正常的sql指令。

.
- 如果只注入一个数据比如id、name、age。可以不借助对象，直接传入普通的数据
  - 因为：Sql命令中只有一条数据注入，所以可以不用找映射，直接使用传入的值
  - 如果传入的是对象，就会根据映射查找数据



#### 注解开发-实现Sql指令的数据注入（不借助对象）
- 上面介绍过，如果sql中只有一个数据进行注入，就可以直接传递数据，而不是传递对象
  - 因为就一个数据，不怕搞混，接收到一个不是对象的数据，就直接使用了

- 如果Sql指令中，有很多个数据进行注入。为了区分数据，所以需要传递一个对象。然后根据属性名找到对应的数据进行赋值。
- 但是，多个数据注入，除了传递一个对象外，也可以传递多个数据进行注入
  - 只要传入的多个数据，能进行区分，Sql指令能找到对应的注入数据完成Sql的拼接就OK
  - **实现数据对应的方式有两种**
    - 第一种: 使用 #{param1}, #{param2}
      - 而param1 就对应第一个传入的数据，param2 对应第二个传入的数据，以此类推
    - 第二种: 在传入的参数前面，都加一个 @Param("key") 注解。
      - 这样的话，#{key1}, #{key2} 就能使用对应的 key 来匹配数据了
      - 这种方式更加灵活（可以随意调整位置，因为他不和位置挂钩，方式一就不能随意更换位置了）

- 实现的示范代码（两种方式都有）
  ```java
  // 辅助类
  public class Demo1 {
      public Integer id;
      public String name;
      public int age;
      public String bj;
  }

  // dao接口（注解开发）
  public interface StudentDao {
      // 第一种注入方式
      //    由于使用了param1、param2，所以dao接口方法的参数名称就随意了
      //   （param1始终对应第一个参数、param2始终对应第二个参数）
      @Select("select * from demo1 where age = #{param1} and name = #{param2}")
      public Demo1 selectOne_1(int a, String b);

      // 第二种注入方式
      //    这种方式，@Param中指定的名称，必须与 #{} 中的名称一致。这样才能映射过去
      //    参数名，就随意了，因为不靠它建立映射关系，叫啥都无所谓
      @Select("select * from demo1 where age = #{age} and name = #{name}")
      public Demo1 selectOne_2(@Param("name") String b, @Param("age") int a);
  }

  // 主函数，测试dao，不采用对象注入数据
  public class Main {
      public static void main(String[] args) {
          // 使用工厂提供的方法，包装dao接口，实现内部的方法，使其可以真正的操作数据库
          StudentDao studentDao = Connect.getMapper(StudentDao.class);

          // 使用dao接口中提供的方法（重写后），操作数据库
          Demo1 demo1 = studentDao.selectOne_1(19,"李四");
          System.out.println(demo1.toString());

          // 使用dao接口中提供的方法（重写后），操作数据库
          Demo1 demo2 = studentDao.selectOne_2("张三", 18);
          System.out.println(demo2.toString());
      }
  }
  ```
  


#### 注解开发-获取新增数据的主键id
- 新增一条数据，如何获取新增数据的主键id
  - 主键一般都是自增的，也就是新增数据的时候，主键对应的数据，设置成null，这样数据新增就会使用自增的id
  - 但是，如果有需求，需要获取新增数据的id（不是自己生成的，所以不能直接获取），有两种方式获取
    - 一种是使用查询语句，在把这条数据查出来，有点浪费效率
    - 一种是借助一个注解 `@Options`，会自动把自增后的id，注入到与表相对应的对象中
      - 自动把自增后的id，注入到传入对象中的某个属性
  - 这样的话，数据新增完，再获取一下注入的对象，就能看到自增后的id值

.
- 示范代码
  - domain辅助类
    ```java
    public class Demo1 {
        public Integer id;
        public String name;
        public int age;
        public String bj;
        public Demo1(String name, int age, String bj) {
            this.name = name;
            this.age = age;
            this.bj = bj;
        }
    }
    ```
  - dao接口
    ```java
    public interface StudentDao {
    @Insert("insert into demo1 values(null, #{name}, #{bj}, #{age})")
        // 自动把传入对象（demo1）的id属性（keyProperty指定的），赋值为本条数据自增后的id
        @Options(useGeneratedKeys = true, keyProperty = "id")
        public void addStudent(Demo1 demo1);
    }
    ```
  - 测试
    ```java
    public class Main {
        public static void main(String[] args) {
            // 使用工厂提供的方法，包装dao接口，实现内部的方法，使其可以真正的操作数据库
            StudentDao studentDao = Connect.getMapper(StudentDao.class);

            // 测试自增的id，能否获取成功
            Demo1 demo1 = new Demo1("测试6", 44, "四班");
            studentDao.addStudent(demo1);
            // 打印一下，发现id确实已经注入了，这样的话，后续就可以使用id，建立关联表（关联数据）了
            System.out.println(demo1);
        }
    }
    ```




#### 注解开发-读数据（单表查询）
- 至于什么时候使用 selectList 还是 selectOne 方法获取数据。是根据接口方法的返回值决定的
  - 如果返回值是list，则使用 selectList。如果返回值是一个单独的数据，则使用selectOne

- 查询数据示范代码
  ```java
  // 辅助类
  public class Demo1 {
      public Integer id;
      public String name;
      public int age;
      public String bj;
  }

  // dao接口（注解开发）
  public interface StudentDao {
      @Select("select * from demo1")
      public List<Demo1> selectList();

      // 只有一个数据注入，所以可以直接使用基本类型进行注入
      @Select("select * from demo1 where id = #{id}")
      public Demo1 selectOne(int id);
  }

  // 主函数，测试dao，获取数据
  public class Main {
      public static void main(String[] args) {
          // 使用工厂提供的方法，包装dao接口，实现内部的方法，使其可以真正的操作数据库
          StudentDao studentDao = Connect.getMapper(StudentDao.class);

          // 使用dao接口中提供的方法（重写后），操作数据库
          List<Demo1> demo1 = studentDao.selectList();
          System.out.println(demo1.toString());

          // 使用dao接口中提供的方法（重写后），操作数据库
          Demo1 demo2 = studentDao.selectOne(1);
          System.out.println(demo2.toString());
      }
  }
  ```




#### 注解开发-读数据（一对一查询，联合查询）
- 配置文件一对一查询，需要自定义映射规则。注解开发也需要自定义映射规则。否则辅助类的外键集合就会赋值为null
- 注意点
  - 注解的联合查询，只能使用多个sql查询的方式，无法使用一个sql进行查询(配置文件可以实现)
  - 原因是：注解不能使用映射的方式，为对象中的对象进行赋值（配置文件中有说明）
  - 所以：就存在 N + 1 的问题

- 查询数据示范代码（含自定义映射规则的定义方式）
  ```java
  // 辅助类
  public class Demo1 {
      public Integer id;
      public String name;
      public int age;
       // 外键属性
      public Demo2 bj;
  }
  // 关联类
  public class Demo2 {
      public int id;
      public String bzr;
      public int age;
      public String bj;
  }

  // dao接口（注解开发，含有自定义映射规则）
  public interface StudentDao {
      // 自定义映射规则，顶在查询注解的上面
      @Results(
              // id 表示复用的名称，毕竟，这个东西配置起来还是很麻烦的
              id="selectEmp",
              // 定义映射规则
              value={
                      // id=true 表示 为主键，相当于配置文件中的 id 标签
                      @Result(property="id", column="id", id=true),
                      @Result(property="name", column="name"),
                      @Result(property="age", column="age"),
                      // 调用另一个辅助 sql，根据班级名，实现一对一的查询
                      //    javaType：数据的类型映射
                      //    column：把那一列数据作为参数，传入辅助sql中，进行数据注入，作为条件进行查询
                      //    selectDept：辅助sql 的接口名
                      //    fetchType= FetchType.LAZY：启用懒加载
                      //    one=@One表示，只有一条数据与之对应（一对一）
                      @Result(property="bj", javaType=Demo2.class, column="bj",one=@One(select="selectFz",fetchType= FetchType.LAZY))
              }
      )
      @Select("select * from demo1")
      public List<Demo1> selectList();

      // 辅助sql，接受上面查询结果的数据注入
      @Select("select * from demo2 where bj = #{bj}")
      public Demo2 selectFz(String bj);
  }

  // 主函数，测试dao，获取数据
  public class Main {
      public static void main(String[] args) {
          // 使用工厂提供的方法，包装dao接口，实现内部的方法，使其可以真正的操作数据库
          StudentDao studentDao = Connect.getMapper(StudentDao.class);

          // 使用dao接口中提供的方法（重写后），操作数据库
          List<Demo1> demo1 = studentDao.selectList();
          System.out.println(demo1.toString());
      }
  }
  ```




#### 注解开发-读数据（一对多查询，联合查询）
- 配置文件一对多查询，需要自定义映射规则。注解开发也需要自定义映射规则。否则辅助类的外键集合就会赋值为null
- 注意点
  - 注解的联合查询，只能使用多个sql查询的方式，无法使用一个sql进行查询(配置文件可以实现)
  - 原因是：注解不能使用映射的方式，为对象中的对象进行赋值（配置文件中有说明）
  - 所以：就存在 N + 1 的问题

- 查询数据示范代码（含自定义映射规则的定义方式）
  ```java
  // 辅助类
  public class Demo1 {
      public Integer id;
      public String name;
      public int age;
      // 外键属性，由于是一对多关系，所以这个地方是一个list集合，用来存放多条数据
      public List<Demo2> bj;
  }
  // 关联类
  public class Demo2 {
      public int id;
      public String bzr;
      public int age;
      public String bj;
  }

  // dao接口（注解开发，含有自定义映射规则）
  public interface StudentDao {
      // 自定义映射规则，顶在查询注解的上面
      @Results(
              // id 表示复用的名称，毕竟，这个东西配置起来还是很麻烦的
              id="selectEmp",
              // 定义映射规则
              value={
                      // id=true 表示 为主键，相当于配置文件中的 id 标签
                      @Result(property="id", column="id", id=true),
                      @Result(property="name", column="name"),
                      @Result(property="age", column="age"),
                      // 调用另一个辅助 sql，根据班级名，实现一对一的查询
                      //    javaType：数据的类型映射
                      //    column：把那一列数据作为参数，传入辅助sql中，进行数据注入，作为条件进行查询
                      //    selectDept：辅助sql 的接口名
                      //    fetchType= FetchType.LAZY：启用懒加载
                      //    javaType=List.class：表示外键属性是一个list集合（多条数据，一对多）
                      //    many=@Many：表示有多条数据与之对应（一对多）
                      @Result(property="bj", javaType=List.class, column="bj",many=@Many(select="selectFz",fetchType= FetchType.LAZY))
              }
      )
      @Select("select * from demo1")
      public List<Demo1> selectList();

      // 辅助sql，接受上面查询结果的数据注入，由于是一对多关系，所以这个地方的返回值是list，用来存放多条数据
      @Select("select * from demo2 where bj = #{bj}")
      public List<Demo2> selectFz(String bj);
  }

  // 主函数，测试dao，获取数据
  public class Main {
      public static void main(String[] args) {
          // 使用工厂提供的方法，包装dao接口，实现内部的方法，使其可以真正的操作数据库
          StudentDao studentDao = Connect.getMapper(StudentDao.class);

          // 使用dao接口中提供的方法（重写后），操作数据库
          List<Demo1> demo1 = studentDao.selectList();
          System.out.println(demo1.toString());
      }
  }
  ```


#### 注解开发-动态sql
- 注解开发的动态sql，是利用一个函数跑出来的（把dao接口接收到的数据，原封不懂的传到动态sql构建函数中，用于sql的构建）
  - 所以，sql构建函数的参数与dao参数，要定义成一样的
- 由于注解的动态sql是利用函数构建出来的，所以可以经过很复杂的运算，计算出来所需要的sql
  - 更加灵活，如果是配置文件开发，通过配置是很难灵活的创建sql的，达不到注解这么灵活的程度

- 示范代码
  ```java
  // 辅助类
  public class Demo1 {
      public Integer id;
      public String name;
      public int age;
  }

  // dao接口
  public interface StudentDao {
      // 运用sql构建函数，动态构建sql
      //    type：动态sql构造函数所处的类
      //    method：使用那个方法，动态构建sql
      @SelectProvider(type = Dt.class, method="dt")
      public Demo1 selectOne(int id);
  }

  // 动态构建sql的类
  public class Dt {
      // 参数的个数以及类型，要与对应的dao保持一致
      public String dt(int id) {
          return "select * from demo1 where id = " + id;
      }
  }

  // 主函数，测试dao，获取数据
  public class Main {
      public static void main(String[] args) {
          // 使用工厂提供的方法，包装dao接口，实现内部的方法，使其可以真正的操作数据库
          StudentDao studentDao = Connect.getMapper(StudentDao.class);

          // 使用dao接口中提供的方法（重写后），操作数据库
          Demo1 demo1 = studentDao.selectList(1);
          System.out.println(demo1.toString());
      }
  }
  ```
