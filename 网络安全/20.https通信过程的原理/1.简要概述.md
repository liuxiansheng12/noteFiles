#### 作用
- http 明文传递数据，容易造成数据泄漏
- https 加密传递数据，不容易（很难）造成数据泄密


#### 加密方式
- 对称加密
  - 加密和解密公用一个密钥，密钥容易泄漏。
    - 密钥一旦泄漏，也就意味着数据可以被拦截，然后解密出来，造成数据泄漏
- 非对称加密
  - 分为公钥、私钥
    - 公钥加密、私钥可以进行解密
    - 私钥加密、公钥可以进行解密
  - 然后，把公钥抛出去，用来加密数据，自己用私钥进行解密，自己用私钥加密，别人用公钥解密
    - 由于私钥不知道，所以第三方无法解密别人用公钥加密的数据
    - 但是，公钥是暴露的，所以自己用私钥加密的数据，就可以被第三方拦截、然后进行解密，造成数据泄漏
    - 造成单方向数据泄漏
  - 于是在一次升级，通信双方都生成公钥和私钥。然后互相交换公钥，双方加密都用对方的公钥
    - 由于数据都是用公钥加密的，解密必须用对应的私钥，但是私钥很难泄漏，所以第三方就无法通过公钥进行解密数据
  - 无论是使用一对密钥，进行数据通信，还是使用两对密钥，进行数据通信。第三方都可以更换公钥，来进行拦截数据
    - 拦截发送给对方的公钥，然后换成自己的，发送过去
    - 当对方发送数据的时候，就会用第三方的公钥进行加密，这样第三方就可以用自己的私钥解密出数据
    - 然后，在用拦截下来的公钥（真实的），加密数据发送过去

#### 证书
- 为了防止非对称公钥，被第三方篡改，于是就搞出了证书
  - 证书上存在两个部分，一个是公钥，一个是公钥的验证信息
  - 验证信息的产生过程
    - 把公钥，通过hash算法，得到一个结果，然后把这个结果用私钥进行加密
  - 当客户端收到证书的时候，会先取到证书上的公钥，然后通过hash算法，得到一个结果。
    - 然后通过加密证书的公钥，揭密出验证信息，如果两个结果一样，说明公钥没有被篡改
  - 由于验证信息，使用私钥加密产生的，所以无法进行替换
    - 替换公钥，必须替换验证信息，但是由于不知道私钥，所以无法替换验证信息
    - 这样，被串改的证书发送到客户端，客户端还用正常的公钥进行解密，得到的结果势必是不同的，于是就提示证书不可信(被串改了)
- 证书的产生过程，是一个权威机构进行管理的（保证公钥统一，私钥保密）
  - 把公钥发给他，然后权威机构就会颁发一个证书
  - 公钥统一，这样浏览器就可以使用固定的公钥进行解密验证信息（公钥是写死的，所以证书无法被串改，串改后用写死的公钥解密，结果就会不一样）
    - 如果这个公钥可以被替换掉，证书就可以被串改


#### https发送请求的流程
- 非对称加密虽然安全，但是效率低
- 对称加密，效率高，但是密钥容易泄漏
- https结合了这两种方式
  - 通信采用的是对称加密，保证了效率
  - 对称加密的密钥产生的过程，用到了非对称加密，保证了对称密钥的安全性（即使拦截，也无法得知密钥是啥）
    - 无法得知密钥是啥，就无法解密通信数据，既保证了效率，又保证了安全性

- https通信流程  
  - 首先进行三次握手
    - 第一次握手，客户端产生一个随机数，发送给服务端
      - 并发送多个计算方式，让服务器选择，计算方式用于产生对称加密的密钥
    - 第二次握手，服务端产生一个随机数，发送给客户端（并且确定计算方式，并告诉客户端）
      - 这一次会把证书，发送给客户端
      - 客户端收到证书后，就会验证证书的真实性，然后取出公钥
    - 第三次握手，客户端产生一个随机数，并把这个随机数用证书上的公钥进行加密，发送给服务端
  - 三次握手后，客户端和服务端都有三个随机数，并且是相同的，以及确定了一个计算方法
    - 这样，双方就会利用确定的计算方式，通过三个随机数，得到一个密钥
    - 由于是自己计算出来的，并没有公布，所以第三方无法拦截
  - 为了保证密钥没有被串改，于是双方就会把密钥通过密钥进行对称加密，然后发送给对方
    - 由于双方手中的密钥是相同的，所以可以进行解密，与自己的密钥进行比较，如果相同则表示没有被串改
  - 至此通信建立完毕，接下来就会用对称加密进行通信
  - 对称加密，发生在传输层
    - 把内容加密，然后包上TCP包头
    - 数据传输中，路由器的某些功能需要得到TCP包头中的端口信息（比如：ACL过滤），所以TCP包头不能进行加密
      - 路由器不知道密钥是啥，加密了就解不开了

#### https通信过程中，对称密钥安全性的保证
- 由于第三个随机数，是利用公钥加密发送的，所以第三方无法得知第三个随机数是啥
- 这样，即使第三方得到了计算方式，也无法计算出与客户端相同的密钥
  - 密钥是以三个随机数为基础得到的，如果某个不一样，计算出来的结果势必是不同的
- 虽然第三方，可以串改发送给服务端的随机数，但是这样服务端保持的三个随机数，就会与客户端的不同
  - 这样，双方通过计算结果产生的密钥就会不同，下一步双方验证密钥，结果就会不同
- 所以，三个随机数，必须老老实实的发送给对方，由于不知道第三个随机数，所以无法计算出密钥
- 双方的互相验证密钥环节，虽然发送了密钥，但是却是用密钥进行的加密
  - 第三方不知道密钥是啥，所以也就解不开，也无法得到密钥
- 这样，对称密钥就会安全建立，并且只有通信双方知道

