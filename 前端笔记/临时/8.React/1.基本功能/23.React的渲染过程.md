# React的渲染过程
    
## React初始化渲染
1. 创建React元素树(为了辅助React虚拟dom树的产生， 就是一个普普通通的对象)
    1) 使用React.createElement()创建
    2) 使用语法糖JSX创建
    3) 需要注意的是，React.createElement是没有执行组件函数的功能的。
    4) 组件函数的执行是在生成虚拟dom树的时候执行的。
    5) `<></>或<React.Fragment></React.Fragment>`不被添加在React元素中，只是起一个辅助作用

简单模拟React元素树的结构，大体表现一下:
![Image text](page/44.jpg)。


2. 根据React元素树创建React虚拟dom树

虚拟dom树中的节点类型有一下几种:
    1) 文件节点: 通过document.createTextNode()创建
    2) dom节点:  通过document.createElement()创建
    3) 空节点:   null、undefined、false、true。创建占位符(空对象)
    4) 组件节点: 创建组件节点对象，执行对应的函数
    5) **注意**； 每个节点都是一个React创建的对象，内部有个属性，指向document创建的dom。
       并不是，直接进行创建。
       该对象开发者是获取不到的。
       由于`<></>或<React.Fragment></React.Fragment>`不被添加在React元素中，所有创建节点对象时也忽略它，不会创建。
       类组件，render之前的周期函数照常执行，componentDidMount在创建完该组件的虚拟dom(子组件也处理完毕)，把该方法加入队列中。当页面渲染完成后，依次从队列中取方法执行。
       在生成虚拟dom的时候，遇到组件，先执行组件。子组件解析完成，本组件的虚拟dom才会创建完成，才会把本组件的componentDidMount放入队列中。
       **所以子组件的componentDidMount先执行**。


示范说明:
```js
function B() {
    return <>
        <div>
            { null }
            123
        </div>
    </>
}
class C extends React.Component {
    render () {
        return <div>789</div>
    }
}

let A = <div>
    lsz,
    <C />
    <B />
</div>
```
生成的React虚拟dom树如下:
![Image text](page/51.jpg)。


3. 把虚拟dom树转换成真实的dom树，渲染到页面上
    按照虚拟dom树的节点对象，把对象内部产生的dom放入指定的位置(可能存在位置的改变)。
    渲染完成后，对虚拟dom进行保存。
    执行队列中的componentDidMount方法。


## React重新渲染的过程
    当类组件的状态发生变化时，
    触发一系列的周期函数，执行render时，又会产生一个React元素树。
    又开始解析新生成的React元素树。

1. 从初始渲染时创建的虚拟dom树中找出该组件所在的位置进行分析。并且为了节约性能，进行了大量的复用。

    1) 查看React元素与对应位置(React元素的第一个子元素，与虚拟dom树的第一个子元素)的节点类型是否相同(type是否一样)。如果一样，dom复用(不在创建新的dom，直接使用之前的dom)。

    2) 如果复用的节点有属性发生了变化，则进行记录，不立即进行修改。

    3) 如果是类组件，类组件环境复用。
       如果render中生成的React元素，使用了组件的状态，从复用的环境中获取。

    4) 递归分析子节点:
        普通节点，递归处理。
        函数组件，重新执行函数组件获取其对应的React元素，进行递归处理。
        类组件，调用重新渲染的周期函数，render执行后，得到React元素，进行递归分析。
        **重点: 如果一个函数组件或者类组件，在重新渲染时没有产生新的React元素，而是使用之前的。函数组件或类组件的重新渲染生命周期函数是不会重新执行的，直接使用之前生成的虚拟dom，包括该组件的子组件。会认为没有变化，节约性能**
        比如: return 中没有使用`<B />`(重新渲染时解析成新的React元素)，而是使用{ b }(b是B组件的React元素，但是在重新渲染时b没有更新)，此时B组件就不会进重新渲染(函数不会执行)
    
    5) 如果节点类型不同，则该节点对象，以及该节点对象的子节点对象会全部卸载，并不会立即卸载。   也是先记录下来。并且整个节点以及子节点都不会再进行比较，而是根据React元素产生一条新的  节点对象。
       如果节点是函数节点(包括子节点)，会先创建新的函数节点，然后执行函数，产生对应React元素，进行分析，生成对应的节点。
       如果节点是类节点(包括子节点)，会重新执行创建生命周期，生成全新的类组件环境。根据render产生的对应React元素，进行分析，生成对应的节点。
       

    6) 如果没有找到对应的节点。
       虚拟dom树上有两个节点，新React元素中有三个节点，最后一个节点找不到，重新创建一个节点对象，记录挂载的位置，不会立即挂载。

    7) 如果有多余的节点
       虚拟dom上有三个节点，新React元素中只有两个节点，dom树上的最后一个节点没有找到对应的节点，记录卸载位置，不会直接进行卸载。

    8) 处理完成，虚拟dom树开始更新，复用dom属性更新，节点更新，节点卸载，节点挂载。
       节点卸载的方式是递归卸载，按照dom树的结构，把一条分支完全卸载完成，在卸另一个分支的结构。
       如果是类组件被卸载，触发componentWillUpMount周期函数，所以所有该函数的运行是在整个创建周期之后(包括子组件的创建)。
       然后按照卸载的顺序触发componentWillUpMount周期函数

    9) 把修改后的dom，渲染到页面上。


2. dom更新完成，触发对应类组件中重新渲染过程中render后面阶段的生命周期函数。
    
    1) 从队列中读取执行，**子节点的周期函数先执行**。

    2) 父节点的render一执行，产生新的React元素，分析React元素，替换节点。此时如果遇到子节点，会进入子节点函数进行处理。此时父节点的render后面一系列声明周期函数还没有解析到。

    3) 当子节点render解析完成，把对应的生命周期函数放入队列中(可能父组件的render还有其他子组件分支，还没有解析完，所以不会进行执行，先进行存放)。
    
    4) 当所有子组件解析完成，父组件的生命周期函数才会存入队列中，最后存入的。

    5) 所以子组件的先执行，父组件的后执行。


## 重新渲染过程中样式复用引发的一些Bug

    
1. dom的复用出现的问题，通常表现在input标签上

需求:  有两个输入框，一个输入框输入姓名，一个输入框中输入学号。这两个输入框不同时显示，点击按钮进行切换。

代码: 
```js
class C extends React.Component {
    state = {
        a: true
    }

    render () {
        // 创建两种输入框需要的React元素
        let inp = null;
        if(this.state.a) {
            inp =  <div> 姓名: <input type="text" value="adfa" /> </div>
        }else {
            inp =  <div> 学号: <input type="text" value="adfa" /> </div>
        }
        return (
            <div>
                { inp }
                <button onClick= { this.clic } >按钮</button>
            </div>
        )
    }

    clic = () => {
        this.setState({
            a: false
        })
    }
}
```

现象:  文字进行了切换，input标签没有被切换，还是之前的input标签，表现为输入的内容依然存在

原因:  进行重新渲染时，input产生了复用。
       最外界div与之前相同，进行复用，行间属性没有变化，不操作
       input的父级div也进行了复用，行间属性没有变化，不操作
       文本节点还是文本节点，没有发生变化，节点复用，但是内容发生了变化，进行记录
       input还是input标签，于是也进行复用，一看行间属性没有变化(value不考虑，即使写上也不考虑)。input标签进行复用，不进行操作。
       在最终渲染时，修改记录的文本，input不进行操作。



2.  组件复用出现的现象(在结构的前面新添加一个组件，表现为后面添加了组件)

需求: 列表循环渲染，数组中是相同的组件，当按键按下时，在数组的前面新添加一个组件。并且每个组件可以修改内部的状态，点击一下数字加1。

现象: 当改变两个组件的状态，点击添加按钮，本该在上面创建一个全新的组件，状态为0，另外两个往下移。实际为在最后新创建了一个组件，状态为0，其它两个组件没变化。

代码:
```js
class C extends React.Component {
    state = {
        a: [<D />, <D />]
    }
    render () {
        return (
            <div>
                { this.state.a }
                <button onClick= { this.clic } >按钮</button>
            </div>
        )
    }
    // 在前面新创建一个组件
    clic = () => {
        this.setState({
            a: [<D />, ...this.state.a]
        })
    }
}

class D extends React.Component {
    state = {
        a: 0
    }

    render () {
        return (
            <div>
                { this.state.a }
                <button onClick= { this.clic } >按钮</button>
            </div>
        )
    }

    clic = () => {
        this.setState({
            a: this.state.a + 1
        })
    }
}
```

原因: 类组件环境的复用，在React元素生成的时候，D组件从两个变成了三个。
      在创建真实的dom的时候，发现第一个和之前的是同一个类组件，于是进行环境的复用，这样在从环境中取值的时候，取得还是之前环境状态中的值。
      到最后，发现最后一个组件没有匹配到，于是才进行重新的创建，状态为0。

总结:
    需求中如果类组件需要重新创建(状态初始化)，或者在某个类组件的前面在重新添加一个新的全新的相同组件时，**需要特别的注意环境复用的问题**。


3. 容易忽略的空节点问题
还是输入框切换的案例，如果换个写法，会发现可以实现切换效果了。原因就是空节点在作怪，引发了节点的重构。

```js
class C extends React.Component {
    state = {
        a: true
    }
    render () {
        return (
            <div>
                { this.state.a && <input type="text" /> }
                { !this.state.a && <input type="text" /> }
                <button onClick = { this.clic } >按钮</button>
            </div>
        )
    }
    // 在前面新创建一个组件
    clic = () => {
        this.setState({
            a: false
        })
    }
}
```

分析: 
    共有两个{}，当一个满足的时候，另一个为false，而false创建的是空节点。
    当下一次状态改变后，满足条件切换，空节点变成input节点，经过对比发现节点类型不同，直接舍弃之前的空节点，创建input节点。
    所以input可以正常的切换。


## key值的作用
    改变同等级下查询的顺序。
    
1. 当重新渲染时，默认第一个元素与第一个查询对比，即默认从第一个开始按照顺序进行查询。
    如果React元素上有key值，就不会按照正常的顺序进行查询，而是从dom树上同一级的节点上获取相同key值的节点，如果查询的节点类型与React元素的类型相同，进行dom或者环境的复用。
    
2. 虽然此处进行了复用，但是复用的位置是不同的，比如元素是第一个，但是复用了Dom树上的第二个节点。
    就会dom树对应的第一个节点踹掉，把复用的节点拿过来，但是不会立即踹掉，先进行标记。把节点对象拿过来。
    为了以后的复用(踹到的节点可能也有key，后面的节点可能要进行复用，所有不会立即踹掉。

    和新创建相比，少了创建dom的步骤，一定程度上优化了性能。

3. 如果没有找到key对应的值，直接进行重新创建，在相同位置的节点做个标记，表示该节点以及子节点将要被卸载，换成新的节点。

4. 而那些没有key属性的元素，正常按照对应位置的DOM节点进行比对，如果正常位置的节点有key，会认为节点不同，直接进行创建。在该位置做标记，表示该节点要被卸载，换成新的节点

5. 如果查询的位置没有key值，则正常比对，按照类型比对，相同就复用。



## 渲染总结
    
1. 根据React元素，产生对应的节点，位置与React元素所处位置相同。
    即使使用了key值复用节点，把其它位置的节点拿过来。React就会认为，React虚拟dom树上对应位置的节点是不同的，使用复用的节点替换掉当前的节点。

2. 重新渲染时，对dom树的操作，都是先进行记录，然后最后统一变化。

3. **React在调用函数组件时，会默认传入两个参数，默认为两个空对象**


