#### render props
1. 要解决的问题
   1. 这是一种封装组件思想，作用是提取公共代码，相当于数据加工厂。
   2. 比如有两个组件，它们获取的初始数据相同，对数据的处理过程相同。但是使用最终数据的进行渲染的样式不同
      1. 最终展示的样式不同，使用的数据，以及数据的处理过程相同，就可以把处理过程封装成一个组件，相当于封装函数
      2. 由于展示是不同的，所以不能进行封装，需要动态传入
      3. 由于展示使用到了处理好的数据，所以还需要接受数据
      4. 所以，把展示做成一个函数，想要使用数据的时候，就使用封装的组件，把展示函数传入
      5. 这样，就能使用一个组件展示出不同的效果
      6. **Consumer用的就是这个原理**
      7. 以上过程，就是render props思想，以及实现过程
      8. 共有两种实现方式
         1. 一种是 `HOC`，把展示函数，作为参数传入，构建出一个新的组件
         2. 一种是借助，children，展示函数作为子节点进行传入(这种方式，被称为`render props`)

    


2. 实现原理
   1. 定义一个组件
   2. 该组件的使用方式，子节点必须传入一个方法。该方法在组件内部的render会进行触发，这样父组件就可以接收到处理完成的数据。直接使用处理完成的数据进行显示不同的样式。 
   3. 如果定义的组件是一个纯组件，为了优化性能，需要把子节点传入的方法定义在外部。
      1. 这样使用该组件的父组件在render重新渲染的时候，传入的子节点函数索引是相同的，不会造成重新渲染。
      2. 如果直接写在组件的子节点位置，父组件render重新执行时，函数会重新构建，传入的索引不同，即使其他数据没有发生变化(不应该重新渲染)，也会造成重新渲染。


3. 示范代码
```js
class A extends React.Component {
    render() {
        return <B>
            {
                // 展示函数，Consumer用的就是这个原理，B就相当于 Consumer
                ({a}) => {
                    return <div>{ a }</div>
                }
            }
        </B>
    }
    
}

// render props，提取相同的功能，进行数据的处理
class B extends React.Component {
    state = {
        a: 123
    }
    
    componentDidMount() {
        this.setState({
            a: 456789
        })
    }
    
    render () {
        // 使用处理的数据，展示出不同的效果
        return this.props.children({...this.state})
    }
}
```

4. 比如，有两个组件，一个组件显示鼠标相对于容器的坐标，一个组件做方块跟随鼠标运动。
   1. 这两个组件，对坐标的处理时相同的，最后都是经过种种处理得到当前鼠标相对于容器的位置。
   2. 这样就可以把坐标的处理提取出来，做成render props组件。

