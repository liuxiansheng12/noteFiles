# 路由



## 路由模式

1. 分类
    路由共有两种模式，一种是哈希路由、一种是浏览器历史记录路由。
    现如今浏览器只支持这两种方式，跳转路径不刷新页面。


2. 使用
    在React的路由中，这两种模式其实就是两种组件，引用方式如下:

```js
// BrowserRouter组件对应浏览器历史记录路由(最常用的)
// HashRouter组价对应哈希路由
import { BrowserRouter, HashRouter } from "react-router-dom";

function A() {
    return (
        <>
            <BrowserRouter>
                <div>浏览器历史记录路由</div>
            </BrowserRouter>
            <HashRouter>
                <div>哈希路由</div>
            </HashRouter>
        </>
    )
}
```
通常让这两种模式(组件)作为最外层的父级，表示整个工程都位于路由环境的下面。
开发起来比较方便。
    

3. 作用
    创建上下文，传入一些参数。



## Route组件

1. 作用
    该组件是React实现路由功能的核心组件。
    该组件的作用就是匹配当前的路径，显示不同的组件内容。


2. 原理(工作方式)
    1) 初始工作
       1) React的核心是创建React元素，然后在根据React元素，生成对应的虚拟节点。
       2) 当React解析到Route组件时，创建组件节点。
       3) 然后在ReactDOM.render()的作用下，激活该组件的环境(执行相应的函数)
       4) 然后判断当前路径，是否满足该组件的匹配规则。
       5) 如果匹配成功，则立即处理传入的组件，生成对应的虚拟dom，挂载到该组件的下面。
       6) 如果匹配不成功，则组件不做任何处理。React就会跳出该组件，继续向下解析。

    2) 当路径发生变化时
       1) 整个Router组件就会被重新渲染
       2) 需要注意的是，由于整个Router下的children元素位于路由的执行期上下文环境中(Provider)。
       3) 当Router进行重新渲染的时候，底层其实是修改了执行期上下文的赋值对象，这才造成了Provider的重新渲染，从而使整个组件的重新渲染，但是Provider的重新渲染是进行了优化的
       4) **Provider的重新渲染，其实是Consumer组件的重新渲染，其它组件不会触发重新渲染**
       5) 比如: 
       ```js
       function A() {
           return <BrowserRouter>
               <B />
               <Route />
           </BrowserRouter>
       }
       ```
       其实，BrowserRouter重新渲染的时候，B组件和Route组件都没有触发重新渲染。
       由于Route下的children就是一个Consumer组件，重新渲染的是Consumer组件，重新进行路径的匹配，处理传入的component组件(造成后续一系列组件都会重新渲染)，这样就造成了Route组件重新渲染的现象。
       由于B不会重新渲染，所以B下一系列子元素都不会被重新渲染。


3. 使用方式

    1) 行间属性
        1) `path` 设置当前Route组件的路径匹配规则，当匹配成功，加载对应的组件。
           1) 可以直接赋值字符串
           2) 如果不写path，则所有路径都可以匹配成功，通常用于显示404界面
           3) 可以赋值数组
              数组的每一项，都为一个地址，只要有一个可以匹配成功，该组件都将进行加载。
           4) 动态路由，字符串的格式为/a/:?/:?，具体介绍在路由信息中。
              后面必须有`:`，这样才能进行动态匹配。
        2) `component` 路径符合所加载的组件
        3) `exact` 设置当前Route的路径匹配模式为完全匹配，默认是不完全匹配。
           比如: /a/b。不完全匹配: /a可以显示组件、/a/b也可以显示组价。
           完全匹配: 只有/a/b可以显示组件。
        4) `render`，该属性也是传递一个组件，与component属性的功能完全一样。
           匹配成功，加载对应的组件。但是不能与component属性共存，否则会失效。
        


    2) 子元素(children)
        与component、render属性功能一样
        当匹配成功时，对应Route下面的children才会被解析加载。


4. 注意点
    1) **Route组件可以写在任何的地方，但是必须位于BrowserRouter或者HashRouter环境的下面**
       该组件就是一个普通的组件，当路径符合，就解析对应的组件，不符合就不解析。


5. 示范代码
```js
import { BrowserRouter, Route } from "react-router-dom";

function A() {
    return (
        <BrowserRouter>
            <Route path="/" exact component={ B }></Route>
            <Route path="/c" component={ C }></Route>
            <Route path="/d" component={ D }></Route>
        </BrowserRouter>
    )
}

function B () {
    return <>我是B组件</>
}

function C() {
    return <>我是C组件</>
}

function D() {
    return <>
        {/* Route可以写在任意地方，当D组件被解析后，该Route就会被解析。
            然后与当前路径进行判断，符合就加载C组件，不符合就不加载 */}
        <Route path="/dadsf" component={ C }></Route>
        我是D组件
    </>
}
```



## Switch组件

1. 功能以及解决的问题
    1) 该组件需要配合Route组件来使用。
    2) Route为该组件的children属性。
    3) 作用: 循环遍历该组件下的children(即Route)，然后逐步与当前的路径进行匹配。
       如果匹配成功，则循环不在执行，直接显示该页面。

    4) 匹配方式: 从上到下，匹配成功就停止匹配。
    5) 解决的问题: 一个组件下面可能有多个Route，用来不同的地址显示不同的内容。
       如果Route使用的是不完全匹配，则一个路径可能匹配到多个组件进行显示，不符合要求。
       此时就可以使用Switch来进行限制，当匹配成功后，就不在继续向下匹配。


2. 注意点
    1) Switch下的第一级子节点必须为Route，不能随便乱写。
    2) 原因: Switch是按照children的顺序从上到下依次查询。
          如果在中间写了个div，无法处理，会直接报错。


3. 示范代码
```js
import { BrowserRouter, Route, Switch } from "react-router-dom";

function A() {
    return (
        <BrowserRouter>
            <Switch>
                <Route path="/" exact component={ B }></Route>
                <Route path="/c" component={ C }></Route>
                <Route path="/d" component={ D }></Route>
            </Switch>
        </BrowserRouter>
    )
}

function B () {
    return <>我是B组件</>
}

function C() {
    return <>我是C组件</>
}

function D() {
    return <>
        <Route path="/dadsf" component={ C }></Route>
        我是D组件
    </>
}
```



## Link组件

1. 作用
    生成一个可以进行无刷新跳转页面的a标签


2. 原理
    a标签默认是刷新跳转页面
    无刷新跳转页面，可以看成是阻止了a标签的默认事件。
    然后使用Router提供的push方法进行无刷新页面的跳转。


3. 使用方式
    1) 行间属性`to`, 设置跳转的地址，有两种赋值方式
       1) 字符串。可以写成/c?a=1#456这种格式，包括路径、数据、哈希
       2) 对象。
          1) 格式为{hash: ?, search: ?, pathname: ?, state: ?}
          2) 分别代表哈希、数据、地址、附加的状态信息(相当于push的第二个参数)
    2) 行间属性`innerRef`
       1) 该属性的属性值为一个自定义函数，并且函数可以接收一个参数。
       2) 接收的参数为内部的a元素对应的真实dom。


4. 示范代码
```js
import { BrowserRouter, Route, Switch, Link } from "react-router-dom";

function A() {
    return <BrowserRouter>
        <div>
            <Link to="/"> B </Link>
            <Link to="/a"> C </Link>
        </div>
        <div>
            <Switch>
                <Route path="/" component={ B } exact></Route>
                <Route path="/a" component= { C }></Route>
            </Switch>
        </div>
    </BrowserRouter>
}

function B() {
    return <div>B</div>
}

function C() {
    return <div>C</div>
}
```


## NavLink组件

1. 作用
    1) 是一种特殊的Link组件，Link组件有的功能该组件都有，除此之外还具有特殊的功能
    2) 组件通过设置的to与路径进行匹配，匹配成功，会添加特殊的class名`active`
       可以利用添加的class设置一些样式，表示当前进入的是该元素对应的页面
    3) 注意: 
       1) 添加class是使用匹配的方式，并不是点击那个NavLink，那个NavLink就添加class。
       2) 默认使用的也是不完全匹配。


2. 使用
    1) 行间属性`to`, 设置跳转的地址，有两种赋值方式
       1) 字符串。可以写成/c?a=1#456这种格式，包括路径、数据、哈希
       2) 对象。
          1) 格式为{hash: ?, search: ?, pathname: ?, state: ?}
          2) 分别代表哈希、数据、地址、附加的状态信息(相当于push的第二个参数)
    2) 行间属性`innerRef`
       1) 该属性的属性值为一个自定义函数，并且函数可以接收一个参数。
       2) 接收的参数为内部的a元素对应的真实dom。

    3) 行间属性`activeClassName`，设置匹配成功时添加的class，而不是active
    4) 行间属性`activeStyle`，设置匹配成功时添加的行间样式
       数据格式为对象，或者普通的字符串
    5) 行间属性`exact`，设置匹配方式为完全匹配



3. 示范代码
```js
import { BrowserRouter, Route, Switch, NavLink } from "react-router-dom";

function A() {
    return <BrowserRouter>
        <div>
            <NavLink to="/" exact> B </NavLink>
            <NavLink to="/a"> C </NavLink>
        </div>
        <div>
            <Switch>
                <Route path="/" component={ B } exact></Route>
                <Route path="/a" component= { C }></Route>
            </Switch>
        </div>
    </BrowserRouter>
}

function B() {
    return <div>B</div>
}

function C() {
    return <div>C</div>
}
```   



## Redirect组件

1. 作用
    该组件用于路径的重定向


2. 使用
    1) 放在Route组件的下面使用，并且Route组件和该组件必须被Switch组件包裹
    2) **当所有的Route组件都没有匹配到，进入Redirect组件进行路径重定向**
    3) 通过行间属性to设置重定向路径，有两种赋值方式
       1) 字符串。可以写成/c?a=1#456这种格式，包括路径、数据、哈希
       2) 对象。
          1) 格式为{hash: ?, search: ?, pathname: ?, state: ?}
          2) 分别代表哈希、数据、地址、附加的状态信息(相当于push的第二个参数)
    4) 行间属性`from`
       1) 该值也是设置路径，只有当前路径与from设置的路径匹配成功，才进行跳转。
       2) 默认为不完全匹配，可以通过设置exact，为完全匹配。
       3) 如果该属性不设置，则任何路径都可以进行跳转。
       4) 属性值还可以写成/a/:id的方式。只要是/a/?的路径都可以匹配成功
          1) 甚至from还可以把匹配到的id，传给to。to的写法为/?/:id，/:id要保持一致。
          2) 比如当前路径为/a/100abc，to设置的为/dd/:id。
          3) 则跳转的地址就变成/dd/100abc，from把匹配到的id传个了to，供to使用。



3. 示范代码
```js
import { BrowserRouter, Route, Switch, Link, Redirect } from "react-router-dom";

function A() {
    return <BrowserRouter>
        <div>
            <Link to="/"> B </Link>
            <Link to="/a"> C </Link>
        </div>
        <div>
            <Switch>
                <Route path="/" component={ B } exact></Route>
                <Route path="/a" component= { C }></Route>
                <Redirect to="/"></Redirect>
            </Switch>
        </div>
    </BrowserRouter>
}

function B() {
    return <div>B</div>
}

function C() {
    return <div>C</div>
}
```



## 路由信息(Route组件向引用组件的props传入的数据)

1. 向引用组件的props共传入三个参数，分别为:
    1) history对象
    2) location对象
    3) match对象


2. history对象，该对象主要提供一些方法
    1) **`push`方法(重要)**
       该方法最常用，作用为无刷新跳转路径(React实现路由的核心方法)
       1) 该方法与`window.history.pushState`方法的区别。
          1) 该方法内部使用了window.history.pushState实现无刷新跳转路径。
          2) 除此之外，还添加了其它的作用
          3) 可以让React感知到路径已经发生了变化，从而激活dom树上的所有Route组件。
          4) 该方法可以兼容哈希模式与浏览器历史记录模式两种情况
       2) 为什么不直接使用`window.history.pushState`
          1) 该方法只能适应一种模式，如果模式发生变化，还需要大量修改代码
          2) 该方法修改路径，React无法感知，页面不会发生变化
    
    2) 只要push一经调用，哪怕路径没有发生变化，还是之前的路径
       **虚拟dom树上挂载的所有Route组件依旧重新渲染判断**
       看似没有变化，其实已经向历史记录栈中压入了新的路径(和之前的一样)。
       所以Route组件会重新渲染判断。

    3) push中除了传入路径外，还有第二个参数，可以向将要加载的组件中传入数据。
       将要加载的组件通过location对象中的state属性获取。


3. location对象
    1) 该对象是对路径的处理，内部常用的有三个属性。
       1) `hash`。可以获取到当前路径的锚点
       2) `search`。可以获取到当前路径所传的参数、
       3) `pathname`。可以获取到当前的路径。

    2) 不同路径对应的不同组件间的传参通常使用路径传参的方式。
       使用的就是这三个属性进行数据的传递。

    3) 该对象通常与`query-string`组件配合使用
       1) `query-string`组件作用是解析hash或者search。
       2) 解析后的hash或者search从字符串变成了对象格式，方便了路由间的传参
       3) 该组件的下载方式`npm install query-string -D`
       4) 使用方式: `import qs from "query-string"`、`let a = qs.parse(?)`


4. match对象
    1) isExact属性，该属性有两个状态值，一个为false，一个为true。
       用来表示当前的Route组件的path设置的地址，是否与当前路径完全一致，数据锚点不算。
       即是否是完全匹配，这里的完全匹配与exact没有关系。

    2) **params属性**(重要)
       该属性可以获取地址上的数据(不是锚点和参数)，是实现动态路由的关键。
       1) 使用方式
          1) 如果当前路径为/dong/10/6/8/djis，想要获取dong后面的数据。
             1) Route行间path定义为: /dong/:a/:b/:c/:d。
             2) 这样Route加载的组件中的params属性为: { a: 10, b: 6, c: 8, d: djis}
          2) 如果想要实现，存在就获取，不存在就为null的效果。
             1) Route行间path定义为: /dong/:a?/:b?/:c?/:d?/:f?，在后面加上?
             2) f没有对应的地址，所以为null。
          3) 如果某位不想获取，但是还必须存在
             1) 可以使用，path可以使用/*代替一位，或者使用不完全匹配。
          4) path还可以使用正则来限制类型
             1) 比如/dong/:a(\d+)/:b，表示a对应的数据必须为1~位的数字，()中写正则表达式。




## 其它组件获取路由信息
路由信息，只能在Route组件通过component属性传入的组件中使用。
如果是传入组件的子组件，是无法使用到路由信息的，因为没有传入。


1. 方法1(常用)
    1) 方法
    可以使用react-router-dom中提供的一个方法`withRouter`进行包装。
    该方法是一个高阶组件，接收一个组件，返回一个组件。
    在Router环境下使用返回的组件，就可以向传入的组件传递路由信息。

    2) 原理
    withRouter返回的组件中，获取执行期上下文中的路由数据，然后打入传入的组件。
    路由的执行期上下文，开发者获取不到，但是内部的方法可以获取到，然后进行传入。

    3) 注意
       1) 使用withRouter进行包装的组件，每次路由发生变化，包装的组件都会进行重新渲染。
       2) 函数组件的重新渲染就是重新执行函数，使用时需要注意。
       3) 重新渲染的原因: 
          1) withRouter的底层使用上下文的Consumer组件包装了一下。如果没有位于Route组件中，Router重新渲染，其实是执行期上下文重新渲染，即Consumer组件重新渲染。这样就造成了被包装组件的重新渲染。
          2) 如果位于Route组件中，会因为Route组件的重新渲染而重新渲染。


2. 方法2(不常用)
    既然Route组件可以向某个组件中，自动注入路由信息
    我们就可以使用该组件对要使用路由信息的组件进行包装。



## 自定义特殊功能的Route组件

1. 应用
    1) 某个路径对应的组件，在加载的时候需要进行特殊的处理。
    2) 比如某个路径对应的页面在进入的时候，需要验证权限。
       如果没有权限，则跳转到指定的权限授权页面。
    3) 解决方法
        1) 如果在页面组件中进行权限的判断，可以实现。
           但是受限制的页面过多，每个页面都进行权限的判断，有些麻烦。
        2) 使用高级组件进行组件的包裹，或者自定义HOOK，可以实现。
        3) 自定义一个Route组件，该组件内部进行判断，符合条件，加载传入的组件。
           底层还是借助Route进行页面的匹配。

2. 开发思路
    1) 自定义Route要有Route的功能，即可以感知页面路径是否发生变化。
       所以还是需要借助Route组件。
    2) 利用Route组件的render属性或者component属性。
       属性值不在是模板函数，而是自定义函数。
    3) 这两个属性向Route组件中传入数据。
       当路径匹配成功，Route组件就会解析传入的数据，即执行传入的自定义函数。

    4) 传入模板，其实传入的就是一个函数，所以可以直接在这两个属性中自定义函数
       进行特殊的处理(比如权限的验证)。
       验证通过，则返回传入的组件，这样传入的组件就会挂载到Route下进行解析。
       验证失败，则返回Redirect组件，这样Redirect组件就会挂载到Route下进行解析。
       只要Redirect一解析，就会进行路径的跳转。


2. 具体的示范代码
```js
// 需要结构传入的参数，其中一些不需要的东西，可以提取出来
// 把component属性换个名字，变成组件的写法，这样可以通过<>进行使用。
function ZdyRoute({component: Component, render, ...prop}) {
    let a = false;
    // 返回Route组件，这样组件就挂载到了自定义组件下面，当自定义组件解析的时候
    // 解析到子组件，Route就会被解析，进行路径的匹配，实现功能
    return <Route {...prop} render={
        () => {
            // 表示验证通过，Route在解析子元素时，就会解析该元素
            if(a) {
                return <Component />
            }else {
                // 验证失败，Route在解析子元素时，就会解析该元素，进行路径的跳转
                // 并且把当前的路径传入，告诉权限验证页面，是从哪个路径跳过来的
                // 这样验证成功后，就可以立即在跳回来
                return <Redirect to={ {
                    pathname: "/c",
                    state: prop.location.pathname   // 传递的数据
                } } />
            }
        }
    }/>
}
```



## 一级路由(利用NavLink和Route开发一级路由)

```js
import { BrowserRouter as Router, Route, Switch, NavLink } from "react-router-dom";

class A extends React.Component{
    render () {
        return (
            <Router>
                <div className="nav">
                    <NavLink to="/b">香蕉</NavLink>
                    <NavLink to="/c">西瓜</NavLink>
                </div>
                <div className="route">
                    <Switch>  
                        <Route path="/b" component={ B }></Route>
                        <Route path="/c" component={ C }></Route>
                    </Switch>
                </div>
            </Router>
        )
    }
}

function B(props) { 
    return <>子组件B</>
}

function C(props) { 
    return <>子组件C</>
}
```

## 多级路由
在那一页使用多级路由，就在那一页像操作一级路由的方式写二级路由即可。

1. 原理: Route的匹配特性，以及可以用在任意的地方
    以二级路由为例。
    二级路由代码写在对应的一级路由的组件中。
    当路径符合一级路由时，就会解析一级路由组件，自然可以解析到内部的Route等组件。
    只要路径符合对应的Route，就会加载对应的组件，这样就形成了二级路由的效果。


2. 多级路由路径的问题
    1) 多级路由的路径肯定要依赖前一级路由的路径
       比如一级路由的路径为/a，则二级路由的路径就要为/a/?。
       
    2) 如果二级路由过多，后期一级路由的路径有发生了变化，这样修改起来就非常的麻烦。

    3) 如果有一个忘记修改了，就会发生下列问题
       1) 如果是Link或者NavLink忘记修改，当点击的时候，路径发生变化。
          此时父级路由的Route就匹配不到，此时组件就会被卸载。
          父级一卸载，子级也完了，路由自然就出现了大问题。
       2) 如果是Route忘记修改，则匹配不到，不显示。


3. 解决方法
核心为: 多级路由的路径，由前一级路由的路径进行自动拼接而成，方法有多种。
    
    1) 单独建立一个路径的js文件，建一个对象，统一对路径进行管理
       这样修改起来就不会漏掉，修改起来也有些麻烦

    2) 单独建立一个路径的js文件，建一个对象，统一对路径进行管理
       建的对象，符合路由的层级。
       然后在创建一个专门解析该对象的方法，按照层级进行路径的拼接，生成多级路由使用的路径
       这样在修改路径的时候，只需要修改一级，就可以。
    
    3. 在组件的内部，利用传入的路由参数(比如match.url或者location.pathname)。
       取出匹配成功的路径，即前一级路由的路径。
       然后在路径的地方使用字符串拼接的方式，拼接出对应的路径
    


## 动态路由

1. 原理分析
    1) 动态路由的核心为，一个路径固定，后面其它的路径可以随机，达到动态匹配的效果。
       比如: /a/1000、/a/10001。

    2) 动态路由的核心是Route组件的路径匹配规则，要达到动态匹配的功能。
       1) 路径使用`:`就能达到动态匹配的效果。比如/a/:id
       2) 只需要在组件内部判断:id对应的数据。
          不同数据显示不同内容，这样就产生了动态路由的效果。
       3) 不可以写/a进行不完全匹配，否则获取不到动态数据(id值)
       



2. **动态路由组件的使用非常容易出现问题的地方**
    1) 问题
       **动态路由对应的组件，如果是类组件**。
       当地址发生变化时，Route一解析，发现符合路径，继续加载该组件。
       此时类组件由于节约性能，会进行环境的复用，直接进入重渲染阶段。
       如果使用在componentDidMount中，获取id，然后进行判断，显示指定的内容。
       当路径发生变化，环境复用，componentDidMount是不会再执行的。

    2) 造成的后果: 动态路由切换，页面没有发生变化
    3) 解决的方式: 在componentDidMount和componentDidUpdate中都对id进行获取
       并且进行判断加载对应的内容。
    4) 如果是函数组件，就没有问题，函数组件每次都重新执行。


3. 组件中获取动态路由地址后面的id数据(动态路由开发的关键)
    通过`props.match.params.id`就可以获取到动态路由地址后面的id。
    **注意: 如果Route没有设置/:id，即利用不完全匹配的规矩匹配成功的，是无法通过params属性，获取id的**。


4. 示范代码
```js
import { BrowserRouter as Router, Route, Switch, NavLink } from "react-router-dom";

class A extends React.Component{
    render () {
        return (
            <Router>
                <div className="nav">
                    <NavLink to="/dong/1000" exact>香蕉</NavLink>
                    <NavLink to="/dong/1001">西瓜</NavLink>
                </div>
                <div className="route">
                    <Switch>  
                        <Route path="/dong/:id" component={ C }></Route>
                    </Switch>
                </div>
            </Router>
        )
    }
}

function C(props) {
    console.log(props.match.params.id);  
    return <>子组件</>
}
```



## 路由间的数据传递
两种方式，一种使用push的第二个参数进行数据的传递，一种使用路径进行数据的传递。



## 静态路由

1. 简单介绍
   1) 和动态路由的差别
      1) 以上的路由写法都是动态路由的写法，即路由的信息在组件中动态的写出来，位置不固定。
      2) 动态路由的好处在于灵活。
      3) 但是相对于静态路由来说，不容易维护。
   
   2) 静态路由，是把所有的路由信息统一写在一个js文件中，便于后期的维护。
      和vue中的路由使用十分相似。


2. 方式
    1) 需要自己单独进行封装，Router中并没有提供这样的写法。
    2) 方法: 在一个数组中，定义出所有的路由信息(和vue一样)
    3) 核心: 自定义数组解析方法，把对应的路由信息解析成对应的Route组件。
    4) 原理: 底层还是借助Route组件，只不过进行了统一管理。


3. 解析路由数组的常用方式，以涉及子路由为例
    1) 核心思想为: 子路由对应的Route组件
       在父路由传入的组件中进行定义，父路由匹配成功，才显示子路由。
    2) 方式: 
       1) 在统一解析路由信息数组的时候，如果该路由有子路由。
       2) 把生成的子路由对应的Route组件，通过行间传值的方式，传入组件中
       3) 这样路由加载的的组件中，就可以使用到传入的Route组件，进行子路由的匹配。


4. 具体的示范代码
```js
import { BrowserRouter, Route, Switch, NavLink } from "react-router-dom";

/**
 * 定义路由信息的数组(可以单独封装到一个js文件中)
 */
let RouterArr = [
    // 一级路由信息
    {
        path: "/",
        name: "home",
        exact: true,
        component: Home
    },
    {
        path: "/z",
        name: "z",
        component: Z,
        children: [
            // 子路由信息
            {
                // 这样写的目的在于，运算完子路由的第一个页面路径与父路由一样
                // 这样就能在一开始就加载第一个子路由信息。
                // 或者不写path。
                path: "",  
                name: "z",
                exact: true,
                component: Z1
            },
            {
                path: "z2",
                name: "z2",
                component: Z2
            },
        ]
    }
]

// 解析路由信息的方法(生成一级路由对应Route组件，子路由进行传入)
function a(data, url) {
    // 是回调生成子路由还是第一次调用生成一级路由
    let route = data || RouterArr;
    // 生成路径对应的Route组件
    let RouteM = route.map( (ele, i) => {
        // 结构信息
        let {path, component: Component, name, children, ...prop} = ele;
            
        return <Route {...prop} key={i}
            // 由于path中不能写函数，但是可以写表达式，所以需要变换立即执行函数
            path={ (() => {
                // 查看是否有path，没有使用父级路径，有就进行拼接，服务子路由。
                if(!path && url) {
                    return url
                }else if(url){
                    return url + "/" + path;
                }else {
                    // 一级路由
                return path;
                }
            })() }
            // 设置路由匹配成功加载的组件，如果有子路由，需要传入子路由对应的Route组件
            // 匹配成功，执行函数，进行组件的处理，也可以使用render函数
            component={ () => {
                // 如果存在子路由，传入子路由对应的Route组件
                if(children && typeof children === "object") {
                    return <Component>
                        {/* 进行递归创建子路由 */}
                        { a(children, !url ? path : url + "/" + path) }
                    </Component>
                }else {
                    // 如果没有不需要进行处理
                    return <Component />
                }
            } }
        />
    } )

    return <Switch>
        { RouteM }
    </Switch>;
}

function RouteJie() {
    // 解析路由文件
    return a();
}


// 主页面
function A() {
    return <BrowserRouter>
        <div>
            <NavLink to="/" exact> 主 </NavLink>
            <NavLink to="/z"> 子 </NavLink>
        </div>
        <div>
            {/* 启用解析路由信息的组件，开始解析路由信息，生成对应的一级路由Route组件
                子路由Route会进行传入 */}
                <RouteJie />
        </div>
    </BrowserRouter>
}

function Home() {
    return <div>主页面</div>
}
// 涉及到子路由
function Z(props) {
    return <>
        <div>子路由导航页面</div>
        <div className="nav">
            <NavLink to="/z">子1</NavLink>
            <NavLink to="/z/z2">子2</NavLink>
        </div>
        <div>
            {/* 使用传入的对应的子路由Route组件 */}
            { props.children }
        </div>
    </>
}
function Z1(props) {
    return <div>子路由页面1</div>
}
function Z2(props) {
    return <div>子路由页面2</div>
}
```


## 导航守卫函数
Router中并没有提供导航守卫函数，要想实现导航守卫函数，需要自己进行自定义
导航守卫，共分为三种情况
1. 当前组件感知到路由的变化，处理某些事情，但是并不会对切换造成任何阻塞
2. 当前组件感知到路由即将发生变化，判断是否达到了跳转条件
   达到才允许进行跳转，达不到，不进行跳转
3. 某个组件是否达到了进入的条件，达不到在退回到之前的路由

### 监控路径的变化

1. 借助的方法为，路由参数history中的`listen`方法。
   

2. 使用方式
    1) 该方法接收一个参数，参数为一个函数。
       1) 当路径发生变化时，传入的方法执行。
       2) 方法执行时会接收到几个参数
          1) 第一个参数，location对象，记录当前的地址信息
          2) 第二个参数，action，一个字符串，表示进入该地址的方式，共分为一下几种:
             1) POP: 出栈(页面回退)
                1) 通过点击浏览器后退，前进
                2) 调用history.go
                3) 调用history.goBack 
                4) 调用history.goForward

             2) PUSH: 入栈
                1) history.push
                2) 点击Link、NavLink组件生产的标签，底层调用的就是history.push方法

             3) REPLACE: 替换
                1) 调用history.replace

    2) listen方法存在返回值，返回值为一个函数，调用该函数可以销毁注册的方法

    3) 获取当前路径和即将要跳转的路径
       1) 当前路径: 通过props.location.pathname
          由于注册的方法是运行在路径即将发生变化，但是还没有进行变化的时候
          所以通过该方法获取的就是当前的路径
       2) 即将要跳转的路径: 通过注册方法的传参，location.pathname

3. 注意事项
    1) 该方法并不会随着组件的销毁而销毁，会一直工作。
        1) 只要该组件被执行，注册了函数。
        2) 哪怕路由切走，在别的组件进行路由的切换
        3) 本组件注册的方法还是会执行的。
    2) 该方法可以重复使用，处理方式为把注册的方法放入一个队列中
        1) 当路径发生变化，会一个一个的执行队列中的方法。
    3) 问题(重点): 
        1) 一个组件中注册了一次函数
        2) 但是路由切换时并没有把注册的方法销毁，下次路径在切回来时，就又注册了一次。
        3) 所以，每个组件使用listen注册方法时，一定要加上组件销毁也销毁注册函数的处理方式。
           如果想要监控多个路由页面，就把listen的使用往上提升，包裹住具体的Route组件。

    4) 注册的方法如果没有在组件销毁时进行销毁
       如果注册的方法中有获取当前路由的代码，则也受**闭包的影响**


 
4. 该方法通常用于打印路由日志
    1) 由于要监听整个路由，所以通过把该方法在最顶级组件中使用。

    2) 开发思路
       1) 路由的最顶级为BrowserRoute组件，或者HashRoute组件。
       2) 所以为了要监听整个路由，需要创建一个组件，包裹住整个Router组件下的内容。
       3) 又为了在写法上和正常的保持层级一致，把Router组件也封装进去。
       4) 这样外界只需要使用自定义组件即可，不需要再写Router组件，写法上保持了层级一致。

    3) 具体代码
    ```js
        import { BrowserRouter, Route, Switch, NavLink, withRouter } from "react-router-dom";

        function A() {
            return <RiZhi listen={ (pathnameD, pathnameX) => {
                console.log(`从${pathnameD}跳到了${pathnameX}`)
            } }>
               <div className="nav">
                   <NavLink to="/" exact>导航一</NavLink>
                   <NavLink to="/c">导航二</NavLink>
               </div>
               <div>
                   <Switch>
                        <Route path="/" exact component={ B }></Route>
                        <Route path="/c" component={ C }></Route>
                   </Switch>
               </div>
            </RiZhi>
        }

        // 封装打印日志文件
        function RiZhi(props) {
            return <>
                <BrowserRouter>
                    <Listen { ...props }/>
                    { props.children }
                </BrowserRouter>
            </>
        }
        // 注册listen方法的组件，由于该组件获取不到路由数据，所以需要使用withRouter进行包裹
        // withRouter会导致当路径发生变化，组件重新渲染
        // 所以使用函数组件注册listen，函数组件需要使用HOOK
        class Lis extends React.Component{

            componentDidMount() {
                // 如果没有传递该方法，说明不想监听路径变化
                if(this.props.listen) {
                    let a = this.props.history.listen( (location) => {
                        // 虽然listen会产生闭包的现象，但是由于组件被withRouter函数进行包装
                        // 每当路径发生变化时，组件进行重新渲染，传入的路由信息是最新的。
                        let pathnameD = this.props.location.pathname;
                        let pathnameX = location.pathname;
                        this.props.listen(pathnameD, pathnameX);
                    } )
                }
            }

            render() {
                return null
            }
        } 
        const Listen = withRouter(Lis);

        function B(props) {
            return <>B</>
        }
        function C() {
            return <>C</>
        }
    ```



### 对路径跳转加限制(阻塞路径跳转)

1. 基础设置，需要两个属性，配合使用
   1) 一个是history中的方法，`history.block()`
   2) 一个是Router组件上的行间属性`getUserConfirmation`传参(传递的也是一个方法)
   该属性有默认值


2. 使用方式
    1) 启用history.block，传入一个数据，只能传递字符串，传递其它类型的参数阻塞无效。
    2) getUserConfirmation中传入的方法可以接收到history.block中的方法
    3) getUserConfirmation中传入的方法接收到的第二个参数是一个函数
       1) 调用该函数，传入true，则允许本次跳转。
       2) 调用该函数，传入false，则阻止本次跳转。
       3) 不调用该函数，页面是无法进行跳转的
    4) history.block也有一个返回值，返回值为函数，调用该函数，可以取消页面阻塞
    5) history.block不写，getUserConfirmation是不起作用的


3. 注意点:
    1) history.block方法也是不会随着组件的销毁而销毁的
       即路由即使切换到了其它的路径，该阻塞也会对其产生影响
    2) 如果history.block没有被销毁，有调用了一次，则控制台弹出警告，阻塞以本次为准。
       getUserConfirmation中传入的方法接收到的第一个参数是新的block设置的。
    3) 为了防止组件间阻塞的相互影响，组件销毁的时候，调用block返回的函数，销毁阻塞
       如果是全局监控，则把block的范围往上提升，包裹住具体的Route组件。
    4) 在listen中启用block，对本次跳转无影响，但是对下一次跳转就开启了阻塞判断
       1) listen发生的时候，路由已经准备跳转，此时开启block已经没有用了
       2) 由于block不会销毁，本次没有用，但是却会作用于之后的路由切换

    5) Router组件的行间属性getUserConfirmation，**只能赋一次值**。
       即哪怕Router组件进行了重新渲染，getUserConfirmation中引入的函数发生了变化
       但是getUserConfirmation使用的还是初始赋的函数，和引用固化相同。
    
    6) getUserConfirmation属性传入的函数接收的第二个参数(是否允许跳转函数)
       **无论在那个地方调用，都可以进行是否跳转的操作**
       即通过调用，把该方法传入了其它的函数中进行调用，也能实现是否跳转。




4. 具体组件实现路径阻塞的效果(该组件满足条件，才允许跳转)
    1) 思路
       1) 封装出一个开启路径阻塞的组件，在需要的组件内使用
       2) 当监听的组件满足条件，就会进行跳转，则组件卸载
       3) 对应的封装组件也会被卸载，路径阻塞取消，下一次在进该组件的时候，重新创建。
          由于组件可能进行重新渲染，所以block函数需要在componentDidMount或者useEffect(, [])中创建，确保重新渲染不会再次调用block方法。
       4) 由于不同的子组件，处理页面跳转的方法不同
          由于getUserConfirmation重新渲染不会造成函数引用的改变
          所以不能直接赋值某个组件处理页面跳转的函数，而是应该进行调用

    2) 以输入框为例，当输入框中有内容时弹出是否进行跳转的提示框，点击确定进行跳转。
    ```js
    import { BrowserRouter, Route, Switch, NavLink } from "react-router-dom";
    import { useEffect } from "react";

    const block = {
        // 保存每个组件处理页面跳转的函数，存储方式有多种。
        confirmation: null,
        Block: (props) => {
            return <BrowserRouter getUserConfirmation={ (data, callBack) => {
                // 不能进行赋值，需要进行调用
                if(block.confirmation) {
                    block.confirmation(data, callBack);
                }else {
                    callBack(true)
                }
            } }>
                { props.children }
            </BrowserRouter>
        },
        Fblock: (props) => {
            // 确保某个组件开启页面阻塞的block只执行一次
            useEffect( () => {
                // 保存阻塞器
                let blockZ = null;
                // 是否开启阻塞
                if(props.confirmation) {
                    // 把组件具体的处理阻塞的方法进行传入
                    block.confirmation = props.confirmation;
                    // 开启阻塞
                    blockZ = props.history.block("");
                }
                
                // 组件卸载时，关闭阻塞处理
                return () => {
                    // 如果已经开启就关闭，没有开启不处理
                    blockZ && blockZ();
                }
            }, [])
            return null;
        }
    }
    // 分解组件
    const { Block, Fblock} = block;

    function A() {
        return <Block>
           <div className="nav">
               <NavLink to="/" exact>导航一</NavLink>
               <NavLink to="/c">导航二</NavLink>
           </div>
           <div>
               <Switch>
                    <Route path="/" exact component={ B }></Route>
                    <Route path="/c" component={ C }></Route>
               </Switch>
           </div>
        </Block>
    }

    class B extends React.Component {
        state = {
            value: ""
        }
        render () {
            return <>
                {this.state.value}
                <Fblock confirmation={ (date, callBack) => {
                    // 有内容不允许跳转
                    callBack(this.state.value ? false : true);
                }  } {...this.props} />
                <input type="text" value={ this.state.value } onChange={ (e) => {
                    this.setState({
                        value: e.target.value
                    })
                } }/>
            </>
        }
    }

    function C(props) {
        return <>C</>
    }
    ```

    3) react-router-dom中，提供一个组件`Prompt`，该组件有两种使用方式
       
       1) 行间属性`message`，传入一个函数。
          1) 该函数会在页面即将跳转时执行
          2) 如果执行返回false，则禁止跳转；如果返回true，则允许跳转
          3) 也能实现对一个页面进行离开守卫的工作
       2) 行间属性`when`传递true，开启阻塞，行间属性`message`传递一个字符串。
          表现形式为: 进行跳转时，询问是否进行跳转，点击确定可以跳转，点击取消禁止跳转
          行间属性message传递的字符串作为提示文字，其实就是getUserConfirmation传递的方法的第一个参数。


5. 监控全局的示范代码(和监控全局的listen封装在一块)
```js
import { BrowserRouter, Route, Switch, NavLink, withRouter } from "react-router-dom";

function A() {
    return <RiZhi listen={ (pathnameD, pathnameX) => {
        console.log(`从${pathnameD}跳到了${pathnameX}`)
    } }  block={ (date, callBack) => {
        console.log(date, 123);
        callBack(true);
    } }>
       <div className="nav">
           <NavLink to="/" exact>导航一</NavLink>
           <NavLink to="/c">导航二</NavLink>
       </div>
       <div>
           <Switch>
                <Route path="/" exact component={ B }></Route>
                <Route path="/c" component={ C }></Route>
           </Switch>
       </div>
    </RiZhi>
}

// 封装打印日志文件
function RiZhi(props) {
    return <>
        <BrowserRouter getUserConfirmation={ (date, callBack) => {
            props.block(date, callBack);
        } }>
            <Listen { ...props }/>
            { props.children }
        </BrowserRouter>
    </>
}


class Lis extends React.Component{
    componentDidMount() {
        // 如果没有传递该方法，说明不想监听路径变化
        if(this.props.listen) {
            let a = this.props.history.listen( (location) => {
                // 虽然listen会产生闭包的现象，但是由于组件被withRouter函数进行了包装
                // 每当路径发生变化时，组件进行重新渲染，传入的路由信息是最新的。
                let pathnameD = this.props.location.pathname;
                let pathnameX = location.pathname;
                this.props.listen(pathnameD, pathnameX);
            } )
        }
        // 如果没有传递该方法，说明不想进行页面的阻塞
        if(this.props.block) {
            let a = this.props.history.block("")
        }
    }

    render() {
        return null
    }
} 
const Listen = withRouter(Lis);

function B() {
    return <>B</>
}
function C() {
    return <>C</>
}
```



### 判断进入条件是否满足(不满足退回之前的路径)
使用listen监控全局的路由变化，当路由发生变化时，进行保存。
某个组件进入的判断可以在componentDidMount中完成。当不满足使用history.push()跳回之前的页面。



## 页面切换动画

1. 自定义Route组件实现动画切换
   1) 思路
       1) 不同页面的显示与否需要与路径进行匹配
          所以自定义Route组件需要实时监控路径的变化
          可以借助withRouter方法，对匹配路径完成组件显示的自定义组件进行包裹
          由于路径改变，所有的withRouter包裹的组件都会进行重新渲染
          此时就可以根据Route组件行间传参path，与当前点击的路径(location.pathname)做比较。
          相同的则为显示，不同的则为销毁。
       2) 动画控制的是一个页面的销毁，另一个页面的创建
          所以最好用的是TransitionGroup组件
          需要注意，该组件下只能跟CSSTransition或者Transition组件。

    2) 示范代码
    ```js
    import { BrowserRouter, NavLink, withRouter } from "react-router-dom";
    import { CSSTransition, TransitionGroup } from "react-transition-group"

    function A() {
        return <BrowserRouter>
           <div className="nav">
               <NavLink to="/" exact>导航一</NavLink>
               <NavLink to="/c">导航二</NavLink>
           </div>
           <div>
                <Route path="/" exact component={B}></Route>
                <Route path="/c" component={C}></Route>
           </div>
        </BrowserRouter>
    }
    
    class Route extends React.Component {
        state = {
            Component: null
        }
        componentDidMount () {
            // 使用withRouter创建组件，
            let component = withRouter(this.fuzhu);
            this.setState({
                Component: component
            })
        }
        render() {
            // 使用withRouter创建的组件
            const Component = this.state.Component;
            return <>
                { Component && <Component {...this.props} /> }
            </>
        }
        // 辅助组件(该组件被withRouter包装，所以当路径发生变化，该组件重新执行)
        fuzhu = (props) => {
            // 判断当前组件是显示还是隐藏
            let boo = props.path === props.location.pathname;
            // 启用动画，不渲染默认父级
            return <TransitionGroup component={ null }>
                {boo && <CSSTransition timeout={500} key={boo}>
                    <props.component />
                </CSSTransition>}
            </TransitionGroup>
        }
    }

    function B(props) {
        return <div>CDDD</div>
    }

    function C(props) {
        return <div>dfad</div>
    }
    ```



## 路由切换后滚动条复位

1. 问题
    1) 由于路由模式是无刷新更改页面，如果两个页面都存在滚动条
    2) 并且某个页面在浏览时，滚动条进行了滚动。然后进行页面的切换
    3) 切换后滚动条的位置是不会发生变化的


2. 解决方法
   1) 由于路由的切换，就是组件的卸载与重新解析
   2) 所以可以在组件的componentDidMount或者useEffect中进行滚动条的复位。




## 导航栏使用其它的标签
在react中的路由导航，默认是a标签，并且不能进行修改，不像vue一样可以随意修改。
如果想要使用其他标签实现导航栏的效果，需要重新封装一个组件。


1. 方式
   1) 如果想要实现Link标签的效果，比较简单，直接用withRouter包裹一下，获取到history对象，使用push方法就可以实现。
   2) 如果想要实现NavLink标签的效果，稍微麻烦一点，需要与当前的路径进行匹配。
      1) 可以借助path-to-regexp插件自己进行匹配。使用withRouter进行包装获取路由环境
      2) 可以借助Route标签，该标签自带匹配功能，把内容作为Route组件的children，这样无论匹配成功与否都会显示。
      然后把to设置为Route标签的path，如果匹配成功Route注入的路由数据的match不为空，如果没有匹配成功，则match为null，利用该属性可以动态添加class。
      当路由发生变化，Route进行重新渲染，又会重新匹配，设置class。


2. 借助Route组件，进行自定义导航标签的封装
```js
const MenuLink = ({to, ...props}) => {
  return (
    <Route path={to} {...props} children={ (p) => {
      console.log(p);
      return (
        <span onClick={ () => { p.history.push(to) } } 
              className={p.match ? "active" : ""}>
          { props.children }
        </span>
      )
    }} />
  )
}
```


