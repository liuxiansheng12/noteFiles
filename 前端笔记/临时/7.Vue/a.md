

# 重新渲染分析及注意点
 
1. 在vue中，直接修改对象中的属性对应的属性值，是可以引发重新渲染的

2. 修改数组，比如新增和修改一个位数的数据，是无法引发重新渲染的
   1) 不是通过数组的方法进行修改，而是通过下标的方式修改
   2) 操作数据的方法都已经进行了重写，内部加上了重新渲染的执行代码

3. 向data中新增数据，然后进行修改，是无法引发重新渲染的

4. 重新渲染，会查看所有的数据，只要与当前渲染的数据不符和，也会顺带着给重新渲染了
   1) 比如当前操作了数组，没有引发重新渲染
   2) 下次操作了一个对象的属性，引发了重新渲染
   3) 则当前的重新渲染，会顺带完成重新渲染数组数据


5. 原理
   1) 底层通过`object.defineProperty`方法进行了监管
   2) 分析模板时，建立了对应模板与数据的关系
   3) 当数据发生变化时，触发set函数
   4) 然后根据数据与模板的关系，找到对应的dom，进行重新渲染




# $set的使用

1. 作用
   1) 强制刷新页面，但是有限制条件
   2) **触发条件: 数据必须发生了变化，并且发生变化的数据，在模板中进行了使用**
      1) 在分析模板，创建dom的时候，对应dom与使用的对应数据建立了联系
      2) 当数据发生变化的时候，根据建立的关系表，重新渲染该节点
   3) **解决修改数组无法引发重新渲染的问题**
      1) 直接修改数组，无法引发页面的重新渲染
      2) 除非修改数组使用的是数组上的一些方法，这些方法已经进行了重新
      3) 内部，加上了获取数组与对应dom的关系，从而进行重新渲染
      4) 或者使用`$set`，直接引发重新渲染



2. 使用方式
   1) 该函数在vue的环境对象中，所以调用该函数有两种方法
      1) 在vue的内部通过`this`调用
      2) 通过new Vue()的返回值对象调用
   2) 该函数接收三个参数
      1) 第一个: 要修改那个对象中的属性，即该对象的索引
      2) 第二个: 要修改的属性
      3) 第三个: 将要赋予的值，即新值
   3) 要修改数组中的某个数据，传入的也是这三个参数
      1) 数组就是一个特殊的对象
      2) 第一个参数，找到该数组(特殊对象)
      3) 数组的属性，就是0、1、2 ··· ··· ，第二个参数只需要传入对应的位数即可



3. 示范代码
```js
   mounted() {
      // 修改对象中的属性
      this.$set(this, "a", ?);
      // 修改数组中的数据，修改第1位数据(即第二个数据)
      this.$set(this.arr, "1", ?)
   }
```







# vue中的指令(不是很常用，但是也有它的作用)

1.  `v-pre`   禁止解析数据(正常情况下会对{{}}进行解析，但是给标签设置了v-pre就进行解析，直接展示{{}}这种形态)

2. `v-cloak`  vue加载时存在，解析完消失(配合css使用`[v-cloak] {   display: none;  }`, 可以避免加载过慢，产生从{{}}到正确数据的变换过程(效果不好))

3. `v-once`   对数据进行缓存，即使修改数据，页面刷新，也是从缓存中取数据(页面不会再发生变化)

4. `v-html`   通过`v-html="data"`，可以把data数据解析成html格式(正常情况下为字符串)。并且以data替换掉整个之前的innerHTML。

5. `v-text`   该指令就是插入文本元素，可以不使用{{}}，直接`v-text="属性名"`，就可以把数据插入到标签中，并且把之前的innerHTML替换掉。


# 标签的行间属性从vue中取值的方式
需要借助一个属性`v-bind:(可以简写成:)`，并且不用加{{}}，直接""。

```html
<img v-bind:src="imgSrc">
<img v-bind:class="class">
<img :src="imgSrc">
<img :style="style">
```



# 组件或dom的显示与隐藏

1. v-if和v-else和v-else-if控制显示与隐藏
   1) `v-if`和`v-else-if`必须写上条件判断，`v-else`不需要写条件判断
   2) 联合使用，`v-if`必须写在前面，其次后面跟`v-else-if`，最后写上`v-else`
      1) `v-if`和`v-else`只能使用一次，`v-else-if`可以使用多次，或者不使用
      2) `v-else`也可以不使用，如果使用，前面必须存在`v-if`或者存在`v-if`和`v-else-if`
      3) 中间不能插入其它的组件
   3) 就相当于js中的`if -> else if -> else`，使用规则相同，功能不同


2. v-show控制显示与隐藏
   1) 后面跟上判断条件就可以控制组件的显示与隐藏了


3. v-if和v-show控制显示与隐藏的区别
   1) v-if会彻底的销毁组件或者dom，即组件会启用销毁周期
      1) 下次满足条件后，会重新创建组件，是一个全新的组件，重新走生命周期
      2) 与key值存在密切的关系
      3) 在解析时，如果条件不满足，组件是不会被解析的，不会被激活
   2) v-show只是控制css样式的`display`为`block`还是为`none`，来控制组件的显示与隐藏
      1) 在解析时，所有的组件都会激活声明周期函数，即使组件隐藏，也会激活
      2) 然后把隐藏的组件的`display`设置为`none`
      3) 无法与key建立关系，因为组件并不会被销毁
      4) v-show无法使用到vue提供的辅助标签`<template>`上
   3) 如果是频繁的显示与隐藏，建议使用`v-show`，效率较高






# 事件的绑定

1. 通过原始方法绑定事件
   1) 选中元素，可以借助ref，然后进行事件的绑定


2. 使用vue中提供的`v-on`指令进行事件的绑定
   1) 直接在模板中绑定事件，以及事件处理函数
   2) 使用方法
      1) 比如: 绑定click事件，`v-on:click="func"`
      2) `func`是自定义的事件处理函数名
      3) 简写: 可以使用`@`替换`v-on:`
         1) 比如: `@click="func"`
  
3. 事件函数的默认值传参
   1) 事件函数默认接收一个参数event，除了默认参数，还可以传递其它的数据，作为默认值
   2) 要想传入默认值，需要写成函数调用的方式
      1) 比如: `@click="func('aaa')"`
         1) 会替换传入的默认参数，接收的第一个参数是默认值`"aaa"`
      2) 要想即传入默认值，又传入event对象，需要借助vue提供的`$event`。
         1) 比如: `@click="func($event, 'aaa')"`  
         2) 第一个参数接收event对象，第二个参数接收默认值`"aaa"`


4. 事件函数内部的this指向
   1) 事件函数在执行时，内部的this，指向的是当前的vue环境对象，并不是触发事件的事件源
   2) 要想获取到触发的dom，需要借助event对象上的target属性






# 列表循环渲染

1. 作用
    1) 遍历vue中的一个数组，生成对应的html模板结构，渲染vue数组中的数据
    2) 可以快速书写出大量相同结构的HTML结构

2. 遍历方法
   1) 借助vue中的`v-for`指令实现遍历，需要`key`的配合
   2) 比如: `v-for="(item, index) in arr" :key="index"`
      1) item对应arr数组的每一项的数据
      2) index为对应的数组索引
      3) v-for内部的模板就可以使用item和index，渲染对应的数据
   3) 如果只使用数据，不使用索引，可以把`()`省略不写
      1) 比如: `v-for="item in arr" :key="item.id"`

3. 与v-for循环配合使用的还有一个`template`标签
   1) 该标签在实际渲染的时会消失，起一个辅助的作用
   2) 通常用于，父级节点使用v-for进行遍历，但是真实的dom结构中，该父级节点并不存在
   3) 需要注意，`key`必须要加在实际展示的标签上
      1) `template`标签不能使用key值，但是v-for必须借助key的辅助
      2) 所以只能加在`template`标签下的第一级子标签上，每个标签都需要进行添加
      1) 所以，为了保持每一个子节点的key都不相同，通常拼接一个后缀
         1) 比如: `<div :key=" 'key.id + a' "> {{ key.name }}</div>`




# key

1. 作用
   1) 为了优化重新渲染时的渲染效率
   2) 复用节点


2. 具体表现
   1) 当数据发生变化，又有可能引发重新渲染。
   2) 此时就可能涉及到了组件或者dom的创建与销毁
      1) 比如使用v-if，涉及到了组件或者dom的销毁与创建
   3) 如果销毁的组件或者dom，与将要创建的组件或者dom
      1) **定义的key相同，并且dom名或者组件名相同，并且位于同级**
      2) 三个条件都满足，就会产生dom或者组件的复用，即不在创建新的
   4) 组件节点使用key的表现形式
      1) 如果进行复用(满足上方的三个条件)，复用的是组件环境，即数据还是之前的数据
      2) 此时，如果组件进行过重新渲染(更改数据引发的)
      3) 由于环境被复用，所以，展示的还是重新渲染后的样式，并没有复原
      4) 如果涉及了`slot`的使用，并且新组件与复用的不同。相当于innerHTML不同
         1) 节点复用，并不涉及`innerHTML`，即`innerHTML`依旧进行判断，如果相同，继续复用
         2) 如果不同进行替换
         3) `slot`的使用会进行更新，不会继承复用环境中的`slot`，如果相同继续复用(优化效率)
      5) 如果没有进行复用，之前的组件就会进行卸载，然后创建新的组件
         1) 会还原成初始的状态，组件是新创建的，是一个新的环境，所有的数据都是初始数据
   5) 普通节点使用key的表现形式
      1) 如果进行复用(满足上方的三个条件)，复用的是dom节点
      2) innerHTML是不会进行复用的，需要继续判断
         1) 如果dom名相同，继续复用，如果标签名不同，创建新的
            1) 然后继续判断dom中的innerHTML
         2) 如果文本内容相同，继续复用，如果文本内容不同，创建新的
         3) 如果旧的多余，进行卸载，如果旧的没有，进行创建
      3) 不会整个结构都进行复用
         1) 只复用当前节点，html结构由节点树构成，复用的是枝杈的头
         2) 枝杈会继续判断
            1) 如果相同，才继续复用
            2) 如果不同，创新新的，替换旧的
         3) 这样，即保证了效率，又保证了与实际相符
   6) 所以，key用于复用节点，而不是复用整个结构


3. `v-for`指令必须配合`key`的使用
   1) `v-for`，涉及到了大量的节点的创建与销毁
      1) 数据发生变化，循环就会重新执行
      2) 此时如果没有key的辅助，所有的节点都会重新生成，大量浪费效率
   2) `key`的值最好不用使用index
      1) 如果使用index作为key值，每次循环都会进行复用
      2) 如果循环过程中，某个节点需要重新创建，index是无法进行操作的
      3) 如果使用其他数据作为key值，是可以进行动态控制的


4. `key`必须加在实际的标签上，`template`标签不能使用key值，它不参与渲染




# 修饰符

常用的修饰符有两种，一种是事件修饰符，一种是v-model使用的修饰符。

事件的修饰符(给事件的触发在加上限制条件)
比如:  `<input @keyup="func">`   只要键盘按下就会触发func事件
加上修饰符，比如: `<input @keyup.enter="func">`  当回车键按下时才触发func函数(多了一条限制条件)
`enter`也可以用对应的键值来替换`<input @keyup.13="func">`。   键值就是`keyCode`

**给键盘修饰符起个别名**
```html
<input @keyup.a-b="func">
<script>
    Vue.config.keyCodes = {
        // 不支持小驼峰式的写法，也就是不能写成aB。要写成a-b
        "a-b": 13   //给键值为13的按键起一个别名(回车键)
    }
</script>
```


v-model修饰符
1. `v-model.lazy`    当输入框失去焦点时，才改变vue中的数据
2. `v-model.number`  当输入框输入的是纯数字时，vue获取的是number类型的数据(正确情况下获取的都是string类型的数据)
3. `v-model.trim`    当输入框中输入的内容两侧存在空格时，vue获取的数据去除两侧的空格(不影响展示样式，input中的空格依旧存在)
    


# 自定义指令

1. 作用
   1) 使用简单的指令，实现复杂的功能，类似黑科技

2. 自定义指令的定义
   1) 全局
      1) 借助Vue的静态方法`directive`进行创建，传入两个参数
      2) 第一个参数传递`自定义指令的名称`，第二个参数传入`指令的处理方式`
      3) 第二个参数有两种赋值方式
         1) `传入一个对象`，对象中有三个属性，属性值都是函数，对应三个阶段的处理函数
            1) `bind`: 使用该指令的dom创建后，但是还没有插入页面时，触发该函数
               1) 只执行一次
               2) 由于对应dom还没有插入，所以实现不了input初始时自动聚焦
                  1) 聚焦的方式: `dom.focus()`
            2) `inserted`: 使用该指令的dom，插入页面后，触发该函数
               1) 只执行一次
               2) 由于对应的dom已经插入页面中，所以可以实现input的自动聚焦
            2) `update`:  当使用该指令的dom的innerHTML进行重新渲染时，触发该函数
               1) 只要重新渲染，该函数就会执行
               2）如果标签进行了重新构建，比如v-if或者key值不同，与之前的就没有关系了
                  1) 从新执行`bind和inserted`
         2) `传入一个函数`，相当于传入对象中的bind和update的合成体
            1) 创建没插入时执行一次
            2) innerHTML重新渲染时执行一次

   2) 局部
      1) 利用Vue使用时的传参对象中的`directives属性`，属性值为一个对象
      2) 对象中的每一个属性，就是一个自定义指令，`属性名为指令名，属性值为指令的处理方式`
         1) 指令属性值，也有两种赋值方式，与全局一样。一种为函数，一种为对象格式。


3. 自定义指令函数接收的参数分析
   1) 指令处理函数，一共接收三个参数。
      1) 哪怕是对象格式中的三个参数，在执行时也接收三个参数。
   2) `el`(第一个参数): 传入使用该指令的dom
   3) `bindings`(第二个参数): 传入该指令的一些基础信息，格式为对象，内部常用的有四个属性
      1) `arg`: 存放的是指令，`:后面，=前面`的一段字符串标记
      2) `value`: 存放的是指令，`=后面`在vue中的实际数据(数据赋值)
      3) `expression`: 存放的是指令，`=后面`的字符串(数据名称)
      4) `modifiers`: 存放的是修饰符的相关信息，格式为对象
         1) 修饰符的名称作为属性名，属性值为true
         2) 表示该修饰符已经启用，具体的功能在指令函数中进行判断创建
         3) 比如: {inn: true}，判断inn为true，执行相应的代码
   4) `vnode`(第三个参数): 使用该指令的虚拟节点信息，内部常用的属性只有一个。
      1) `context`: 指向的就是当前的vue环境


4. 示范代码
```js
Vue.directive("abc", {
    bind(el, bindings, vnode) {
        // 无法进行聚焦，没有效果
        el.focus();  
    },
    update(el, bindings, vnode) {
    },
    inserted(el, bindings, vnode) {
        // 可以进行聚焦
        el.focus();  
    }
})
```

5. 使用时，通过`v-自定义指令名`进行使用。


6. 注意
   1) 如果指令中，涉及到了数据变化，从而引发重新渲染，或者绑定一些事件
      1) 要使用对象的赋值方式，然后在bind中进行实现
      2) 如果使用函数的赋值方式，或者在对象模式中的update中进行实现
         1) 会操作死循环，或者事件重复定义



# 过滤器

1. 作用
   1) 改变将要展示的数据，对数据进行加工
      1) 比如`老马 -> 姓名: 老马`
      2) 实际对应的数据(data)，还是`老马`，数据不会发生变化

2. 原理
   1) 当渲染时，分析vue模板
   2) 当分析到具有过滤器符号的模板，就会触发定义的过滤器
   3) 把vue中的数据，传入过滤器中，**实际上，用于替换模板的数据，是过滤器的返回数据**
   4) 即: 本来是`老马`替换，现在变成了`姓名: 老马`替换。展示的自然为`姓名: 老马`
   5) 影响的是模板的替换过程
   

3. 触发环境
   1) **只有渲染时(初始渲染、重新渲染)，分析到过滤器模板，过滤器才会触发**


4. 过滤器的定义
   1) 局部过滤器
      1) Vue的传参对象中的`filters`属性，用于定义局部过滤器，属性值为一个对象
      2) 对象中的每一个属性，就是一个具体的过滤器，属性值为过滤器函数
      3) 比如: `filters: { abc() {} }`，abc就是一个局部过滤器
   2) 全局过滤器
      1) Vue有一个`filter`静态属性，用于定义全局过滤器，属性值为一个函数
      2) 调用一次函数，创建一个全局过滤器
         1) 第一个属性，传入过滤器器的名称
         2) 第二个属性，传入过滤器处理函数
      3) 比如: `Vue.filter("abc", () => {} )`，abc就是一个全局过滤器
   3) **如果全局过滤器与局部过滤器重名，优先使用局部过滤器**

5. 过滤器的使用
   1) `<div>{{name | a | b}}<div>`
      1) a、b为定义好的过滤器
      2) **过滤器函数默认接收一个参数**
         1) 第一个过滤器接收的是: 前面对应的vue数据(即name对应的数据)
         2) 后面使用的过滤器函数，接收的参数，是前面过滤器的返回值
            1) 相当于进一步加工
      3) 最终替换模板所使用的数据，是最后一个过滤器的返回值
         1) **渲染的是最后一个过滤器的返回值**
   2) `<div>{{name | a(1, 2) | b(3, 4)}}<div>` 
      1) **给过滤器传递其它的数据**
      2) 过滤器函数，默认接收一个参数，作为第一个参数
      3) 过滤器函数，接收的数据，从第二个位置开始，对应模板中传入的数据


6. 过滤器运行在重新渲染时，所以需要了解重新渲染机制
   1) 修改数据，不造成重新渲染，过滤器是不会运行的
   2) 使用$set，强制重新渲染，哪怕数据没有发生变化，都要重新渲染
      1) 只要重新渲染，就会分析模板，分析到过滤器，过滤器就会运行
      2) $set使用一次(处理使用过滤器的数据)，过滤器运行一次









# vue执行的流程

1. 查看传入的参数有没有el
   1) 如果没有el，查看是否使用了wn.$mount
   2) 如果也没有，则vue停止处理直接退出
   3) 如果有则进行挂载

2. 挂载完成后就要获取到对应的模板
   1) 首先查看传参中是否有template属性，如果有则把模板取出
   2) 如果没有定义template属性，则通过$el.outerHTML取出实际的模板

3. 获取模板后，就要形成虚拟dom，构建虚拟dom树
   1) 首先查看传参中是否有render属性，如果有则使用自定义的render方法构建虚拟dom
   2) 根据模板构建虚拟dom树

4. 根据虚拟的dom，形成真实的dom。然后进行替换，浏览器正常渲染。









# vue传参对象中的template属性

1. 作用
   1) 创建vue的分析模板
   2) vue的核心就是分析模板
   3) 如果没有该属性，则使用默认的模板，即通过el绑定的节点，调用`outerHTML`方法获取默认模板

2. 使用方式
   1) 属性值是一个字符串，字符串就是当前组件分析的vue模板
   2) 如果模板中使用了其它的组件，需要借助`components`属性，进行声明
   3) `template`中使用的组件，就是一个字符串
      1) vue需要拿到该组件的配置对象，才能分析对应的组件
      2) 对应组件的配置对象，就是通过`template`中的组件字符串，从`components`对象中进行获取
      3) 所以需要在`components`对象中，声明对应的组件配置对象，以便查询使用







# vue传参对象中的render属性

1. 作用
   1) 创建vue的虚拟dom树，根据该虚拟dom树，创建真实的dom树
   2) 如果没有该属性，使用vue模板创建对应的虚拟dom树

2. 使用方式
   1) 该属性对应的属性值，是一个函数
   2) 函数接收一个参数，接收的参数也是一个函数
      1) 利用接收的函数，可以创建出一个vue的虚拟dom
      2) render函数，返回接收函数所创建的虚拟dom(返回的是根节点)
   3) 接收函数，在使用时
      1) 传入一个参数
         1) **传入的就是vue的配置参数对象，即将要创建的节点的配置参数对象**
         2) 由于直接传入的是组件配置对象
            1) 可以直接获取到该组件配置对象，进行分析
            2) 不需要在`components`对象中进行声明
      2) 传入三个参数
         1) 第一个参数: 当前的节点名(标签名)，格式为字符串
         2) 第二个参数: 当前节点的行间属性，格式为对象
            1) `class属性`: 设置该节点的class名
               1) 有三种赋值方式，与vue模板中class的三种赋值方式一样
               2) 分别为字符串、数组、对象
            2) `style属性`: 设置该节点的行间样式，有三种赋值方式
               1) 有三种赋值方式，与vue模板中style的三种赋值方式一样
               2) 分别为字符串、数组、对象
         3) 第三个参数: 当前节点的子节点
            1) 如果是多个子节点，需要放在数组中传入
            2) 如果是文本节点，直接写文本信息
            3) **如果是元素(标签)节点，可以再次使用接收的函数进行创建**
               1) 该函数就是创建虚拟dom的函数


3. 该函数在执行时，内部的`this`指向当前的组件环境对象，可以正常使用数据


4. render函数传入的第三个参数，为虚拟节点对象或者虚拟节点对象组成的数组
   1) 通过接受的函数，也是创建虚拟节点对象，所以第三个参数传入的是虚拟节点对象
   2) 可以与插槽(`this.$slots.?`)联合使用
   3) 通过`this.$slots.?`获取到的就是对应的插槽虚拟节点对象，所以可以直接使用






# vue的生命周期函数

1. 初始化以及初始渲染阶段
   1) 初始化vue
   2) 初始化完成后，执行周期函数`beforeCreate`
   3) 初始化自定义的数据(data)
   4) 初始化完成后，执行周期函数`created`
      1) `this`指向正常，可以操作`data`的数据，可以进行`ajax`请求
   5) 查看是否有el，$mount。
   6) 获取模板
      1) 获取自定义的模板: 即`template`
      2) 获取默认模板，即`el.outerHTML`
   7) 创建虚拟节点
      1) 使用render创建
      2) 根据模板创建
   8) 虚拟节点创建完成后，执行周期函数`beforeMount`
   9) 根据虚拟节点创建真实的节点
   10) 真实节点创建完成后，执行周期函数`mounted`    (通常发送ajax请求)
   11) 把真实的节点进行插入


2. 重新渲染阶段
   1) 当重新渲染前的时候，执行周期函数`beforeUpdate`
      1) 可以修改`data`中的数据
      2) 由于重新渲染时异步的，此时还没有重新渲染完成
      3) 修改数据，不会再次引发重新的渲染的过程
   2) 当重新渲染完成时，执行周期函数`updated`  
      1) 不能修改`data`中的数据
      2) 由于此时重新渲染完成
      3) 再次进行修改的话，会再次触发重新渲染流程，陷入死循环


3. 销毁阶段
   1) 当前组件不在重新渲染，触发销毁生命周期，比如`v-if`，`v-show`无法触发销毁周期
   2) Vue销毁前，执行周期函数`beforeDestroy`
      1) 通常用来消除vue中使用到的定时器
   3) Vue销毁完成，执行周期函数`destroyed`  





# vue中的计算属性

1. 作用
   1) 对一个数据，进行进一步加工，然后在进行显示
   2) 但是对原数据不会产生任何影响，和过滤器的作用差不多


2. 计算属性的创建
   1) 组件属性对象中，存在一个`computed`属性，属性值是一个对象
   2) 对象的每一个属性，就是一个计算属性，并且属性值有两种赋值方式
      1) 赋值为一个函数，相当于对象格式中的get
         1) 函数默认接收一次参数，为当前vue的环境对象
         2) 比如: `computed: { a() {} }`
         3) 修改数据，还是需要修改原始数据，data中的数据
      2) 赋值为一个对象，对象中有两个属性
         1) `set属性`，属性值为一个函数
         2) `get属性`，属性值为一个函数
         3) 修改数据，可以给计算属性赋值，运行set函数，然后把赋的值作为参数传入
            1) 然后在set函数中，修改data中的数据
            2) 这样就可以通过计算属性，完全控制data中的数据
            3) 相当于`Object.defineProperty`中的get和set


3. 计算属性的使用
   1) 如果是vue执行程序中使用
      1) 和data中的数据使用方式相同，直接通过`this.计算属性名`使用
      2) 计算属性虽然运行的是一个函数，但是**不能写成函数调用的形式**
      3) 比如: `mounted() { console.log( this.a ) }`
   2) 如果是vue模板中使用
      1) 和使用data中的数据相同，直接`计算属性名`
      2) 比如: `{{ a }}`


4. 计算属性的特点
   1) 计算属性**第一次获取**，运行计算属性函数
      1) 根据运行过程中执行的代码，如果使用了data中的数据，与该数据建立起联系
      2) 比如: `a -> compuA(); b -> compuA();`，并把a、b的值保存起来。
   2) 获取完成后，对计算属性函数的返回值进行缓存
   3) 如果再次获取计算属性值(js获取，模板获取)，先判断data依赖中的数据有没有发生变化
      1) 与上次缓存时，**所依赖的data数据对应的当时的值**，进行比较
      2) 如果发生变化，从新执行计算属性函数，然后把**返回值再次缓存**
      3) 如果没有发生变化，则计算属性函数不再执行，**直接使用缓存中的缓存数据**
   4) 修改计算属性所依赖的data数据，需要注意的问题
      1) 修改依赖数据，**data中的数据发生变化，但是不会对计算属性产生影响**
         1) 此时不会更新计算属性
      2) 如果是vue模板中使用了计算属性，修改依赖数据，会进行重新渲染
         1) 重新渲染，需要重新读取计算属性，此时就会判断依赖是否发生变化
         2) 如果变化，重新执行计算属性函数，然后更新缓存
         3) 造成了修改依赖，直接影响计算属性的效果，底层进行了读取

5. 注意事项
   1) 只有依赖数据发生了变化，重新读取计算属性时，才重新运行计算属性函数
   2) 只要依赖数据没有发生变化，就一直从缓存中取数据
   3) 哪怕使用`this.$set()`，强制重新渲染，只要数据没有变化，还是从缓存中取数据



# vue中的侦听器

1. 作用
   1) 用来监听vue中data数据的变化
   2) 当数据发生变化时，即不影响原先的功能，然后添加附加功能


2. 创建侦听器
   1) 组件对象中，存在一个`watch`属性，属性值为一个对象
   2) 对象中的每一个属性，就是一个侦听器，属性值有两种格式
      1) 对象格式，常用属性
         1) `handler`: 属性值为一个函数，侦听器执行函数
         2) `immediate`: 属性值为布尔值
            1) 当`true`时，初始时，侦听器函数就执行一次
            2) 当为`false`时，初始时，侦听器函数不进行执行，相当于直接赋值函数
               1) 只有当侦听的数据发生变化，侦听器函数才会执行
         3) 比如: `watch: { name: {  handler(res) { }, immediate: true } }`
      2) 函数格式
         1) 函数接收一个参数，就是数据的变化值(新赋值的值)
         2) **在初始时，侦听器函数不会进行执行，只有侦听属性发生变化时才进行执行**
   3) 利用`$watch函数`创建侦听器
      1) 不像watch属性创建侦听器一样，利用函数可以动态创建侦听器
      2) 通过`this.$watch()`创建侦听器
      3) `$watch`函数的传参
         1) 第一个参数: 侦听器的名称，必须与侦听属性相同
         2) 第二个参数: 侦听器执行函数
         3) 第三个参数: 侦听器的配置对象
            1) 比如: `immediate`，就在该对象中进行设置
            2) 如果第三个参数没有传递，`immediate`默认为false
               1) 开始时不进行执行，只有侦听属性发生变化才进行执行
               2) 如果想要开始时执行一次，需要把对应的属性值设置为true
      4) 比如: `this.$watch("a", function (res) {}, { immediate: true })`
   4) 侦听器名称，需要与被侦听的数据相同。
      1) 比如侦听data中的a数据，侦听器的名称必须为a
   5) 侦听器函数，只有一个参数
      1) 初始时执行，传入侦听属性的初始值
      2) 侦听属性值变化时，传入新赋值的值
   6) 侦听器函数中，如果想要通过this读取到当前组件的vue环境对象，不能使用箭头函数


3. 注意事项
   1) 只有侦听的数据发生了变化，侦听器函数才会执行
   2) 哪怕使用`this.$set()`，强制重新渲染，只要数据没有变化，侦听器函数是不会触发的
      1) 与上次的值一比较，发现一样，侦听器函数就不会执行





# 自定义组件

1. 创建方式
   1) 全局组件
      1) Vue上有一个静态方法`component`，通过该方法就可以创建一个全局组件
      2) component函数，共接收两个参数，第一个参数是组件名，第二个参数是组件数据对象
   2) 局部组件
      1) 在Vue的传参对象中，有一个`components属性`，属性值为一个对象
      2) 对象中的每一个属性，就是一个自定义组件。属性值为一个对象，对象用于描述自定义组件
      3) 自定义组件的描述对象中的属性，和Vue传参对象中的属性相同，功能也相同
      4) data属性的属性值比较特殊，不是一个直接的对象，而是一个函数
         1) 函数的返回值，是一个对象，内部定义该组件中使用的数据
   3) 组件的嵌套
      1) 可以在组件中再定义一个局部子组件，获取使用定义好的全局组件
      2) 局部子组件的创建方式，也是利用组件数据对象中的`components属性`进行定义


2. 自定义组件的声明周期问题
   1) 自定义组件声明周期的起点发生在父级周期的`beforeMount`和`mounted`之间
      1) 创建真实dom的时候
      2) 父组件的声明周期函数`beforeMount`，执行完，紧接着开始分析子组件，激活子组件周期
      3) 子组件的周期执行完`mounted`后，表示子组件渲染完成，父组件的`mounted`才会执行
         1) 所有的子组件全部渲染完成  
   4) 子组件重新渲染，触发自己的`updated`函数，不会触发父级的`updated`函数


3. 正是由于每个组件都是一个对象，所以就可以把这些组件对象单独的提取出来，形成专门的模块化开发
   1) vue框架，使用的就是这种方法，通过loader，把以vue为后缀的文件解析成组件对象，然后抛出







# 组件间的传参

## 子组件获取父组件定义的数据

1. 父组件通过行间属性v-bind向子组件进行数据的传递
   1) 子组件通过props属性，获取行间传入的数据
      1) 比如: `props: ["a"]`
      2) 获取行间传入的a数据
   2) 如果行间使用了某个属性进行传参，但是该属性没有在props中引入，会在行间显示出来
      1) props中引入的数据，行间是不会显示出来的，只显示那些传入但是没有引入的数据
      2) 可以通过 `inheritAttrs: false`进行消除
   3) 行间传参，但是没有被props引入的数据，会放在`$attrs`对象中
      1) 子组件可以通过`this.$attrs`获取到剩余的，没有被props引入的行间传参
      2) props中引入的行间传参，`$attrs`对象中是没有的
      3) 可以解决跨级传参的问题(中间一级没有使用某个数据，props也需要进行引入)
         1) 行间使用`v-bind="$attrs"`，把$attrs对象中的数据继续向下传递

2. 子组件直接获取父组件的vue环境，然后获取父组件中的数据
   1) 通过`this.$parent`，获取父组件的vue环境对象
   2) 相当于父组件的this，这样就可以通过`this.$parent.?`获取到父组件中的某个数据
   3) 计算属性可以进行监管
      1) 比如: `computed: { aa() { return this.$parent.a } }`


3. 执行期上下文传递数据
   1) 没有层级限制，只要位于执行期上下文的环境中，就可以使用内部的数据
   2) 在组件中，通过`provide属性`创建执行期上下文。
      1) 比如: `provide: { a: 123 }`
   3) 某个组件创建了执行期上下文，则该组件的所有子组件都位于该上下文的环境中
      1) 子组件，要想使用上下文中的数据，通过`inject属性`进行获取
         1) 和props的使用方式一样
         2) 比如: `inject: ["a"]`
      2) 创建执行期上下文中的组件，是不位于该上下文中的
         1) 也就是不能通过inject获取上下文中的数据
   4) 创建执行期上下文的组件，是无法使用上下文中的数据的
      1) 要想使用，可以直接通过`this._provided.?`，是可以访问到上下文空间对象的
      2) 通过`this._provided.?`是无法造成，使用上下文数据的子组件的重新渲染的
         1) 直接通过inject取数据，然后{{}}中使用，是无法造成重新渲染的
            1) 相当于，取出数据，然后赋值给了某个属性，数据变化是不会重新赋值的
            2) props可以引发重新渲染，是父组件行间传参，建立的对应关系。
               1) 数据变化，根据对应关系，找到对应的组件，直接重新渲染
               2) inject是无法建立关系的，没有关系自然无法重新渲染
         1) 计算属性也无法进行重新渲染
   5) 子组件先从距离最近的父组件创建的上下文中取数据，如果没有，在继续向上查询         



## 父组件获取子组件中的数据

1. 获取子组件的环境
   1) 当前的组件环境有一个`$children`属性，通过该属性可以获取到下一级子组件的vue环境
      1) 由于下一级子组件可能有多个，所以该属性是一个数组
      2) 数组的每一项对应一个子组件的vue环境对象
      3) 比如: `this.$children[0]`，获取第一个子组件的vue环境对象
   2) 无法进行跨级获取，如果想要进行跨级获取，需要进行`$children`的连用
      1) 比如: `this.$children[0].$children[0]`


2. 通过数据引用的方式，获取到子组件的数据
   1) 其实获取的也是下一级子组件的vue环境，类似$children
   2) 在vue的行间中，有这么一个属性`ref`
      1) 行间，通过`ref="ref名称，自定义"`，启用ref
      2) 比如: `ref="a"`
   3) 普通的dom，使用ref
      1) 通过`this.$refs.对应的ref名`。获取到的是该dom节点
   4) 组件，使用ref
      1) 通过`this.$refs.对应的ref名`。获取到的就是该组件对应的vue环境
   5) 注意同一个组件下，ref不要重复，否则发生替换
   6) v-for循环对应的ref比较特殊
      1) 由于，v-for循环产生对应的html结构，ref势必会相同
      2) 虽然相同，但是不会进行替换，而是把它们放在一个数组中
      3) 通过`this.$refs.对应的ref名`，获取到的就是一个数组
      4) 数组的每一项，对应循环产生的dom节点或者组件的vue环境对象



3. 通过函数传参的方式，获取子组件的数据
   1) 父组件中声明一个函数，然后把函数传入子组件中
   2) 子组件调用函数，把对应的数据传入，这样父组件就可以获取到子组件中的数据



4. 子组件通过手动触发组件上绑定的事件，向父组件传参
   1) 原理借助的还是函数传参
   2) 组件上绑定的事件可以是自定义的，也可以是原生的
      1) 绑定方式，比如: `<App @a="func" />`
   3) 子组件中，就可以通过`$emit()`方法，手动触发组件上绑定的事件
      1) 使用方式: `this.$emit(事件名, 传递的参数1，传递的参数2，··· ···)`
      2) 比如: `this.$emit("a", this.b)`
         1) 触发func函数，然后把b传入
   4) 子组件中，通过`this.$options._parentListeners`，可以获取到组件上绑定的事件函数
      1) 得到的是一个对象，对象的属性名为事件名，属性值为事件函数
      2) 这样就可以手动直接调用事件函数，进行传参，不用通过`$emit`进行触发
      3) 比如: `this.$options._parentListeners.a( this.b )`，但是有些麻烦
   5) 子组件中，通过`this._events`，可以获取到组件上绑定的事件函数
      1) 得到的是一个对象，对象的属性名为事件名，属性值为一个数组
         1) 数组中的数据为对应的事件函数
      2) 可以直接调用事件函数，进行传参，，不用通过`$emit`进行触发
      3) 比如: `this._events.a[0]( this.b )`，但是有些麻烦



## 兄弟组件间的传参

1. 借助共同的父级
   1) 先把数据传入共同的父级中，然后共同的父级在把数据传入另一个组件中
   2) 过程过于麻烦


2. 利用事件总线的方式，实现兄弟组件间的传参
   1) 原理，在事件总线上绑定函数，然后其它的组件手动触发事件总线上绑定的函数，进行数据传递
      1) 类似事件传参
      2) 往事件总线上绑定函数，是在组件中完成的，利用组件上的一个方法。
      3) 创建一条事件总线，`Vue.prototype.自定义事件总线名 = new Vue()`
         1) 该条事件总线，就会贯穿整个组件
      4) 组件中，往事件总线上绑定方法
         1) 通过`this.总线名.$on("自定义事件名", 事件处理函数)`
         2) 如果事件处理函数中，需要使用this，获取到当前组件的vue环境对象
            1) 必须写成箭头函数的形式
            2) 如果使用function关键字定义的事件处理函数，则this指向有问题
               1) 指向的是创建事件总线时new Vue()，返回的vue环境对象
         3) 由于，事件处理只需要注册一次，所以通常周期函数`mounted`中注册
         4) 并且事件名可以重复，不会发生覆盖现象
            1) 会按照注册的顺序，全部触发
            2) 甚至多个组件中，都可以注册同一个事件名
            3) 触发的时候，多个组件中注册的事件函数，都会触发
            4) 只要是该事件名，全面触发
      5) 组件中，触发事件总线上绑定的事件，进行传参
         1) 通过`this.总线名.$emit("将要触发的事件名称", 传参, 传参, ··· ···)`
         2) 父子级间的传参，也可以使用事件总线的方式，进行传参
   






# 父子级组件间的双向通信

1. 作用
   1) 父子级组件共用一个数据


2. 原理
   1) 父组件定义数据，然后通过行间传参的方式传入子组件中
   2) 同时在传入一个函数，子组件通过传入的函数，可以实现对父组件中的数据进行修改


3. vue中专门提供了一种方式
   1) 把传入函数与传入数据绑定在一起
   2) 即: `:b.sync="?"`
   3) `?`表示用来进行双向数据绑定的数据
   

4. `:b.sync`的原理
   1) 和v-model实现双向数据绑定的原理一样
   2) 使用的是绑定事件的方式
   3) 绑定的事件为: `update:b`
   4) 子组件要想修改`:b.sync`中绑定的数据，需要手动触发`update:b`事件
      1) 具体代码: ``this.$emit("update:b", 123)``



5. 借助`v-model`来实现父子级组件的双向数据通信
   1) 该方法给组件绑定的事件为`input`事件
   2) 子组件需要手动触发`input`事件，来修改绑定的数据
      1) 具体代码: `this.$emit("input", 123)`



   






# props数据的验证

1. 作用
   1) 只作用于开发阶段
   2) 限制父组件，通过props向子组件所传参数的格式
   3) 如果不符合设置的格式，则控制台打印出错误，但是赋值正常
   4) 给开发者起一个提示的作用


2. 具体使用
```js
Vue.component('my-component', {
   props: {
      // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
      propA: Number,
      // 多个可能的类型
      propB: [String, Number],
      // 必填的字符串
      propC: {
         type: String,
         required: true
      },
      // 带有默认值的数字
      propD: {
         type: Number,
         default: 100
      },
      // 带有默认值的对象
      propE: {
         type: Object,
         // 对象或数组默认值必须从一个工厂函数获取
         default: function () {
         return { message: 'hello' }
         }
      },
      // 自定义验证函数
      propF: {
         validator: function (value) {
         // 这个值必须匹配下列字符串中的一个
         return ['success', 'warning', 'danger'].indexOf(value) !== -1
         }
      }
   }
   })
```








# 组件上的事件操作


1. 使绑定的事件起作用
   1) 在组件上绑定的事件，是无法自动触发的
      1) 比如: 绑定click事件，点击该组件下的元素，是触发不了事件的
      2) 组件标签，并不是一个原生的标签，无法进行用户操作监控
   2) 要想使绑定的事件发生作用，需要加上修饰符`native`
      1) 比如: `<a-b @click.native="func"></a-b>`


2. 组件中，获取组件上绑定的事件
   1) 通过`this.$listeners`可以获取事件对象
   2) 事件名作为属性值，事件绑定的方法作为属性值
   3) **注意: 如果事件使用了native修饰符，则通过$listeners获取不到**


3. 手动触发事件
   1) 标准方法: `this.$emit("事件名", 传参)`
   2) 直接取出事件函数进行调用: `this.$listeners.函数名(传参)`



4. 组件内移用组件上的所有事件
   1) 把组件上所有的事件原封不动的，在给其它标签和组件绑定
   2) 借助的是`v-on`和`$listeners`。方法为`v-on="$listeners"`
      1) 只要组件中的某个标签或者子组件的行间写上，上面的方法
      2) 则该标签或者子组件，就会绑定当前组件上所有的事件
   3) 该方式，可以实现组件间的事件函数的传递
      1) 前提是组件上的事件没有使用修饰符`native`
      2) 否则`$listeners`获取不到
      3) 移用的是`$listeners`中的所有事件
         1) 相当于遍历该对象，然后把内部的事件依次进行重新注册













# 以vue为后缀的文件介绍

1. VScode的辅助插件
   1) 插件名称`Vetur`
   2) 作用: 让vue代码高亮显示


2. 以vue为后缀的文件
   1) 相当于Vue中的components属性中的组件对象
   2) 它是一个普通的文件，要想转换成组件，需要借助webpack的loader进行处理


3. 每一个vue文件中定义的style样式，是会对全局起作用的，而不是只针对当前的vue文件
   1) 最终打包形成行间标签`style`中的样式，作用于全局










# 手动使用webpack工具进行vue的开发

1. vue工作的入口是: `new Vue()`，就会进行模板的解析与替换

2. 需要借助的插件
   1) `vue`: 提供vue构造函数
   2) `vue-loader、vue-template-compiler`: 用于解析`.vue`为后缀的文件
      1) 如果不涉及vue为后缀的文件引入，这两个插件不需要下载。
         1) 配置文件中也不需要配置对应的代码
      2) **原理(vue模块化开发的原理)**
         1) 浏览器是不认识以vue为后缀的文件的，所以需要时webpack工具进行打包
            1) 借助loader，把以vue为后缀的文件进行代码替换
         2) 把以vue为后缀的文件，解析成对应的一个模块对象
         3) 就是Vue传参对象中components属性，定义的模块对象
         4) 当使用`import或者request`引入以vue为后缀的文件时，得到的就是模块对象
            1) loader对以vue为后缀的文件中的代码进行了重写
            2) 把原先的代码解析成对应的模块对象，然后把模块对象进行抛出
            3) 比如: `const obj = {};  export default obj;`
            4) 初次引入以vue为后缀的文件，运行的就是替换代码，然后得到模块对象
            5) 之后，就是从缓存中取模块对象


3. 配置文件代码
```js
const VueLoaderPlugin = require("vue-loader/lib/plugin");
module.exports = {
    entry: "./src/index.js",
    mode: "development",
    output: {
        path: __dirname + "/dist",
        filename: "index.js"
    },
    module: {
        rules: [
            {
                test: /\.vue$/,
                use: ["vue-loader"]
            },
        ]
    },
    plugins: [
        new VueLoaderPlugin()
    ],
    resolve: {
        alias:  {
            vue: "vue/dist/vue.js"
        }
    }
}
```
