
#### 使用

- 作用
  - 定义出一个操作对象的中介对象，这样再次操作对象的时候，就可以通过操作中介对象，实现操作对象的作用。
  - 不在直接与对象接触，而是与中介对象接触，然后中介对象在操作对象
  - 可以实现**观察者模式，当对象中的属性发生变化，可以被代码感知到，从而进行一些处理**

- **对象的修改需要手动定义代码，不会自动进行修改的**

- 示范代码
```js
const obj = {
    name: "adfa"
}        

const proxy = new Proxy(obj, {
    set(_obj, key, value) {
        // 可以进行一些其他的处理，比如数据的验证
        console.log(_obj, key, value);
        // 对 对象中的元素进行修改
        //   （手动定义修改代码，不会自动进行修改的）
        Reflect.set(_obj, key, value);
      
        // 甚至可以这样做
        //    修改是手动实现的，只要能实现修改对象中的属性，通过什么方法都可以
        // _obj[key] = value;
    }
    get(_obj, key) {
        console.log(_obj, key);
        return Reflect.get(_obj, key);
    }
});
// 修改对象中的name，就会触发上面的set
proxy.name = 456;
// 读取对象中的name，就会触发上面的get
console.log( proxy.name );

// 直接通过对象读取，不会触发get（没有走代理对象）
console.log( obj.name );
```


#### Reflect（反射）
- 对 对象完成实际的操作，是通过 Reflect 实现的，Reflect可以直接用
- 比如
```js
const obj = {
    name: "adfa"
}        
// 修改对象中的name
Reflect.set(obj, 'name', '3456');

// 读取，发现已经实现了修改
console.log( obj.name );
```



#### 旧版本的实现（以及两者的差距）
- Es5之前，只能借助`Object.defineProperty`中的set和get来实现
  - 需要另外创建一个集合，用于保存数据，避免死循环
  - 新增属性无法进行观察，需要重新使用`Object.defineProperty`进行设置

- Es6中的代理，由于创建了一个观察对象，只要一点，就会调用get或者set。然后内部手动改变对象
  - 所以，哪怕新增属性，也会调用set，从而被观察到
