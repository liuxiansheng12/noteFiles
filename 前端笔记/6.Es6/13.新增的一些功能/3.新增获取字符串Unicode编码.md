

#### 新增获取字符串Unicode编码

1. **作用**
   1) 可以间接的求出字符串的长度

2. **字符码点和码元的介绍**
   1) 刚开始时，由于硬件有限，只有16位的码元。也就是只有 2^16 个字符
   2) 后来随着技术的发展，这点字符已经不够用了，于是开发了32位的码元
   3) 之前的字符，还是前16位，后16位为0，表示占一个码元
   4) 之后添加的字符，前16有值，后16肯定也有值，表示占两个码元
   5) 字符所占的码点都是一个
   6) 但是字符串的长度，取得却是码元值。在一定程度上会造成误差
   7) 一些古汉字，是占有两个码元的，即length = 2
   8) 现代汉字，是占有一个码元的，即length = 1
   9) 造成了字符串长度的误差(比实际的长)
   10) **求字符串长度，根据码点求出的才是正确的，而length默认是根据码元求**

3. **Es6提出了一个方法`字符串.codepointAt()`**
   1) 通过该方法可以获取一个字符的Unicode编码
   2) Es5中也有一个方法可以获取Unicode编码(`charCodeAr`)
      1) 该方法获取的是码元的Unicode编码，如果是双码元字符，需要求和，才是真正的Unicode编码
      2) `const Unicode = 双码元字符.charCodeAt(0) + 双码元字符.charCodeAt(1)`
   3) `codepointAt方法`可以直接获取到Unicode编码，双码元的字符不用手动求和
      1) 其实底层自动完成的求和
      2) `双码元字符.codepointAt(0)`其实求得也是第一个码元的Unicode编码
         1) 只不过会自动查询后一位，如果后一位也有Unicode编码，表示是双码元字符
         2) 会自动求和然后返回。
         3) 如果使用 `双码元字符.codepointAt(1)`，一看后面没有Unicode编码，会认为是单码元字符，直接返回结果，即`双码元字符.codepointAt(1) = 双码元字符.charCodeAt(1)`
         4) 所以使用`codepointAt()`求双码元字符的Unicode编码，必须从第一个码元求才正确。
      3) 获取的是实际的32位值，只要与0xffff进行比较，如果大于，则表示实际长度应该减1
   4) 可以传递参数，表示求出字符串第几位的Unicode编码，默认是0


4. **示范代码**
```js
const a = "abc";
function _length(str) {
    // 保存实际的字符串长度
    let length = 0; 
    // 遍历字符长度，如果有双码元字符，长度肯定长
    for(let i = 0; i < str.length; i ++) {
        // 判断是否是双码元
        if( str.codePointAt(i) > 0xffff ) {
            // 表示是双码元，i要加上1，一定是从第0个码元开始，隔去第1个码元
            i ++;
        }
        // 实际的长度，双码元也只相加一次(少循环一次，相当于双码元只加一次)
        length ++;
    }
    return length;
}
console.log(_length(a));
```
      



