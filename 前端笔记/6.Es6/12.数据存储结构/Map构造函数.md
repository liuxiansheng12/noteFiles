
#### Map构造函数

1. 作用
   1) 专门创建一个存放键值对的集合

2. 以前存放键值对的方法
   1) 键值对类似对象属性，所以在Es6之前都是用对象存放键值对的
   2) 使用对象存放键值对的缺点
      1) 对象属性只能是字符串或者符号(symbol)
      2) 对象不容易获取存放数据的个数
      3) 容易产生与原型上某个属性重名的现象，这样原型上的属性就无法使用了

3. 特点
   1) 键名(属性名)可以是任意的数据
      1) 即使是函数、对象、数组，也能作为键名(属性名)。
      2) 增加键值对的对应关系。
      3) 比如以某标签的dom作为属性名，属性值为该标签的一些数据
      4) 标签与数据具有很强的对应关系，这在对象中是做不到这么完美的

4. 创建Map对象
   1) 方式: `let a = new Map();`

5. 存放数据
   1) 创建时存储，传参有要求
      1) Map传参，传入的也是一个可迭代的集合
      2) **传入集合的每一项必须为数组**
      3) 存放数据时: 先迭代外层的集合，得到子集合(数组)
      4) 然后数组的第一项数据作为键名，数组的第二项作为键值
         1) 如果数组的长度大于2，则后面的数据失效
      5) 然后继续迭代外层的集合，继续创建键值对
      6) 底层使用`Object.is方法`进行键名的判断，如果相同，则替换之前的键值对
   2) 创建完成后存储
      1) Map构造函数的原型上，有一个`set方法`，使用该方法可以向map对象上添加数据
         1) 传递的第一个参数，作为键名
         2) 传递的第二个参数，作为键值
         3) 底层使用`Object.is方法`进行键名的判断，如果相同，则替换之前的键值对
      2) 比如: `map.set({}, 123);`



6. 数据的获取
   1) 通过Map原型上的`forEach方法`(不是数组上的)遍历获取
      1) forEach传入的回调函数，共接收三个参数
         1) 第一个参数，接收本次遍历的键值
         2) 第二个参数，接收本次遍历的键名
         3) 第三个参数，接收遍历的map对象
   2) 通过Map原型上的`get方法`获取具体的键名对应的键值
      1) 传入对应的键名
      2) 如果没有对应的键值对，则获取undefined
      3) 如果属性名是引用类型的数据，必须保存到外界，这样才能根据索引获取到对应的属性值
         1) 否则键名是对应不上的
   3) 使用for-of进行迭代(map对象也具有可迭代协议)
      1) 遍历出的数据是数组格式，和创建Map存放数据的格式一样。
      2) 第一项为键名，第二项为键值
      3) **并不是键值**



7. 删除某个键值对和清空整个集合
   1) 删除: 借助原型上的`delete方法`
      1) 传入要删除的键名，删除成功返回true，删除失败返回false
      2) 如果删除一个没有的键值对，则返回false(删除失败)
   2) 清空: 借助原型上的`clear方法`，无参数传递



8. 查看map集合中共存放了多少条数据
   1) 借助私有属性`size`
   2) 由于该属性与map集合紧密相连，长度随时变化，所以该属性设置成了存取器属性
      1) 获取属性值，运行get方法，把get方法的返回值，返回。


9. 验证map集合中有没有某个键值对
   1) 使用原型上的`has方法`，传入键名
      1) 有返回true，没有返回false。


10. 扩展(map集合底层存放原理)
Map存储数据，依靠的是链表、hash(哈希算法)、桶。

Map的底层共有八个桶(空间)，对应的有八个哈希值(每个哈希值对应一个固定的桶)。
每个桶之间的数据也是一个一个的对象，这些对象依靠链表(穿成一条线)建立联系。

```js    
//  以new Map([[{}, "s"], ["ss", 5], ["ct", 8]])
   
//  按照属性名计算哈希值，假设对象的是2，字符串的是4。
//  此处有两个字符串，都放入4号桶内，并且依靠next建立链表(穿成一串)，最顶层的是ss，第二个是st

// 具体如下   
   {
    /* 1 */   {}，
    /* 2 */   {
                  next: {
                      key: {},
                      value: "s",
                  }
              }，
    /* 3 */   {}，
    /* 4 */   {
                  next: {
                      key: "ss",
                      value: 5,
                      next: {
                          key: "ct",
                          value: 8,
                      }
                  }
              }，
    /* 5 */   {}，
    /* 6 */   {}，
    /* 7 */   {}，
    /* 8 */   {}
   }
```
  

