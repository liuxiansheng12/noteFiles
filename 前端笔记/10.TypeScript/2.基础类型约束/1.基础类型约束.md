# 基本类型约束

> TS是一个可选的静态的类型系统

# 如何进行类型约束

仅需要在 变量、函数的参数、函数的返回值位置加上```:类型```

ts在很多场景中可以完成类型推导

any: 表示任意类型，对该类型，ts不进行类型检查

> 小技巧，如何区分数字字符串和数字，关键看怎么读？
> 如果按照数字的方式朗读，则为数字；否则，为字符串。

# 源代码和编译结果的差异

编译结果中没有类型约束信息

# 基本类型

- number：数字
- string：字符串
- boolean：布尔
- xxx[] 或者 `Array<xxx>` ：数组
- object: 对象
- null 和 undefined

null和undefined是所有其他类型的子类型，它们可以赋值给其他类型

在配置文件中的 "compilerOptions" 中
  - 通过添加```strictNullChecks:true```，可以获得更严格的空类型检查，null和undefined只能赋值给自身。

# 其他常用类型

- 联合类型：多种类型任选其一
  - 配合类型保护进行判断
  - 类型保护：当对某个变量进行类型判断之后，在判断的语句块中便可以确定它的确切类型，typeof可以触发类型保护。

- void类型：通常用于约束函数的返回值，表示该函数没有任何返回
  
- never类型：通常用于约束函数的返回值，表示该函数永远不可能结束
  - 比如死循环，抛出错误
  
- 字面量类型：使用一个值进行约束
  - 比如: :"a"
  - 比如: :{name: string, age: number}，约束对象
    - 这也是字面量，要与接口分开
- 元祖类型（Tuple）: 一个固定长度的数组，并且数组中每一项的类型确定
  - 比如：[string, number, "a", 1 | 2]
  - 这样的话，长度和每一位的类型就固定了

- any类型: any类型可以绕过类型检查，因此，any类型的数据可以赋值给任意类型
  - 比如：`let a:any = 3; let b:string = a;`
  - 这是OK的，因为会绕过类型检查

# 类型别名

对已知的一些类型定义名称

```
type 类型名 = ...
```

# 函数的相关约束

- 函数重载：在函数实现之前，对函数调用的多种情况进行声明
```ts
// 如果有多个传参组合，可以用方法的重载，约束参数，使用 | 不太灵活，有时候满足不了需求
function demo(a: number, b: number):number
function demo(a: string, b: string):string
// 如果使用 string | number 则有四种情况的传参情况
//   但是该方法只能接受两种情况，所以要用重载，而不是 | 
function demo(a, b) {
  return a + b
}


const a = demo("a", "b");
const b = demo(1, 2);
// 这样就不行了，因为没使用 | 进行约束
//    而定义的重载中又没有该情况
// const c = demo(1, "2");
```

- 可选参数：可以在某些参数名后加上问号，表示该参数可以不用传递。可选参数必须在参数列表的末尾。