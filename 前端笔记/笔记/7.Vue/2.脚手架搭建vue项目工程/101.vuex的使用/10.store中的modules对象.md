1. 作用
   1) 进行仓库的模块化开发，适用于庞大的仓库开发


2. 仓库模块的创建方式
   1) 利用`namespaced`属性，开启命名空间，给当前的仓库模块起一个名字
      1) 属性值，为Boolear类型，为`true`，开启命名空间
      2) 把`modules`对应的属性名，作为仓库名
   2) 其它的属性也是仓库中的那几个属性，并且作用也相同
   3) 甚至，模块中可以利用`modules`属性，继续嵌套模块


3. 具体的示范代码
```js
export default new Vuex.Store({
    modules: {
        // 组件a
        a: {
            // 开启命名空间
            namespaced: true,
            state: { },
            getters: { },
            mutations: { },
            actions: { },
            modules: {
                c: {
                    namespaced: true, 
                }
            }
        },
        // 组件b
        b: { }
    }
})
```


4. 模块化开发
   1) 既然每个模块，都是一个单独的对象
   2) **就可以单独的提取出来，新建一个js文件，然后抛出模块对象**
   3) 引入: `import a from './a.js'`;
   4) 使用: `modules: { a }`


5. 模块化开发，构建仓库的原理
   1) 虽然仓库中的数据，是在各个模块中进行创建定义的
   2) `Vuex.Store`在进行处理的时候，会把各个模块合并到一个对象中，然后抛出
   3) 合并的原理
      1) state中的数据
         1) 以模块名，作为属性名
         2) 属性值: 模块中的state对象
         3) 每个模块，还是单独的state对象
      2) 其它对象中的数据
         1) 不会形成单独的对象，而是合并到一个对象中
         2) 只不过每个模块中的属性名进行修改，防止覆盖
         3) 修改规则: `第一级组件名/第二级组件名/··· ···/模块中对应的属性名`
            1) 比如: `a/b/?`、`a/?`
         4) 只有开启命名空间的模块，才会进行拼接
         5) 没有开启命名空间的模块，直接用属性名，不进行拼接
            1) 如果不同模块中的属性名相同，就会产生冲突，进而报错


6. 命名空间的作用
   1) 不开起命名空间，模块化也可以使用
   2) 但是有几点注意点
      1) state对象是单独的对象，所以没有问题，不会产生冲突问题
      2) 其它对象的属性，用于合并到同一个对象中，所以会自动拼接，但是必须开启命名空间
      3) **没有开启命名空间的模块，直接用属性名，不进行拼接**
         1) 如果不同模块中的属性名相同，就会产生冲突，进而报错
   3) **虽然不开起命名空间，其它对象的属性不进行拼接，但是state对象依旧以模块的方式存在**


7. vue中使用模块化仓库中数据的方式(针对开启命名空间的仓库)
   1) 使用`$store`获取，获取到创建的仓库对象
      1) 获取仓库中state中的数据，向对应模块中获取
         1) 比如: `this.$store.state.a.name`
      2) 获取其它对象中的数据，使用拼接后的属性名获取
         1) 比如: `this.$store.getters.a/myname`
         2) 比如: `this.$store.commit("a/b/myna", {})`
      3) 就是正常的操作对象
   2) 使用vuex提供的方法，快速创建获取方法
      1) 底层借助的还是`$store`
      2) 创建对应属性的使用方法时
         1) 第一个参数传入模块名
         2) 第二个参数传入对应的属性名，不是拼接后的，而是原始定义的
         3) 比如: `...mapState('a', ["name"])`
         4) 比如: `...mapGetters('a/b', ["myname"])`，模块嵌套


8. vue中使用模块化仓库中数据的方式(没有开启命名空间的仓库)
   1) 使用`$store`获取，获取到创建的仓库对象
      1) 获取仓库中state中的数据，向对应模块中获取
         1) 比如: `this.$store.state.a.name`
         2) 虽然没有开启命名空间，但是state依旧以模块的方式存在
      2) 获取其它对象中的数据，使用原始属性获取
         1) 不会进行拼接，在使用拼接属性获取，获取不到
         2) 比如: `this.$store.getters.myname`
         3) 比如: `this.$store.commit("myna", {})`
      3) 就是正常的操作对象
   2) 使用vuex提供的方法，快速创建获取方法
      1) 底层借助的还是`$store`
      2) 创建对应属性的使用方法时，比较特殊
         1) 第一个参数传入的是空间名，但是由于对应的模块没有开启空间名
         2) 所以第一个参数传入的比较特殊，由底层原理控制
            1) 如果是`mapState`，需要传入命名空间
            2) 如果是其它对象，传入空字符串
         2) 第二个参数传入对应的属性名，不是拼接后的，而是原始定义的
         3) 比如: `...mapState('a/c', ["name"])`
         4) 比如: `...mapGetters('', ["name"])`



9. 使用vuex提供的方法，快速创建获取模块化仓库数据的方法的原理
   1) 底层借助的还是`$store`，操作仓库对象
   2) 所以，需要对传入的模块名进行处理
      1) 如果是`mapState`方法，对传入的模块名进行拆分
         1) 然后根据拆分值，去对应的state对象中取数据
         2) 这也是无论是否开启命名空间，都需要传入模块名
         3) 因为它们创建的state相同，都是模块化
      2) 如果是`其它`方法，对传入的模块名与数组中的属性名进行字符串拼接
         1) 拼接完成，形成了真正的属性名，对应仓库中的属性名
         2) 然后借助`$store`进行获取
         3) 这也是没有开启命名空间的模块，传入空字符串的原因
         4) 没有开启命名空间的模块，直接把属性名作为仓库对应的属性的属性名，没有进行拼接
            1) 在获取时，也不能进行拼接，所以传入空字符串，拼接完还是原属性名
