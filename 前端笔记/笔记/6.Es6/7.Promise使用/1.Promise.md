

#### Promise


1. 功能
   1) 解决回调地狱问题
   2) 解决不同异步之间的联系
   3) Promise不能消除回调，只不过给回调形成了一种模式
      1) 所有的回调都使用提供的模式进行回调，让回调看起来更加整洁



2. 异步状态
   1) 异步正在发生时，被称为未决状态，即`pending`
   2) 异步结束时，被称为已决状态(此时已经出结果)，共存在两种结果
      1) 成功，即`resolved`
      2) 失败，即`rejected`
   3) Promise完善异步，利用的就是这两种状态。
    

3. 使用
   1) 创建一个promise对象，通过`new Promise( () => {} )`进行创建
      1) 函数必须传递，负责报错
   2) 给promise对象，绑定已决状态的回调函数(成功和失败)
      1) promise对象上有一个方法(Promise.prototype上的方法)`then`
         1) 该函数接收两个参数，第一个参数为成功回调函数，第二个参数为失败回调函数
      2) promise对象上有一个方法(Promise.prototype上的方法)`catch`
         1) 该方法接收一个参数，为失败回调函数
      3) 可以给一个promise对象上绑定多个回调函数(通过then或者catch)
         1) 当达到对应的已决状态时
         2) 按照绑定的先后顺序，进行对应回调函数执行，先绑定的先执行


4. 执行原理
   1) 通过`then`或者`catch`，给promise对象注册上回调函数
   2) **当promise对象的状态从未决状态变成已决状态时，就会触发对应的回调函数**
      1) 按照注册的顺序执行
      2) 成功`resolved`，触发成功回调函数(放入微任务队列中)
      3) 成功`rejected`，触发失败回调函数(放入微任务队列中)
   3) **改变promise对象的状态(从未决变成已决)，依靠Promise函数执行时传入的函数**
      1) 传入函数接收两个形参，格式为函数
      2) 当第一个函数执行时，创建的promise对象的状态，变为resolved状态
      3) 当第二个函数执行时，创建的promise对象的状态，变为rejected状态
      4) 如果Promise的传入函数在执行时出现了错误(执行错误，不是语法错误)
         1) 创建的promise对象的状态，也会变为rejected状态
         2) 错误信息作为参数，传入失败的回调函数中
         3) 并且控制台不会抛出错误信息，不会造成阻塞，只要绑定了失败回调函数
            1) 不会阻塞代码，执行失败回调函数，执行完代码正常
            2) 如果没有绑定失败回调函数，则控制台抛出错误，表示没有对应的函数执行
               1) 由于Promise是异步执行，所以出现错误，不会影响其他异步函数的执行
            3) 不会造成阻塞的原因，执行栈中的执行的代码没有抛出错误
               1) 底层使用的是try-catch，进行了错误拦截
      5) **状态变为已决状态后，将不可被修改**
      6) **改变状态时，可以传递参数，会把传递的参数，传入执行的回调函数中**
   4) 只要给创建的promise对象绑定上回调函数(无论通过什么手段)
      1) 当Promise传入函数改变状态，绑定的回调函数就会执行


5. finally函数
   1) 该函数是Promise.prototype上的方法
   2) 通过该方法，也能像promise对象上绑定回调函数
   3) 绑定的回调函数，无法接受参数，没有形参
   4) 绑定的函数，无论promise对象的状态是成功还是失败，都会触发
      1) 改变状态传入的参数，通过finally绑定的函数是接收不到的
      2) 原因: 
         1) 失败和成功都能触发该方法绑定的函数
         2) 如果可以接收参数，不清楚参数是成功状态还是失败状态传入的。
   5) 该方法是Es7新增的一个方法


6. 链式调用
   1) `then、catch、finally`，这三个方法存在返回值，返回值为promise对象
      1) 返回的是一个全新的promise对象，并不是调用该方法的promise对象
   2) promise对象，可以使用`then、catch、finally`绑定回调函数
      1) 形成了链式调用
   3) `新promise对象`注册的回调函数，受`新promise对象`的状态控制
   4) `前一个promise对象`执行的回调函数，控制`新promise对象`的状态
      1) `前一个promise对象`执行的回调函数，在执行时报错(同步执行)
         1) `新promise对象`的状态变为rejected，触发失败函数
         2) 并且错误信息作为参数传入
      2) `前一个promise对象`执行的回调函数，执行完没有发生错误
         1) `新promise对象`的状态变为resolved，触发成功函数
         2) 并且把返回值作为参数传入
      3) `前一个promise对象`执行的回调函数，执行完没有发生错误，并且返回值为promise对象
         1) 则`新promise对象`的状态不变，改变与返回的promise对象绑定起来
         2) 返回的promise触发成功状态后，`新promise对象`的状态变为resolved
         3) 返回的promise触发失败状态后，`新promise对象`的状态变为rejected
         4) 触发状态传入值，作为`新promise对象`回调函数执行时的参数传入
         5) 返回的promise执行过程中报错，`新promise对象`的状态变为rejected
            1) 错误信息作为参数传入
   5) 链式调用，前一个promise对象的功能处理完成，下一个promise对象的状态才会改变
   6) 如果promise对象的状态改变，但是没有绑定对应的回调函数，就会报错
      1) 错误信息可以被下一个promise对象获取，然后状态变为reject，触发失败函数
      2) 如果没有失败回调函数，当前promise对象报错，再被下一个promise对象获取
      3) 以此类推，直到某个promise对象注有失败回调函数，并且正常执行
      4) 后面的promise对象的状态就会变为resolve。触发成功回调函数


7. Promise上的一些其它API(静态属性)
   1) `resolve`函数
      1) 返回一个已经是已决状态(resolve)的promise对象
      2) 传递的参数，作为回调函数的形参传入
      3) 如果传入的是一个promise对象，则返回传入的promise对象，不在创建
         1) 该函数的功能就是创建promise对象
         2) 既然传入一个，不在多此一举的创建，直接返回传入的
   2) `reject`函数
      1) 返回一个已经是已决状态(reject)的promise对象
      2) 传递的参数，作为回调函数的形参传入
      3) 如果传入的是一个promise对象，则返回传入的promise对象，不在创建
         1) 该函数的功能就是创建promise对象
         2) 既然传入一个，不在多此一举的创建，直接返回传入的
   3) `all`函数
      1) 该函数创建一个promise对象
      2) 创建的promise对象的状态，受多个promise对象状态的控制
         1) 该函数传入的参数是一个数组，数组的每一项为一个promise对象
         2) 成功状态的触发条件
            1) 传入的所有promise对象的状态都变为resolve
            2) 该方法创建的promise对象的状态才变成resolve
            3) **每一个触发成功状态的传参，会放入一个数组中，传入执行的回调函数中**
         2) 失败状态的触发条件
            1) 传入的所有promise对象的状态只要有一个变为reject
            2) 该方法创建的promise对象的状态就会变为reject
            3) **第一个触发失败状态的传参，传入执行的回调函数中**
            4) 其它的promise依旧正常执行，执行完不会影响该方法创建的promise对象
   4) `race`函数(竞赛模式)
      1) 该方法创建一个promise对象
      2) 该方法接收一个参数，格式为数组
      3) 传参数组的每一项为一个promise对象
      4) 创建的promise对象的状态改变为resolve的条件
         1) 传入的promise对象，只要有一个状态变为resolve
         2) 创建的promise对象的状态就变为resolve
         3) 传入的promise对象触发状态时的传参，作为回调函数的参数传入
      5) 创建的promise对象的状态改变为reject的条件
         1) 传入的promise对象，只要有一个状态变为reject
         2) 创建的promise对象的状态就变为reject
         3) 传入的promise对象触发状态时的传参，作为回调函数的参数传入
      6) 类似竞赛模式
         1) 传入的promise对象，那个先改变状态，创建的promise对象就立即改变状态
         2) 其它的promise对象正常执行，但是不会对创建的promise对象造成任何影响




