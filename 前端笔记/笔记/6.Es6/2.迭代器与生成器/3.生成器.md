#### 生成器

1. 作用
   1) 生成器最初创建的目的，简化迭代器的书写
   2) **为迭代提供数据**

2. 生成器解决的现象
   1) 迭代的原理
      1) 一次取一个数据
      2) 可以理解为调用一次next，经过一系列复杂的函数处理，返回一个对象
   2) 生成器解决的现象
      1) 迭代一次取一个数据，取出的数据可能在next内部进行了复杂的处理
      2) 并且是根据将要迭代的集合数据进行了复杂的处理
      3) 如果集合每次迭代一个数据，处理方式不同
      4) 这样迭代器的next构建起来就非常麻烦(既复杂，每次迭代处理方式还不同)
      5) 生成器就可以快速的构建出这个复杂的生成器
         1) 每次迭代，对数据的处理不同(可以相同)，然后返回迭代的数据

3. 生成器的创建方法
   1) 生成器不能直接创建(底层API不开放)
   2) 可以通过生成器创建函数，创建一个生成器
   3) **只要在函数名的前面加*，该函数就变成了生成器函数**
      1) 匿名函数，在()的前面加上*
      2) 普通函数转换成生成器函数，就会失去原先的功能
   4) 调用生成器创建函数，默认返回一个生成器函数
      1) 内部的代码体，会放在一个特殊的地方(调用函数不会进行执行)
      2) 内部代码变成迭代执行的代码，使用next才进行执行


4. 生成器的使用
   1) 生成器是为了给迭代提供数据，所以就需要有指令提供数据
      1) 迭代一次，运行一部分生成器中的代码，然后返回迭代到的数据
   2) `yield指令`
      1) 调用一次next方法，生成器函数中的代码执行一次，执行完yield后面的表达式，停止执行
      2) 然后把yield后面表达式的值，赋给迭代返回的对象中的value属性，作为本次迭代得到的值
      3) **done属性一定为false**，代码停止还没有运行完，哪怕yield在函数的最后
         1) 函数最后为return，虽然没写，但是会自动添加，返回undefined
         2) 所以，虽然yield写在最后，实际后面还有代码，表示当前生成器还可以进行迭代
         3) done的属性值自然为false
      4) **下次迭代，从上次迭代的位置(yield)开始执行，执行完下一个yield后方的表达式**
   3) `return指令(表示迭代完成)`
      1) 如果生成器函数中没有yield关键字，进行迭代(运行next)，会一直运行到结束
      2) 如果生成器函数中存在yield关键字，以yield为分界线，迭代一次运行一段代码
      3) return的作用
         1) 标记，生成器的最后一次迭代
            1) 如果某次迭代，运行了生成器的return，表示生成器中定义的代码已经运行完成
            2) 本次迭代是最后一次迭代
         2) 把return值，作为本次迭代的数据返回，如果没有返回值，为undefined
         3) 与正常迭代不同之处
            1) 如果生成器存在return，则迭代出的对象，value属性有值
            2) 但是done属性的值为true，表示迭代完成
            3) 正常迭代器，done为true，value为undefined


5. yield指令的使用
   1) 分割生成器中的代码，迭代一次运行一段代码
   2) yield指令，与赋值符号一起运用的原理
      1) 比如: const a = yield ?
      2) 并不是yield后面的表达式运行结果赋值给a，作为本次迭代的返回数据
      3) **迭代一次运行完yield后面的表达式，返回表达式值，就会立刻停止执行**
      4) 即，虽然赋值符号与yield写在一起，但是并没有被解析
      5) 解析时间: 进行下一次迭代，代码重新执行，此时才会解析赋值符号进行赋值
         1) **此时迭代，就已经与上一次迭代无关了**
         2) 所以赋值符号使用的也不是上一次迭代的结果
         3) 迭代，就是运行next方法，next方法运行值可以传递参数
         4) 赋值符号使用的就是本次迭代，next的传参，把传参赋值给a


6. 生成器的原理
   1) 生成器就是一个特殊的对象
   2) 该对象即使一个迭代器，存在next属性(迭代调用的方法)
   3) 该对象也是一个具有可迭代协议的对象，存在知名符号`Symbol.iterator`
   4) 生成器创建函数中的代码，按照yield拆分完，放在一个集合中
      1) 迭代一次，运行一段代码

7. 生成器的示范代码
```js
function * a() {
    const a = yield 1;
    // 打印b
    console.log(a);
    const b = yield 2;
    // 打印c
    console.log(b);
    return 3;
}

// 创建生成器
const sheng = a();
// 迭代一次，打印{value: 1, done: false}
console.log(sheng.next("a"));
// 迭代一次，打印{value: 2, done: false}
console.log(sheng.next("b"));
// 迭代一次(结束)，打印{value: 3, done: true}
console.log(sheng.next("c"));
```


8. 生成器与promise的配合使用
   1) 使用原理
      1) yield后面跟的表达式，返回一个promise对象
      2) 使用生成器创建函数，创建生成器
      3) 生成器调用next，进行迭代，得到的迭代数据对象的value属性就是一个promise对象
      4) 给promise对象绑定状态，当promise对象的状态改变，触发成功回调函数
      5) 成功回调函数中，在调用生成器的next方法，继续迭代
      6) 并且传入成功回调函数接收的参数(上次迭代得到的promise对象的状态改变时的传参)
      7) 可以使用递归的方式，进行生成器的迭代
   2) 示范代码
   ```js
   function * a() {
       const a = yield fetch("http://127.0.0.1:10086/a");
       const ajie = yield a.text();
       console.log(ajie);
       const b = yield fetch("http://127.0.0.1:10086/b");
       const bjie = yield b.text();
       console.log(bjie);
       const c = yield fetch("http://127.0.0.1:10086/c");
       const cjie = yield c.text();
       console.log(cjie);
       return cjie;
   }


   // 创建一个生成器
   const f = a();
   function d(res) {
       // 进行一次迭代(返回一个对象，对象中的value属性是一个promise对象)
       const pro = f.next(res);
       // 判断是否迭代完成，迭代完成，该属性为true
       if(pro.done) {
           console.log(pro, "结束");
           return pro.value;
       }
       // 如果没有迭代完成，给promise对象绑定回调函数
       pro.value.then( (res) => {
           // 如果promise对象变为成功状态，表示promise对象的功能处理完成
           // 可以进行下一次的迭代处理，进行递归
           d(res);
       } )
   }
   d();
   ```


9. 使用点点点运算符和for-of循环迭代生成器
   1) 只要具有可迭代协议，就可以使用点点点运算符和for-of循环进行迭代
   2) 生成器的原型上就具有可迭代协议，所以是可以使用点点点运算符和for-of循环迭代生成器
   3) 由于for-of和点点点，只有迭代返回对象的done属性的属性值为false，才展示迭代出的数据
   4) 但是，生成器构建函数的return返回值，使用for-of或点点点运算符是得不到的
      1) 最后一次迭代的done的结果为false，对应的value不会显示出来




