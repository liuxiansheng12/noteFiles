
#### class类

1. 类的作用
   1) 简化构造函数的书写，以及原型的书写
   2) 是一个构造函数看起来向一个整体
      1) 和其它大型语言相似


2. 类的特点:
   1) 类声明不会进行提升，与let和const一样，并且也存在暂时性死区
      1) 必须先声明在使用
   2) 类中的所有代码均在严格模式下执行
   3) 类中的所有方法都是不可枚举的(原型上的方法)
      1) 遍历对象，无法遍历出原型上的方法
   4) 类中的所有方法，都不能作为构造函数，通过new的方式调用，如果调用报错
   5) 类构造器必须通过new的方式调用


3. 类的使用
   1) 通过`class A {}`创建一个类，A是类的名称
   2) 类通过函数`constructor`函数，创建类的构造器(相当于构造函数)
   3) 原型上的方法，直接在类中写函数
      1) 比如: `class A{ constructor(){} pro() {} }`，pro为定义在原型上的方法
      2) new A的传参，constructor接收到传入的具体的参数
      3) 即类的形参在constructor上定义
   4) 定义类的静态属性，通过`static`进行标记
      1) 比如: `class A{ static b() {} }`，方法b作为A的静态属性函数
      2) 调用该函数，需要通过A.b()进行调用
      3) 定义普通的静态属性: `class A{ static b = 123 }`
   5) 如果在类中以赋值的方式定义属性，会作为私有属性进行定义(被称为字段初始化器)
      1) `class A{ b = 5 }`，b会作为使用该类构造出的对象的私有属性
      2) 相当于`class A{ constructor(){ this.b = 5 } }`
      3) 该功能是Es7中提出的
      4) 间接说明，类的原型上只能定义方法，无法定义出普通属性
         1) 除非间接使用`__proto__`进行定义
      5) 可以通过该方法定义私有属性的固定值(不是从外界传入的)
      6) 在constructor中可以使用字段初始化定义的数据
         1) 即使字段初始化器定义在constructor的后面
         2) 说明字段初始化执行的时间早于constructor的执行
      7) **通常使用该方法绑定this(利用箭头函数)**
         1) 为了防止`const fun = obj.b;  fun()`，以这种方式调用
         2) 但是b函数中使用了this，此时就会报错
         3) 严格模式下，直接调用，this指向undefined，而不是window
         4) 可以使用字段初始化器，绑定this，示范代码如下:
         ```js
         class A {
             b = () => {
                 console.log(this);
             }
             // 由于使用的是箭头函数，内部的this指向外界环境的this
             /**
              * 字段初始化器相当于
              constructor() {
                  this.b = () => {}
                  * 此时的constructor的this，指向的就是创建的对象
                  * 是否是通过obj对象调用，this指向相同，指向创建的obj对象
              }
             */
         }
         const obj = new A();
         const fun = obj.b;
         b();
         ```
   6) 使用计算属性名
      1) 在类中，每个属性名(私有属性、或者原型属性、或者静态属性)都可以直接使用`[]`，内部直接添加计算属性表达式
      2) 并且在调用时，也可以直接通过[]，内部添加对应的计算属性表达式进行调用
      3) 示范代码
      ```js
      const name = "abc"
      class A {
          constructor() {
              this[name] = 1
          }
          [name + 1]() {
              console.log(this[name]);
          }
      }
      const a = new A();
      a[name + 1]();
      ```
   7) 添加存取器属性(相当于Object.defineProperty方法中的set和get)
      1) 对某个属性值赋值，运行某个函数
      2) 取值的时候，也运行某个函数，然后把返回值作为取到的值返回
      3) Es5需要借助Object.defineProperty函数的辅助才能完成
      4) 但是在类构造器中，简化了操作。可以直接通过set和get关键字直接设置
      5) 示范代码
      ```js
      class A{
          constructor() {
              // 甚至在constructor中触发下方对应的监听属性函数
              // 说明age的形成时间很早，在函数开始就赋值，然后此处相当于重新赋值
              this.age = 123;
          }
          set age(a) {
              this._a = a;
          }
          get age() {
              return this._a;
          }
          // 相当于在constructor中(私有属性)添加了一个age属性
          // 当给该属性赋值时，运行对应的set标记的函数
          // 当获取age的值时，运行对应的get标记的函数
          // 这两个方法并不是定义在原型上的
      }
      ```
   8) 类表达式(匿名类)
      1) `const A = class {}`，这种表达式被称为类表达式，使用方式不变
   9) 通过类构造出的对象，可以通过`__proto__`影响到构造函数的原型
   10) 可以通过`类名.prototype`访问到原型空间


4. 类的继承(构造函数原型的继承和私有属性的继承)
   1) 有两个关键字
      1) `extends`: 继承原型属性
      2) `super`: 继承私有属性，可以传递参数，并且监听属性set和get定义的属性也可以继承4
      3) 这两个关键字是必填的
      4) 子类中没有写constructor，则不用写super。
         1) 实际上启用了底层默认的constructor，自动调用super
         2) 并且底层的constructor定义形参和继承类的constructor的形参个数相同
         3) 然后使用super传入到继承类的constructor中
   2) 静态属性无法继承
   3) this指向，无特殊情况，一直指向创建出的对象，继承属性中的this也指向创建的对象
   4) 一般父类，都是抽离一些有相同特征子类的相同属性，照理说不能直接通过new调用
      1) 只能通过子类的继承属性super调用
      2) 可以在父类中使用`new.target`进行判断
    


