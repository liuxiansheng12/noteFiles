
#### 普通符号


1. 作用
   1) 为了解决对象的属性私有化，而诞生的一种数据类型，被称为符号


2. 使用
   1) 通过调用函数`Symbol`，得到符号
      1) 虽然是一个构造函数，但是不能通过new的方式调用，而是直接使用
   2) 函数中可以传递参数，传递的参数没有什么用处，只是起一个说明作用，被称为符号说明
   3) 比如: `const sym = Symbol("描述");`，得到的是`Symbol(描述)`;



3. 特点
   1) 符号没有字面量的书写方式，只能通过调用函数Symbol进行创建;
   2) 使用typeof得到的符号类型，为`symbol`;
   3) **Symbol得到的符号永远不相等，即使长得一样**
      1) 比如: `let a = Symbol("a"); let b = Symbol("a");`
      2) `a === b`，得到的是false
   3) **Symbol字符可以作为对象的属性名存在，利用该功能完成对象的属性私有化**
      1) 外界通过对象，无法使用该属性，只能对象内部才能使用
      2) 借助了闭包和符号永远不相等的概念，实现对象属性私有化的开发
      3) 对象属性私有化的示范代码
      ```js
      function createObj() {
          // 创建Symbol属性
          const sym = Symbol();
          return {
              // 添加一个私有属性
              [sym]: 123
          }
      }
      ```
      4) 通过函数创建出一个对象，由于闭包的作用，sym外界是无法获取的。
         1) 属性获取不到，则外界通过`对象.属性`也无法获取到属性对应的属性值
         2) 通过`对象.[ Symbol() ]`，虽然属性长相相同，但是不是同一个，所以也无法获取。
         3) 遍历对象，可以获取到对象的属性，通过遍历的属性就可以访问到对应的属性值
         4) Symbol为了防止该情况，所有的字符属性都是不可枚举的
            1) for-in无法获取到字符属性
            2) Object.keys()，获取对象的所有可以枚举的属性，但是无法获取符号属性
            3) Object.getOwnPropertyNames()，获取可枚举和不可枚举的属性，也无法获取符号属性
         5) 属性获取不到，自然无法获取到对应的属性值，这样该属性就变成了对象的私有属性
         6) 函数内部可以获取到定义sym，从而读取到对应的属性值
         7) 如果外界非要使用字符属性，Es6提供了一个方法`Object.getOwnPropertySymbols()`
            1) 该方法可以获取到一个对象中的所有字符属性，只能得到字符属性
            2) 不会顺着原型链查询，只获取传入对象的字符属性
  



