




#### 导包时候的细节
1. 使用绝对路径导包
2. 使用相对路径导包（**./**）
   1. 相当于当前路径进行导包，其实最终也是转换成对应的绝对路径
3. 使用相对路径导包（**abc**），没有点
   1. 查看是否为内置模块，比如: **fs，node**
   2. 从node-modules文件夹下查找，如果没有找到，去父文件中的node-modules中查找，如果最终还没有找到，就报错
   3. 最终也是转换成绝对路径，进行导包
4. 如果一个路径找不到，先自动拼接后缀名，依次查找的顺序为 **`.js`、`.json`、`.node`、`.mjs`**
   1. 如果还找不到，会作为文件名，查看下面的`index.js`文件
   2. 所以`./a` 的查找顺序为
      1. 先查找 `./a.js`
      2. 在查找 `./a.json`
      3. 在查找 `./a.node`
      4. 在查找 `./a.mjs`
      5. 在查找 `./a/index.js`
      6. 还找不到，报错
5. 如果相对路径写的是 `abc`，也就是去 `node-modules` 文件中查找，比较特殊
   1. 拼接后(那四个)，如果没有找到，作为文件夹，查找下面的index.js文件
   2. 其实是先查的是，abc下有没有package.json文件，如果有的话，读取该文件中的main属性
      1. 然后，把该属性拼接在abc上进行查询
      2. 比如: `main: ./cc/index.js`
      3. 最终查询的位置是 `abc/cc/index.js`
      4. 如果，`main: ./cc`
      5. 最终查询的是 `abc/cc`
         1. 会基于这个路径，进行拼接后缀(那四个)，如果没有找到，查询`abc/cc/index.js`
      6. 如果没有找到，是不会在获取 `abc/index.js` 的
   3. 如果没有，在查找index.js
6. 根路径中的 `package.json`，中的main属性，指定的是，命令行运行node时，拼接的路径名
   1. 比如: `main: ./cc/index.js`
   2. 运行: `node ./a`  如果找不到，也是先拼接后缀(那四个)，如果还找不到，就会运行 `node ./a/cc/index.js`
   3. 默认是: `main: ./index.js`
   4. 运行: `node ./`  如果找不到，也是先拼接后缀(那四个)，如果还找不到，就会运行 `node ./index.js`
      1. 如果改成: `main: ./abc.js`
      2. 运行: `node ./`  如果找不到，也是先拼接后缀(那四个)，如果还找不到，就会运行 `node ./abc.js`
   5. **利用该方法，可以一定程度上简化命令行，运行文件，的路径的书写**




#### module的细节
1. 这是一个对象，在node运行的时候，就创建好了
2. 模块通过，这个对象，可以获取到该模块的一些信息，比如，那个模块引入了该模块，该模块的子模块有那些






#### 每个模块，其实是包裹在一个函数中执行的，并且函数会注入四个属性
```js
function a(module, exports, __dirnama, __filename) {
    // 模块代码
}
```
1. 并且函数的执行方式为: 
```js
a.call(module.exports, module, module.exports, __dirnama, __filename);
```
2. 所以，模块抛出数据，其实是往 `module.exports` 中注入数据，然后进行缓存
3. 我们通过 `require()`，引入数据的时候，其实先看缓存中有没有，如果有直接获取，如果没有的话，才解析模块，然后进行缓存
   1. 是根据 `require()` 传入的路径，获取对应模块的数据。
   2. 类似，把所有模块的数据放在一个对象中，对象的属性为模块路径名，值就是 `module`
4. 我们通过 `require()`，引入数据的时候，该方法，返回的就是对应模块的 `module.exports` 属性 
5. **注意点**
   1. `require()` 方法，最终获取的是，对应模块的 `module.exports`
   2. 对应模块在执行的时候，共有三个属性可以访问到 `module.exports`，然后注入数据，如果不注意，则模块抛出数据就会出现问题
   3. 示范代码
   ```js
   this.a = 1;
   exports.b = 2;
   module.exports = {
       c: 3
   }
   // 由于，require最终得到的是 module.exports
   // 虽然，刚开始的时候，this   exporst   module.exports 指向的是同一个对象
   // 但是后面，改变了 module.exports 的指向，这样在获取的时候，获取的就是新的对象空间 {c: 3}
   // 而 a 和 b 是存在旧空间中，是获取不到的

   // 如果没有改变 module.exports 的指向，而是通过.的方式操作，则这三个操作的是同一个的空间
   // require获取值的时候，获取的也是该空间，则 a   b   c 都可以获取到
   
   // 以上过程需要特别注意
   ```