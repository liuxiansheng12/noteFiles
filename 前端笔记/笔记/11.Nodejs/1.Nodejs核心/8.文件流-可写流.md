

#### 创建一个写入流
1. `const f = fs.createWriteStream(路径，配置对象)`
2. 配置对象中，常用的属性有
   1. `flag`，控制写入的方式，默认是覆盖，如果设置为 `a`，则追加
   2. `encoding`: 设置解码的字符集，把传入的文本解析成字节
   3. `highWaterMark`，控制一次最多可以写入多少个字节，与字符集没有关系，就是字节数
      1. 而一个汉字，按照`utf-8`解析，是占三个字节的
      2. 默认是 `16 * 1024`，也就是16kb

3. 写入一组数据
   1. `f.write(data)`，data可以为字符串，也可以为Buffer数组。如果是字符串，按照给定的字符集，解析成Buffer
   2. 该方法有一个返回值，是boolean类型，表示写入的通道中还有没有数据
      1. 如果还有空余的位置，返回true。如果没有空余的位置返回false 
         1. 如果返回false后，还进行使用该方法写数据，就会把数据放在排队队列中排队
      2. 调用一次`f.write(data)`就是写入一个数据，如果调用很多次，是会造成背压的问题的
      3. 原因就是: 写文件是很慢的，但是node执行是非常快的，嗖的一下就完成
      4. 假设，`highWaterMark` 设置的是 `3`，表示一次只能写 `3` 个字节
         1. 其实是，底层开辟了一个3个字节的管道，用来写数据
         2. 但是，nodejs执行很快，3个字节，一下子就堆满了，导致后面需要写入的数据，就要进行排队
         3. 而排队，其实就是一个内存队列，如果要写的数据很多，内存队列中就会存放非常多的数据，在那等着。
            1. 当管道中，有空余位置后，排队队列中的数据，就会进入管道，继续写
         4. **如果数据量过大，这样就会造成内存的压力过大，从而崩溃，所以要避免这个问题**
            1. **避免这个问题，就需要用，f.write()的返回值，当返回false的时候。说明，管道已经装不下了**
            2. 就不要再装了，再装就要放到排队队列中了
            3. 如果返回true，但是还有一个空余字节，一下子又写了10个字节的数据，剩下的9个进入排队队列中排队。
            4. 给内存造成的压力也可以忽略不计，就9个字节
          5. 当 `write` 返回false的时候，为了减少内存的压力就先不进行写了，先让之前的数据写一会，写完之后在继续写
             1. **如何监听管道中的数据已经全部写完了呢，通过 `drain` 事件**
             2. 该事件的触发点，是当管道装满后，全面写完后触发，如果没有装满，写完后是不会触发的
             3. 这样的话，我们就可以在该事件的处理函数中，继续写数据了
             4. **大大缓解了内存的压力**

4. 写完后，需要手动给文件一个关闭的信号，此时文件才进行关闭
   1. 通过 `f.end()` 方法，该方法一执行，就会告诉文件，写完了，可以关闭了，此时文件就会关闭
      1. 前提是： 配置对象中的属性 `autoClose` 的属性值为`true`(默认值)，如果设置为`false`，是无法关闭的
      2. end方法，也可以传递数据，格式为字符串或者Buffer， 表示最后一次写入的数据，写入完成后，文件关闭。
         1. 通常不进行数据的传递，只是关闭文件
   
   