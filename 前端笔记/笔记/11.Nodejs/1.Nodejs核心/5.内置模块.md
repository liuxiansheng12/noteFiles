

#### os包
1. `os.EOL`，获取换行符，不同的系统可能不一样，比如`\r\n`
2. `os.arch()`，获取架构名，比如 `x32` 或者 `x64`，安装软件的时候需要考虑这个东西
3. `os.cpus()`，获取CUP，每一个核的信息，格式是一个数组，**数据的长度，代表当前电脑有多少个内核**
4. `os.freemem()`，获取当前电脑，还有多少个空余的内存可以使用，单位是字节，**转换的话，除1024**
5. `os.homedir()`，获取当前电脑的用户目录
6. `os.hostname()`，获取当前电脑的主机名
7. `os.tmpdir()`，获取当前电脑的**操作系统的临时目录**



#### path包（路径包）
1. 该包中，有一些方法，处理路径字符串，并不会真正的查询文件。只是单纯的操作路径字符串，比如拆分，拼接，截取
2. `path.basename()`
3. `path.sep`
4. `path.delimiter()`
5. `path.dirname()`，给一个路径，获取该路径的目录
   1. 比如: `path.dirname('a/b/c/d.index')`，得到的是 `a/b/c`，不会检查文件
6. `path.extname()`，给一个路径，获取该路径的后缀名，不会检查文件，没有后缀名，得到的是空字符串
7. `path.join()`，把多段路径，拼接成一个路径
   1. 比如: `path.join('a', 'b', 'c', 'd.js')`，拼接完为 `'a/b/c/d.js'`
   2. 甚至可以使用 `../` 进行返回，比如: `path.join('a/b/c', '../', 'd.js')`，拼接完为 `'a/b/d.js'`
      1. `../`，返回上级目录，所以，`c` 就没有了
8. `path.normalize()`
9. `path.relative()`
10. `path.resolve()`，传入一个相对路径，得到一个绝对路径，其实就是一个拼接字符串
    1. 比如: `path.resolve('/a/b', './index.js')`，得到的是 `'/a/b/index.js'`
    2. 如果没有传递绝对路径，则根据当前的命令行所在的绝对路径拼接
    3. `../`也可以回退



#### url包
1. 这个包，可以解析`url`信息，**本质上就是分析 `url` 字符串**，然后得到分析出的信息，比如提取 `url` 上传递的数据
2. 使用方式，`new url.URL(u)` 或则 `url.parse(u)`，得到的是一个`url`对象
   1. `URL.format(obj)`，可以把一个 `url` 对象，转换成一个`url`字符串
   2. 也就是说，是可以反向转换的



#### util（工具包）
