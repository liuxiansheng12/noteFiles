<script src='/笔记/see/index.js'></script>
[toc]

#### 概念
- 使用该 hooks，可以在函数组件中，创建出组件状态，并且修改该状态也能引发重新渲染
- 注意点：
  - 不能放在循环判断、回掉函数中使用，否则会报错（在每个组件渲染中，必须以完全相同的顺序调用React钩子）
    - 条件判断，可能打破 useState 的调用顺序


#### 使用
- useState，返回一个数组
  - 数组的第一项为状态值
  - 数组的第二项为修改状态的函数（调用此函数，修改状态，可以引发重新渲染）
```js
function Demo() {
    // 创建状态
    const [a, setA] = useState('a');
    // 修改状态
    const onClick = () => {
        setA('a修改');
    }
    return (
        <div>
            {a}
            <div onClick={onClick}>按钮</div>
        </div>
    )
}
```


#### 状态修改
- 状态修改有两种方式，并且是异步修改的（即修改完紧接着获取，还是旧状态）
  - 方式一：直接传入修改后的值
  - 方式二：传入一个回调函数（同一个状态的回调函数，会放在一个队列中，然后依次执行）
    - 最后一个函数的返回值，会做为新的状态
    - 回调函数，接收一个参数（新的状态）
    - **使用回掉函数，可以获取到前一个状态进行使用**
```js
function Demo() {
    const [a, setA] = useState('a');
    const onClick = () => {

        setA('a修改1');
        // 如果想要紧接着使用 a修改1，可以用变量保存，然后 setA(变量);，这样就能使用新的值了
        //    还有一种方式：就是利用回调函数，会把这个值进行传入，然后就可以使用了
        setA((d) => {
            console.log(d, '1');  // 得到的就是 a修改1（新的状态）
            return 'a修改2'
        });
        setA((d) => {
            console.log(d, '2');  // 得到的就是 a修改2（新的状态）
            return 'a修改3'        // 这个会作为最后的状态，进行修改引发重新渲染
        });
        
        // 打印的还是 a，并且这个打印先执行，因为修改状态是异步执行的
        console.log('a');
    }
    return (
        <div>
            {a}
            <div onClick={onClick}>按钮</div>
        </div>
    )
}
```
