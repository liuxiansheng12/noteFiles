- setState的作用：修改组件内定义的状态，并且引发重新渲染
  - 只要一调用，传入一个对象（哪怕是个空对象），就会引发重新渲染，无论有没有值（不传递参数，才不会引发重新渲染）
- setState修改状态，是异步执行的（也有同步执行的情况）
  - 也就是调用 setState后，立刻获取状态，得到的是之前的状态，而不是新的状态
    ```jsx
    class Demo extends React.Component {
        state = {
            age: 20
        }

        // 事件函数需要使用this，所以要用箭头函数
        eventCall = () => {
            this.setState({age: 30});
            console.log(this.state.age);  
            // 打印的是20，而不是30。当事件函数再次执行的时候，age就变成了30
            // 说明，执行 console.log() 的时候，状态还没有发生变化，说明this.setState是异步执行的
        }

        render() {
            return (
                <div className='Demo'>
                    <div onClick={this.eventCall}>ann</div>
                </div>
            )
        }
    }
    ```

.
.
- setState同步执行的情况
  - 在 setTimeout 和 setInterval 中是同步执行的（即不是由事件触发的，而是电脑在某个情况下，自动执行的代码，修改状态是同步执行的）
    ```jsx
    class Demo extends React.Component {
        state = {
            age: 20
        }

        // 事件函数需要使用this，所以要用箭头函数
        eventCall = () => {
            this.setState({age: 30});
            console.log(this.state.age); 
            // 打印20，说明是异步的（是由事件触发的）
            setTimeout(() => {
                this.setState({age: 40});
                console.log(this.state.age); 
                // 打印40，说明不是由事件触发的，而是时间到了，电脑自动触发的
            }, 1000) 
        }

        render() {
            return (
                <div className='Demo'>
                    <div onClick={this.eventCall}>ann</div>
                </div>
            )
        }
    }
    ```
    - React这样考虑的原因：事件可能会执行很复杂的逻辑，期间可能涉及到大量使用setState，如果改成同步的（每执行一次，就重新渲染一次，就会很卡（重新渲染需要一定的计算能力））
      - 所以，就把事件中的setState做成了异步的（先放在一个队列中，当时间到了，统一执行修改状态，然后触发一次的重新渲染）
      - 而 setTimeout 和 setInterval 中很难有复杂的代码，所以就是同步执行的，便于修改状态后，使用状态（不是之前的值，而是新的值，这样更加方便）



.
.
- setState的回掉函数（可以解决，修改状态后，获取不到新的状态）
  - 一个是利用 setState的第二个参数，传入一个回掉函数
    - 会把所有的回掉函数，放入一个队列中，当重新渲染后，依次执行（这样就能获取到变化后的值）
      - **由于，回掉函数的执行是发生在render后，所以可以获取到新的状态**
    ```jsx
    class Demo extends React.Component {
        state = {
            age: 20
        }

        // 事件函数需要使用this，所以要用箭头函数
        eventCall = () => {
            this.setState({age: 30}, () => {
                console.log(this.state.age);
            });
            this.setState({age: 40}, () => {
                console.log(this.state.age);
            });
            this.setState({age: 50}, () => {
                console.log(this.state.age);
            });
            // 由于是渲染后，统一执行，所以先执行render，在执行上面的三个回掉函数
            //    由于是状态全部修改完成，在进行渲染，所以三个回掉函数，打印的都是 50
        }

        // 事件函数需要使用this，所以要用箭头函数
        eventCall = () => {
            this.setState({age: this.state.age + 1}, () => {
                console.log(this.state.age);
            });
            this.setState({age: this.state.age + 1}, () => {
                console.log(this.state.age);
            });
            this.setState({age: this.state.age + 1}, () => {
                console.log(this.state.age);
            });
            // 渲染后，统一执行三个回掉函数，打印的都是 21
            // （原因：上面三个setState执行的时候，不会引发重新渲染，所以状态没有变化，三个最终设置的都是 21）
        }

        render() {
            console.log('渲染');
            return (
                <div className='Demo'>
                    <div onClick={this.eventCall}>ann</div>
                </div>
            )
        }
    }
    ```
    - 要注意的是：**重新渲染后，在依次执行**
.
.
  - 一个是利用 setState的第一个参数，传入一个回掉函数（之前传入的是一个对象）
    - 传入的函数，也会放在一个队列中，也是异步执行的，但是执行的时间在render
    - 每个函数的返回值，都会与原始的state进行融合，**得到一个新的对象，传入下一个执行的函数中**
      - 也就是返回的obj，相当于 setState(obj)
      - 当最后一个函数执行完成后，最后引发一次重新渲染（所以，执行时间在render前）
    - **由于，状态融合后，会传入下一个回调函数中，所以，在后面的回掉函数中，可以获取到前面设置的新状态**
    ```jsx
    class Demo extends React.Component {
        state = {
            age: 20,
            name: 30
        }

        // 事件函数需要使用this，所以要用箭头函数
        eventCall = () => {
            this.setState((state) => {
                console.log(state);
                return {
                    age: 25
                };
            });
            this.setState((state) => {
                console.log(state);   // 得到的状态，age就已经是 25（上面与state融合后传入）
                return {
                    name: 50
                };
            });
            this.setState((state) => {
                console.log(state);   // 得到的状态，name就已经是 50（上面与state融合后传入）
                return {
                    age: 333
                };
            });
            // 最终，name也变成了50，说明，不是最后一个回掉函数，才会与原始的state进行融合
            // 而是，每一个返回值，都会进行融合，融合完最后一个，得到的就是最终的 state，所以name才会变成 50
            // 最后，age是 333，第一个融合变成了 25，最后一个融合会替换它（都是age），所以变成 333

            console.log('执行');  
            // 这个打印先执行，上面的回掉函数在执行，说明上面的回掉函数也是异步触发的，并不是立即执行的
        }

        render() {
            return (
                <div className='Demo'>
                    <div onClick={this.eventCall}>ann</div>
                </div>
            )
        }
    }
    ```
