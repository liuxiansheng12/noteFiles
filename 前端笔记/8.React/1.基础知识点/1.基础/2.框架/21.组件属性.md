- 组件属性的传递
    ```jsx
    <Demo name='张三' age={18} ></Demo>
    ```


- 函数组件使用行间属性
  - 会把行间属性汇总到一个对象中，然后传递
    ```jsx
    function Demo(props) {
        return (
            <div className='demo'>
                <span>{props.name}</span>
                <span>{props.age}</span>
            </div>
        )
    }
    ```


- 类组件使用行间属性
  - 会把行间属性汇总到一个对象中，然后传递到构造函数中
    - 构造函数，类组件默认已经定义好了，不用手动写
    ```jsx
    class Demo extends React.Component {
        // 构造函数，默认已经写好了，可以忽略
        // 但是，如果自定义了构造函数，下面的内容在构造函数中必须存在
        constructor(props) {
           super(props); // 内部执行了 this.props = props;
           // 如果构造函数中，只有这些内容，会出现警告，但是不影响使用
           // 警告的原因：默认已经实现了，不需要在写一遍了
        }
        render() {
            return (
                <div className='Demo'>
                    <span>{this.props.name}</span>
                    <span>{this.props.age}</span>
                </div>
            )
        }
    }
    ```


.
.
- 行间属性的优化
  - 如果，行间属性过多，可以先放在一个对象中，然后在组件行间中进行展开传递（效果是一样的）
    ```jsx
    const obj = {
        name: '张三',
        age: 18
    }
    <Demo ...obj ></Demo>
    // 相当于
    <Demo name='张三' age={18} ></Demo>

    // 写成 ...obj，便于管理，但是可读性不好，一眼不知道传递了哪些参数
    // 如果行间属性定义的过多，就会显得有些混乱，但是这样写可读性比较好，一眼就知道传递了哪些参数
    ```

.
.
- 组件中的行间属性对象中的属性，是无法修改的（只可读，但是监听的没有那么深）
  - 没有进行克隆，把属性直接存到props中，然后把props设置成只读
  - 这样的结果就是，如果行间属性是一个集合，是可以修改的（只读限制，限制不了这个集合）
    ```jsx
    function Demo(props) {
        // 修改就会报错
        props.name = '李四';
        // 但是，监听的没有那么深，比如行间属性是一个集合，这样是可以修改的
        props.obj.name = '李四';
        // props.obj 得到的是原始对象（没有克隆），所以可以进行修改
        // 但是，不要这样操作

        return (
            <div className='demo'>
                <span>{props.name}</span>
                <span>{props.age}</span>
            </div>
        )
    }
    ```
    - 作用：保证数据的完整性（那个组件定义的属性，只能那个组件中进行修改，这样有利于排错）
    - 比如：A中定义了一个属性，然后传入了B中，但是B做了修改
    - 然后A中使用这个属性，报错了，如果层级比较深，时间一长，就不知道这个属性在那个组件中做了修改从而导致了报错，这样就不好排错了
    - 为了避免这种现象，所以，组件中的行间属性对象中的属性，无法修改，修改就会报错


