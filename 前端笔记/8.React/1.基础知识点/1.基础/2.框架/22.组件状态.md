- 组件状态：组件中自己维护的一些数据，和外界（父级组件）没有关系

- 组件状态的使用
  - 函数组件要想使用状态，需要借助hooks（useState），后面介绍
  - 类组件状态的使用
    ```jsx
    class Demo extends React.Component {
        constructor(props) {
           super(props); 
           // 上面的内容必须要存在，因为要接收组件属性

           // 定义组件状态
           this.state = {
               name: '张三',
               age: 20
           }
        }

        // 状态定义（常用，不借助构造函数，书写量少）
        // 如果这两种情况都定义了，则构造函数的状态集合会覆盖这里定义的（整个替换，而不是混合替换）
        state = {
            age: 2033
        }

        render() {
            return (
                <div className='Demo'>
                    {/* 使用组件状态 */}
                    <span>{this.state.name}</span>
                    <span>{this.state.age}</span>
                </div>
            )
        }
    }
    ```


- 组件状态的修改（类组件）
  - 如果想要引发重新渲染，需要借助 this.setState 这个函数。
    - 该函数，传入一个对象，会把传入对象的属性，替换原始state对象中的属性（没有创建，有就替换）
    - 并不是整个对象全部替换，而是把两个对象进行融合（传入的对象 和 当前的state对象 进行融合）
    - **需要注意的是，setState是异步修改状态的**
      - 也就是修改完，紧接着就使用 this.state 就会发现值还是之前的
    ```jsx
    class Demo extends React.Component {
        constructor(props) {
            super(props); 
            // 上面的内容必须要存在，因为要接收组件属性

            // 定义组件状态
            this.state = {
                name: '张三',
                age: 20
            }

            // 重新渲染
            setTimeout(() => {
                this.setState({
                    age: 33
                });
                // 重新渲染后，发现 name 还是 张三，age变成了 33
                // 说明，该函数传递的对象不会替换state对象，而是把这两个对象进行融合
                //   类似
                /**
                 * const obj = {...this.state} 已有的属性不能进行删除
                 * for (const prop in _obj) {  遍历传入的对象，替换属性（没有创建，有就替换）
                    obj[prop] = _obj[prop];  没有创建，有就替换
                 }
                 */
            }, 3000)
        }

        render() {
            return (
                <div className='Demo'>
                    {/* 使用组件状态 */}
                    <span>{this.state.name}</span>
                    <span>{this.state.age}</span>
                </div>
            )
        }
    }
    ```
  - 如果不想引发重新渲染，可以直接使用 `this.state.name = 'xxx'` 进行修改
    - 当重新渲染触发的时候，展示的内容就会变成新的值（不渲染，一直是之前的值）
    

- 组件中不能修改组件属性
  - 要想既能接收行间传参，又能修改这个参数。就可以定义一个状态，接受这个参数，然后在修改状态
  - 这样的话，行间参数还是之前的值，组件中又能把这个值作为初始数据，然后修改这个值渲染出不同的内容