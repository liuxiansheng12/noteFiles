<script src='/笔记/see/index.js'></script>
[toc]


#### 准备工作
1. 安装umi
   1) 可以全局安装或者局部安装
      1) 全局安装npm i umi -g
      2) 局部安装npm i umi -D
2. 启用工程
   1) umi dev  表示在开发环境中启用

3. 使用 umi 搭建项目
   > npm create umi


#### umi约定式路由的开发

1. umi约定
   1) umi为了便于开发，进行了一些约定，使用这些约定，可以减少路由的代码开发
   2) 约定
      1) 在项目文件夹下，建立一个src文件夹，内部建立一个pages文件夹
         1) 可以不用建src，直接建立pages文件夹也能使用，为了便于开发，建立src文件
         2) pages文件夹下创建的就是页面组件。
            1) 当时候umi会自动解析该文件夹，创建出一个js文件，为路由Route组件的配置文件
            2) umi根据解析的配置文件，创建对应的Route组件，然后直接插入到页面中进行匹配，不用自己插入。
      2) 根路径对应的展示页面，直接在pages文件夹下创建index.js文件
      3) 文件名(除index外)会直接作为该页面对应的路由地址
      4) 二级或者多级路由对应的页面，把父级路由作为文件夹，把最后一级路由作为文件名
         1) 比如: /a/b/c地址对应的页面组件创建，在pages文件夹下建立a文件夹，然后在a文件夹下建立b文件夹，然后在b文件夹下建立c.js，抛出对应的组件。
      5) 多级路由对应的跟路径展示的文件，也是在对应文件夹下创建index.js文件。
         1) 比如: /a下有子路由/a/b、/a/c。如果想要定义/a对应的展示页面组件，方式有两种
            1) 方法一: 可以通过在pages文件夹建立a.js，该方法不推荐使用。
               1) 原因: /a下有子路由，所以pages下有一个a文件夹，在写一个a.js文件不合适
            2) 方法二: 在a文件夹下建立index.js。表示a对应的根路径，即/a对应的页面组件
            3) 要注意文件名与文件夹名的冲突问题。
      6) 动态路由的创建，借助$符。
         1) 比如/a/:id。创建文件的方式为在pages下建立a文件夹，然后建立$id.js。
         2) 比如/a/:a/:b。创建文件的方式为在pages下建立a文件夹，然后建立$a文件夹，然后建立$b.js文件  
      7) 路由切换，一些组件一直显示(导航栏，页脚栏)
         1) 在src文件夹下(不是pages文件夹)，新建layouts文件夹
            1) 在layout文件夹下建立index.js文件，只能建该文件。
            2) 该文件抛出的是一级路由对应的共享组件(一级路由导航栏，会一直存在)
            3) **一级路由对应的Route组件会作为children进行传入，可以进行动态插入**
         2) 子路由共享组件，二级或者多级导航栏
            1) 在对应的二级路由或者多级路由的父级文件夹下创建layout.js文件。
            2) 会被该文件夹下所有的路由，子路由共享。
            3) 比如: /a/b、/a/c、/a/b/c共享一个组件。就可以在a文件夹下创建一个layout.js文件。
            4) **同样，对应的Route组件会作为children文件进行传入**。
         3) 由于共享组件中，Route会作为children进行传入，所以可以进行动态插入
            1) 比如开头作为导航栏，下面作为页脚。中间就可以动态插入Route组件，进行动态匹配，实现页眉页脚的开发。
         4) 原理
            1) 对应的Route组件，会作为children，传入共享组件中，利用的就是子路由的配置。
            2) 比如a文件夹下有一个layout.js文件，表示共享。
               1) 创建的路由信息为{ path: "/a" component=require("./a/layout").default exact="false" route=[{/a/b}{/a/b/c}] }
               2) umi在解析路由信息时，route会正常解析创建出对应的Route组件，然后传入component组件中。
               3) 当进行路径匹配时，由于/a是不完全匹配，所以共享组件就可以一直显示。
               4) 当使用children时，传入的Route组件就开始匹配
      8) pages文件夹下，直接创建一个404.js。
         1) 在开发模式下访问不存在的路径，使用的还是默认的404页面，便于调试
         2) 如果打包部署上线后，再访问一个不存在的路径，就会显示自定义的404页面   
         3) 可以直接访问/404，查看页面样式 
   3) 修改路由配置文件
      1) 路由配置文件，除了根据pages文件，创建出一些默认的配置属性外，还可以自定义属性(保存一些数据)   
      2) 自定义属性的方式
         1) 在pages文件夹下具体的页面文件中的开始部分(代码前面)，加上/** */。
            1) 内部写的代码会放入配置文件该页面对应的路由数据对象中。
            2) 比如: /** a: 123  b: 456 */ 
               1) 规范: 每一条数据独占一行，:后面加上一个空格，否则没用
            3) 定义数组，不能通过[ ]进行定义，:后面敲上换行(相当于[ ])
               1) 数组的每一项，前面最少有一个空格，空格后面加上-符号，后面再跟上具体的数据
               2) 数组的每一项独占一行。
      3) 配置文件的特殊属性`Routes`
         1) 该属性也是通过/***/进行定义，默认是没有的
         2) 数据格式是一个数组，数组的每一项为一个组件相对于src文件的路径地址
         3) 解析时，该路径对应的组件，就变成了该属性数组中的第一个路径对应的组件
            1) 之前的组件，会作为children传入该属性数组中的最后一个组件中
            2) 最后一个组件，会作为children传入前一个组件中，以此类推
         4) 作用
            1) 该属性可以对一个真正的页面组件进行层层的包装，进行一些功能的验证(是否有权限访问该页面)    
            2) 同意时，插入children，就会显示真正的组件。不同意时不处理对应children，则真正的组件不会加载，表示没有权限访问该页面。
   4) 路由的配置文件中的每一个路由对应的数据对象，会传入到对应的路由组件中，通过props可以获取到配置对象，从中使用自定义的一些数据。  
   5) 所有的自动生成的Route组件，exact默认都设置成了true(完全匹配)，可以通过修改配置文件来进行控制。    



#### umi配置式路由的开发
1. 前言
   umijs路由的开发，其实就是配置式路由的开发。即使是约定式路由的开发，底层也是转成了配置式路由，只不过我们感受不到


2. 配置式路由开发的过程及注意点
   1) 在根路径下创建一个`.umirc.js文件或者config文件夹下config.js文件`
      1) 这两个配置文件，不光可以配置路由信息，它可以配置非常多的东西。
   2) 建立的文件，导出一个对象，对象中建立一个routes数组。用来配置路由信息
      1) 数组的每一项为一个对象，表示一个路由信息
      2) 只要该属性一经定义，则约定式路由就会失效，不定义约定式路由依旧工作
   3) 路由信息对象中常用的属性
      1) path: 用来设置匹配路径
      2) component: 用来设置匹配成功时显示的组件
         1) 该属性的赋值方式为一个字符串，对应组件的地址。**并且是相对于pages文件夹的地址**
      3) Routes: 属性值为一个数组，数组的每一项为一个组件的路径(相对于根路径)
         1) 该属性设置后，匹配成功后，显示的组件不在是component对应的组件，而是该数组的第一项路径对应的组件
         2) component对应的组件，会作为children放入数组的最后一项路径对应的组件中
         3) 该数组的后一项路径对应的组件，会作为children放入前一项路径对应的组件中
      4) route: 子路由，数据格式为数组，数组的每一项为路由的配置对象。
         1) 解析创建出的Route会作为children传入使用该属性的对象的component对应的组件中
         2) 使用route属性的路由对象，exact需要设置为false，默认设置的是true
         3) 使用route属性的路由对象的component对应的组件，作为共享组件，用来设置导航栏或者页脚
         4) 约定式路由的layout.js文件的原理，就是使用的该属性
      5) 可以填写自定义属性


3. 代码示范
```js
export default {
    routes: [
        {
            path: "/",
            // 用来配置导航栏
            component: "./link.js",
            // 该属性必须设置，默认是绝对匹配，这样/a，导航栏组件就匹配不成功
            exact: false,
            route: [
                {
                    path: "/",
                    component: "./Home.js",
                    // 自定义属性
                    a: 123,
                },
                {
                    // 动态路由
                    path: "/a/:id",
                    component: "./A.js",
                    Route: ["./src/a.js", "./src/b.js"]
                }
            ]
        }
    ]
}
```




#### 路由组件与路由数据的导入

1. 在umi中，Route组件会根据路由配置文件自动创建
2. Link组件: 通过`umi/link`手动导入
3. NavLink组件: 通过`umi/navlink`手动导入
4. 获取路由信息history对象中的方法: 通过`umi/router`手动导入，数据格式为对象。对象中是一些history对象中的常用方法(不是全部方法)，比如push、replace。
5. withRouter: 通过`umi/withRouter`手动导入



#### umi中启动dva定义模块(仓库)
1. 前言
   1) umi中，可以手写原生的创建仓库的代码，但是过于麻烦。
   2) dva中，对仓库的创建进行了封装，可以方便简洁的创建出仓库数据
   3) dva要想起作用，必须使用start启动dva，显示页面。但是umi已经把显示的工作给做了，如果在使用start，会导致页面文件放入两次，破坏了结构。所以在umi中不能通过直接引入dva插件的方式使用dva。

2. umi中使用dva的方式
   1) umi提供了一个插件集，内部有非常多的插件依赖，其中就有dva。
      1) 该插件集需要下载: `npm i umi-plugin-react -D`
   2) 要想使用插件集中的某个插件(比如dva)，需要在配置文件中进行插件的启动
      1) 配置文件就是配置式路由使用的配置文件(.umirc.js或者config文件夹下config.js)
      2) 配置文件不光配置路由，可以配置很多东西，开启插件集中的插件就是其中一项功能
   3) 开启的代码
   ```js
    export default {
        plugins: [
            // 第一项为插件的名称，第二项为插件的配置(启动插件集的某个插件功能)
            ["umi-plugin-react", {
                // 把数组中的每一项都生成一个script标签，放入到浏览器显示的HTML文件中
                // 如果是，js代码(写在字符串中)，会创建对应的script标签，把代码放入内部执行
                // 与dva无关，扩展
                scripts: [{src: "a.js"}, {src: "b.js"}, `console.log(123)`],
                // 开启dva
                dva: true
            } ]
        ]
    }
   ```
   4) dva开启后，就可以定义仓库模块了。
      1) 并不是引入一个dva对象，然后使用model方法定义模块，而是使用约定的方式，创建约定名称的js文件，然后抛出一个对象(model传入的对象)
      2) 最终umi在解析的时候，由于dva功能已经开启，底层会自动调用model方法，从约定的文件中引入对象，进行模块的创建
   5) 仓库模块共分为两种，一种是全局模块，一种是局部模块
      1) 全局模块的介绍
         1) 全面模块一开始就创建好模块放入仓库中，所有页面都能使用模块中的数据
         2) 所以，全局模块中通常放一些全局使用的数据
      2) 局部模块的介绍
         1) 局部模块，只有当对应的组件显示时，才会往仓库中加入模块
            1) 当前文件夹中的页面，或者子文件夹中的页面，显示时，加入模块。
         2) 没有对应页面显示时，仓库中是没有对应的模块的。局部模块定义的数据
         3) 只有当前文件夹中的页面，或者子文件夹中的页面可以使用局部模块中定义的数据，其它页面无法使用。
            1) 比如，a文件夹下定义了model，父级文件夹下也有model。
               1) 则a文件夹下的组件可以使用两个模块中定义的数据
               2) 父级文件夹下不在a文件夹下的组件，只能使用父级文件夹定义model，相当于继承。
         4) 所以，局部模块中通常放一些子路由共享的数据
         5) 注意，在开发环境下，局部模块也是会在一开始就加入到仓库中，和全局模块一样，所有模块都可以正常使用，在打包上线后就会恢复正常。
      3) 全局模块的创建
         1) 第一步: 在src文件夹下创建models文件夹
         2) 第二步: 在models文件夹下建立全面模块对应的js文件(可以创建多个文件，对应多个模块)
         3) js文件名，默认作为仓库属性名，可以使用namespace进行设置指定的模块名
      4) 局部模块的创建
         1) 第一步: 在pages对应的文件夹下，创建models文件夹
         2) 第二步: 在models文件夹下建立全面模块对应的js文件(可以创建多个文件，对应多个模块)
         3) js文件名，默认作为仓库属性名，可以使用namespace进行设置指定的模块名
         4) models文件夹可以省略，直接创建model.js文件(但是这样只能创建一个模块)   
   6) 由于局部模块的js文件是放在pages文件夹下，所以约定式路由在解析该文件夹的时候，并不认识该文件，所以正常处理成路由信息对象，生成对应的Route组件，虽然没有太大的影响，但是，会污染路由配置文件。解决办法: **在配置文件中进行配置，禁止约定式路由解析某个文件**，代码如下:
   ```js
    export default {
        plugins: [
            ["umi-plugin-react", {
                dva: true,
                // 排除掉某些文件
                routes: {
                    // 正则表达式，排除掉路径带有models的文件，数组中可以定义多个正则，只要满足一个就忽略
                    exclude: [/.*models.*/]
                }
            }]
        ]   
    }
   ```


3. 使用仓库中的数据
   1) 直接从dva模块中导入`connect`高阶组件，对要获取仓库状态的组件进行包装，使用方法一样
      1) dva插件不需要重新下载，在下载umi的时候已经下载完成，可以直接使用。



#### umi引用样式文件

1. 全局样式
   1) 全局样式文件的定义方式
      1) 在src文件夹下，直接创建global.css文件，该文件就是全局样式文件。
   2) 全局样式文件，umi不会交给css-module插件处理
      1) 文件中定义什么选择器的名称，打包后还是什么名称，不会进行修改
      2) 可以直接使用全局样式的选择器，比如: className="a"
   3) 全局样式文件，由于不向局部样式一样，选择器是唯一的，所以**有时需要多个选择器进行限制**


2. 局部样式
   1) 局部样式文件的定义方式:
      1) 直接在pages文件夹下对应组件所在的文件夹下定义css文件，文件名没有要求
         1) 当通过import引入的时候，umi就会把该文件作为局部样式文件处理
      2) 在src文件夹下创建assets文件夹，然后在内部创建css文件夹，在内部创建具体的样式文件
         1) 当通过import引入的时候，umi就会把该文件作为局部样式文件处理
   2) 局部样式经过打包后，也会作用于全局。
   3) umi为了防止局部样式的选择器产生冲突，自动启用了css-module插件
      1) 比如: 
         1) 一个组件中使用了className="a"
            1) 在该组件对应的局部样式文件中直接使用了.a的方式定义样式
            2) 并没有父级选择器的限制。
         2) 其它组件也有className="a"
            1) 在该组件对应的局部样式文件中也是直接使用.a的方式定义样式
            2) 也没有父级选择器的限制。
         3) 由于umi最终会把所有的样式都打包到一个文件中，此时这两个样式就会产生覆盖问题。
      2) css-module插件，在打包样式文件后，会自动给每一个选择器添加随机的字符串，并且是唯一的，这样就避免了选择器冲突的问题。
         1) umi在打包css时，局部样式文件，使用css-module插件进行处理，全局样式文件不进行处理
         2) 由于局部样式文件中定义的选择器最终会被css-module进行修改，并且是随机的。
            1) 造成不能直接使用局部样式文件中定义的选择器，否则样式作用不上的问题
            2) 应该使用css-module修改后的对应的选择器的名称
            3) css-module修改名称，是随机的，不知道会变成什么名称，所以直接书写实现不了
            4) **被css-module修改的css文件，在引入的时候，会抛出一个对象**
               1) 该对象中的属性就是原始的选择器的名称
               2) 属性值就是对应选择器的名称被css-module插件修改后的名称
               3) 这样就可以通过对象属性的方式，给标签赋对应的选择器
         3) **同一个文件下相同的选择器，变成的随机名称也相同，不同文件下不同**
            1) 标签选择器是不会修改的，无法修改。
   4) 使用局部样式的示范代码
   ```js
   /**
    *  a.css样式中的代码
    *  .a{ ··· ··· }
    */
   import css from "./a.css";
   function A() {
       // 由于局部样式文件会经过，css-module插件处理
       // 打包后的css文件，.a就会变成其它名称
       // 直接写className="a"，样式是无法起作用的
       return <div className={css.a}>123</div>
   }
   ```
   5) **局部样式中选择器的使用，通常不使用父级选择器进行约束**
      1) 由于局部样式，会交给css-module插件进行处理
      2) 处理完选择器就是唯一的，直接使用，也不会产生冲突问题
      3) 可以使用父级选择器进行约束
         1) 没有任何影响，只不过样式文件中要多写些代码(约束的父级选择器)

3. less的使用
   1) 在umi中less可以直接使用，不需要进行特殊的配置。
      1) 并且也分全局和局部样式，局部样式依旧自动修改选择器的名称，保持唯一性。
      2) 局部和全局的定义方式和css相同，只需要把后缀名换成less即可。



#### umi代理

1. 前言
   在开发过程中，umi工程是放在localhost本地服务器下的。如果在开发过程中，需要请求服务器中的数据进行调试，此时就涉及到了跨域的问题。虽然服务器中可以处理跨域的问题，允许访问，但是这样服务器中的数据就会变得非常不安全，只要是localhost都可以请求数据，此时就需要使用服务器代理。

2. umi代理操作
   1) umi在开发过程中，是工作在localhost服务器下的，umi是可以借助该服务器，使其进行代理进行数据的请求，然后在返回给浏览器，这样就不存在跨域问题。
   2) umi启动localhost的代理功能，代理那个请求，是需要在配置文件中进行配置的。
      1) 底层配置的是webpack
   3) 配置代码
    ```js
    export default {
        proxy: {
            // 接收到的请求地址以/api开头。
            "/api": {
                // 把对应的请求地址，打到指定的服务器下
                // 在localhost服务器中完成，被称为服务器代理
                target: "https://www.baidu.com",
                // 修改源(在localhost下发起的请求，修改成上方指定的服务器)
                // 请求源相同，不存在跨域问题
                changeOrigin: true 
            }
        }
    }
    ```



#### umi数据模拟

1. 原理
   1) 当服务器中的代码还没有开发完成，此时前端开发就需要借助模拟数据的方式，模拟出一个假数据进行开发。
   2) 模拟数据的方式有多种
      1) 可以在文件中直接模拟数据，然后读取。
      2) 而umi中有一种更加高级的方式，是采用模拟服务器创建数据的方式。
         1) 前端请求可以写正常的ajax请求(当成服务器已经开发完成)
         2) 由于在开发过程中，是工作在localhost服务器下的，所以请求是直接打到该服务器下
            1) 没有写具体的域名，直接书写地址
         3) umi会在localhost下模拟出一个请求，然后返回对应的数据。
            1) localhost模拟的数据，需要自己创建，有约定式写法
               1) 只需要按照约定式创建文件，当umi工作的时候，该文件中的代码就会放在服务器下作为模拟代码


2. 模拟数据的创建方法
   1) 在根路径下创建mock文件夹，该文件夹下创建的所有js文件
      1) 创建的文件，umi会自动处理，然后把对应的代码放在localhost服务器环境下运行，作为服务器代码。
   2) 模拟文件中的代码示范
    ```js
    export default {
        // 属性名为请求类型和请求地址，请求类型和请求地址之间要有一个空间
        // 属性值为请求返回的数据
        "GET /a/b/c": {
            name: "a",
            arr: [1, 2]
        }
    }
    ```


3. 借助插件(mockjs)快速生成模拟数据
   1) 插件下载: `npm i mockjs -D`
   2) 插件使用(示范代码): 
    ```js
    // 引入组件
    import Mock from "mockjs";
    // 创建模拟数据
    const mock = Mock.mock({
        // 固定的数据
        a: 123,
        // 快速生成数组，arr为属性名，100表示生成的数组中有100项
        // 每一项都是给定的对象格式: 属性名相同，属性值可能随机生成(不同)，如果固定则相同
        "arr|100": [{
            // 固定数据
            a: 1,
            // 生成一个随机的中文名字(100项都是随机的)
            b: "@cname",
            // 生成一个随机的中文地址(100项都是随机的)
            c: "@city",
            // 按照定义的正则，随机生成一个符合的字符串(100项都是随机的)
            d: /demo\d{2}_\d{10}/,
            // 属性值为数字类型，表示生成一个随机数字，取值范围为1000~2000(100项都是随机的)
            "e|1000-2000": 0, 
            // 属性值从给定的数字开始增加，后一项都比前一项增加指定的数据(1)
            "f|+1": 0
            // 随机从数组中选出一位(100项都是随机的)
            "g|1": [1, 2, 3]
        }]
    })
    export default mock
    ```




#### umi引入组件时路径的简化
  
umi中定义组件的层级可能会非常深，如果使用相对路径，一级一级的返回，过于麻烦。
umi中提供了一个@符，相当于从src开始查询，如果没有src，则从根路径开始查询。简化了相对路径的书写。




