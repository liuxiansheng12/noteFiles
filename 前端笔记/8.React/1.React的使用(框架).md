<script src='/笔记/see/index.js'></script>
[toc]


#### react中引入图片路径的问题

1. **不能直接使用相对路径**
   1. 在react中的各个组件中，引入图片。如果img直接使用相对路径，最终会出现问题。
   2. 原因: react最终会进行打包处理，打包完路径就会发生变化。

2. 正确引入的方法
    1. 首先通过`import a from "可以使用相对路径`"，引入图片。
    2. 该组件使用该图片时，直接`src={ a }`，就可以进行图片的引入。


#### css样式文件的引入
在js文件中引入
```js
import "路径"
```
在css文件中引入其它的css文件
```css
@import "路径"
```



#### jsx语法注意点
- 只能有一个根结点
  - jsx是一个语法糖，最终会打包成 `React.createElement()`
    - 也就是最后相当于 `return React.createElement()`
    - 一个 React.createElement() 对应一个节点，所以只能有一个根节点
    - 有两个节点，return 就会报错（不可能 return 1 2，返回两个值，除非返回一个集合，但是<></><></>两个节点，不会自动转换成集合，所以语法上就会报错，即使能打包成功也无法执行，所以jsx就会认为存在两个根节点，是错误的写法）
  - 子节点就无所谓了，因为 React.createElement() 的第三个参数就是子节点，数据类型可以是一个数组（也就是多少个字节点都可以）


- null 和 undefined 和 false 作为节点，不会进行显示，其他的都会进行显示
  - 比如：`<div>{null}</div>`（不显示）
  - 比如：`<div>{undefined}</div>`（不显示）
  - 比如：`<div>{false}</div>`（不显示）
  - 比如：`<div>{0}</div>`（显示0）
  - 即，只有 null 和 undefined 和 false 不会显示，其他的正常展示
    - 并不是只要判断是 false 就不会显示


- 不能把普通对象作为节点（不是所有的对象都不能作为节点，React虚拟元素就是一个对象， 而React虚拟元素是可以作为字节点的）
  - 也就是说：`React.createElement('div', {}, React.createElement())` 这样是可以的（React虚拟元素可以作为字节点）
    - 因为：`<div><span>demo</span></div>` 这种写法是很常见的（html的基础）
    - 所以，第三个参数必须可以传递 React虚拟元素



#### 组件的使用
- 组件：包含内容、样式、功能的UI
- 分类：分为函数组件、类组件
  - **组件的首字母必须大写**

.
- 函数组件的定义
  - 函数组件必须返回一个React元素（jsx表达式或者React.createElement）
    ```jsx
    function Demo() {
        return (
            <div className='demo'>
                <span>demo组建</span>
            </div>
        )
    }
    ```
- 函数组件的使用
  - 不太友好的使用
    ```jsx
    <div>{Demo()}</div>
    // 函数组件，就是一个不同的函数，可以直接调用，得到返回值
    // 这样就相当于直接写成如下内容，没有形成组件结构（也不利于后期的渲染）
    <div>
        {
            <div className='demo'>
                <span>demo组建</span>
            </div>
        }
    </div>
    ```
  - 正确使用
    ```jsx
    <div>
        <Demo />
    </div>
    ```

.
- 类组件的定义
  - 类组件，必须继承React.Component
  - 类组件中，必须有一个render方法，该方法必须返回一个React元素（jsx表达式或者React.createElement）
    ```jsx
    class Demo extends React.Component {
        render() {
            return (
                <div className='Demo'>
                    <span>Demo类组件</span>
                </div>
            )
        }
    }
    ```


- 类组件的使用
  - 类组件只能这样使用
    ```jsx
    <div>
        <Demo />
    </div>
    ```
  - 不能通过 `{ new Demo() }` 的方式使用


.
- 组件名称必须大写的原因（这要从React的渲染机制说起）
  - React的渲染流程可以看成两部分（创建虚拟dom、根据虚拟dom创建真实dom）
  - 首先，虚拟dom，就是一个React定义的对象，渲染的时候就是根据这个对象创建出对应的真实dom
  - **虚拟dom对象中，有一个属性（type）**
    - 如果这个属性是个字符串，在创建对应真是dom的时候，就调用 `document.createElement(type属性值)`，创建出真实的dom
    - 显然 `<Demo />`(组件节点)，不是一个dom，所以type就不能是一个字符串（否则就会用上面的方法创建出一个真实的dom）
    - **而通过查看组件节点的上的type属性，发现**
      - 函数组件，type的类型是一个函数
      - 类组件，type的类型是一个类
      - 即：如果是组件节点，就会把对应组件的地址引用赋值过来
    - **React在创建React元素对象的时候，是如何区分这是一个普通的节点，还是一个函数节点，靠的就是首字母**




#### 组件属性
- 组件属性的传递
    ```jsx
    <Demo name='张三' age={18} ></Demo>
    ```


- 函数组件使用行间属性
  - 会把行间属性汇总到一个对象中，然后传递
    ```jsx
    function Demo(props) {
        return (
            <div className='demo'>
                <span>{props.name}</span>
                <span>{props.age}</span>
            </div>
        )
    }
    ```


- 类组件使用行间属性
  - 会把行间属性汇总到一个对象中，然后传递到构造函数中
    - 构造函数，类组件默认已经定义好了，不用手动写
    ```jsx
    class Demo extends React.Component {
        // 构造函数，默认已经写好了，可以忽略
        // 但是，如果自定义了构造函数，下面的内容在构造函数中必须存在
        constructor(props) {
           super(props); // 内部执行了 this.props = props;
           // 如果构造函数中，只有这些内容，会出现警告，但是不影响使用
           // 警告的原因：默认已经实现了，不需要在写一遍了
        }
        render() {
            return (
                <div className='Demo'>
                    <span>{this.props.name}</span>
                    <span>{this.props.age}</span>
                </div>
            )
        }
    }
    ```


.
.
- 行间属性的优化
  - 如果，行间属性过多，可以先放在一个对象中，然后在组件行间中进行展开传递（效果是一样的）
    ```jsx
    const obj = {
        name: '张三',
        age: 18
    }
    <Demo ...obj ></Demo>
    // 相当于
    <Demo name='张三' age={18} ></Demo>

    // 写成 ...obj，便于管理，但是可读性不好，一眼不知道传递了哪些参数
    // 如果行间属性定义的过多，就会显得有些混乱，但是这样写可读性比较好，一眼就知道传递了哪些参数
    ```

.
.
- 组件中的行间属性对象中的属性，是无法修改的（只可读，但是监听的没有那么深）
  - 没有进行克隆，把属性直接存到props中，然后把props设置成只读
  - 这样的结果就是，如果行间属性是一个集合，是可以修改的（只读限制，限制不了这个集合）
    ```jsx
    function Demo(props) {
        // 修改就会报错
        props.name = '李四';
        // 但是，监听的没有那么深，比如行间属性是一个集合，这样是可以修改的
        props.obj.name = '李四';
        // props.obj 得到的是原始对象（没有克隆），所以可以进行修改
        // 但是，不要这样操作

        return (
            <div className='demo'>
                <span>{props.name}</span>
                <span>{props.age}</span>
            </div>
        )
    }
    ```
    - 作用：保证数据的完整性（那个组件定义的属性，只能那个组件中进行修改，这样有利于排错）
    - 比如：A中定义了一个属性，然后传入了B中，但是B做了修改
    - 然后A中使用这个属性，报错了，如果层级比较深，时间一长，就不知道这个属性在那个组件中做了修改从而导致了报错，这样就不好排错了
    - 为了避免这种现象，所以，组件中的行间属性对象中的属性，无法修改，修改就会报错



#### 组件状态

- 组件状态：组件中自己维护的一些数据，和外界（父级组件）没有关系

- 组件状态的使用
  - 函数组件要想使用状态，需要借助hooks（useState），后面介绍
  - 类组件状态的使用
    ```jsx
    class Demo extends React.Component {
        constructor(props) {
           super(props); 
           // 上面的内容必须要存在，因为要接收组件属性

           // 定义组件状态
           this.state = {
               name: '张三',
               age: 20
           }
        }

        // 状态定义（常用，不借助构造函数，书写量少）
        // 如果这两种情况都定义了，则构造函数的状态集合会覆盖这里定义的（整个替换，而不是混合替换）
        state = {
            age: 2033
        }

        render() {
            return (
                <div className='Demo'>
                    {/* 使用组件状态 */}
                    <span>{this.state.name}</span>
                    <span>{this.state.age}</span>
                </div>
            )
        }
    }
    ```


- 组件状态的修改（类组件）
  - 如果想要引发重新渲染，需要借助 this.setState 这个函数。
    - 该函数，传入一个对象，会把传入对象的属性，替换原始state对象中的属性（没有创建，有就替换）
    - 并不是整个对象全部替换，而是把两个对象进行融合（传入的对象 和 当前的state对象 进行融合）
    - **需要注意的是，setState是异步修改状态的**
      - 也就是修改完，紧接着就使用 this.state 就会发现值还是之前的
    ```jsx
    class Demo extends React.Component {
        constructor(props) {
            super(props); 
            // 上面的内容必须要存在，因为要接收组件属性

            // 定义组件状态
            this.state = {
                name: '张三',
                age: 20
            }

            // 重新渲染
            setTimeout(() => {
                this.setState({
                    age: 33
                });
                // 重新渲染后，发现 name 还是 张三，age变成了 33
                // 说明，该函数传递的对象不会替换state对象，而是把这两个对象进行融合
                //   类似
                /**
                 * const obj = {...this.state} 已有的属性不能进行删除
                 * for (const prop in _obj) {  遍历传入的对象，替换属性（没有创建，有就替换）
                    obj[prop] = _obj[prop];  没有创建，有就替换
                 }
                 */
            }, 3000)
        }

        render() {
            return (
                <div className='Demo'>
                    {/* 使用组件状态 */}
                    <span>{this.state.name}</span>
                    <span>{this.state.age}</span>
                </div>
            )
        }
    }
    ```
  - 如果不想引发重新渲染，可以直接使用 `this.state.name = 'xxx'` 进行修改
    - 当重新渲染触发的时候，展示的内容就会变成新的值（不渲染，一直是之前的值）
    

- 组件中不能修改组件属性
  - 要想既能接收行间传参，又能修改这个参数。就可以定义一个状态，接受这个参数，然后在修改状态
  - 这样的话，行间参数还是之前的值，组件中又能把这个值作为初始数据，然后修改这个值渲染出不同的内容




#### 事件
- 事件的绑定
    ```jsx
    class Demo extends React.Component {
        // 事件函数的定义，接收事件数据，比如可以阻止事件冒泡
        eventCall(e) {
            console.log('事件触发了', e);
            // 阻止事件冒泡
            e.stopPropagation();
        }

        render() {
            return (
                <div className='Demo' onClick={ this.eventCall }>事件</div>
                {/* <div className='Demo' onClick={ eventCall }>
                    函数组件绑定事件，就不用使用this
                    this 的作用就是找到对应的事件处理函数（类组件访问上面定义的 函数需要加上this）
                </div> */}
            )
        }
    }
    ```

.
.

- 组件上绑定事件的注意点（无效）
  - **组件上绑定事件，并不是绑定事件，而是作为一个行间属性，传入到了组件中（这样还可以实现自定义事件）**
    ```jsx
    function De(props) {
        console.log(props);  // 有onClick、有onZdy
        return '';
    }

    class Demo extends React.Component {
        render() {
            return (
                <div className='Demo'>
                    // 虽然绑定了onClick，但是点击没有效果（说明只作为一个不同的行间属性，进行传递）
                    <De 
                        onClick={ this.eventCall }
                        // 自定义事件
                        onZdy={ this.eventCall }
                    /> 
                </div>
            )
        }
    }
    ```



.
.

- 类组件事件函数中的this问题
  - 默认指向 undefined ，但是类组件要想使用方法和状态都需要借助 this
  - 所以，事件函数中要想调用其他方法和组件状态，就需要解决this的指向问题
  - **解决方式有两种**
    - 使用箭头函数
    ```jsx
    class Demo extends React.Component {
        eventCall = (e) => {
            console.log(this);
        }
        render() {
            return (
                <div className='Demo'>
                    <div onClick={this.eventCall}>ann</div>
                </div>
            )
        }
    }
    ```

    - 使用bind
    ```jsx
    class Demo extends React.Component {
        eventCall(e) {
            console.log(this);
        }
        render() {
            return (
                <div className='Demo'>
                    <div onClick={this.eventCall.bind(this)}>ann</div>
                </div>
            )
        }
    }
    ```



#### setState的介绍(获取变化后的状态)
- setState的作用：修改组件内定义的状态，并且引发重新渲染
  - 只要一调用，传入一个对象（哪怕是个空对象），就会引发重新渲染，无论有没有值（不传递参数，才不会引发重新渲染）
- setState修改状态，是异步执行的（也有同步执行的情况）
  - 也就是调用 setState后，立刻获取状态，得到的是之前的状态，而不是新的状态
    ```jsx
    class Demo extends React.Component {
        state = {
            age: 20
        }

        // 事件函数需要使用this，所以要用箭头函数
        eventCall = () => {
            this.setState({age: 30});
            console.log(this.state.age);  
            // 打印的是20，而不是30。当事件函数再次执行的时候，age就变成了30
            // 说明，执行 console.log() 的时候，状态还没有发生变化，说明this.setState是异步执行的
        }

        render() {
            return (
                <div className='Demo'>
                    <div onClick={this.eventCall}>ann</div>
                </div>
            )
        }
    }
    ```

.
.
- setState同步执行的情况
  - 在 setTimeout 和 setInterval 中是同步执行的（即不是由事件触发的，而是电脑在某个情况下，自动执行的代码，修改状态是同步执行的）
    ```jsx
    class Demo extends React.Component {
        state = {
            age: 20
        }

        // 事件函数需要使用this，所以要用箭头函数
        eventCall = () => {
            this.setState({age: 30});
            console.log(this.state.age); 
            // 打印20，说明是异步的（是由事件触发的）
            setTimeout(() => {
                this.setState({age: 40});
                console.log(this.state.age); 
                // 打印40，说明不是由事件触发的，而是时间到了，电脑自动触发的
            }, 1000) 
        }

        render() {
            return (
                <div className='Demo'>
                    <div onClick={this.eventCall}>ann</div>
                </div>
            )
        }
    }
    ```
    - React这样考虑的原因：事件可能会执行很复杂的逻辑，期间可能涉及到大量使用setState，如果改成同步的（每执行一次，就重新渲染一次，就会很卡（重新渲染需要一定的计算能力））
      - 所以，就把事件中的setState做成了异步的（先放在一个队列中，当时间到了，统一执行修改状态，然后触发一次的重新渲染）
      - 而 setTimeout 和 setInterval 中很难有复杂的代码，所以就是同步执行的，便于修改状态后，使用状态（不是之前的值，而是新的值，这样更加方便）



.
.
- setState的回掉函数（可以解决，修改状态后，获取不到新的状态）
  - 一个是利用 setState的第二个参数，传入一个回掉函数
    - 会把所有的回掉函数，放入一个队列中，当重新渲染后，依次执行（这样就能获取到变化后的值）
      - **由于，回掉函数的执行是发生在render后，所以可以获取到新的状态**
    ```jsx
    class Demo extends React.Component {
        state = {
            age: 20
        }

        // 事件函数需要使用this，所以要用箭头函数
        eventCall = () => {
            this.setState({age: 30}, () => {
                console.log(this.state.age);
            });
            this.setState({age: 40}, () => {
                console.log(this.state.age);
            });
            this.setState({age: 50}, () => {
                console.log(this.state.age);
            });
            // 由于是渲染后，统一执行，所以先执行render，在执行上面的三个回掉函数
            //    由于是状态全部修改完成，在进行渲染，所以三个回掉函数，打印的都是 50
        }

        // 事件函数需要使用this，所以要用箭头函数
        eventCall = () => {
            this.setState({age: this.state.age + 1}, () => {
                console.log(this.state.age);
            });
            this.setState({age: this.state.age + 1}, () => {
                console.log(this.state.age);
            });
            this.setState({age: this.state.age + 1}, () => {
                console.log(this.state.age);
            });
            // 渲染后，统一执行三个回掉函数，打印的都是 21
            // （原因：上面三个setState执行的时候，不会引发重新渲染，所以状态没有变化，三个最终设置的都是 21）
        }

        render() {
            console.log('渲染');
            return (
                <div className='Demo'>
                    <div onClick={this.eventCall}>ann</div>
                </div>
            )
        }
    }
    ```
    - 要注意的是：**重新渲染后，在依次执行**
.
.
  - 一个是利用 setState的第一个参数，传入一个回掉函数（之前传入的是一个对象）
    - 传入的函数，也会放在一个队列中，也是异步执行的，但是执行的时间在render
    - 每个函数的返回值，都会与原始的state进行融合，**得到一个新的对象，传入下一个执行的函数中**
      - 也就是返回的obj，相当于 setState(obj)
      - 当最后一个函数执行完成后，最后引发一次重新渲染（所以，执行时间在render前）
    - **由于，状态融合后，会传入下一个回调函数中，所以，在后面的回掉函数中，可以获取到前面设置的新状态**
    ```jsx
    class Demo extends React.Component {
        state = {
            age: 20,
            name: 30
        }

        // 事件函数需要使用this，所以要用箭头函数
        eventCall = () => {
            this.setState((state) => {
                console.log(state);
                return {
                    age: 25
                };
            });
            this.setState((state) => {
                console.log(state);   // 得到的状态，age就已经是 25（上面与state融合后传入）
                return {
                    name: 50
                };
            });
            this.setState((state) => {
                console.log(state);   // 得到的状态，name就已经是 50（上面与state融合后传入）
                return {
                    age: 333
                };
            });
            // 最终，name也变成了50，说明，不是最后一个回掉函数，才会与原始的state进行融合
            // 而是，每一个返回值，都会进行融合，融合完最后一个，得到的就是最终的 state，所以name才会变成 50
            // 最后，age是 333，第一个融合变成了 25，最后一个融合会替换它（都是age），所以变成 333

            console.log('执行');  
            // 这个打印先执行，上面的回掉函数在执行，说明上面的回掉函数也是异步触发的，并不是立即执行的
        }

        render() {
            return (
                <div className='Demo'>
                    <div onClick={this.eventCall}>ann</div>
                </div>
            )
        }
    }
    ```





#### 执行期上下文
- 作用，用于父子集组件的数据共享

- 执行期上下文中的数据，都是在父组件中进行填充，然后子组件共享
  - 状态的改变，也是在父组件中进行的
  - 如果子组件想要修改状态，只能父组件往执行期上下文中灌入一个修改状态的方法
- **父组件修改状态，引发重新渲染，重新解析结构，这样子组件使用的就是最新的值，产生重新渲染的效果**



- **具体的使用**
- 父组件灌入数据
```tsx
// 创建一个执行期上下文
export const context = React.createContext<{a:number, b: number, setA:Function}>({
  a: 0, b: 0, setA: () => {}
});

const EditableTable = () => {
    const [a, setA] = useState(0)
    return <div>
        <context.Provider value={{
            a: a,
            b: 456,
            setA
        }}>
            <Apps></Apps>
        </context.Provider>
    </div>
}

export default EditableTable;
```

- 子组件获取数据，方式一
```tsx
// 获取对应的执行期上下文
import { context } from "@/App";
import React, { useContext, useEffect } from "react";

export function Apps(props: any) {
    // 获取父组件灌入的执行期上下文数据对象（虽然是引入的执行期上下文，但是只有子组件才能获取）
    const a:any = useContext(context)
    console.log(a);
    return <div>{con.a}</div>
}
```


- 子组件获取数据，方式二
```tsx
import { context } from "@/App";
import React from "react";

export function Apps(props: any) {
    return <div>
        <context.Consumer>
            {
                // 想用那个数据，就接收那个数据
                ({a}) => {
                    return <div>{a}</div>
                }
            }
        </context.Consumer>
    </div>
}
```



- **注意点**
- 子组件使用执行期上下文，只会查找最近的父级组件创建的执行期上下文，查询不到为undefeated，不会在继续往上查询
  - 一个组件只能存在一个执行期上下文环境
  - 执行期上下文，不会进行合并
  - 比如
  ```tsx
    <div>
        <context.Provider value=a>
            <context.Provider value=b>
                <A></A>
            </context.Provider>
            <B></B>
        </context.Provider>
    </div>
    // A使用的是b，B使用的是a
  ```


- 重新渲染的加强
  - 类组件，重新渲染的时候，会执行shouldComponentUpdate()
    - 当返回false，会截止当前组件的重新渲染，即render不在执行
  - 上下文内容改变，引发子组件的重新渲染，会绕开该函数，直接执行render，进行重新渲染
    - 造成性能优化的拦截失败
    - 解决方式，不改变 Provider的value的指向
      - 比如：单独创建一个对象，把该对象的索引赋给Provider的value，只要对象不重新创建就OK
      - 比如：借助hooks的功能，固化对象索引
      - 这样的话，状态改变，但是value指向的索引没有变化，就会走正常的重新渲染流程

#### 事件的绑定(以及函数的定义)

1. 事件的绑定就是React元素上的一个行间属性。比如绑定点击事件：`onClick = { this.func }`

2. 事件函数(React函数)的定义。有两种方法
    1) 在`constructor`中通过`this.func = ?`进行定义
    2) 在`class`中直接通过 `func = ?`进行定义

3. 事件函数在使用时的注意点
    1) 事件函数，如果使用`func = function`的方式定义，则内部的this指向undefined。指向的并不是触发该事件的dom。如果想要改变this的指向，需要通过`this.func.bind(this)`，这样内部this就指向该组件的环境。
    2) 事件函数，如果使用`func = () =>`的方式定义，则内部的this指向该组件的环境。指向的并不是触发该事件的dom。
    3) 如果想给事件函数传递默认值，也必须使用`this.func.bind(5)`，这样的话事件函数就无法使用event，已经被5给替换掉了。
    4) 如果想要获取到触发事件的dom，可以通过`e.target`获取。

```js
class Abc extends React.Component{
  render () {
    return (
      <>  
        <div onClick={ this.click }>我是一个组件</div>
      </>
    )
  }
  click = (a) => {
    console.log(a);
  }
}
```


#### setState函数的详解

1. 同步和异步的判断
    1) 如果setState方法执行的触发源头是事件函数，或者周期函数，则setState对数据的修改是异步的。
    2) 如果setState方法执行的源头，是由定时器(setTimeout和setInterval)触发的，则setState对数据的修改是同步的。

示范: 
```js
class A extends React.Component {
    state = {
        a: 123
    }
    render() {
        return ( <div onClick={ this.func }>{this.state.a}</div> )
    }

    componentDidMount() {
        // 定时器调用
        setTimeout(() => {
            this.cc("sss");
        }, 0)
    }
    // 事件调用
    func = () => {
        this.cc("ddd");
    }

    cc = (c) => {
        // 一次同步执行，一次异步执行
        this.setState({
            a: c
        })
        // 定时器调用，打印出sss，同步执行
        // 事件函数调用，打印出sss，没有打印ddd，异步执行
        console.log(this.state.a);
    }
}
```

2. setState函数的第二个传参的作用(获取数据)

    1) 第二个参数传递的是一个回调函数，并且该函数的执行，是在`render`函数执行后才进行执行。
    2) 该方法可以在setState修改数据后，使用数据。
    3) 无论setState是同步执行还是异步执行，所传递的回调函数(第二个参数)都是在`render`执行后执行。

示范:
```js
class A extends React.Component {
    state = {
        a: 123
    }
    render() {
        return ( <div onClick={ this.func }>{this.state.a}</div> )
    }

    func = () => {
        this.cc();
    }
    cc = () => {
        this.setState({
            a: "dsfas"
        }, () => {
            // 在render后执行，此时数据以及发生变化，就可以使用该数据进行判断或者处理
            console.log(this.state.a);
        })
        // 由于是异步的，所以此时使用数据，还是之前的，如果进行处理就会出现问题
        console.log( this.state.a );
    }
}
```

3. setState的性能优化(只针对异步操作)
    1) 异步优化:  如果setState是异步执行的，并且在render执行前执行了多个setState，对数据进行了修改，会把所有的setState处理完，然后只调用一次render。这也是React优化性能的一种体现。

    2) 其实多个异步setState会进行合并，每个setState都有一个修改数据的对象，然后进行后面的合并前面的操作(相同替换，没有添加的方式，其它不动的方式)。这样就生成了，一个修改数据的最终对象，然后在根据该对象，对state进行修改。由于只修改了一次，所以render才会触发一次。
    从其它的周期函数也可以验证setState只对state操作了一次，其它的周期函数也只执行一次。

    3) 同步正常:  如果是多个setState函数是同步的，则执行多少次setState，render就会执行多少次。

4. setState异步操作的一种现象

```js
class A extends React.Component {
    state = {
        a: 1
    }
    render() {
        return ( <div onClick={ this.func }>{this.state.a}</div> )
    }

    func = () => {
        this.setState({
            a: this.state.a + 1
        })
        this.setState({
            a: this.state.a + 1
        })
        this.setState({
            a: this.state.a + 1
        })
        // 最终a，渲染成了2， 而不是4。
        // 原因: setState是异步执行，而对象中的表达式会立即执行，即this.state.a + 1会立即执行，三个得到的都是2。最终结果，a为2。
    }
}
```

5.  setState的第一个参数的另外一种写法，传递函数(可以解决上例问题)
    1) render执行前，所有异步setState传入的第一个函数参数，会放在一个队列中。在执行时，从队列中依次取出方法，进行执行。

    2)  并且该方法在执行的时候，会传入state对象，返回值也必须是一个对象(修改数据的对象)。

    3) 并且下一个队列中的方法，接收的参数，是上一个函数的返回修改数据的对象。然后根据上一次修改数据的对象，再次进行操作，返回一个修改对象，最终会根据所有的方法返回的对象进行合并操作，然后以合并的最终对象，对state进行数据的修改。然后触发一次render方法进行重新渲染。

    4)并且当所有的队列函数执行完成，才会执行render函数进行重新渲染。然后在触发每个setState函数传入的第二个回调函数(此时在获取a，获取的是4，而不是2，或者3)

```js
class A extends React.Component {
    state = {
        a: 1
    }
    render() {
        return ( <div onClick={ this.func }>{this.state.a}</div> )
    }

    func = () => {
        this.setState((val) => {
            return {
                a: val.a + 1
            }
        }, () => {
            // 获取的是4，因为该函数是在render函数执行完才会执行，但是render是在所有的setState处理完数据后才会执行，所有获取的是4。
            console.log(this.state.a);
        })
        this.setState((val) => {
            return {
                a: val.a + 1
            }
        })
        this.setState((val) => {
            return {
                a: val.a + 1
            }
        })
        // 最终a渲染成4
    }
}
```

6. **如果利用setState修改数据，是在原先数据的基础上进行修改，建议使用传递函数的方式**
可能多个setState设置的数据会有依赖关系，如果不使用传递函数的方式，则依赖会消失。
所以为了保险起见，只要是在原先的基础上修改数据，建议使用传递函数的方式，即使setState只使用了一次。


7. setState的执行，会重新开辟一个对象空间，然后进行属性的合并处理，并不是在state的基础上进行合并。






#### 受控组件和非受控组件(表单元素表现明显)

- **受控组件和非受控组价的定义**
1. 组件的定义方式有两种: 函数组件、类组件
2. 组件的类型也有两种: 受控组件、非受控组件
    1)  受控组件: 自身没有状态(state中没有自己的数据)，该组件使用的数据全靠外界(使用者)通过行间属性传入。即使用者传递的数据不同，该组价的表现形式不同，完全受使用者的控制。该类组件被称为受控组件。
    总结: 组件内使用的所有数据，都是从props中获取的，该类组件为受控组件
    
    2) 非受控组件: 所有的状态都是组件内通过state进行控制，使用者无法进行控制(所有的使用者使用该组件，表现形式都是一样的。无法通过外界行间传参的方式影响表现形式，即不受使用者的控制。该类组件被称为非受控组件)
    总结: 组件内使用的所有数据，都是从state中获取的，没有从props中获取一个数据，该类组件为非受控组件

- **表单元素的受控组件和非受控组件的表现形式**

**表单元素默认为非受控组价**。
表单元素就是一个普通的标签，并不是自定义的组件，但是这种标签被称为内置组件。
但是表单元素的行间可以传递参数，从而影响到表单元素的展示样式，比如value。
如果表单元素的展示样式完全受外界使用者的影响，则该类表单元素就可以被称为受控组件。

- **输入框的受控组件和非受控组件的表现形式**

1. 输入框的非受控组件的表现形式，直接书写`<input type="text" />`。
    1) 该标签的表现状态无法受外界的控制，就是一个普通的输入框，可以正常输入。
    2) 使用`defaultValue={ ? }`给input的value附一个初始值，但是后期是可以正常输入的。
    3) 无论哪个使用者使用该标签，它就是一个普通的输入框，顶多赋个初始状态，但是实现的功能完全一样(普通的输入框)，不受使用者的控制。所以该写法为非受控组件。

2. 输入框的受控组件的表现形式，在行间加入`value={ ? }` 和 `onChange={ ? }`
    
    1) 需要注意的是value和onChange必须成对出现，否则控制台报出错误，但是不影响使用。
    2) input标签的展示样式完全受value的控制，即使在输入框中输入内容，只要value赋值的状态没有发生变化，输入是没有效果的，和defaultValue不同。

    3) Change是input上的事件，当输入框中的内容发生变化时，该事件就会触发。
    在input中是可以输入内容的，只不过输入完成，在value属性的作用下有瞬间进行了重新赋值。所以视觉上input没有发生变化，但是Change事件是会触发的。利用该事件是可以获取到input中的内容(没有被替换前)，从而影响value，使输入框具有特殊的功能。

    4) input事件也可以实现效果，但是Change更贴合需求。
    
3. 用户就可以使用value和onChange控制input，定义出不同功能的input标签
    比如只能输入数字，或者只能输入字母，完全根据用户进行定义，这就是受控组件。

```js
class A extends React.Component {
    state = {
        val: "123"
    }
    render() {
        return ( <input text="func" value={ this.state.val } onChange={ this.fun } /> )
    }
    fun = (e) => {
        // 把非数字过滤掉，只能输入数字
        let val = e.target.value.replace(/\D/g, "");
        this.setState( {
            val: val
        } )
    }
}
```


- **选择框的受控组件和非受控组件的表现形式**
1. 默认为非受控组件

2. 受控组件，只需要在行间添加上 `checked={ ? } onChange={ ? }` 
这样该选框的状态，受checked完全控制，为true选中状态，为false取消状态。
Change事件，当你点击的时候，触发该事件。可以进行一些操作。
这样使用者可以通过checked的赋值，完全控制该选项框，使其变成了受控组件

3. 案例(做个爱好复选框，点击获取可以获取到选中的所有爱好)
选中和未选中状态的切换，使用到了数组，因为复选框有多个选中状态，所以需要使用数组
数组的筛选(取消选中)，数组是否包含该选项(选中)，数组的添加(选中)
```js
class A extends React.Component {
    state = {
        // 所有爱好
        checkBoxDate: ["篮球", "足球", "排球", "其它"],
        // 选中的爱好
        checked: ["篮球"]
    }
    render() {
        let CheckBox = this.state.checkBoxDate.map( (el) => {
            return (
                <input type="checkbox" 
                    // 只要选中的爱好中有该属性，则该项选中
                    checked={ this.state.checked.indexOf(el) > -1 } 
                    // 点击触发事件，进行选中爱好的添加和移出，从而引发选中项的重新渲染
                    onChange={(e) => {
                        // 如果点击的选项已经存在，则需要进行移除，数组想要引发重新渲染需要赋新数组
                        if( this.state.checked.indexOf(el) > -1 ) {
                            this.setState( {
                                // 进行筛选，不同的保留，相同的移除
                                checked: this.state.checked.filter( (l) => {
                                    return l !== el
                                } )
                            } )
                        }
                        // 否则进行添加
                        else {
                            this.setState( {
                                // 在数组中添加一条选项
                                checked: [ ...this.state.checked, el ]
                            } )
                        }
                    } } />
            )
        } )
        return (
            <div>
                { CheckBox }
            </div>
        )
    }
}
```

- **下拉框**
1. 默认是非受控组件
2. 通过给select标签添加 value={ ? } onChange={ ? }，使其变成受控组件。
只要value中给定的值与option中的value相同，默认选中那个。

3. 案例
下拉框只有一种状态，不需要使用数组，复选框需要借助数组。

```js
class A extends React.Component {
    state = {
        // 所有的下拉框
        selectOption: ["篮球", "足球", "排球", "其它"],
        // 标识那个被选中
        select: "篮球"
    }
    render() {
        let selectOption = this.state.selectOption.map( (el) => {
            return (
                <option value={ el }> { el } </option>
            )
        } )
        return (
            // 使其变成受控组件
            <select value={ this.state.select } onChange={ this.change } >
                { selectOption }
            </select>
        )
    }

    change = (e) => {
        // 改变状态
        this.setState({
            // 获取到点击的option对应的值
            select: e.target.value
        })
    }
}
```




#### HOC(高阶组件)

1. 概念
    React中组件的写法就是函数。而函数存在一种方式，传入的参数是方法，返回值也是方法，该类组件被称为高阶函数。
    高阶组件的核心也是，传入一个组件，返回一个组件。

2. 作用
    对某个组件进行进一步的包装，使其功能变得更加的强大

3. 一个组件可以进行多次包装
    组件包装完成，返回的还是一个组件函数，我们还可以进一步对该组件进行包装，让其功能越来越强大。

4. 思想以及工作流程
   1) 利用函数，传入一个组件，返回一个新的组件。然后使用者在外界进行接收，这样就得到了一个新的组件(在原来的组件上添加了一些功能)。

   2) 当代码解析到`<新组件 />`时，新组件被激活(如果新组件时类组件，周期开始启动)。那些新添加的功能就会开始工作。

   3) 在新组件的返回值中，一定要存在旧组件(传入组件)的引用，即`<传入组件 />`。当新组件启动后，就开始解析新组件，当解析到`<传入组件 />`时，传入组件就会被激活，处理组件本来的功能。
   
   4) 这样，某个组件就被包裹了一层华丽的外衣，增强了其功能性(本身的功能在HOC中被激活)。

4. 示例
```js
function HOC(Element) {
    return class H extends React.Component {
        componentDidMount() {
            console.log(123);
        }
        render() {
            return <Element />
        }
    }
}

// 需要添加功能的组件
class C extends React.Component {
    render() {
        return ( <div>组件</div> )
    }
}

// 对C组件进行包装得到一个新的组件
let A = HOC(C);

// C组件本身没有打印123的功能，通过HOC给它包裹了该功能
```


#### ref

1. 功能
    让js中的数据与使用ref的标签或者组件建立起一种联系。
    通过js中的数据，可以直接获取到标签的dom或者组件的环境。
    不用再通过document.***的方式获取标签

2. 注意
    自定义函数组件不能使用ref，只有内置组件或者自定义类组件可以在行间使用ref。

3. 旧版本的使用方法(性能不是很好)
    给ref赋值字符串，该方法已经不推荐使用。

```js
class A extends React.Component {
    componentDidMount() {
        // 获取
        console.log(this.refs.abc);
    }
    render() {
        // 使用
        return ( <div ref="abc">组件</div> )
    }
}
```

4. 新版本的使用方法
    
    1) 给ref赋值为对象(对象有特殊要求，React中提供了一种方法，可以直接创建出该对象)

```js
// 需要添加功能的组件
class A extends React.Component {
    state = {
        // 创建ref使用的专门对象，不用通过new的方式。
        ref: React.createRef()
    }
    componentDidMount() {
        // 获取
        console.log(this.state.ref.current);
        // ref使用的专门对象，其实就是一个普通的对象，只不过对象内部必须有current属性
        // 可以手动创建该对象 { current: null }
    }
    render() {
        // 使用
        return ( <div ref={ this.state.ref }>组件</div> )
    }
}
```

    2) 给ref赋值为函数(函数也有特殊的写法，需要按规定写)
    函数的执行时间: 
    创建时: componentDidMount前render后，函数执行，所以componentDidMount中可以获取并使用ref
    销毁时: 函数执行
    ref赋值的函数的地址引用发生变化(重新赋了个新函数):  旧函数执行一次，新函数执行一次。
    其中销毁时和旧函数执行时，函数执行传参为null。
    其它时候的执行，传入的参数为当前标签的dom或者当前组件的环境。

```js
class A extends React.Component {
    state = {
        // 用于接收ref
        ref: null
    }
    componentDidMount() {
        // 获取
        console.log(this.state.ref);
    }
    // 通常把函数写在外部，如果写在render中
    // 重新渲染的时候每次都会重新创建函数，新旧函数就会重新执行
    ref = (r) => {
        this.state.ref = r
    }
    render() {
        // 使用
        return ( <div ref={ this.ref }>组件</div> )
    }
}
```


#### ref转发

1. 作用
    针对组件提出的一种思想，父组件获取子组件中的某个标签或者某个组件的状态。

2. 思想
    利用行间传参的方式，把父组件创建好的ref函数或者ref对象(新方法)通过行间进行传入。
    由于方法和对象都是引用类型，所以子组件中操作的和父组件中定义的是一个空间。
    这样父组件就可以获取到子组件中的某个标签或者某个组件的状态

3. 测试

```js
class A extends React.Component {
    state = {
        ref: React.createRef()
    }
    componentDidMount() {
        // 获取子组件使用转发ref的dom
        console.log(this.state.ref.current);
    }
    render() {
        // 通过行间传参的方式进行转发
        return ( <B forwardRef={ this.state.ref } /> )
    }
}

// 子组件
class B extends React.Component {
    render() {
        // 使用转发的ref
        return ( <div ref={ this.props.forwardRef }>子组件</div> )
    }
}  
```


4. React官方提出的方法`React.forwardRef()`
    1) 只适用于函数组件，类组件如果想要使用该方法需要进行包装。
    2) React.forwardRef()其实就是一个高级组件。对一个函数组件进行包装，让ref可以进行转发
    
    3) 会把行间ref，作为函数组件的第二个参数进行传入(第一个参数是props)
    4) 行间必须是ref，才能传入。如果写其它的，会放在props中进行传入。

```js
class A extends React.Component {
    state = {
        ref: React.createRef()
    }
    componentDidMount() {
        // 获取子组件使用转发ref的dom
        console.log(this.state.ref.current);
    }
    render() {
        // 调用包装好的组件，ref才起作用(必须写ref)
        return ( <ForwardRef ref={ this.state.ref } /> )
    }
}

// 子组件(必须是函数组件，使用forwardRef进行包装)
function B(props, forwardRef) {
    // 使用转发的ref
    return ( <div ref={ forwardRef }>子组件</div> )
}
// 进行包装
let ForwardRef = React.forwardRef(B);
```


5. ref转发的提出，是为了解决高级组件。
    高级组件是对一个组件进行了包装，所以在使用时通过ref获取到的是包装后的组件环境。原始的组件环境获取不到。为了获取到原始组件的环境，提出了ref转发。
    
    由于高级函数是使用函数组件进行包装，官方就是根据该特点提出的官方方法`forwardRef`





#### react中的插槽功能

react和vue的插槽功能不同，没有slot专门替换的标签。而是把传入的内容放到了this.props.children中。具体的使用方式如下:

```js
// 组件的使用
<C>
  <div>123</div>
  <div>456</div>
</C>

// 组件中的处理代码
import React from 'react';
class C extends React.Component{
  render () {
    return (
      <>
         {/* 把接收到的html放在此处 */}
         { this.props.children }
         <div>22221111</div>
         {/* 把接收到的html放在此处 */}
         { this.props.children }
      </>
    )
  }
}
// 组件的抛出
export default C;
```



#### PureComponent(纯组件)

1. 作用
    避免不必要的重新渲染(减少render的使用次数)，从而提高效率。
    

2. 原理
    1) PureComponent是一个封装好的组件。
    2) 底层是借助shouldComponentUpdate进行实现，拦截render的执行。
    3) 原理
    类似封装库，把shouldComponentUpdate要实现的拦截功能写好，然后封装在一个组件中。
    让其它组件继承该组件，就会继承该组件写好的shouldComponentUpdate(原型上的方法)。
    当其它组件激活时，自己的shouldComponentUpdate不能定义，这样就会顺着原型链找到封装好的shouldComponentUpdate进行工作。

    4) 正常类组件在定义的时候，继承的是Component，如果想要其变成纯组件，需要继承PureComponent，PureComponent组件继承的是Component。

    5) 相当于，在原型链的中间又加了一个原型。当组件激活时，生命周期函数就会在适当时候执行，本组件中找不到该生命周期函数，就会沿着原型链找。


3. 使用示范代码
```js
// 使A组件变成纯组件，改变继承的组价
class A extends React.PureComponent {
    render() {
        return <div>123</div>
    }
}
```


4. 函数组件变成纯组件
    1) 函数组件没有继承关系，无法直接继承PureComponent。
       需要使用`React.memo()`进行包装，返回一个新的组件(高级组件的思想)。

    2) 原理
    返回的新组件是一个类组件，render中激活传入的函数组件。
    当新组件需要重新渲染时，执行shouldComponentUpdate(继承的方法)。发现达不到重新渲染的条件，返回false，阻断render的执行。则函数组件也不会被重新解析渲染，以此间接的实现函数组件具有纯组件的功能。

    3) 仿写memo方法
```js
function memo(Element) {
    return class C extends React.PureComponent {
        render () {
            return <Element {...this.props} />
        }
    }
}
```

4. 注意点
    1) PureComponent中的shouldComponentUpdate使用的是**浅层比较**，即只比较第一级属性的地址。

    2) 纯组件的现象
    如果状态或者属性是一个对象或者数组，但是状态和属性在发生变化时，只操作了内部的一个属性(比如push)，地址引用没有发生变化。
    这样shouldComponentUpdate在进行比较时，一看地址没有变化，直接返回false，阻断重新渲染。
    造成了数据变化，但是没有引发重新渲染的现象。

    3) 所以组件的状态或者属性发生变化时，最好整个给它改掉(重新构建数据空间)。

    4) PureComponent的产生就是为了优化性能，如果采用了深层比较，反而浪费了性能。



#### portals( 插槽 )

1. 功能
    1) 该插槽并不是slot插槽，不是服务于组件。
    2) 功能更加强大，可以把某个组件插入到指定的位置。
    3) 但是并不会改变React元素树的结构层级。

2. 实现方法加分析
通过`ReactDOM.createPortal()`，把指定的组件插入到指定的位置。
ReactDOM.createPortal()返回的也是一个React元素对象，但是有了特殊的标识，指定了位置。

```js
class A extends React.Component {
    render () {
        return (
            <>
                <div className="bbb">
                    <B />
                </div>
            </>
        )
    }
}

// B组件在使用时，生成的真实的dom，就会放入指定的位置
class B extends React.Component {
    render () {
        // div元素处于.bbb的下面，作为子元素。在渲染的时候，生成的真实dom也会放入.bbb的下面
        // 但是使用createPortal给div元素指定了位置。
        // 虽然在React元素树上div元素依旧处于.bbb的下面，但是在渲染的时候，div会放入#aaa的下面
        return ReactDOM.createPortal(<div>123</div>, 
            document.querySelector("#aaa"));
    }
}
```

3. 原理

    1) 正常React组件在解析的时候，会从上到下构建一个React元素树
    2) 如果React元素没有进行特殊的操作，ReactDOM.render在解析React元素树生成真实dom的时候，遵循子元素放入父元素的下面，作为子节点的规律创建真实的dom树。
    3) 如果某个React元素在生成的时候，加入了特殊的标记，指定了一个位置
    4) ReactDOM.render在解析该React元素时，本来该元素生成的dom要放入父元素的下面，但是一看有特殊标识，指定了位置，则ReactDOM.render就会把生成的真实的dom，放入指定位置。
    5) 而该元素的子元素，在生成真实的dom的时候，还是遵循子元素放入父元素生成的dom的下面的规律。就会造成一整条分支都跟随该元素移动了位置。
    6) 但是React元素树的结构没有变化。即元素树与dom产生了不对应的关系。


4. 事件冒泡的注意点
    1)  在React中，对事件进行了封装处理，当事件进行冒泡时，不遵循真实的dom，而是遵循React元素树。
    2)  比如: 在真实dom中两个不是父子级元素的两个标签，却产生了冒泡现象。原因就是在React元素树上，它们处于父子级元素的关系，但是其中一个组件通过createPortal改变了真实dom的位置。
        


#### 错误边界

1. 解决的现象
    1) 表现
    React中有一个强大的现象，当一个组件在渲染的过程中发生了错误，会导致整个React元素树的移除，页面上就什么都看不到，即使是一个非常不起眼的小组件出现问题，也会造成整个页面的崩塌。

    2) 原因
    组件渲染时出现问题，自己处理不了，会往上传递，看看父组件能否进行处理。
    父组件一看也处理不了，继续向上传递，直到传递到根组件，根组件一看也处理不了，组件就会崩塌。根组件一崩塌，下面即使是没有问题的分支，也显示不出来，整体进行了移除。

    3) 解决方式
       父组件进行错误的拦截，但是无法阻止错误的上传，组件会继续崩塌，解决方式父组件拦截到错误后进行一些特殊的处理。



2. 处理方式1
利用一个静态方法`getDerivedStateFromError`，进行错误的拦截。
该方法的执行是在渲染前并且子组件的渲染过程中出现了问题。
只需要在该函数的内部修改状态，此时render就会重新执行，重新渲染。
在本次渲染的时候，屏蔽掉出错组件的渲染，重新渲染没有错误，构建正常React树。
页面就可以正常显示。

由于getDerivedStateFromError是一个静态的方法，是无法通过this获取到state的。但是该方法有个返回值，可以覆盖掉之前的state。

```js
class A extends React.Component {
    state = {
        a: true
    }
    // 如果子组件渲染时发生了错误，该函数才会被激活，然后该函数在渲染前进行执行
    static getDerivedStateFromError() {
        // 修改状态，屏蔽出错的组件
        return {
            a: false
        }
    }

    render () {
        return (
            <div className="bbb">
                4444
                { this.state.a && <B /> }
            </div>
        )
    }
}

// 报错的子组件
class B extends React.Component {
    constructor () {
        super();
        
        // 没有aaa，进行报错
        console.log(aa);
    }
    render () {
        return <div>122</div>;
    }
}
```



3. 处理方式2

使用函数`componentDidCatch`进行处理，该函数的执行时间是，子组件出现问题并且页面重新渲染后。
处理错误的原理:
    子组件发生了错误，向上传递，父组件处理不了，React元素树崩塌。然后`componentDidCatch`运行，修改状态，重新渲染，跳过错误组件，重新构建正常的React元素树，页面正常显示。

```js
class A extends React.Component {
    state = {
        a: true
    }
    // 如果子组件渲染时发生了错误，该函数才会被激活，然后该函数在渲染完成后进行执行
    componentDidCatch() {
        // 修改状态，屏蔽出错的组件
        this.setState({
            a: false
        }) 
    }

    render () {
        return (
            <div className="bbb">
                4444
                { this.state.a && <B /> }
            </div>
        )
    }
}

// 出现问题的子组件
class B extends React.Component {
    constructor () {
        super();
        
        // 没有aaa，进行报错
        console.log(aa);
    }
    render () {
        return <div>122</div>;
    }
}
```


4. 方式2处理错误的缺点
由于`componentDidCatch`的执行周期是在页面渲染完成后运行。React元素树，先卸载后创建，浪费了效率。

所以通过使用`componentDidCatch`记录错误的信息，`getDerivedStateFromError`处理错误信息


5. 两种方式无法扑捉到的错误
    
    1) 本组件中出现的问题
    2) 异步错误
    3) 事件错误

本组件的错误可以用父组件处理。异步错误和事件错误，只能使用try - catch进行处理


#### React中的事件机制

1. React中对事件的处理真实的过程
    1) React中对事件的绑定，是进行了优化的，采用了更高效的方式。
    React会先在document上绑定所有可以进行冒泡的事件。
    
    2) 开发者在React元素上通过on绑定的事件，比如onClick，其实并没有在真实的dom上绑定事件。
    
    3) React使用的方式是，点击该真实的dom，事件就会进行冒泡，最终冒泡到document上。
       触发React在document上绑定的点击事件，然后分析触发的事件源。
       随后查询React虚拟dom树，从React元素树中找到对应的React元素，直接执行注册的点击函数。
       然后顺着React虚拟dom树，向上查询，只要有父元素使用了onClick注册事件，就会执行注册函数。产生冒泡的现象。

2. 分析改变真实dom的位置，但是冒泡却依旧按照React虚拟dom树的结构进行冒泡的原因

    1) 某个元素绑定了事件，但是该元素通过createPortal改变了真实dom的插入位置。
    2) 当点击该元素的时候，其实是正常按照真实dom树的结构进行冒泡，直到document。
    3) 然后React手动调动对应的事件，然后从事件源的位置，顺着React元素树进行查询。
    4) createPortal虽然改变了真实dom的位置，但是在React元素树中的位置并没有发生变化。所以产生了该现象。
    如果React元素的位置也变到指定的位置，则React查询的方向和真实dom冒泡的方向就会相同。
    5) 所以这种现象都是假象，是React搞的鬼。


3. React中的事件对象event
    1) event的原理
    其实React中的事件对象event，也不是原始的事件对象event。
    原始的事件对象是document的事件对象，要来没什么用，所以React就舍弃了真实的event。
    自己创造了一个event，传入的就是React自己高度合成的event。

    2) event的优化
    并且React为了节约效率，先把event对象创建好了，平时的时候内部的每个属性都为null。
    当需要的时候生成对应的event对象，然后传入对应的事件中，当事件函数执行完，event对象中的属性就会进行初始化，为冒泡或者下一次事件的触发做赋值准备。


4. 根据React绑定事件的方式和event优化的原理，产生了一些现象

    1) 父元素事件先触发，子元素事件在触发，不符合冒泡原理。
       该现象产生的必要条件:
       父元素是通过dom，直接绑定的事件而不是通过React语法绑定的事件。
       子元素的事件是通过React语法进行绑定的事件。
       现象分析:
       通过React语法绑定事件，并不会真正的绑定到该dom上。触发时，进行进行冒泡。
       如果在真实dom冒泡的过程中，在某个父dom上直接绑定了事件，则先触发该事件。
       然后在继续冒泡，直到到达document，触发React绑定的点击事件。
       然后在反过来执行对应的事件函数。
       造成了表象上父组件的事件先执行，子组件的事件在执行的现象。
    
    2) 真实dom上绑定的事件，阻止事件冒泡，React绑定的事件就会失效。
       在冒泡过程中的某个真实dom绑定的事件上阻止了事件冒泡，则document上的事件无法执行，无法进行分析自动调动对应的方法，产生事件失效的现象。

    3) 事件函数中异步使用event，需要进行特殊的处理 
       由于React对event进行了优化，事件执行完，event就会初始化，为下次的传入做准备。
       如果异步使用event，使用的是初始化的even。
       不会获取到自己的event，和其它事件的event，只有当任务队列空时，异步函数才会执行，此时事件函数以及处理完毕，event已经进行了初始化。
       所以异步直接使用event会出现大问题。
       解决方式: 
       在事件中调用e.persist()，进行事件对象的固化。
       原理可以看成，把e克隆一份，然后在赋给e。React在操作React中创建的事件对象event时，就与该事件中的e没有关系了。

    4) stopPropagation阻止冒泡的原理
       stopPropagation阻止的是沿React元素树查询的过程，当查询到该位置，阻止查询，则上方的事件函数不在执行，造成阻止事件的表象，其实并没有组织真实dom的冒泡。


#### 开发工具
    
- **严格模式**

有一个组件`React.StrictMode`，该组件不会参与到UI渲染。
<></>即React.Fragment也不会参与UI渲染。

该组件的作用是: 在该组件的内部(子组件)，如果存在不合适的代码，会报出一些警告的消息，提示开发者。

不合适的代码:
1. 使用旧版的生命周期
2. 使用过时的ref赋值字符串的方式
3. 使用废弃的findDOMNode方法，该方法是很早的方法，用来获取dom。ref已经很好的解决了该问题，所以该方法被移除掉了。
4. 检测周期函数中意外的副作用
    1) 副作用:  一个函数中，做了一些影响函数外部数据的事情。如: 异步请求，改变参数值，setState，本地存储。 没有副作用的函数，被称为纯函数。
    如果开启了严格模式，副作用代码仅能出现在componentDidMount、componentDidUpdate、componentDidWillUnMount这三个声明周期函数中。

    2) 严格模式下，是无法监控到具有副作用的代码的，所以不会弹出警告。
    它的处理方式是，把那些不能写副作用代码的周期函数(除那三个之外)，故意调用两次。本来执行一次。
    如果它修改了外部的数据(产生了副作用)，调用两次和调用一次，差别是很大的，有可能出现问题。以这种方式提示开发者。
    把代码发布出去，是不会执行两遍的，只在开发环境下有效。


5. 使用过时的context API(旧版的执行期上下文)


- **Profiler(性能分析工具)**

该组件并不是在代码中使用，而是浏览器的一个开发工具。
作用: 分析每一个组件重新渲染所需要的时间，可以找到那些比较耗时的组件进行优化。



#### 行间传参的使用介绍(props)
从props中获取的数据，都是只读的，不能进行修改，如果想要修改，就需要在state中在定义一个属性，对传递进来的数据进行保存，修改和使用都用state中保存的数据。
如果行间传进来一个对象或者数组，是可以对内部的某个属性进行修改的，但是不推荐使用该方式。

React开发的铁规律: 子组件不能操作父组件中的数据，实现想操作，只能父组件传递一个修改数据的接口，调用接口进行数据的修改。



#### 属性默认值(给props赋默认值)
1. 通过 `static defaultProps = {}`，可以对props赋默认值。
底层是props与defaultProps对象进行混合。

2. 在组件外部，通过`组件名.defaultProps = {}`，可以对props赋默认值。



#### props的数据校验

props的数据校检发生在props赋初始值的后面，constructor的前面。

要想完成数据的校验，需要借助一个新的插件: `npm install prop-types -D`
该插件的介绍网址(数据校检的方法)   https://github.com/facebook/prop-types


1. 常用的数据校检的方式

    1)  `PropTypes.string` 表示传入的数据必须是字符串类型
    2)  `PropTypes.number` 表示传入的数据必须是数字类型
    3)  `PropTypes.bool`   表示传入的数据必须是布尔类型
    4)  `PropTypes.func`   表示传入的数据必须是方法
    5)  `PropTypes.object` 表示传入的数据必须是对象
    6)  `PropTypes.array`  表示传入的数据必须是数组
    7)  `PropTypes.any`    表示传入的数据任意，配合isRequired的使用，设置必填

    8)  `PropTypes.node`   表示传入的数据是可以渲染的数据(jsx，字符串，数字 ···)
    9)  `PropTypes.element` 表示传入的数据必须是React元素对象( jsx和React.createElement() )
    10) `PropTypes.elementType` 表示传入的数据必须是React元素类型( 组件名，即组件函数 )
        使用方式:  `let V = this.props.V;   <V />`。
        把组件构造函数传入，子组件中创建传入组件的React元素对象
    11) `PropTypes.instanceOf(构造函数)` 表示传入的数据的原型链上必须有某个构造函数的原型。
        用于限制传入的对象，必须是由某个构造函数产生的。
    12) `PropTypes.oneOf(数组)` 表示传入的数据必须是数组中的某一项(相等)。
    13) `PropTypes.oneOfType(数组)` 表示传入的数据的类型必须是数组中的某一项。
        比如: `PropTypes.oneOfType([PropTypes.number, PropTypes.string])` 

    14) `PropTypes.arrayOf(PropTypes.XXX)` 表示传入的数据必须是一个数组，并且数组的每一项必     须为限制的类型。
        比如: `PropTypes.arrayOf(PropTypes.string)`  数组中的每一项必须为字符串，有一项不是字符串就会弹出警告。

    15) `PropTypes.objectOf(PropTypes.XXX)` 表示传入的数据必须是一个对象，并且对象的每个属      性的属性值必须为限制的类型。
        比如: `PropTypes.objectOf(PropTypes.string)`  对象的每一个属性值必须为字符串，有一项不是字符串就会弹出警告。
    
    16) `PropTypes.shape(对象)`  表示传入的数据必须是一个对象，并且每个属性的属性值的类型必     须与设置的类型相同。
        比如: `PropTypes.shape( { a: PropTypes.string.isRequired } )`  传入对象中的a属性对应的属性值的类型必须为字符串且必须传入，可以限制所有的属性。
        甚至可以对象嵌套对象：`PropTypes.shape( { b: PropTypes.shape{ c: XXX } } )`  表示传入的对象中，有一个b对象，该对象中的c属性对应的属性值的类型必须为设置的类型，还可以继续嵌套。
        结合数组的arrayOf使用: `PropTypes.arrayOf(PropTypes.shape({ a: PropTypes.XXX }))`
        表示传入的必须是一个数组，并且数组中的每一项必须为对象，然后对象中的属性值的类型必须符合设定的。 
    
    17) `PropTypes.exact(对象)`  和shape的功能一样，用法也一样，但是限制的更加准确。
        exact对传入的对象属性有严格限制，不能有多余的属性，每个属性都必须存在验证方法。
        而shape对传入对象属性没有限制，只验证规定的属性，其它属性不管。

    18)  `PropTypes.isRequired` 表示该属性必须传入，可以与其它的验证混合使用。
        比如: `PropTypes.number.isRequired`  表示传入的数据必须是数字类型且必须传入
        混合使用的方式 `PropTypes.***.isRequired`

    19) 自定义验证方法:  `function(props, propName, componentName) {}`。
        props为当前组件的props对象，propName为验证的属性名，componentName为当前的组件名
        该方法有返回值，返回new Error()，返回一个创建好的错误，控制台就会弹出该错误提示。说明数据不合理，该错误是自定义的。
        
 
2. 注意: 
    1)  如果行间传入的是null或者为undefined，React会认为没有传递，属性不同弹出警告。如果设置了必填项`isRequired`，则会弹出警告

    2)  数据校检，只发生在开发阶段，即在控制台打印出警告，提示开发者。对数据没有任何影响，传入的数据正常使用。

3. 使用示范代码如下
```js
import React from 'react';
// 引入数据校检的插件
import PropTypes from "prop-types";

class Abc extends React.Component{
  // 进行校验
  static propTypes = {
    name: PropTypes.string,  // 传入的name必须是字符串

    salary: function(props, propName, componentName) {
      if (props[propName] < 10000 ) {    // 如果传入的值小于10000，抛出错误
        return new Error(
          `${componentName}组件内，传入的${propName}小于10000`
        );
      }
    },
  }

  render () {
    return ( <div>{ this.props.name }</div> )
  }
}
// 组件的抛出
export default Abc;
```

4. prop-types组件的引入问题
    1) 有些版本可以通过`import Proptypes from "prop-types"`进行引入
    2) 有些版本需要通过`import ReactProptypes from "prop-types`进行引入。
       如果还是使用Proptypes进行引入，控制台会弹出'Proptypes' is not defined  no-undef这样一个错误



#### 生命周期
- 生命周期只存在于类组件中，函数组件不存在生命周期，但是可以借助hooks实现生命周期的一些功能

.
- **旧版生命周期**
  - 版本：React < 16.0.0

  - 图解

  <img src='https://lsz.net.cn/node/imgs/9f4127d8fe163d377d9d96e2dfcafb2a.png' />

  - 具体生命周期介绍
    - componentWillMount
      - 可以使用setState，但是为了避免bug，不建议使用
    - render
      - 返回一个虚拟DOM，会被挂载到虚拟DOM树中，最终渲染到页面的真实DOM中
      - render可能不只运行一次，只要需要重新渲染，就会重新运行，所以严禁使用setState，因为可能会导致无限递归渲染
    - componentDidMount
      - 通常情况下，会将网络请求、启动计时器等一开始需要的操作，书写到该函数中
    - componentWillReceiveProps
      - 即将接收新的属性值，参数为新的属性对象
    - shouldComponentUpdate
      - 指示React是否要重新渲染该组件，通过返回true和false来指定
      - 默认情况下，会直接返回true
    - componentWillUpdate
      - 组件即将被重新渲染
    - componentWillUnmount**
      - 通常在该函数中销毁一些组件依赖的资源，比如计时器


.

- **新版生命周期**

  - 移除了一些周期函数，加入了一些周期函数

  - 图解
  <img src='https://lsz.net.cn/node/imgs/fd50913d8f141f09fa4aac33a0e1a8b5.png' />

  - 版本：React >= 16.0.0


  - 函数详解
    - getDerivedStateFromProps
      - 通过参数可以获取新的属性和状态
      - 该函数是静态的
      - 该函数的返回值会覆盖掉组件状态
    - getSnapshotBeforeUpdate
      - 真实的DOM构建完成，但还未实际渲染到页面中。
      - 在该函数中，通常用于实现一些附加的dom操作
      - 该函数的返回值，会作为componentDidUpdate的第三个参数

.

- **扩展**
  - render函数，创建虚拟dom，如果某个元素是一个组件，于是触发子组件的生命周期，创建虚拟dom
  - 所以componentDidMount要等子组件创建完成后，才会执行
    - 并且子组件的componentDidMount先执行
    - 因为创建真实dom，如果遇到组件，要先创建组件的，组件创建完成后，componentDidMount 就会被触发
  - 类似递归，先外后内（render前），在内到外（render后）



#### React中的动画插件
需要下载外部插件 `npm install react-transition-group -D`。
该库中提供了四种组件。

#### 动画插件—Transition组件

1. 使用案例
```js
import { Transition } from "react-transition-group";
import { useState } from "react";

function A() {
    let [boo, setBoo] = useState(true);

    return <>
        {/* 使用提供的第一个组件，行间需要传入两个必要的数据 */}
        <Transition in={boo} timeout={500} >
            {/* 内部必须传入一个函数，该函数有一个参数 */}
            {
                (state) => {
                    console.log(state);
                    return <div>123</div>
                }
            }
        </Transition>

        <button onClick={ () => {
            setBoo( !boo );
        } }>切换状态</button>
    </>
}
```


2. 过程分析
    1) Transition组件行间传入的两个参数，一个表示状态，一个表示动画的时间。
    2) 组件中传入方法的接收到的参数是实现动画运动的关键。
    3) Transition行间传入的in并不是控制组件的显示隐藏。而是控制向函数中传入什么值。
    4) 参数共有四个值(在不同的时间传入)
        `entered`: 初始时如果in为true，传入该值
        `exiting`: in发生了变化，从true变成了false，传入该值
        `entering`:  in发生了变化，从false变成了true，传入该值
        `exited`: 初始时如果in为false，传入该值


3. in发生变化，具体的流程分析
    1) 初始值不用分析，in为true，传入的是`entered`。in为false传入的是`exited`。
    2) 每次in发生变化，其实传入的函数都会执行三次，三次传入不同的值，设置不同的状态。
       并且这三个传入的值与设置的时间也有关系。
    
    3) true变成false，传值顺序为先传入`entered`，然后传入`exiting`。
       然后开始等待，等待时间为设置的时间，然后在传入`exited`。

    4) false变成true，传值顺序为先传入`exited`，然后传入`entering`。
       然后开始等待，等待时间为设置的时间，然后在传入`entered`。


4. 使用分析
    1) 传值模式与往复运动十分接近，比如通过opacity控制dom的显示隐藏。

    2) 当in为true时，传入entered(起点)。表示显示，opacity设置为1。
    3) 当in为false时，传入exited(终点)。表示隐藏，opacity设置为0。
    
    4) 当in发生变化时，从true变化成false(从起点到终点)，从显示过渡到隐藏
       1) 先传递`entered`(起点)。表示在设置一下起点的样式，确保从起点开始变化。
       2) 然后传入`exiting`(变化)。设置终点的样式，如果起点中设置了transition。
       此时就开始进行过渡动画，设置的过渡时间要小于等于in，最好等于in。
       3) 当到达设置的时间，传入`exited`(终点)。在设置一遍终点的样式。
       4) 虽然exiting中设置的样式过渡完就是终点的样式。
       但是中间可能发生新的变化，赋了新的终点样式。
       5) 所以在最后为了保险，传入终点标记，设置终点样式。
    
    5) 从false变化到true同理。

5. 注意点
    1) 要想实现动画，css样式需要自己写，尤其是动画的关键transition属性，并不会自己添加。
    组件只是提供了几个阶段的标记。
    
    2) 设置的时间没有到达，in的状态又发生了变化，则之前状态终点传入的值不在传入。
       直接进行下一次的切换周期，先执行传入切换初始传入的值，然后在执行传入第二个值。
       然后再次进入等待状态，等待时间一到，执行函数传入当前状态对应的值。


6. 扩展
    1) **通常使用传入的四个数据作为标签的class名，以此控制动画的产生**。
    2) 也可以在函数中判断传入的值，通过行间样式实现动画。



#### 动画插件—CSSTransition组件

1. 功能
    1) 相对于Transition组件，该组件更加专注与处理css样式，直接给标签添加指定的class名。

2. 基础使用
    1) 和Transition使用方式一样。行间也传入in和timeout两个属性。
    2) 初始时，dom不添加任何特殊的class。只有in发生变化时才进行添加
    
    3) in从true变化到false
       1) 变化时，先添加`exit`，然后在下一帧在exit的基础上添加`exit-active`。
          可以在exit中添加transition，好处在于，运动完该属性销毁，不用一直监听属性
          在exit-active中添加过渡终点的样式。
       2) 时间运动完，class替换为`exit-done`。设置终点的样式。

    4) in从false变化到true
       1) 变化时，先添加`enter`，然后在下一帧在enter的基础上添加`enter-active`。
          可以在enter中添加transition，好处在于，运动完该属性销毁，不用一直监听属性。
          在enter-active中添加过渡终点(起点)的样式。
       3) 时间运动完，class替换为`enter-done`。设置起点的样式。


3. 子组件加className
    1) 标识性class与className中设置的进行合并，在原有的基础上添加标识性class，不会替换。
       这样标签可以有个初始class，设置初始时的样式，与标示性class的动画联系起来。


4. 注意点
    1) 第一次动画还没有运动完，in的状态就发生了变化
    如果等待的时间没有到达，in发生了变化，比如从true变成了false，然后又变成了true。
    则`exit-done`不在设置，直接进去下一次周期。
    从`exit exit-active`直接切换到`enter enter-active`。时间一到添加`enter-done`。
    不会等待上一次变化周期完成，下一次才能开始。

    2) CSSTransition组件的下面只能有一个节点，可以是组件节点，可以是普通节点
      如果是组件节点，CSSTransition在添加标示性class时。
      是给组件下可以渲染出真实节点的第一个节点添加。


5. 使用案例
```js
import { CSSTransition } from "react-transition-group";
import { useState } from "react";

function A() {
    let [boo, setBoo] = useState(true);

    return <>
        {/* 使用提供的第一个组件，行间需要传入两个必要的数据 */}
        <CSSTransition in={boo} timeout={10000}>
            <div className={ "a b" }>123</div>
        </CSSTransition>

        <button onClick={ () => {
            setBoo( !boo );
        } }>切换状态</button>
    </>
}
```
    

6. 更改标示性的class名称，换成自定义的。
    在组件的行间使用classNames，该属性有两种赋值方式:
    1) 赋值字符串，则子组件添加的标示性class与设置的字符串进行拼接。比如`a-exit`
    2) 赋值对象，可以指定某个标示性class名换成自定义的名字。
       比如{exit: 'abc'}。则exit在添加时就变成了abc，不再是exit了。
       如果想要改变exit-done名字，需要换成小驼峰式的写法。即exitDone


7. 添加初始class
    CSSTransition组件在刚开始渲染时，下面的第一个子节点是不会添加任何class的。
    如果想要添加初始的class，有两种方式:
    1) 一种是在子节点对应的React元素上直接使用className添加
       但是这种方式添加的class会一直存在。
    2) 另一种方式是在CSSTransition组件的行间写上`appear`这个属性。
       该属性会在初始时给第一个子节点添加两个class名，即`appear appear-active`。
       当in的状态发生变化进行重新渲染时，这两个class将会消失，以后也不再生成。
       即只存在初始阶段。
       **appear-active也是在appear的后一帧添加**。
       如果in的初始值赋的为false，这两个class不会添加。


8. 组件行间定义的各种事件以及作用
    


#### 动画插件—SwitchTransition组件
    
1. 作用
    用于有秩序的切换内部组件，可以实现一个离开后另一个在进入的效果。

    **控制组件的创建和销毁，并且为销毁和创建添加了一个过程**。


2. 使用
    1) 该组件不能单独使用，需要配合Transition组件或者CSSTransition组件配合使用。
       并这两个组件上不在使用in，而是使用key。

    2) 效果先触发两个组件的离开效果，然后在触发组件的进入效果，最终展示为组件的进入状态。
    
    3) 以CSSTransition组件为例，切换状态。
       由于key的值发生了变化，此时整个组件以及下面的节点都将被卸载然后生成全新的。
       但是新旧节点的替换并不是立即完成的，在SwitchTransition组件的作用下。
       旧组件先触发离开状态，即节点添加class名`exit exit-active`，表示正在离开。
       到达设置的时间后，旧组件才被替换成新的组件。
       然后新的组件触发进入状态，即添加class名`enter enter-active`，表示正在进入。
       到达设置的时间后，新组建的节点设置为`enter-done`。表示已经进入。

    4) 无论从true变成false，还是从false变成true。经过的步骤都是旧组件先离开，新组件进入。

    5) 正是由于组件的创建和销毁多了一个过程，并且有对应的class名。
       我们就可以根据class名设置进入和离开时的样式，形成动画。
       然后根据key的值，显示不同的内容。
       这样就形成了一个页面离开后另一个页面进入的效果


3. 示范代码
```js
import { SwitchTransition, CSSTransition } from "react-transition-group";
import { useState } from "react";

function A() {
    let [boo, setBoo] = useState(true);

    return <>
        <SwitchTransition>
            <CSSTransition timeout={ 2000 } key={boo}>
                <div>123</div>
            </CSSTransition>
        </SwitchTransition>
        

        <button onClick={ () => {
            setBoo( !boo );
        } }>切换状态</button>
    </>
}
```


4. 使用appear设置初始class名
    1) 该属性给CSSTransition或者Transition组件进行设置，给SwitchTransition设置无效
    2) 比如给CSSTransition设置该属性，状态无论是true还是false。
       初始都为`appear appear-active`。
       然后经过设置的时间后变成`appear-done enter-done`。
    3) 变化的目的在于符合SwitchTransition组件的新组建进入的特点。
    appear appear-active表示组件创建，开始进入。appear-done enter-done表示进入完成。


5. 特点
    如果一个旧组件还没有离开页面，此时状态又发生了变化。
    Transition组件是不会进行重新解析的，只有当新的组件插入到页面，哪怕是刚插入。
    即旧组件已经离开，此时切换状态才有效。
    要考虑到旧节点是否已经被新节点进行了替换。



#### 动画插件—TransitionGroup组件

1. 作用
    该组件的children，可以接收多个Transition或者CSSTransition组件
    该组件用于根据这些子组件的key，控制它们的销毁或者创建


2. 使用
    1) 该组件只能控制Transition或者CSSTransition组件的销毁，或者创建。
    2) 无法控制它们的的状态切换
    3) 只不过销毁和创建多了一个过程
       和SwitchTransition一样，销毁多了移出的过程，创建多了移入的过程。

    4) 销毁不会立即销毁，而是添加`exit exit-active`。
       等到了该组件设置的timeout(时间)后才进行组件的卸载。
       这样就可以利用这两个class做一些销毁离开的效果。

    5) 创建会立即插入，然后添加`enter enter-active`。
       等到了该组件设置的时间后，class替换为enter-done。
       可以利用这几个class做一些创建进入的效果。

    6) 如果使用appear添加默认的class
       先为`appear appear-active`，等到了组件设置的时间，变为`appear-done enter-done`。
       可以利用这几个class做一些创建进入的效果
       如果每个组件都有appear，可以把该属性添加在TransitionGroup上，会作用用于全部子组件

    7) TransitionGroup在各个子组件的外围默认创建一个div父级，把组件进行包裹。
       可以设置创建的父级dom，TransitionGroup利用行间属性component="?"，指定dom
       比如`component="ul"`，创建ul。如果设置为`{ null }`，表示不创建dom。
       如果在TransitionGroup上使用`className`，是给创建的组件父级标签添加class。



3. 示范代码
```js
import { TransitionGroup, CSSTransition } from "react-transition-group";
import { useState } from "react";

function A() {
    let [boo, setBoo] = useState(true);
    let [boo1, setBoo1] = useState(true);

    return <>
        <TransitionGroup appear> 
            {
                boo && <CSSTransition timeout={ 5000 }>
                    <div>123</div>
                </CSSTransition>
            }
            {
                boo1 && <CSSTransition timeout={ 1000 }>
                    <div>789</div>
                </CSSTransition>
            }
        </TransitionGroup>
        
        {/* 控制两个组件的销毁和创建 */}
        <button onClick={ () => {
            setBoo( !boo );
        } }>切换状态</button>

        <button onClick={ () => {
            setBoo1( !boo1 );
        } }>切换状态</button>
    </>
}
```
       



#### react使用webpack进行打包的操作

下载react需要的插件 `npm install react react-dom -D`;
下载webpack需要的插件 `npm install webpack webpack-cli -D`;

下载打包react需要的插件 `npm install @babel/core @babel/preset-env @babel/preset-react babel-loader @babel/plugin-proposal-class-properties -D`


@babel/plugin-proposal-class-properties。 该插件的作用是对语法进行降级，解决react中使用了新语法(比如 state = {} )，如果不下载该组件，直接打包会进行报错。


注意版本号(不同的版本，使用方式不同):
> babel-loader@8.0.6
> @babel/preset-react@7.7.4
> @babel/core@7.7.5
> @babel/preset-env@7.7.6


1. 建立.babelrc文件(打包react必须的文件，设置babel的一些数据)
内部代码(新旧版本的代码不同)
```js
{ 
    "presets": [
        "@babel/react",
        "@babel/env"
    ],
    // 如果没有下载@babel/plugin-proposal-class-properties该插件，下方代码可以不用写
    "plugins": ["@babel/plugin-proposal-class-properties"]
}
```

2. webpack中的代码
```js
let path = require("path");
let HtmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
    mode: "development",
    entry: "./src/main.js",
    output: {
        filename: "react-bundle.js",
        path: path.resolve(__dirname, "dist")
    },
    module: {
        rules: [
            // 打包react的代码
            {
                test: /\.(js|jsx)$/,
                loader: 'babel-loader'
            }
        ]
    },
    plugins: [
        new HtmlWebpackPlugin({
            // 内部需要定义一个标签，用来react的插入
            filename: "index.html",
            template: "./index.html",
            minify: {
                removeComments: true,
                collapseWhitespace: true
            }
        })
    ]
}
```

3. react主入口文件的代码
```js
import React from "react";
import { render } from "react-dom";
// 总组件
import App from "./App";

render(<App />, document.getElementById("app"));    
```


#### antDesign库(UI库)的引入与使用

1. 作用
   该库提供了非常多的常用组件，并且这些组件的样式也已经定义完成。


2. create-react-app脚手架搭建的项目使用该库的方式
   1) 下载插件，同时会下载下来对应的css文件(打包好的，底层使用的less开发的)
      1) 下载方式: `npm i antd -D`
      2) 找一个初始时就加载的文件，加载该插件对应的css样式
         1) 引入代码: `import "antd/dist/antd.css"`
      3) 样式文件引入成功后，就可以在组件文件中使用该UI库中的组件
         1) 引入方式和引入自定义的组件的方式相同，代码如下
         2) `import { 具体的组件 } from antd`


3. umi脚手架搭建的项目使用该库的方式
   1) 按照create-react-app搭建的项目使用方式进行使用
      1) 下载插件
      2) 在src文件夹下的global.js文件中引入下载下来的css文件
         1) 引入代码: `import "antd/dist/antd.css"`
         2) global.js会在一开始的时候就执行，然后加载样式文件
      3) 样式文件引入成功后，就可以在组件文件中使用该UI库中的组件
         1) 引入方式和引入自定义的组件的方式相同，代码如下
         2) `import { 具体的组件 } from antd`
   2) 利用配置文件启用该插件(不需要下载antd插件)
      1) 由于该库和umi是同一家公司的，所以umi的插件集(umi-plugin-react)中包含了该插件
         1) 启用后就可以直接使用，不需要导入css文件，自动导入，直接导入对应的插件就可以使用
         2) 但是umi-plugin-react没有下载的话，需要下载umi-plugin-react。
      2) 启用代码如下
    ```js
    export default {
        plugins: [
            ["umi-plugin-react", {
                antd: true
            }]
        ]
    }
    ```
    

