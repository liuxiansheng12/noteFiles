<script src='/笔记/see/index.js'></script>
[toc]


#### redux的下载
需要下载的插件`npm i redux -D`;


#### action数据

1. 作用
    action数据概念，是根据后端MVC思想衍生的一种适用于前端处理数据的思想。

2. 解决的问题(组件间共享数据的问题)
    1) 大型项目处理数据的问题
       1) 一个大型项目，伴随着有很多的组件。
       2) 如果很多组件需要共享大量的数据，就需要把数据提升到公共的父级(props向下传参，上下文)
       3) 但是这样容易出现一个非常严重的问题，公共父级中的数据，不知道被那个组件修改，如果出现问题，调试起来非常困难
    2) 借用后端MVC模式处理数据的不现实情况
       1) 前端是无法实现完整的MVC思想的。归根原因，前端处理数据的方式太多，太杂。
       2) 比如页面中有大量的组件，这些大量的组件中含有非常多的事件，用来处理数据。
       3) 如果把这些事件都写在控制器中，则控制器就会变得非常庞大。
    3) 后端可以使用MVC模式处理数据的原因
       1) 根据请求，把请求分发到控制器中，进行数据的处理。由于请求都是固定的，一共就那么几个，这样构造器就变得很整洁简单。
       2) 根据这一思想，就诞生了action数据。

3. action数据的使用
   1) action其实就是一个对象，就相当于请求地址
   2) action的好处在于，把视图与控制器的直接关系给断开了
   3) 视图在修改数据的时候，构建一个action对象(描述我要修改该数据了，如果修改)

4. action的使用
   1) action是一个对象，内部必须有一个type属性，表示约定的状态。
   2) 其它属性可以随意，但是通常action对象中只有两个属性
      另一个为payload属性，表示附加信息，比如给某个状态赋的新值
   3) action的示范样式
   ```js
   var action = {
      type: "REPLACE",   // 约定该状态为替换  
      payload: {a: 123}  // 替换的属性和新的数据
    }
   ```
   4) 注意: action对象只能是有Object构造函数直接生成的(即平面对象)，即它的原型为Object.prototype。不能通过自定义的构造函数进行创建。


5. action的使用需要依赖很多东西
   1) action就是一个修改数据的描述，并不能修改数据。
   2) 要想修改数据，需要专门解析action的函数，以及把action发送到解析函数的函数。
   3) 这就是redux的底层功能(发送action，解析action, 修改存放的数据)


6. 扩展
   1) 由于大型项目中，修改数据的规则有很多，action的type对应的属性值有很多种，为了防止出现问题，单独起一个js文件，专门定义type规则以及根据规则生成对应action对象的函数。


#### reducer函数

1. 作用
   该函数需要进行自定义，是一个专门解析action对象，处理数据的函数。

2. 使用
   该函数接收两个参数，第一个是仓库中存放的数据，第二个是action对象

3. 注意点
   1) 该函数根据action修改状态时，最好不要直接修改第一个传入的参数(仓库数据)
   2) 而是应该克隆出一份仓库数据，修改克隆出的数据，然后在返回克隆出的数据，进行保存。
   3) 该函数中，不要出现异步操作，不要修改外部数据，不要有副作用。

4. 示范代码
```js
// 定义仓库中的初始数据
const mystate = {
  name: "lsz",
  age: 18
}

function reducer( state = mystate, action ) {
    // 克隆仓库数据
    const newState = JSON.parse( JSON.stringify(state) );

    switch (action.type) {
        case "CHANGE":         // 修改规则
            ··· ··· ···        // 修改数据的操作
            return newState    // 返回修改后的数据，进行保存
        default:
            return state;      // 如果啥都没修改，直接返回原数据
    }
}
```   


#### createStore函数

1. 作用
   使用该函数，创建出一个操作仓库的对象，以及创建仓库

2. 使用
   1) 该函数，可以接收三个值，一个值为reducer函数，一个为仓库的原始数据，一个为中间键函数
   2) 该函数是插件redux中提供的一个方法，所以需要进行导入
   3) 由于该函数传递reducer函数，会在创建数据库的时候直接执行一次。
   传入的action是自定义的，type属性是随机的，所以与reducer中定义的状态不同，返回初始对象进行保存，所以该函数的第二个参数可以不用传入。


3. 示范代码
```js
import { createStore } from "redux";

const mystate = {
  name: "lsz",
  age: 18
}

const reducer = ( state = mystate, action ) => {}

// 创建仓库
const store = createStore(reducer);  

export default store;
```



#### dispatch函数

1. 作用
   使用该函数，可以把创建好的action对象传入到reducer函数中，并且执行reducer函数处理action，更改数据

2. 使用
   该函数，是创建仓库时，得到的仓库对象中的一个方法。
   该函数，接收一个参数，action对象。


3. 使用方式
```js
import store from "./store"; // 引入数据库组价

var action = {}
    
store.dispatch(action);
```

#### subscribe函数

1. 作用
   1) 该函数被称为发布订阅函数，通过该函数，可以订阅一个函数，当仓库发生变化时(dispatch函数被调用时)，会触发订阅函数。和router中的listen函数的功能差不多。
   2) 通过该函数，可以实现React监听仓库变化，从而刷新组件的功能。

2. 使用
   1) 该函数也是，创建仓库时得到的仓库对象中，提供的一个方法。
   2) 该方法接收一个参数，该参数必须是一个函数
   3) 该方法可以被多次使用，订阅多个函数，不会发生覆盖现象，会逐步执行
   4) 该方法返回一个方法，通过调用该方法，可以取消本次使用订阅的方法，通常在组件销毁时使用


3. 代码示范
```js
import store from "./store"; 

// 订阅函数
store.subscribe( () => {
    console.log("仓库数据发生了变化");
});
```



#### getState函数

1. 作用
   用于获取仓库中的数据

2. 使用
   1) 该函数是，创建仓库时得到的仓库对象中，提供的一个方法
   2) 该方法没有参数，只有一个返回值，即仓库中的数据


3. 代码示范
```js
import store from "./store"; 

// 订阅函数
const state = store.getState();
console.log(state);
```



#### bindActionCreators函数

1. 作用
   1) 该函数可以加强构造action函数的功能
   2) 在大型项目中，为了便于状态与action对象的管理，统一放在js文件中。并且有专门的函数生成action对象。
   但是这些函数只能创建action对象，要想使用reducer进行解析，还必须调用dispatch函数，把创建好的action对象进行传入。
   使用该函数进行包装后，会自动封装dispatch函数，不用再手动调用dispatch函数。

2. 使用
   1) 该函数是redux组件提供的方法，所以使用时需要从redux中引入。
   2) 该函数接收两个参数，一个是要包装的生成action对象的函数，一个是dispatch函数
   3) 如果想要包装多个生成action对象的函数，可以把这些函数放在一个对象中，作为该函数的第一个参数进行传入。
   4) 如果传入的是对象格式，该函数返回的也是一个对象格式的数据，并且属性值和传入对象的属性值相同(便于使用)，属性值对应的action对象不变
   但是对应的属性值发生了变化，变成新的函数，该内部集成创建action对象函数的调用，以及使用传入的dispatch发生action对象)
   5) 如果传入的是一个单独的函数，返回值是一个新函数，内部集成action的创建与dispatch发送。


3. 示范代码
```js
import store from "./store.js";
import {bindActionCreators} from "redux";
// 生成action对象的函数对象(传参要求必须放在一个对象中)
let obj = {
    a: function () {
        return {
            type: "a"
        }
    },
    b: () => ({
        type: "b"
    })
}
// 正常使用，第一步创建action，第二步使用dispatch
const action = obj.a();
store.dispatch(action);


// 使用bindActionCreators，传入对象，返回值也为函数
const objDispatch = bindActionCreators(obj, store.dispatch);
// 创建action对象加使用store.dispatch函数发送
objDispatch.b();   


// 使用bindActionCreators，传入单独的函数，返回值也为函数
const aDispatch = bindActionCreators(obj.a, store.dispatch);
// 创建action对象加使用store.dispatch函数发送
aDispatch();  
```



#### combineReducers函数

1. 作用
   该函数的作用就是合并reducer函数，实现了仓库的组件化开发。


2. 原理
   1) 其实该函数的底层就是，创建了一个新的reducer函数，因为仓库的创建只能接收一个reducer函数，如果想要使用多个reducer函数进行功能模块化开发，必须把这些reducer函数封装在一个reducer函数中。
   2) 当使用dispatch传入状态时，调用封装好的reducer函数，但是在封装好的reducer函数中，会调用传入的所有模块化的reducer函数，然后把每一个reducer函数的返回值(数据)，保存到仓库中的一个属性中
   3) 相当于在仓库中开辟了一个子区域，由于所有的reducer函数都会运行，所有type在定义时，不要出现相同的。


3. 使用
   1) 该函数是redux组件中的函数，所以在使用时需要从redux中引入
   2) 该函数接收一个参数，参数格式为对象，对象的属性值就是每个模块的reducer函数


4. 代码示范
```js
// A模块对应的数据
const mystateA = {
    a: 1
}
function reducerA(state=mystateA, action) {}

// B模块对应的数据
const mystateB = {
    b: 2
}
function reducerB(state=mystateB, action) {}

// reducer的封装
const reducer = combineReducers({
    reducerA,
    reducerB
})

// 创建仓库时使用的是最终封装好的reducer函数
const store = createStore(reducer);

/** 最终仓库中保存的数据格式为
{
    该属性对应模块A的数据
    reducerA: {
        a: 1
    }
    该属性对应模块B的数据
    reducerB: {
        b: 2
    }

    所以要想获取某个模块中的数据，需要从具体的属性中获取，
    比如获取组件A中的a数据，方式为: store.getState().reducerA.a
}
*/
``` 




#### 实现createStore函数的功能—源码

1. 思路
   1) 该方法创建一个数据库，并且返回一个对象
   2) 在开始时就调用一次reducer方法，并且传入一个随机type
   3) 该方法可以传递三个参数，第三个参数先不考虑。第二个参数也分情况，如果是函数形式，则为中间键函数(默认值没有传递，第二个参数也可以传入中间键函数)
   4) 返回的对象中有一系列的方法
      1) getState方法: 调用该方法，直接返回内部的数据仓库
      2) dispatch方法，自动调用reducer方法，自动调用订阅的方法
      3) subscribe方法，使用该方法订阅一个方法，并且返回一个方法，取消订阅的方法


2. 代码示范
```js
export default function createStore(reducer, mystate, z) {
    // 对reducer函数进行保存，仓库中有一个方法，可以替换reducer函数
    const reduc = reducer;
    // 保存数据(仓库)
    let state = null;
    // 默认值位置不是中间键函数
    if(mystate && typeof mystate != "function") {
        state = mystate;
    }
    // reducer是不是个函数，如果不是需要抛出错误
    if(typeof reducer != "function") {
        new Error("reducer 必须为 function");
    }
    // 初始时调用一次reducer函数
    state = reduc(state, {
        // action的type随机
        type: `@@redux/INIT` + randomStr(6).split("").join(".")
    })
    
    // 如果reducer执行完(按理说应该匹配不成功)，如果得到的是undefined
    // 说明reducer中没有处理匹配不成功的情况，这种是错误的reducer函数，需要抛出错误
    if(state === undefined) {
        new Error("reducer 有问题")
    }

    // 保存订阅函数的数组，可以订阅多次
    const subscribeFun = [];

    return {
        getState: () => {
            // 返回仓库数据
            return state;
        },
        subscribe: (func) => {
            // 订阅的必须是一个方法
            if(typeof func !== "function") {
                new Error("订阅的不是一个函数");
            }
            // 进行订阅
            subscribeFun.push(func);

            // 返回取消订阅的函数
            return function () {
                // 查询到订阅函数的位置
                const index = subscribeFun.indexOf(func);
                // 移出订阅函数
                subscribeFun.splice(index, 1);
            }
        },
        dispatch: (action) => {
            // 使用reducer函数，重新保存修改后的数据
            state = reduc(state, action)

            // 触发订阅函数
            subscribeFun.forEach( (ele) => {
                ele();
            } )
        }
    }
}

// 创建指定长度的随机字符、数字
function randomStr(length) {
   return Math.random().toString(36).substr(2, length)
}
```


#### 实现combineReducers函数—源码

1. 思路
    1) 返回一个全新的reducer函数
    2) 对每个reducer函数也进行了验证，防止没有处理匹配不成功返回原始数据的操作
    3) 其实是验证了两次，防止内部强行定义type含有@@redux/INIT字符串，返回初始值的处理方式
    4) 具体的reducer函数在调用时，需要传入对应的数据，不能传入整个state数据
    5) 还需要考虑，可能reducer是创建仓库时初始调用，此时state为null，没有该属性
       

2. 代码示范
```js
export default function combineReducers(obj) {
    // 判断传入的是否为对象格式
    if(typeof obj !== "object") {
        new Error("传参错误")
    }
    for(let prop in obj) {
        // 逐渐执行reducer函数，进行reducer的第一次验证
        const a = obj[prop](null, {
            type: "@@redux/INIT" + randomStr(6).split("").join(".")
        })
        if(a === undefined) {
            new Error("reducer 有问题")
        }
        // 进行reducer的第二次验证，防止固定@@redux/INIT返回初始值
        const b = obj[prop](null, {
            type: "@@redux/PROBE_UNKNOWN_ACTION" + randomStr(6).split("").join(".")
        })
        if(b === undefined) {
            new Error("reducer 有问题")
        }
    }
    
    // 返回新的reducer函数
    return function (state, action) {
        // 判断传入的action有没有type属性
        if(!action.type) {
            new Error("action没有type属性")
        }
        // 定义仓库数据
        const stateObj = {};
        for(let prop in obj) {
            // 逐渐执行reducer函数，并且保存返回值
            // 注意，具体的reducer函数，需要传入对应的数据，不能传入整个state数据
            // reducer可能创建仓库时调用，需要考虑到没有该属性值的情况。
            stateObj[prop] = obj[prop](state && state[prop], action)
        }
        return stateObj
    }
}

// 创建指定长度的随机字符、数字
function randomStr(length) {
    return Math.random().toString(36).substr(2, length)
}
```    


#### 实现bindActionCreators函数—源码

1. 思路
   1) 对创建action的函数进行包装，生成自动调用dispatch的函数
   2) 该函数需要判断，传入的是方法还是对象的情况


2. 代码示范
```js
export default function bindActionCreators(actionFun, dispatch) {
    if(typeof actionFun === "function") {
        return creators(actionFun, dispatch)
    }
    else if(typeof actionFun === "object") {
        let obj = {};
        for(let prop in actionFun) {
            if(typeof actionFun[prop] !== "function") {
                new Error("错误");
            }
            obj[prop] = creators(actionFun[prop], dispatch)
        }
        return obj
    }
}

// 专门封装函数的函数
function creators(actionFun, dispatch) {
    // 在使用时可能传递一些参数，用于action对象的构建
    return function (...data) {
        dispatch( actionFun(...data) )
    }
}
```



#### redux中间键—中间键的原理(如何进行自定义中间键)
1. 中间键的作用
    1) 增强了仓库中dispatch函数的功能
    2) 比如之前只能传入action对象，经过中间键的加强，可以传入方法，promise
    3) 重点，中间键并不对仓库造成任何影响，只是在已有的dispatch函数的基础上又套了一层

2. 中间键的原理
   1) 中间键就是一个函数，用来生成一个新的dispatch函数
   2) 然后把新生成的dispatch函数，替换掉仓库中的dispatch函数
   3) 在替换之前，把旧的dispatch函数先进行保存
   4) 新的dispatch函数，会在合适的时候，调用旧的dispatch函数，全靠旧的dispatch函数修改仓库中的数据
   5) 中间键可以连续使用(一层一层的增强dispatch的功能)
      1) 调用规则是，从后面开始包裹，最后一个调用仓库中原始的dispatch函数，倒数第二个调用倒数第一新生成的dispatch函数，以此类推。
      2) 这种方式被称为洋葱模式，一层一层的处理数据。


3. 示范代码，数据库创建完成后，进行dispatch的替换
```js
import store from "./store";

// 中间键1
function dispatch1(action) {
    dispatch2(action);
}

// 中间键2
function dispatch2(action) {
    dispatch(action)
}

// 进行保存
const dispatch = store.dispatch;
// 进行替换
store.dispatch = dispatch1;
```



#### redux中间键—applyMiddleware函数

1. 功能
   该函数的作用，给某个仓库加入中间键

2. 使用
   1) 通过该函数就可以创建出一个注入中间键的仓库，并且返回一个函数(绑定仓库)
   2) 调用返回的绑定仓库的函数，会返回创建仓库的函数
   3) **中间键函数也有固定的写法**
   4) 使用方式
   ```js
   // 该函数传入中间键，然后会返回一个绑定仓库的函数
   let f1 = applyMiddleware(中间键函数)
   // 使用返回的绑定仓库的函数，传入仓库的创建函数，会返回具体的仓库创建函数
   const createSto = (reducer, default) => createStore(reducer, default);
   let sto = f1(createSto);
   // 创建出具体的使用中间键的仓库
   const store = sto(reducer, default);
   ```



3. 中间键函数的执行规则
   1) 具体的新的dispatch函数，外面被包裹了两层函数
   2) 执行规则
      1) 首先按照传入的顺序，执行最外层的函数，得到创建dispatch的函数
      2) 然后**倒着执行**创建dispatch函数的函数，创建出具体的dispatch函数
      3) 倒着执行的原因，是把dispatch函数往前传递
      4) 最后第一个中间键函数的dispatch可以调用第二个中间键函数的dispatch函数
      5) 这样在具体调用dispatch函数时，就会从左向右(第一个开始)，依次调用各个中间键的dispatch函数，比较符合开发逻辑


4. 代码示范
```js
import { createStore, applyMiddleware } from "redux" 

// dispatch接收的是一个对象，内部存放了仓库中的getState函数，和最终的dispatch函数
function logger1(dispatch) {
    // next接收的是下一个中间键返回的dispatch函数
    return function(next) {
        // 对应的dispatch
        return function (action) {
            console.log(1)
            next(action)
        }
    }
}
// dispatch接收的是一个对象，内部存放了仓库中的getState函数，和最终的dispatch函数
function logger2(dispatch) {
    // next接收的是下一个中间键返回的dispatch函数
    // 最后一个接收的就是仓库中原来的dispatch(初始的dispatch)
    return function(next) {
        // 对应的dispatch
        return function (action) {
            console.log(2)
            next(action)
        }
    }
}

// 创建仓库的函数
const storeFun = (reducer) => createStore(reducer);
// 创建仓库
const store = applyMiddleware(logger1, logger2)(storeFun)(reducer);
// 经过applyMiddleware函数的包装，logger1中的next就是logger2创建的dispatch。
// 由于logger2是最后传入的中间键，所以next为最原始的dispatch函数
```


5. 在创建仓库的函数中使用applyMiddleware函数注入中间键
   1) 在createStore函数的第二个参数或者第三个参数是可以传入applyMiddleware函数绑定中间键的
   2) 比如: `const store = createStore(reducer, applyMiddleware(logger1, logger2));`
   3) 原理
      1) 底层还是使用的`applyMiddleware(logger1, logger2)(storeFun)(reducer)`这种方式
      2) 在调用函数时传入的applyMiddleware，是执行情况，相当于创建了绑定数据库的函数
      3) 在createStore中的处理，直接是(storeFun)(reducer)这种方式，阻断了默认的创建方式
      4) 其实(reducer)，最终调用的还是数据库函数，创建数据库，由于没有传入第三个参数，此时进不去(storeFun)(reducer)，走默认创建仓库的方式
      然后把创建的仓库对象的dispatch属性进行替换


1. 功能
   1) 该函数接收的参数不固定，但是每个参数都必须为中间键函数
   2) 会倒着执行传入的中间键函数的返回函数(第一级返回函数)
      以便于把后面中间键函数创建的dispatch函数(第二级返回函数)，可以传入前一个中间键中




#### redux中间键—实现applyMiddleware函数—源码

1. 思路
   1) 共返回两次函数
   2) 倒着执行中间键创建dispatch的函数
   3) 中间键函数，是在创建仓库时进行解析的，前两次的函数不进行解析
   4) 先执行创建仓库函数，在解析中间键函数
   5) 中间键的第一层函数执行时，传递的dispatch是最终的dispatch

2. 代码示范
```js
export default function applyMiddleware(...apply) {
    // 不知道接收多少个中间键函数，所以使用点点点的方式

    return function (createStore) {
        // 返回绑定数据库的函数，接收数据库函数

        return function(reducer, defaultDate) {
            // 返回创建数据库的函数，可以接收reducer，默认值
            
            // 创建数据库
            let store = createStore(reducer, defaultDate)

            // 解析中间键函数
            // 中间键第一层函数传入的数据(getstate，dispatch)
            const _store = {
                getState: store.getState,
                // 对dispatch重写，底层调用最新的dispatch函数。
                dispatch: (action) => {
                    store.dispatch(action)
                }
            }
            // 解析中间键最外层的函数，得到创建dispatch函数的函数
            const applyArr = apply.map( (ele) => {
                return ele(_store);
            } )
            // 保存dispatch
            let dispatch = null;
            // 倒着执行创建dispatch的函数
            for(let i = applyArr.length - 1; i >= 0; i --) {
                if(i === applyArr.length - 1) {
                    // 得到dispatch函数
                    dispatch = applyArr[i](store.dispatch)
                }else {
                    // 执行函数，传入dispatch，形成了闭包
                    dispatch = applyArr[i](dispatch)
                }
            }
            /*  高级写法
                let dispatch = applyArr.reduce( (a, b) => {
                    return (dispatch) => {
                       return a(b(dispatch))
                    }
                } );
                dispatch = dispatch(store.dispatch);
            */
            
            // 更改仓库中的dispatch函数
            store = {
                ...store,
                // 进行dispatch的替换，不要直接修改store.dispatch
                dispatch
            }
            return store
        }
    }
}
```



3. createStore中对应的代码
```js
export default function createStore(reducer, mystate, z) {
    // 对reducer函数进行保存，仓库中有一个方法，可以替换reducer函数
    const reduc = reducer;
    // 保存数据(仓库)
    let state = null;
    
    // 处理中间键
    if(typeof mystate === "function") {
        z = mystate;
        mystate = null;
    }
    if(typeof z === "function") {
        state = z(createStore)(reducer, mystate)
        return state;   // 直接截止
    }

    // 创建仓库的代码省略
}
```




#### redux中间键—redux-thunk中间键

1. 作用
   该中间键创建的dispatch函数，不光可以传递普通的action对象，还能传递函数

2. 使用
   1) 需要通过npm下载，然后引用，下载方式`npm i redux-thunk -D`
   2) 该中间键会自动生成对应的dispatch函数，正常调用store.dispatch()，传入对应的数据即可
   3) 传递参数的类型
      1) 传递普通的action对象，不做任何操作，内部直接调用后面中间键的dispatch函数或者原始的dispatch函数进行数据的操作，即继续向下走。
      2) 传递函数，该函数接收一个参数，参数为store.dispatch函数(最终的dispatch函数)
         1) 当使用dispatch传递函数时，函数会在dispatch内部被调用
         2) 如果想要修改仓库数据，需要使用函数接收的dispatch函数，然后传入对应的action，会从头走一遍(因为传入的dispatch为最终的dispatch函数，不是初始的dispatch函数)
         3) 当再次走到该中间键定义的dispatch函数时，一看传入的是action对象，继续向下走
         4) 如果函数没有使用接收的dispatch，则状态不会进行变化(无法向后走，执行初始的修改状态的dispatch函数)


3. 代码示范
```js
import { createStore, applyMiddleware } from "redux";
import thunk from "redux-thunk";
// 使用redux-thunk中间键(创建对应的dispatch函数)
const store = createStore(reducer, applyMiddleware(thunk));  

function a(dispatch) {
    // 可以进行任意的处理
    console.log(123);

    // 合适的时间修改仓库状态
    let action = {
        type: "a",
        payload: ""
    }
    dispatch( action );  
}
// dispatch中传入函数
store.dispatch(a);
```



#### redux中间键—实现redux-thunk中间键—源码

1. 原理
   1) 创建的dispatch函数，可以传入函数
   2) 传入的函数，可以接收到参数，为最终的dispatch函数
   3) 如果传入对象，直接后面的dispatch函数


2. 代码示范
```js
export default function thunk({dispatch}) {
    return function (next) {
        return function (action) {
            if(typeof action === "object") {
                next(action);
            }
            if(typeof action === "function") {
                action(dispatch);
            }
        } 
    }
}
```



#### redux中间键—redux-promise中间键

1. 作用
   该中间键创建的dispatch函数，除了可以传递action对象，还可以传递Promise对象，还可以传递action对象但是payload属性是Promise对象

2. 使用
   1) 需要通过npm下载，然后引用，下载方式`npm i redux-promise -D`
   2) 该中间键会自动生成对应的dispatch函数，正常调用store.dispatch()，传入对应的数据即可
   3) 传递参数的类型
      1) 可以传递action对象，不做任何处理，直接运行后面的dispatch
      2) 可以传递Promise对象，当Promise对象的成功状态被激活时，自动调用then中的成功函数。
         1) 底层，后面的dispatch自动定义在then的成功回调函数中，所以只要触发成功状态，传入普通的action对象
         2) 就可以从头开始，解析到该中间键提供的dispatch函数后，一看是普通的action对象，自动向后运行
         3) 如果不触发成功状态，则后面的dispatch函数就不会执行，不会修改仓库中的状态
         4) 只能触发一次状态
      3) 可以传递action对象但是payload属性是Promise对象
         1) 当Promise对象的成功状态被激活时，自动调用then中的成功函数。
         2) 底层，后面的dispatch自动定义在then的成功回调函数中，所以只要触发成功状态，传入的值作为payload的属性值。
         3) **把当前的action进行传入，这种用法的promise，type是已经固定下来的，不能进行更改，并且成功状态的传入数据并不是新的action对象，只会替换payload属性**
         4) 就可以从头开始，解析到该中间键提供的dispatch函数后，一看是普通的action对象，自动向后运行
         5) 如果不触发成功状态，则后面的dispatch函数就不会执行，不会修改仓库中的状态
         6) 只能触发一次状态


3. 代码示范
```js
import { createStore, applyMiddleware } from "redux";
import promise from "redux-promise";


// 创建仓库的函数
const store = createStore(reducer, "ahdfoia", applyMiddleware(promise));

store.dispatch( new Promise( (rew, j) => {
        rew({
            type: "a"
        })
    } )
)
store.dispatch( {
    type: "d",
    payload: new Promise( (rew, j) => {
        rew("fadf")
    } )
} )
```


#### redux中间键—实现redux-promise中间键—源码
  
1. 原理
   1) 接收到普通的action对象，直接向后执行
   2) 接收到promise对象，绑定上then函数，then函数内部使用dispatch函数
   3) payload是Promise对象，成功状态调用传入的值为payload的新值，通过dispatch函数进行发送
   4) 对象Promise对象进行判断


2. 代码示范
```js
export default function promise({dispatch}) {
    return function (next) {
        return function (action) {
            if(typeof action === "object") {
                if(action instanceof Promise) {
                    action.then( (action) => {
                        dispatch(action)
                    } )
                }else if(action.payload instanceof Promise) {
                    action.payload.then( (payload) => {
                        dispatch({
                            ...action,
                            payload
                        })
                    } )
                }else {
                    next(action)
                }
            }
        }
    }
}
```



#### redux-saga中间键

- **saga使用**
1. 作用
   1) 纯净、不会污染action。
      1) 像thunk、promise中间键，dispatch在调用时，可以传入其他类型的变量，不用传入action对象。这样做，在一定程度上造成了action和dispatch的污染。
      2) saga中间键，在使用dispatch时，传入的还是普通的action对象，不能传入其他的类型的数据，相对来说，保持了action和dispatch的纯净。
      3) **saga中间键，并不影响dispatch传入的action，reducer会正常处理**
         简单来说saga就是在dispatch发送途中装了一个监听器，当监听到监听的指令发送了，不会影响当前的发送，然后saga去处理自己的事情。
   2) 强大
      1) saga在开始时，就会启动一个任务，相当于对dispatch传入的action进行监控。当传入的action满足一定的条件，通过调用next，再次触发生成器阻断后的代码，进行一定功能的处理
      2) 定义action条件、以及阻塞生成器的就是saga指令，saga中间键提供的很多的指令，不同的指令对应不同的功能，所以功能非常强大。
   3) 灵活
      saga中间键，可以定义多个生成器，每个生成器可以使用saga指令，完成对应的功能，这样就可以对生成器函数进行封装，另起js文件。使用起来比较灵活方便。


2. 使用
   1) 下载对应的插件 `npm i redux-saga -D`
   2) saga的引入，然后使用引入函数创建一个saga中间键
   3) 定义一个saga任务(就是一个普通的生成器函数，但是内部有些要求)
   4) 当仓库创建完成后，立即启动saga任务。通过`run`函数开启saga任务
   5) saga可以定义多个生成器函数，但是需要进行生成器的合并。
      生成器的合并，需要在saga任务对应的生成器函数中，使用`all`指令，进行合并。
   

3. saga任务(生成器)的执行规则
   1) 生成器内部代码的解析是受到next控制的，所以saga中间键可以完全的控制saga任务的执行
   2) 当使用run开启saga任务后，saga中间键会立即调用一次next，开始saga任务的解析
      1) 也就是saga任务是从一开始就已经启动了的
      2) 由于生成器中存在yield语法，所以每一次next的执行，
      3) 只会执行一段代码，执行完yield后面的表达式，就会终止执行
      4) 当再次调用next后，才会继续向下执行，直到下一个yield或者函数结尾
      5) 所以saga中间键可以通过next函数的执行时间，控制整个saga任务
   3) saga中间键，触发next函数的规则
      1) 在一开始，调用一次next函数，当遇到yield，解析完yield后面的代码，返回一个数据对象，就会终止执行。
      2) 此时saga中间键就会解析next返回的数据对象，判断内部的value属性的属性值
      3) 如果该属性值不是saga指令对象(自定义代码)，继续触发next向下执行，再次进行判断。
      4) 如果该属性是saga指令对象，saga中间键不会立刻调用next函数，于是生成器被阻断
      5) 会在合适的时候，saga中间键再次触发next，继续判断。合适的时候通过指令定义
      6) 如果saga固定没有写在yield的后面，是无法起到阻断效果的(判断是否继续触发next，依据的是next执行的返回值，只有yield处才能创建返回数据，写在别处是无法得到指令对象的)
   4) 如果没有遇到指令阻塞，会把yield后面的表达式的值，作为下一次next的参数传入到生成器中。阻断位置定义的变量就可以接收到，比如const a = yield * ，a会接收到next传入的参数，继续向下执行。起到数据传递的工作，没啥用。



4. 代码示范
```js
import createSagaMiddleware from "redux-saga";

// 创建一个saga中间键
const sagaMid = createSagaMiddleware();
// 创建saga任务(要写成生成器函数的形式，便于saga中间键控制内部代码的执行)
function* sagaTask() {
    // run触发该任务，立即解析，不会阻塞直至结尾
    console.log(1);
    // 2，作为下一次next的参数传入(中间键手动传入的，并不会自动传入)，a就会得到2。
    cosnt a = yield 2;
    console.log(a);
}

// 创建仓库的函数
var store = createStore(reducer, "ahdfoia", applyMiddleware(sagaMid, logger2));
// 启动一个创建好的saga任务(必须在仓库创建完成后启动saga任务)
sagaMid.run(sagaTask);
```


5. **重点**
   1) 当生成器中的函数，通过next执行完。saga就会失去作用，如果想要实现一直工作，可以继续while循环，如果想要借助while循环，yield必须起到阻塞作用，即必须存在saga指令
   2) 由于saga指令众多，**通常一个生成器函数中只使用一次指令**，并且位于while下。
      此时就需要进行生成器的合并。
      它们都是位于阻断的情况下，哪一个指令的触发条件满足，哪一个就会继续向下解析，处理完对应的功能，在while的作用下，又回到了阻塞状态。
   3) while虽然是一个死循环，只要内部的yield处于阻断的状态，该循环就可以跳出。即并不影响其它代码的执行。


#### saga指令

saga中间键，提供了非常多的指令，每个指令其实就是一个函数。这些指令只能在yield处才能起作用。

所有的saga指令，都在redux-saga/effects该库中进行定义抛出，所以要想使用saga指令，需要从该库中进行引入。

**saga指令，相当于给yield设置一个阻塞条件，只要达到阻塞的条件，该yield就会放行**
**可能多个生成器都处于阻塞状态，那个满足阻塞的条件，那个就放行**


#### saga指令—all指令

1. 作用
   1) 该指令可以合并多个生成器函数，作用于saga，
   

2. 使用
   1) 该指令，传值参数为一个数组，数组的每一项为一个生成器对象。
   2) 该指令会造成yield的阻塞，放行条件为只有传入的生成器函数全部解析完成，才会放行
   3) 如果传入的生成器中有一个死循环，则永远不会放行


3. 示范代码
```js
import createSagaMiddleware from "redux-saga";
import { all } from "redux-saga/effects"

// 创建一个saga中间键
const sagaMid = createSagaMiddleware();

function* a() {
    yield 1;
    console.log("a");
}
function* b() {
    yield 1;
    console.log("b");
}

// 创建saga任务(要写成生成器函数的形式，便于saga中间键控制内部代码的执行)
function* sagaTask() {
    // 传递的是生成器对象，不是生成器构建函数，所以需要执行
    yield all([a(), b()]);
    console.log(1);
}

// 创建仓库的函数
var store = createStore(reducer, "ahdfoia", applyMiddleware(sagaMid, logger2));

// 启动一个创建好的saga任务(必须在仓库创建完成后启动saga任务)
sagaMid.run(sagaTask);
```


#### saga指令—take指令
    
1. 作用
   1) 该指令，可以监听一个action对象中的type属性。


2. 使用
   1) 传入与需要监听action对象的type相同的数据，进行监听
   2) 放行条件，只要使用dispatch传入的action等于阻塞位置设置的属性，就会放行。可以放行多个
   3) 放行时间，仓库状态修改完成


3. 示范代码
```js
import createSagaMiddleware from "redux-saga";
import { all, take } from "redux-saga/effects"
// 创建一个saga中间键
const sagaMid = createSagaMiddleware();

const mystate = {};
function reducer(state = mystate, action) {
    switch (action.type) {
        case "a":
            return {a: 789}
        case "b":
            return {a: 123}
        default:
            return state
    }
}
// 创建仓库的函数
var store = createStore(reducer, "ahdfoia", applyMiddleware(sagaMid, logger2));
// 启动一个创建好的saga任务(必须在仓库创建完成后启动saga任务)
sagaMid.run(sagaTask);


// 生成器函数
function* a() {
    // 监听a
    yield take("a");
    console.log("a");
}
function* b() {
    while(true) {
        // 监听a
        yield take("a")
        console.log("b")
    }
}
function* c() {
    while(true) {
        // 监听b
        yield take("b")
        console.log("c")
    }
}

// 创建saga任务
function* sagaTask() {
    yield all([a(), b(), c()]);
    // 由于生成器存在死循环，所以该yield永远不会放行
    console.log(1);
}

store.dispatch( {type: "a"} )   // 会打印 a b
store.dispatch( { type: "b" } ) // 会打印c
store.dispatch( {type: "a"} )   // 会打印b
```



#### saga指令—takeEvery指令

1. 作用
   监听一个action对象

2. 使用
   1) 该指令不会造成yield的阻塞，所以不能使用while进行包裹
   2) 由于该指令不会造成阻塞，所以没有放行条件
   3) 该指令第一个参数传入监听的action的type值，第二个参数传入一个函数
      1) 当调用dispatch传入的action对象符合监听的action对象，就会执行该指令传入的函数。
      2) **该指令传入的函数必须是一个生成器创建函数**。
   4) 由于监听效果一直存在，虽然不会造成阻塞，看生成器代码执行完成，但是当前生成器永远不会运行结束，会影响到all指令的放行(永远不会放行)。
   5) 由于该指令不会造成阻塞，所以**一个生成器中可以使用多次该指令**，监听不同的action对象
   6) 如果调用的生成器函数中也存在saga指令阻塞，会照常阻塞
      但是并不影响监听函数的运行，即当下一次满足条件时，依旧会调用传入的生成器函数，此时还是照常阻塞。
      当阻塞条件满足，每个阻塞会正常放行，继续向后执行。
   7) 如果第一个参数传入`"*"`，则发送任意的action都会被监听到，执行传入的生成器函数


3. 代码示范
```js
import createSagaMiddleware from "redux-saga";
import { all, takeEvery, take } from "redux-saga/effects"
// 创建一个saga中间键
const sagaMid = createSagaMiddleware();

const mystate = {};
function reducer(state = mystate, action) {
    switch (action.type) {
        case "a":
            return {a: 789}
        case "b":
            return {a: 123}
        default:
            return state
    }
}
// 创建仓库的函数
var store = createStore(reducer, "ahdfoia", applyMiddleware(sagaMid, logger2));
// 启动一个创建好的saga任务(必须在仓库创建完成后启动saga任务)
sagaMid.run(sagaTask);


function* a() {
    // 可以多次使用，甚至监听相同的属性
    yield takeEvery("a", aa1)
    yield takeEvery("a", aa2)
    yield takeEvery("b", bb) 
}
function* aa1() {
    console.log("aa1");
    // 照常阻塞，但是不影响aa1的下次执行
    yield take("b");
    console.log("放行了");
}
function* aa2() {
    console.log("aa2");
}
function* bb() {
    console.log("bb");
}
// 创建saga任务
function* sagaTask() {
    yield all([a()]);
    console.log(1);
}


store.dispatch( {type: "a"} )
store.dispatch( {type: "a"} )
store.dispatch( { type: "b" } )  // 即会运行bb，也会放行两次aa1的阻塞
```


#### saga指令—delay指令

1. 作用
   1) 在生成器函数中，实现某段代码的延时执行。
   2) 虽然使用setTimeout也可以实现延时的效果，但是saga中是无法监听控制setTimeout中的代码的，3) 如果想要实现延时执行的代码中也有saga的阻塞与放行的效果，借助setTimeout是无法实现的。

2. 使用
   1) 该指令会造成阻塞，接收一个参数，就是延时的时间
   2) 放行条件，延时的时间一过，saga调用next()放行，继续向下执行，相当于实现了代码延时执行的效果。
   3) 由于delay指令是正常的阻塞与放行，所以下方的yield依旧会起作用，受saga的控制


3. 代码示范
```js
import createSagaMiddleware from "redux-saga";
import { all, delay, take } from "redux-saga/effects"
// 创建一个saga中间键
const sagaMid = createSagaMiddleware();

const mystate = {};
function reducer(state = mystate, action) {
    switch (action.type) {
        case "a":
            return {a: 789}
        case "b":
            return {a: 123}
        default:
            return state
    }
}
// 创建仓库的函数
var store = createStore(reducer, "ahdfoia", applyMiddleware(sagaMid, logger2));
// 启动一个创建好的saga任务(必须在仓库创建完成后启动saga任务)
sagaMid.run(sagaTask);


function* a() {
    yield take("a");
    // a放行后，在阻塞300ms，然后在执行下方的代码，相当于setTimeout
    yield delay(300);
    console.log("a");
    // 延时300ms后，解析到该代码，正常阻塞
    yield take("b");
    console.log("b");
}
// 创建saga任务
function* sagaTask() {
    yield all([a()]);
    console.log(1);
}

store.dispatch( {type: "a"} )
```


#### saga指令—put指令

1. 作用
   重新触发dispatch，传入action，修改仓库状态。
   比如: 某个dispatch传入的action，放行了saga中的某个阻塞。可能会进行一些副作用的处理，处理完成可能需要重新修改仓库状态，就需要借助该指令


2. 使用
   1) 该函数不会造成阻塞，相当于dispatch函数，传入一个action对象，重新修改状态
   2) 使用put发送action对象，saga照样可以监听到，该放行的放行。
   3) 在while中take和put指令联合使用，即使设置相同的type，也不会造成死循环。
      put发送的时候，take还没有阻塞，代码还没有执行到哪，当put发送完，代码解析到take，正常阻塞，由于此时put已经发送完成，所以阻塞不会放行，死循环形成不了。


3. 代码示范
```js
import createSagaMiddleware from "redux-saga";
import { all, put, take } from "redux-saga/effects"
// 创建一个saga中间键
const sagaMid = createSagaMiddleware();

const mystate = {};
function reducer(state = mystate, action) {
    switch (action.type) {
        case "a":
            return {a: 789}
        case "b":
            return {a: 123}
        default:
            return state
    }
}
// 创建仓库的函数
var store = createStore(reducer, "ahdfoia", applyMiddleware(sagaMid, logger2));
// 启动一个创建好的saga任务(必须在仓库创建完成后启动saga任务)
sagaMid.run(sagaTask);


function* a() {
    yield take("a");
    // put就相当于dispatch函数
    yield put({type: "b"});
    console.log("a");
}
// 创建saga任务
function* sagaTask() {
    yield all([a()]);
    console.log(1);
}

store.dispatch( {type: "a"} )
```


#### saga指令—call指令

1. 作用
   搞定生成器函数中的异步操作，但是只能监听promise对象。

2. 使用
   1) 可能会造成阻塞
   2) 传参的个数不定，第一个参数为**函数引用(必传)，可以只传递这一个参数**，第二个参数~最后一个参数为传入函数执行时传入的数据。
      1) 如果传入的是普通的函数，返回值作为next的参数传入，由于函数立即执行完成，所以并不会造成阻塞
      2) 如果传入的函数返回值是一个promise对象，会造成阻塞。只有promise触发成功或者失败状态，阻塞才会放行。
      3) 触发成功状态，传入的数据，会作为放行next执行时的参数传入。
      4) 触发失败状态，会在当前的yield处抛出错误，代码终止。
         如果使用try-catch进行监听，catch中接收的错误信息就是触发失败状态时的传参
   3) 如果想要给call，传入的函数绑定this。共有两种方式
      1) 一种为第一个参数变成数组格式，数组的第一项为函数执行时的this指向，第二项为函数引用
      2) 一种为第一个参数变为对象格式，对象的context属性设置函数执行时的this指向，fn设置函数的引用
   

3. 代码示范
```js
import createSagaMiddleware from "redux-saga";
import { call, take } from "redux-saga/effects";
// 创建一个saga中间键
const sagaMid = createSagaMiddleware();

const mystate = {};
function reducer(state = mystate, action) {
    switch (action.type) {
        case "a":
            return {a: 789}
        case "b":
            return {a: 123}
        default:
            return state
    }
}
// 创建仓库的函数
var store = createStore(reducer, "ahdfoia", applyMiddleware(sagaMid, logger2));
// 启动一个创建好的saga任务(必须在仓库创建完成后启动saga任务)
sagaMid.run(sagaTask);


// 定义一个函数，返回promise
function promise(a, b, c) {
    console.log(a, b, c, this);
    return new Promise( (dis, dsj) => {
        setTimeout(() => {
            // 触发成功状态
            dis("123")   
            // 触发失败状态
            // dsj("789")   
        }, 1000)
    } )
}
// 创建saga任务
function* sagaTask() {
    yield take("a");
    // 为了方式触发失败状态
    try {
        // 不写call，直接写函数调用，效果一样
        const a = yield call({
            context: "a",
            fn: promise
        }, 4, 5, 6)
        // const a = yield call(["a", promise], 4, 5, 6)
        // 通常只穿一个函数引用
        // const a = yield call(promise)
        console.log(a);   // 接收到的a为，成功状态的传参，"123"
        
        // 通常与put配合使用，获取到数据，保存到数据库中
    } catch (e) {
        console.log(e)    // 接收到的e为，失败状态的传参，"789"
    }
}

store.dispatch( {type: "a"} )
```


4. 扩展
   1) 如果yield 后面跟的就是一个promise对象，即next执行完，接收到的对象参数的value属性值为promise对象，会自动进行阻塞
   2) 只有promise触发成功状态，或者失败状态，才会放行。
   3) 和call或者apply指令，实现的功能相同，可以不用借助这两个指令也能实现功能
   4) 为了保持相同性，或者进行代码检测时更加容易，通常加上call或者apply



#### saga指令—apply指令

1. 作用
   和call的功能相同，管理promise对象，只有传递参数的不同。


2. 使用
   1) 使用方式，第一个参数为函数的this执行，第二个参数为函数引用，第三个参数为函数执行时传入的数据(格式为对象)
   2) 其它的使用方式相同，也有可能进行阻塞


3. 代码示范
```js
import createSagaMiddleware from "redux-saga";
import { apply, take } from "redux-saga/effects"
// 创建一个saga中间键
const sagaMid = createSagaMiddleware();

const mystate = {};
function reducer(state = mystate, action) {
    switch (action.type) {
        case "a":
            return {a: 789}
        case "b":
            return {a: 123}
        default:
            return state
    }
}
// 创建仓库的函数
var store = createStore(reducer, "ahdfoia", applyMiddleware(sagaMid, logger2));
// 启动一个创建好的saga任务(必须在仓库创建完成后启动saga任务)
sagaMid.run(sagaTask);


// 定义一个函数，返回promise对象
function promise(a, b, c) {
    console.log(a, b, c, this);
    return new Promise( (dis, dsj) => {
        setTimeout(() => {
            // 触发成功状态
            dis("123")   
            // 触发失败状态
            // dsj("789")   
        }, 1000)
    } )
}
// 创建saga任务
function* sagaTask() {
    yield take("a");
    // 为了方式触发失败状态
    try {
        const a = yield apply("a", promise, [4, 5, 6])
        // 通常只穿一个函数引用
        // const a = yield call(promise)
        console.log(a);   // 接收到的a为，成功状态的传参，"123"

        // 通常与put配合使用，获取到数据，保存到数据库中
    } catch (e) {
        console.log(e)    // 接收到的e为，失败状态的传参，"789"
    }
}

store.dispatch( {type: "a"} )
```


#### saga指令—select指令

1. 作用
   获取数据库

2. 使用
   1) 只有一次参数可以传入，格式为一个函数。函数有一个参数可以接收，为获取到的数据库。返回值作为next执行时的参数传入。通常用于仓库数据的筛选
   2) 不传递参数，next执行时的参数传入就是整个仓库中的数据

3. 代码示范
```js
// 创建saga任务
function* sagaTask() {
    yield take("a");
    // 获取仓库数据，此时已经是a规则，修改完的仓库数据
    const state = yield select()
    console.log(state);
}
```


#### saga指令—cps指令

1. 作用
   用于处理回调问题

2. 使用
   1) 传入的参数不固定，第一个为函数引用，后面的参数为函数引用执行时的传参
      1) 并且该指令会向函数引用中自动传入一个回调函数。回调函数saga已经写好，自动传入，不用引入
      2) 回调函数传入的位置，与传入的参数合并，放在最后一个，所以函数引用在最后要多定义一个参数用于接收回调函数。

   2) 当传入的函数中，调用回调函数时，回调函数可以传入两个参数，第一参数为错误信息，第二个参数为实际数据。
      1) 当错误信息为null时，yield放行，next传入的参数为回调函数的第二个参数(数据)
      2) 当错误信息存在时，yield的位置就会报错，代码终止。
         可以使用try-catch处理错误，catch接收到的错误信息，就是回调函数传入的第一个参数

   3) 会造成阻塞，放行条件为，传入函数中，调用回调函数。


3. 代码示范
```js
import createSagaMiddleware from "redux-saga";
import { cps, take } from "redux-saga/effects"

// 定义一个函数
function func(a, b, callBack) {
    console.log(a, b);
    setTimeout( () => {
        // 假设数据获取成功，调用回调，进行数据的处理
        callBack(null, "ahofd");
        // 数据获取出现问题
        // callBack("asjdfoasjpdf");
    }, 1000)
    return "adfas"
}

// 创建saga任务
function* sagaTask() {
    yield take("a");
    try {
        const a = yield cps(func, 1, 2)
        console.log(a);  // 接收到的参数为，回调函数的第二个参数，前提是第一个参数为null
    } catch (e) {
        console.log(e);  // 接收到的是回调函数的第一个参数(错误信息)，前提是第一个参数有值
    }
}

store.dispatch( {type: "a"} )
```



#### saga指令—fork指令

1. 功能
   在启动一条新的任务线，在开发中不常用，在saga的底层，该方法使用比较频繁

2. 使用
   1) 不会造成阻塞，传入一个新的生成器函数，然后执行该生成器函数
   2) 该指令的返回值，可以取消本次新开的任务线，需要cancel指令的配合
      1) 新开的任务线，正在阻塞。当取消后，相当于在yield后直接调用了return
      2) 这样当阻塞放行的时候，一执行return，则生成器终止，后面的代码不在运行，任务线结束
   3) takeEvery指令的底层，就是利用该指令完成的

3. 代码示范
```js
import createSagaMiddleware from "redux-saga";
import { take, fork, delay } from "redux-saga/effects";

// takeEvery的底层代码
function* func() {
    while(true) {
        yield take("a")
        // 监听到了a，其实是新开了一个任务线，处理对应的事情。
        // 如果不是新开一条任务线，造成阻塞，下一次a在触发，是无法监测的
        yield fork(function* () {
            yield delay(2000);
            console.log("a");
        } )
    }
}

// 创建saga任务
function* sagaTask() {
    yield fork(func);
    // 虽然func中存在阻塞，但是那是属于另一个任务线，并不影响当前任务线
    console.log(1);
}


store.dispatch( {type: "a"} )   
```


#### saga指令—cancel指令

1. 功能
   取消一条任务线，生成器执行完，就会自动取消。但是如果任务线被阻塞，可以通过该指令取消。
   只能取消阻塞状态的任务线，并不会生成器正在解析，忽然间进行了停止。

2. 使用方式
   1) 传值，取消指定的任务线，传的值必须是fork指令或者takeEvery指令返回的值
   2) 不传值，取消当前任务线
   3) 父任务线取消，并不会影响子任务线
   4) 如果想要取消多个任务，可以传递多个参数

3. 代码示范
```js
import createSagaMiddleware from "redux-saga";
import { take, fork, delay, cancel } from "redux-saga/effects"

function* func() {
    let a = null;
    while(true) {
        yield take("a");
        // 每次触发a，下面都将新开一个任务，然后进行等待
        // 如果在a触发后，取消上次新开的任务，则等待时间到达后只会打印一次a
        // 执行的最后一个任务，前面的两次任务都被取消了
        if(a) {
            yield cancel(a)
            // 如果不传值，会立马取消当前任务线，相当于该生成器函数执行完成，下面的fork将不在执行
            // yield cancel()
        }
        a = yield fork(function* () {
            yield delay(2000);
            console.log("a");
        } )
    }
}

// 创建saga任务
function* sagaTask() {
    yield fork(func);
}


store.dispatch( {type: "a"} )
store.dispatch( {type: "a"} )
store.dispatch( {type: "a"} )
```



#### saga指令—takeLatest指令

1. 作用
   1) 该指令会自动取消之前开启的任务线，和takeEvery指令的作用一样，只不过takeEvery指令不会取消之前的任务。
   2) 简单介绍takeEvery指令
      1) takeEvery指令，内部其实是新开了一条任务线监听某个属性。当监听到符合属性，会立即在开启一条任务线进行处理(传入的生成器函数)。
      2) 所以takeEvery指令返回的是监听属性的那条任务线，使用cancel取消任务线，取消的是监听任务的任务线，即下次无法在进行监听，但是内部新开的任务线是无法取消的。
      3) 比如，如果想要监听a，当action来临的时候，如果type符合，就进行某项处理。
         1) 如果action在一段时间内多次触发(瞬间请求了多次)，只需要处理最后一次即可，
         2) 此时就需要取消前面，监听到的属性新开的任务。
         3) 如果使用takeEvery指令和cancel指令是无法做到的(获取不到任务)，使用fork指令和cancel指令可以办到，可能写起来稍微麻烦点。
   3) 简单介绍takeLatest指令
      1) 该指令也是新开一条任务线，监听某个属性，当属性监听到的时候，也会立即开启一条任务线进行处理(传入的生成器函数)
      2) 当下次监听到属性时，会自动取消上一次开启的任务线，取消的不是监听任务线


2. 使用
   1) 使用方式和takeEvery指令一样，第一个参数传入监听的属性，第二个参数传入生成器函数


3. 代码示范
```js
import createSagaMiddleware from "redux-saga";
import { delay, takeLatest } from "redux-saga/effects"

function* func() {
    // 在takeLatest指令的作用下，a只会打印一次，不是两次。之前的任务会自动取消
    yield delay(2000);
    console.log("a");
}
// 创建saga任务
function* sagaTask() {
    yield takeLatest("a", func);
}


store.dispatch( {type: "a"} )
store.dispatch( {type: "a"} )
```


#### saga指令—cancelled指令

1. 作用
   判断当前任务线有没有被取消，可以处理一些任务线取消的后续操作。
   要想判断任务取消，只能在阻塞的yield后面进行判断，前面写任务肯定没有取消，由于任务线取消，yield后面的代码将不会再解析，所以就需要try-finally的配合。finally里面的代码是无论如何都会执行的。


2. 使用
   直接使用，不需要传参，如果返回true，说明当前任务已经被取消


3. 代码示范
```js
import createSagaMiddleware from "redux-saga";
import { cancelled, delay, takeLatest } from "redux-saga/effects";

function* func() {
    // 在takeLatest指令的作用下，该任务会自动取消
    try {
        yield delay(2000);
        console.log("a");
    } finally {
        // 无论上方的yield阻塞是取消，还是正常工作，下方的代码都会执行
        // 所以可以用来判断，当前任务有没有被取消
        if( yield cancelled() ) {
            console.log("任务取消了");
        }
    }
}
// 创建saga任务
function* sagaTask() {
    yield takeLatest("a", func);
}


store.dispatch( {type: "a"} )
store.dispatch( {type: "a"} )
```


#### saga指令—race指令

1. 功能
   1) 该指令和all指令的功能相同，传入多个生成器函数，开启多个任务，并且立即进入内部解析。
   2) 唯一不同之处在于，all指令，是当传入的所有生成器都解析完毕才会放行。
   3) 该指令，只要有一个生成器函数解析完成，就会立刻放行，并且其他生成器会立刻终止(任务销毁)
   4) 相当于竞赛指令，看谁跑的快


2. 使用
   1) 会造成阻塞，放行条件，只要有一个生成器函数解析完成，就会立刻放行
   2) 传参有两种形式，一种是传入数组格式，一种是传入对象格式的数据
   3) 该指令放行时，即next调用时，传入的是第一个执行完成的生成器函数的**return的返回值**，并且传值类型，与race指令的传值类型有关



3. 代码示范
```js
import createSagaMiddleware from "redux-saga";
import { cancelled, delay, race} from "redux-saga/effects"


function* a() {
    // 该任务被销毁，b先执行完
    try {
        yield delay(2000);
        console.log("a");
    } finally {
        if( yield cancelled() ) {
            console.log("a任务取消了");
        }
    }
}
function* b() {
    try {
        yield delay(1000);
        console.log("b");
        return "fadsf"
    } finally {
        if( yield cancelled() ) {
            console.log("b任务取消了");
        }
    }
}

function* c() {
    // 该方法先触发成功状态，阻塞放行
    const c = yield new Promise( (r, j) => {
        r("abc")
    }) 
    // c得到的是abc
    return c;
}
function* d() {
    const d = yield new Promise( (r, j) => {
        setTimeout( () => {
            r("ddd")
        }, 100)
    } ) 
    return d;
}


// 创建saga任务
function* sagaTask() {
    const ab = yield race([a(), b()])
    const as = yield race({
        c: c(),
        d: d()
    })
    // 打印的是{c: "abc"}   [undefined, "fadsf"]
    // 对象格式，next传递对象，数组格式，next传入数组
    console.log(as, ab)
}
```



#### react-actions插件

1. 功能
   该插件，简化了action对象的创建，reducer函数的书写。
   该插件提供了六种方法。

#### react_actions插件—createAction

1. 作用
   调用该函数，返回action对象的创建函数。通过调用返回的函数，可以创建出对应的action对象。


2. 使用方式
   1) 传递一个参数，调用该方法返回的函数，创建一个action对象，传入的参数会作为type的属性值
   2) 传递两个参数，第二个参数是函数格式，传递一个数据，返回一个数据。
      调用该方法返回的函数。如果传参，会运行传入的函数(第二个参数)。
      返回的数据会作为action对象的payload属性的属性值。
   3) 传递三个参数，第三个参数会赋给创建的action对象的第三个属性(meta)，作为元数据(相当于请求头)。
      传参格式为一个函数，把要设置的对应数据通过返回值返回。
      **注意**: 不能向payload一样，实现动态传入，通过调用返回函数进行传参，这两个函数接收的都是传入的第一个产生，不太好实现分开处理，所以该函数返回一个固定的数据。


3. 代码示范
```js
import { createAction } from "redux-actions";

const aAction1 = createAction("a");
// 打印{ type: "a" }
console.log( aAction1() );

const aAction2 = createAction("b", b => b);
// 打印{ type: "b", payload: 2}
console.log( aAction2(2) );

// meta属性要返回具体的数据，必须要写成函数格式
const aAction3 = createAction("c", c => c, () => ({c: 123}));
// 打印{ type: "c", payload: 2, meta: {c: 123}}
console.log( aAction3(2) );
```


#### react_actions插件—createActions

1. 作用
   通过该函数可以创建多个action对象的创建函数

2. 使用
   1) 该方法传入一个对象，对象的属性名，作为action对象的type属性，属性值作为payload属性，格式也是函数。如果没有payload属性，直接写null。
   2) 该方法返回的也是一个对象，对象的属性值，为传入对象的属性值转换成小驼峰式的写法(单词分界线为_符号)。每一个对象属性对应一个action的创建函数


3. 代码示范
```js
import { createActions } from "redux-actions";

const action = createActions({
    "A": null,
    "A_B": null,
    "A_C": a => a
})
// 属性值变为a, aB, aC
console.log(action.a());  // 打印{type: "A"}
console.log(action.aB()); // 打印{type: "A-B"}
console.log(action.aC(2)); // 打印{type: "A-B", payload: 2}
```



#### react_actions插件—handleAction

1. 作用
   创建一个属性对应的reducer处理函数。

2. 使用
   1) 该方法接收三个参数
      1) 监听的属性，两种赋值方式
         1) 直接赋值，对应的type值
         2) 附上创建action对象的函数引用
            1) 注意: 此处生成的创建action对象的函数必须是借助当前组件的方法创建出来的
            2) 原因: 该组件创建生成action对象的函数的时候，会自动在函数上添加一个方法(toString)。通过该方法，可以获取到生成action对象的type值。
            3) 原理: 此处附上函数引用，在内部会自动调用该函数的toString方法，取出对应的type值。
      2) 监听到属性的处理函数，接收两个参数(state, action)
      3) 仓库的默认值
   2) 返回一个方法，即真正的reducer函数


3. 代码示范
```js
import { handleAction, createAction } from "redux-actions";
const a = createAction("A");

// "A"也可以替换成a，会自动调用a.toString()，取出对应的type值
const reducer = handleAction("A", (state, action) => {
    return {
        ...state,
        a: 456
    }
}, {a: 123})
/**
 * 相当于下面的写法
 * function reducer(state = {a: 123}, action) {
 *     switch(action.type) {
 *         case "A":
 *             return { ...state,  a: 456  }
 *         default:
 *             return state
 *     }
 * }
 */
```



#### react_actions插件—handleActions

1. 作用
   创建多个属性对应的reducer处理函数。

2. 使用
   1) 该方法接收两个参数
      1) 第一个参数: 对象格式
         1) 属性名，监听的属性，两种赋值方式
            1) 直接书写对应的action对象的type值
            2) 填写上对应的创建action对象的函数(该组件生成的)引用，会自动调用toString方法取出对应的type属性值。
               1) 注意: 由于是对象的属性值，所以要填写函数引用，需要用[]进行包裹，如果不进行包裹，就是一个正常的属性。
         2) 属性值，监听到的处理方法，接收两个参数(state, action)
      2) 仓库的默认值
   2) 返回一个方法，即真正的reducer函数


3. 代码示范
```js
import { handleActions, createAction, createActions } from "redux-actions";

const a = createAction("A");
const action = createActions({
    "B": null,
    "C": c => c
})


const reducer = handleActions({
    [a]: (state, action) => ({...state, a: 789}),
    B: (state, action) => ({...state, b: 456}),
    [action.c]: (state, action) => ({...state, c: action.payload})
}, {a: 123})
/**
 * 相当于下面的写法
 * function reducer(state = {a: 123}, action) {
 *     switch(action.type) {
 *         case "A":
 *             return { ...state,  a: 789  }
 *         case "B":
 *             return { ...state,  b: 456  }
 *         case "C":
 *             return { ...state,  c: action.payload  }
 *         default:
 *             return state
 *     }
 * }
 */
```


#### react_actions插件—combineActions


1. 作用
   简化handleActions的书写，多个监听属性共用同一个处理函数。

2. 使用
   1) 传参个数不定，每一个参数对应一个action对象的type属性
   2) 该方法返回一个对象，对象中有一个toString方法。

3. 代码示范
```js
import { createStore } from "redux";
import { handleActions, createAction, combineActions } from "redux-actions";

const a = createAction("A");

// 多个属性("D", "E")共用一个action处理函数
const ss = combineActions("D", "E");
// 可以传递创建action对象的函数，会自动调用toString函数，获取到实际的type属性值
// const ss = combineActions(d, e);

const reducer = handleActions({
    [a]: (state, action) => ({...state, a: 789}),
    B: (state, action) => ({...state, b: 456}),
    [action.c]: (state, action) => ({...state, c: action.payload}),
    // 监听到"D"或者"E"，触发的都是该函数
    [ss]: (state, action) => ({...state, d: action.payload})
    /**
     * 相当于下列写法，由于写法相同，所以进行了提取。
     * D: (state, action) => ({...state, d: action.payload}),
     * E: (state, action) => ({...state, d: action.payload})
     */
}, {a: 123})
const store = createStore(reducer);


store.dispatch(a())
store.dispatch({type: "D", payload: "DDD"})
```



#### react-redux插件

1. 作用
   该插件的功能是，实现React与redux进行连接。
   不使用该库也能实现连接，但是代码繁琐。

2. 使用
   1) 该库提供了一个组件(Provider)和一个高级组件(connect)。它们的作用是:
      1) 组件: 创建执行期上下文，通过行间传参的方式，传入具体的仓库对象store，保存到上下文中
      2) 高阶组件。在外界定义好获取的仓库数据，和修改仓库状态的dispatch发送。然后通过行间传参的方式，传入被包装的组件中进行使用。并且加上了仓库状态改变，组件重新渲染的功能。


3. 代码示范
```js
import {Provider, connect} from "react-redux";
import store from "./store";

// 获取仓库中的那些数据
function mapStateToProps(state) {
    // 会自动传入整个仓库状态
    return {
        // 该对象会进行解构，然后把每一个属性传入被包装的组件
        a: state.a,
        b: state.b
    }
}

// 修改仓库状态
function mapDispatchToProps(dispatch) {
    // 会自动传入仓库对应的dispatch函数
    return {
        // 该对象会进行解构，然后把每一个属性传入被包装的组件
        toA: () => {
            dispatch({
                type: "A"
            })
        },
        toB: () => {
            dispatch({
                type: "B"
            })
        },
    }
}

// 组件包装
const A = connect(mapStateToProps, mapDispatchToProps)(A);


function App() {
    // 创建执行期上下文保存仓库
    return <Provider store={ store }>
        {/* 使用被包装的组件 */}
        <A />
    </Provider>
}
function A(props) {
    return <>
        <div onClick={ props.toA }> { props.a } </div>
    </>
}
```


4. 注意点
   1) mapDispatchToProps还有另外两种处理方式
      1) 格式是一个对象，对象中是一个一个的方法。和使用bindActionCreators进行创建action对象的函数，进行功能增强。
      2) 或者mapDispatchToProps写成对象格式，每个属性值就是action的创建函数。 connect组件会自动添加dispatch发送，和bindActionCreators函数的功能一样。




#### connected-react-router插件

1. 作用
   建立路由与redux之间的关系
   redux中存放路由中的数据，其实存放的是`history对象的action属性，以及location对象`。其它的数据没有存放的必要。

2. 使用
   该组件抛出了很多方法，重用的方法如下(该插件要想起作用，前三个是必要的):
   1) `connectRouter`方法，用于管理仓库中的路由数据的状态。
      1) 调用该方法，传入history对象(初始值)。会返回路由数据在仓库中的管理函数reducer。
      2) 由于返回的是一个单独专门处理路由的reducer函数，所以需要借助combineReducers进行合并。
      3) 由于该方法需要传递一个history对象，所以需要借助history插件进行生成，不能通过路由获取。
   2) `routerMiddleware`方法，调用该方法返回一个中间键。
      1) 该方法在使用时，需要传入一个history对象，并且与connectRouter中传入的是同一个。
      2) 返回的中间键的作用为: 
         1) 监听一些特殊的action。实现对路由的操作
         2) 比如type为push，表示路径需要跳转，reducer中是不能进行跳转的。所以需要使用中间键进行拦截，拦截成功，则路由进行跳转。
         3) 由于该插件管理仓库中路由数据的reducer是自动生成的，所以内部使用了那些type是不知道的，所以不能通过手写的方式监听。

   3) `ConnectedRouter`组件，该组件将代替BrowterRouter或者HashRouter组件，创建路由上下文。
      1) 该组件行间传入`history="history对象"`，即connectRouter中传入的history对象(共用的)。
      2) 替换的原因:  
         1) 使用react-router-dom中提供的BrowserRouter组件，该组件会自动创建一个history对象，当使用NavLink或者Link组件进行路由的跳转，当前组件的history对象中的location对象会发生变化，进行更新。
         2) 但是由于组件创建的history对象是新的，与仓库中的history对象没有关系，所以仓库中的数据是无法发生变化的。
         3) connectedRouter组件，创建的执行期上下文，使用的history对象是行间传入的。如果传递的与connectRouter中传递的是同一个history对象，则路径再次发生变化时，history的location更新，由于仓库中使用的也是该location，所以仓库中的数据也会进行更新
      3) **该组件必须位于react-redux插件提供的Provider组件下面，否则不起作用**
    
   4) `push`方法，作用产生一个跳转路由的action对象(无法通过手写，只能使用插件提供的)。
      1) 当使用dispatch发送该方法产生的action对象时，中间键就可以检测到，进行路由的操作。
      2) 通常使用该方法，加上dispatch发送的方式，进行js跳转路由。
         1) 使用history中的push也能使用路由的跳转，但是不太好。
         2) 既然仓库中有路由的数据，与路由存在对应关系。所以在js进行跳转路由的操作，只需要修改仓库中的状态(发送action对象，表示要跳转路由)，仓库中的状态变化，实际路由也进行变化(这样才能实现仓库与路由的对应关系)。
      3) 如果使用了ConnectedRouter组件，则该组件之外的跳转失效。


3. 代码示范
```js
import React from "react";
import { Link, Route, Switch} from "react-router-dom";
import { createStore, applyMiddleware, combineReducers } from "redux";
import { Provider } from "react-redux"
import { createBrowserHistory } from "history";
import { connectRouter, routerMiddleware, ConnectedRouter, push } from "connected-react-router";

// 创建history对象
const history = createBrowserHistory();
// 创建路由的reducer方法
const routerReducer = connectRouter(history);
// 创建路由的中间键函数
const routerMiddlewareFun = routerMiddleware(history);


// 定义两个reducer方法
function reducerA(state={a: "A"}, action) {
    return state
}
function reducerB(state={b: "B"}, action) {
    return state
}
// 进行reducer的合并
const reducer = combineReducers({
    reducerA,
    reducerB,
    router: routerReducer
})
// 创建仓库
const store = createStore(reducer, applyMiddleware(routerMiddlewareFun));
console.log(store.getState());
store.subscribe( () => {
    console.log(store.getState());
} )


// 路由相关的react代码
export default function App () {
    // 此处不进行跳转，仓库状态也没有发生变化
    store.dispatch( push("/c") )
    return (
        <Provider store={store}>
            {/* 共用一个history对象 */}
            <ConnectedRouter history={history}>
                <div>
                    <Link to="/">首页</Link>
                    <Link to="/a">菜单</Link>
                    <div onClick={ () => {
                        // 进行动态跳转
                        store.dispatch( push("/a") )
                    }}>fasdfa</div>
                </div>
                <div>
                    <Switch>
                        <Route path="/" exact component={A} />
                        <Route path="/a" component={B} />
                    </Switch>
                </div>
            </ConnectedRouter>
        </Provider>
    )
}
function A() {
    return <div>123</div>
}
function B() {
    return <div>456</div>
}
```


      

