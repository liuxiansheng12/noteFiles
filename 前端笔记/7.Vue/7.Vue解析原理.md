<script src='/笔记/see/index.js'></script>
[toc]

#### vue执行流程

1. 查看传入的参数有没有el
   1) 如果没有el，查看是否使用了wn.$mount
   2) 如果也没有，则vue停止处理直接退出
   3) 如果有则进行挂载

2. 挂载完成后就要获取到对应的模板
   1) 首先查看传参中是否有template属性，如果有则把模板取出
   2) 如果没有定义template属性，则通过$el.outerHTML取出实际的模板

3. 获取模板后，就要形成虚拟dom，构建虚拟dom树
   1) 首先查看传参中是否有render属性，如果有则使用自定义的render方法构建虚拟dom
   2) 根据模板构建虚拟dom树

4. 根据虚拟的dom，形成真实的dom。然后进行替换，浏览器正常渲染。





#### template属性
1. 作用
   1) 创建vue的分析模板
   2) vue的核心就是分析模板
   3) 如果没有该属性，则使用默认的模板，即通过el绑定的节点，调用`outerHTML`方法获取默认模板

2. 使用方式
   1) 属性值是一个字符串，字符串就是当前组件分析的vue模板
   2) 如果模板中使用了其它的组件，需要借助`components`属性，进行声明
   3) `template`中使用的组件，就是一个字符串
      1) vue需要拿到该组件的配置对象，才能分析对应的组件
      2) 对应组件的配置对象，就是通过`template`中的组件字符串，从`components`对象中进行获取
      3) 所以需要在`components`对象中，声明对应的组件配置对象，以便查询使用




#### render属性
1. 作用
   1) 创建vue的虚拟dom树，根据该虚拟dom树，创建真实的dom树
   2) 如果没有该属性，使用vue模板创建对应的虚拟dom树

2. 使用方式
   1) 该属性对应的属性值，是一个函数
   2) 函数接收一个参数，接收的参数也是一个函数
      1) 利用接收的函数，可以创建出一个vue的虚拟dom
      2) render函数，返回接收函数所创建的虚拟dom(返回的是根节点)
   3) 接收函数，在使用时
      1) 传入一个参数
         1) **传入的就是vue的配置参数对象，即将要创建的节点的配置参数对象**
         2) 由于直接传入的是组件配置对象
            1) 可以直接获取到该组件配置对象，进行分析
            2) 不需要在`components`对象中进行声明
      2) 传入三个参数
         1) 第一个参数: 当前的节点名(标签名)，格式为字符串
         2) 第二个参数: 当前节点的行间属性，格式为对象
            1) `class属性`: 设置该节点的class名
               1) 有三种赋值方式，与vue模板中class的三种赋值方式一样
               2) 分别为字符串、数组、对象
            2) `style属性`: 设置该节点的行间样式，有三种赋值方式
               1) 有三种赋值方式，与vue模板中style的三种赋值方式一样
               2) 分别为字符串、数组、对象
         3) 第三个参数: 当前节点的子节点
            1) 如果是多个子节点，需要放在数组中传入
            2) 如果是文本节点，直接写文本信息
            3) **如果是元素(标签)节点，可以再次使用接收的函数进行创建**
               1) 该函数就是创建虚拟dom的函数


3. 该函数在执行时，内部的`this`指向当前的组件环境对象，可以正常使用数据


4. render函数传入的第三个参数，为虚拟节点对象或者虚拟节点对象组成的数组
   1) 通过接受的函数，也是创建虚拟节点对象，所以第三个参数传入的是虚拟节点对象
   2) 可以与插槽(`this.$slots.?`)联合使用
   3) 通过`this.$slots.?`获取到的就是对应的插槽虚拟节点对象，所以可以直接使用






