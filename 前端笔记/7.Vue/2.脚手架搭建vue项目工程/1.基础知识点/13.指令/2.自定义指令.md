

1. 作用
   1) 使用简单的指令，实现复杂的功能，类似黑科技

2. 自定义指令的定义
   1) 全局
      1) 借助Vue的静态方法`directive`进行创建，传入两个参数
      2) 第一个参数传递`自定义指令的名称`，第二个参数传入`指令的处理方式`
      3) 第二个参数有两种赋值方式
         1) `传入一个对象`，对象中有三个属性，属性值都是函数，对应三个阶段的处理函数
            1) `bind`: 使用该指令的dom创建后，但是还没有插入页面时，触发该函数
               1) 只执行一次
               2) 由于对应dom还没有插入，所以实现不了input初始时自动聚焦
                  1) 聚焦的方式: `dom.focus()`
            2) `inserted`: 使用该指令的dom，插入页面后，触发该函数
               1) 只执行一次
               2) 由于对应的dom已经插入页面中，所以可以实现input的自动聚焦
            2) `update`:  当使用该指令的dom的innerHTML进行重新渲染时，触发该函数
               1) 只要重新渲染，该函数就会执行
               2）如果标签进行了重新构建，比如v-if或者key值不同，与之前的就没有关系了
                  1) 从新执行`bind和inserted`
         2) `传入一个函数`，相当于传入对象中的bind和update的合成体
            1) 创建没插入时执行一次
            2) innerHTML重新渲染时执行一次

   2) 局部
      1) 利用Vue使用时的传参对象中的`directives属性`，属性值为一个对象
      2) 对象中的每一个属性，就是一个自定义指令，`属性名为指令名，属性值为指令的处理方式`
         1) 指令属性值，也有两种赋值方式，与全局一样。一种为函数，一种为对象格式。


3. 自定义指令函数接收的参数分析
   1) 指令处理函数，一共接收三个参数。
      1) 哪怕是对象格式中的三个参数，在执行时也接收三个参数。
   2) `el`(第一个参数): 传入使用该指令的dom
   3) `bindings`(第二个参数): 传入该指令的一些基础信息，格式为对象，内部常用的有四个属性
      1) `arg`: 存放的是指令，`:后面，=前面`的一段字符串标记
      2) `value`: 存放的是指令，`=后面`在vue中的实际数据(数据赋值)
      3) `expression`: 存放的是指令，`=后面`的字符串(数据名称)
      4) `modifiers`: 存放的是修饰符的相关信息，格式为对象
         1) 修饰符的名称作为属性名，属性值为true
         2) 表示该修饰符已经启用，具体的功能在指令函数中进行判断创建
         3) 比如: {inn: true}，判断inn为true，执行相应的代码
   4) `vnode`(第三个参数): 使用该指令的虚拟节点信息，内部常用的属性只有一个。
      1) `context`: 指向的就是当前的vue环境


4. 示范代码
```js
Vue.directive("abc", {
    bind(el, bindings, vnode) {
        // 无法进行聚焦，没有效果
        el.focus();  
    },
    update(el, bindings, vnode) {
    },
    inserted(el, bindings, vnode) {
        // 可以进行聚焦
        el.focus();  
    }
})
```

5. 使用时，通过`v-自定义指令名`进行使用。


6. 注意
   1) 如果指令中，涉及到了数据变化，从而引发重新渲染，或者绑定一些事件
      1) 要使用对象的赋值方式，然后在bind中进行实现
      2) 如果使用函数的赋值方式，或者在对象模式中的update中进行实现
         1) 会操作死循环，或者事件重复定义


