<script src='/笔记/see/index.js'></script>
[toc]


#### vue的工作流程（初始渲染）
- 首先，创建出一个实例（一个对象）
  - new Vue();
- 然后，把属性、方法，注入到实例中（注入）
- 在然后，创建出虚拟dom树（虚拟dom，是一个描述真实dom的对象）
  - 虚拟dom树的创建：利用的是 render 这个函数，每一个虚拟dom，都是利用render函数创建出来的
  - **render这个函数，可以自定义，但是通常都是根据模版自动产生**
    - 因为通过自定义render，构建虚拟dom树结构，过于麻烦
    - 每个节点都要写一个render函数，不如`<div></div>` 这样写来的方便
  - 通常情况下，都是利用模版，自动产生对应的render函数，然后创建出对应的虚拟dom
    - 比如：解析到`<div></div>`，就会创建出一个 render 的调用，然后创建出一个div虚拟dom
- 最后，根据虚拟dom树，创建出对应的真实dom，然后渲染出来
  -这一步是非常消耗性能的，所以vue在重新渲染的时候，做了优化


#### vue的工作流程（重新渲染）
- 首先，发生变化的地方，会重新构建一个虚拟dom树
- 然后，与旧的虚拟dom树进行比较
- 最后，只针对发生变化的dom，进行真实dom的操作（即：不是所有的dom都重新构建一遍，这很浪费效率）


#### Vue实例的创建与挂载
- 创建，通过 new Vue()
- 挂载，有两种
  - 一种是通过属性 el
  - 一种是通过 $mount() 这个方法
    - 两个共存，以$mount()为准
  - 比如
    ```js
    const App = new Vue({
      el: '#App'
    })

    App.$mount('#App');
    ```
- 以上是原生的Vue使用方式： `cdn` 引入
- 如果使用的是vue脚手架，则创建和挂载如下
  ```js
  import {createApp} from 'vue'
  // 引入组件对象
  import App from './App.vue'

  createApp(App).mount('#App');
  ```

#### render函数
- 作用，创建虚拟dom，形成虚拟dom树
- 在src中引入和脚手架中使用略有不同
- 在src中引入
  - render函数，接受的参数是一个函数（构建虚拟节点的函数）
  - 返回值必须是构建的虚拟节点（通过接收的参数构建），返回其他的不好使（比如返回JSX结构，就无效）
  - render和template共存，template会失效，以render为准
  - 比如
    ```js
    new Vue({
        el: '#app',
        template: `<div>123456</div>`,
        // render和template共存，template会失效，以render为准
        render(h) {
            return h('div', {class: 'd'}, [
                h('span', {}, '子节点')
            ])
        }
    });
    ```
  - 虚拟dom创建函数，还可以传递一个组件对象
  - 比如
    ```js
    const App = {
      template: `<div>123</div>`
    }
    new Vue({
        el: '#app',
        render(h) {
          // 可以直接传入一个组件对象
          return h(App)
        }
    });
    ```
- 脚手架使用render
  - 不能和模版共存（不是template属性，脚手架不能使用template），否则会被替换掉
    - 脚手架在打包的时候，会把模版解析成一个render函数，然后自定义的render就会被替换掉（可以打印一下引入的组件，发现就是一个普通的对象，对象中有一个render方法）
    - 比如
      ```js
      // Vue组件的模版，如果模版存在，则自定义的render就会被替换掉
      <template>
        <div>123</div>
      </template>

      <script>
        export default {
          name: 'App',
          data: function() {
            return {
              ds: 'any'
            };
          },
          // 发现无效果
          render(h) {
            console.log(h);
            return <div>456</div>
          }
        }
      </script>
      ```
- 接收的参数不在是虚拟dom的构造函数，而是当前组件的实例对象（内部有状态data，可以获取状态）
- 返回值是JSX结构（内部可以使用data定义的状态）
  - 由于没有虚拟dom的构造方法，所以无法返回虚拟dom
  - 比如
    ```js
    <script>
      export default {
        name: 'App',
        data: function() {
          return {
            ds: 'any'
          };
        },
        // 定义一些方法
        methods: {
          call: () => {
            console.log('自定义方法');
          }
        },
        render(h) {
          // 由于接收的参数是当前组件的实例对象，所以可以使用定义的方法和状态
          console.log(h);
          h.call();
          return <div>{h.ds}</div>
        }
      }
    </script>
    ```
  


#### 组件
- 作用：降低项目的复杂度
- 本质：就是一个普通的对象
- 比如：
  ```js
  const obj = {
    // 定义组件状态，需要注意的是组件状态是一个函数，返回一个对象
    //    而不是直接赋值一个对象
    data: () => {
        return {
            ds: 'dssdd'
        }
    },
    template: `<div>123</div>`
  }
  ```

- 组件分为全局组件和局部组件
  - 全局组件
    - 利用Vue上的component方法
    - 作用，一次定义，全局使用
    - 比如
      ```js
      const App = {
        template: `<div>123456</div>`
      }
      // 创建一个全局组件
      Vue.component("App", App);
      new Vue({
          el: '#app',
          template: `<App />`,
      });
      ```
  - 局部组件
    - 利用属性components
    - 作用，只能在引入组件的组件中使用，其他地方是无法使用的
    - 比如
      ```js
      const Vue = window.Vue;
      const App = {
        template: `<div>123456</div>`
      }
      new Vue({
          el: '#app',
          // 局部组件只能内部使用
          template: `<App />`,
          // 引入一个局部组件
          components: {
              App
          }
      });
      ```

- 需要注意的是，脚手架中没有模版解析器，所以template不能使用，可以使用render（使用方法render中有介绍）
  - 组件是一个普通的对象，如果直接写，略有复杂，所以脚手架就搞出了一个vue的类型文件，用来编写组件代码
  - 在打包的时候，就会打包成一个对象
  - 既然，打包的时候，是把vue文件打包成一个对象，则这个对象我们可以完全手写出来（简单的原理）
  - 比如
  ```js
  import { createApp } from 'vue';
  // 引入的组件
  import App from './App.vue';
  console.log(App);  // 发现就是一个普通的对象，可以手动写一个对象也是可以用的
  // 手写的组件对象，可以可以用的
  const Apps = {
      name: 'App',
      data: () => {
          return {
              ds: 'dssdd'
          }
      },
      render(d) {
          console.log(d);
          return <div>
              <span>{d.ds}</span>
          </div>
      }
  }
  // 正常使用
  createApp(Apps).mount('#app')
  ```


#### 解决组件间类样式冲突问题(style)
- 比如当前组件设置样式，选择的是 .demo。但是其他组件中也可能有.demo，这样就有可能对其他组件的demo造成css样式冲突
- 解决办法
  ```js
  <template>
    <div class="demo">123</div>
  </template>

  <script>
  export default {
  }
  </script>


  <style scoped>
    /* 加一个scoped，就行了 */

    .demo {
      color: red;
    }
  </style>
  ```
- 加上了 scoped，在打包的时候，该组件的每个元素都会加上一个组件唯一的属性
  - 组件中一样，组件间不同
- 选择器也会自定的加上对应的选择器（可以在浏览器上查看源代码）
  - 比如
    ```js
    <style>
      // ['data-v-3234q23'] 就是自动生成的组件唯一标示
      //    这样.demo就只能选中当前组件的demo了，与其他组件就无关了
      //    完美的解决了类样式冲突问题
      .demo['data-v-3234q23'] {
        color: red;
      }
    </style>
    ```


#### 组件之间的传参（行间属性传递）
- 父组件可以通过行间属性，向子组件传递一些数据
  - 子组件通过props属性，获取行间传入的数据
    - props有两种使用方式，一种是数组，一种是对象（可以用来数据验证）
  - 比如
    ```js
    const App = {
      // 获取父组件传递的行间属性（获取什么，就指定什么）
      props: ['a', 'b'],
      template: `<div>{{a}} {{b}}</div>`
    }
    new Vue({
      el: '#app',
      // 父组件向子组件传递参数
      template: `<App a="1" b="2" />`,
      components: {
          App
      }
    });
    ```
- 传递非字符串类型的数据或者状态、属性
  - 需要借助 v-bind: 指令，简写 :
  - 比如
    ```js
    const App = {
      props: ['a', 'b'],
      template: `<div>{{a}}</div>`
    }
    new Vue({
      el: '#app',
      data() {
          return {
              ds: 3
          }
      },
      // 只要加了: 则该属性后面的 "" 中写的就是表达式了，如果没有:，则写的就是一个字符串
      //    所以 :b="1"，传入的就是数字 1，而不是字符串 1
      template: `<App :a="ds" :b="1" />`,
      components: {
          App
      }
    });
    ```

- 扩展
  - 如果行间使用了某个属性进行传参，但是该属性没有在props中引入，则该属性就会在行间渲染出来
    - 比如父组件共传递了a、b、c三个属性参数，但是子组件就用了a、b两个属性
    - 则 c 就会在元素的行间渲染出来
    - 这样查看元素的时候就会感觉很奇怪，虽然没有什么影响
    - 比如：
      ```js
      const App = {
        // 传递了三个，但是获取了两个，则另一个就会在行间显示出来
        props: ['a', 'b'],
        // div是根组件，所以c就会在div上显示出来，具体样子为 <div c='3'>1 2</div>
        template: `<div>{{a}} {{b}}</div>`
      }
      new Vue({
        el: '#app',
        template: `<App a="1" b="2" c='3' />`,
        components: {
            App
        }
      });
      ```
    - 解决办法
      - 设置属性`inheritAttrs: false`
      - 比如：
        ```js
        const App = {
          props: ['a', 'b'],
          // 设置不展示多余的属性
          inheritAttrs: false,
          // 这样c就会消失不见，展示样子为 <div>1 2</div>
          template: `<div>{{a}} {{b}}</div>`
        }
        new Vue({
          el: '#app',
          template: `<App a="1" b="2" c='3' />`,
          components: {
              App
          }
        });
        ```

- $attrs的使用
  - 行间传参，但是没有被props引入的数据，会放在`$attrs`对象中
    - 这样，子组件就可以通过`this.$attrs`获取到剩余的，没有被props引入的行间传参
    - 比如
      ```js
      const App = {
        props: ['a', 'b'],
        // $attrs中，有两个属性c、d（a、b被props引入了）
        template: `<div>{{$attrs.c}}</div>`
      }
      new Vue({
        el: '#app',
        template: `<App a="1" b="2" c='3' d='4' />`,
        components: {
            App
        }
      });
      ```
  - 可以实现行间属性跨级传输
    - 比如：
      - A有子组件B，B有子组件C
      - A向B和C同时传递参数，但是B没有使用C的参数
      - 这样，正常情况下，就是B也通过props接受C使用的参数，然后在通过行间传递给C
    - 这样的后果就是**B中多了几个多余的props属性，并且B往C传递的行间参数要写很多（一个一个的写出来，过于麻烦）**
    - 这样的话，B组组件就可以使用`v-bind="$attrs"`，把$attrs对象中的数据继续向下传递（多余的属性，C用到的属性，传递下去）
      - 当然，如果某个属性B也使用了，C也使用了，就只能老老实实的单个传输了
    - 比如
      ```js
      const Demo = {
        props: ['b', 'c', 'd'],
        template: `<div>{{b}} {{c}}</div>`
      }
      const App = {
        props: ['a', 'b'],
        // 通过v-bind=$attrs，把多余的属性传到Demo中（Demo单独的属性）
        // :b="b"，把b也传到Demo中（两个组件共用的行间属性，只能单独传递，因为$attrs中没有）
        template: `<Demo :b="b" v-bind=$attrs />`,
        components: {
            Demo
        }
      }
      new Vue({
        el: '#app',
        template: `<App a="1" b="2" c='3' d='4' />`,
        components: {
            App
        }
      });
      ```
         
#### 行间属性传参的类型约定(数据验证)（只作用于开发阶段）
- **验证props传入的的数据参数，是否正确，以防胡乱传递**
- 作用：限制父组件，通过props向子组件所传参数的格式
- 如果不符合设置的格式，则控制台打印出错误，但是赋值正常
  - 只是给开发者起一个提示的作用


- 具体使用
  ```js
  Vue.component('my-component', {
    props: {
      // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
      propA: Number,
      // 多个可能的类型
      propB: [String, Number],
      // 必填的字符串
      propC: {
        type: String,
        required: true
      },
      // 带有默认值的数字（行间不传递，就使用默认值）
      propD: {
        type: Number,
        default: 100
      },
      // 带有默认值的对象（行间不传递，就使用默认值）
      propE: {
        type: Object,
        // 对象或数组默认值必须从一个工厂函数获取，不能直接赋值一个对象
        default: function () {
          return { message: 'hello' }
        }
      },
      // 自定义验证函数（只要返回true，就表示验证通过，返回false，验证失败）
      propF: {
        validator: function (value) {
          // 这个值必须匹配下列字符串中的一个
          return ['success', 'warning', 'danger'].indexOf(value) !== -1
        }
      }
    }
  })
  ```










#### 计算属性
- 作用：可以对某些值进行运算，然后得到一个新的渲染结果
  - 对原数据不会产生任何影响，和过滤器的作用差不多
- 组件的配置对象中，存在一个`computed`属性，该属性是一个对象
  - 该对象中的每一个属性，就是一个自定义的计算属性
- **计算属性的定义方式有两种**
  - 直接给计算属性赋值成一个函数，相当于对象赋值中的get方法
    ```js
    const App = {
        // 定义计算属性
        computed: {
            // 函数赋值
            comA: () => {
                console.log('计算属性A');
                return '123'
            },
        },
        template: `<div>
            {{comA}}
        </div>`
    }
    new Vue({
        el: '#app',
        template: `<App />`,
        components: {
            App
        }
    });
    ```
  - 给计算属性赋值成一个对象，对象中有两个属性可以使用，一个是get函数，一个是set函数（get是取计算属性时运行的函数，set是修改计算属性运行的函数）
    ```js
    const App = {
        methods: {
            setA() {
                // 只要一执行这个赋值语句，就会执行该计算属性的set方法
                //   相当于`Object.defineProperty`中的set
                this.comA = 3;
            }
        },
        // 定义计算属性
        computed: {
            comA: {
                get() {
                    return '计算属性'
                },
                set(d) {
                    console.log('计算属性发生了修改', d);
                }
            }
        },
        template: `<div>
            {{comA}}
            <button @click="setA">按钮</button>
        </div>`
    }
    new Vue({
        el: '#app',
        template: `<App />`,
        components: {
            App
        }
    });
    ```
    - 如果直接给计算属性赋值成一个函数，则修改是没有效果的
    - 如果赋值成一个对象，对象中有set方法，则修改计算属性，则会运行set方法，然后把赋的值作为参数传入
      - 当然，计算属性的值不一定发生变化，因为计算属性的值和set没有关系，和get有关
      - 除非set中修改了状态，然后触发了计算属性重新计算，才会发生变化
    - set和get配合使用，这样就可以通过计算属性，完全控制data中的数据
    - 相当于`Object.defineProperty`中的get和set


- **计算属性的使用**
  - 如果是vue执行程序中使用
      1) 和data中的数据使用方式相同，直接通过`this.计算属性名`使用
      2) 计算属性虽然运行的是一个函数，但是不能写成函数调用的形式
      3) 比如: `mounted() { console.log( this.a ) }`
  - 如果是vue模板中使用
      1) 和使用data中的数据相同，直接`计算属性名`
      2) 比如: `{{ a }}`


- **计算属性的特点**
  - 只有执行到需要计算属性的地方，才会执行计算属性对应的方法（或者get方法）
    - 比如解析模版 {{comA}}
    - **也就是说，计算属性对应的函数，并不是定义了就会执行**
  - 并且计算属性对应的函数，只会执行一遍，就会产生缓存
    - 如果计算属性的依赖（状态和props）没有发生变化，则下一次使用该计算属性的时候，就会从缓存中获取，而不是重新在执行一遍计算属性对应的函数（优化效率）
    - 比如
      ```js
      const App = {
          data: () => {
              return {
                  a: 'a'
              }
          },
          methods: {
              setA() {
                  // 引发重新渲染
                  this.a = 'a点击了'
              }
          },
          // 定义计算属性
          computed: {
              comA: () => {
                  // 由于没有依赖（依赖没有发生变化），则该打印在重新渲染的时候，就不会在执行了
                  console.log('计算属性A');
                  return '123'
              },
          },
          template: `<div>
              {{comA}}
              {{a}}
              <button @click="setA">按钮</button>
          </div>`
      }
      new Vue({
          el: '#app',
          template: `<App />`,
          components: {
              App
          }
      });
      ```
  - 虽然，计算属性定义的时候，是一个函数，但是使用的时候，不能写成函数调用，而是作为一个普通的属性使用
  - 计算属性重新执行的情况（依赖发生了变化）
    - 并不是依赖一发生变化，计算属性就会重新执行
    - 而是，依赖发生变化，会引发重新渲染，重新渲染的时候，解析到计算属性（获取计算属性值），在获取的时候，才会进行依赖的判断，如果发生变化，重新执行函数，如果没有发生变化则从缓存中获取
    - 即：如果计算属性没有被使用，即使依赖发生变化，也不会重新执行

- **注意点**
  - 由于计算属性存在缓存，所以尽量不要使用日期，随机数，异步函数。会造成数据不准确性

#### 预编译(打包)
- 作用：优化了效率
- Vue的渲染，利用的是虚拟dom。而虚拟dom的创建依赖的是render函数
- 如果没有render，就会利用模版解析器，解析template。然后产生对应的render函数，创建出对应的虚拟dom
  - 这个解析模版的过程是发生在执行过程中

- 但是脚手架就不一样了，由于存在一个打包过程，它就会直接把模版打包成对应的render（这个过程就是预编译）
  - 这样，在执行的时候，就不需要在解析模版了，缩短了时间
- 由于，打包后，项目中不存在模版了，所以脚手架在打包的过程中，就会舍弃掉模版解析器代码
  - 这也是脚手架中不能使用template属性的原因（打包的时候不解析该模版，打包后又没有模版解析器，所以templage无效）



#### 组件事件
- **事件的绑定**
  - 原始方式，借助ref，获取到dom，然后进行事件的绑定（不推荐使用）
  - Vue提供的事件绑定方式
    - 借助指令 v-on:。简写成@
    - 比如
      ```js
      <template>
        <!-- 完整写法 -->
        <button v-on:click="clickCall">按钮1</button>
        <!-- 简写 -->
        <button @click="clickCall">按钮2</button>
      </template>

      <script>
      export default {
        // 定义事件处理方法
        methods: {
          clickCall() {
            console.log('按钮点击了');
          }
        }
      }
      </script>

      <style scoped>
      </style>
      ```



- **事件函数的传参**
  - 事件函数默认接收一个参数event。
  - 但是，除了默认参数，还可以传递其它的数据
  - 要想传入其他数据，则事件函数，就需要写成函数调用的方式
    - 比如: `@click="func('aaa')"`
      - 会替换传入的默认参数，接收的第一个参数是默认值`"aaa"`
      ```js
      <template>
        <!-- 传入默认值a，和状态d -->
        <button @click="clickCall('a', d)">按钮2</button>
      </template>

      <script>
      export default {
        data: () => {
          return {
            d: 'd'
          }
        },
        // 定义事件处理方法
        methods: {
          clickCall(a1, a2) {
            console.log('按钮点击了', a1, a2);
          }
        }
      }
      </script>
      ```
    - 要想即传入自定义属性，又传入event对象，需要借助vue提供的`$event`。
      - 比如: `@click="func($event, 'aaa')"`  
        - 第一个参数接收event对象，第二个参数接收默认值`"aaa"`
        ```js
        <template>
          <!-- 传入默认值a，和事件属性集合 -->
          <button @click="clickCall('a', $event)">按钮2</button>
        </template>

        <script>
        export default {
          data: () => {
            return {
              d: 'd'
            }
          },
          // 定义事件处理方法
          methods: {
            clickCall(a1, a2) {
              console.log('按钮点击了', a1, a2);
            }
          }
        }
        </script>
        ```

- **事件函数内部的this指向**
  - 如果事件函数，定义的是一个箭头函数，则this指向undefined
  - 如果事件函数，定义的是一个普通函数，则this指向当前组件的实例对象
  - 比如
    ```js
    <template>
      <button @click="clickCall_a">按钮1</button>
      <button @click="clickCall_b">按钮2</button>
    </template>

    <script>
    export default {
      data: () => {
        return {
          d: 'd'
        }
      },
      // 定义事件处理方法
      methods: {
        // 箭头函数，指向undefined
        clickCall_a: () => {
          console.log('按钮点击了', this);
        },
        // 普通函数，指向当前组件的实例对象
        clickCall_b() {
          console.log('按钮点击了', this);
        }
      }
    }
    </script>
    ```
  - 要想获取到触发事件的dom，可以借助event对象上的target属性







- **组件上绑定事件的无效问题**
  - 组件元素，是Vue特有的东西，并不会真正的渲染到页面中
    - 比如：`<App />`，而App并不会真正的渲染，只是标记这个地方要插入一个组件
  - 由于组件元素不会渲染，所以上面绑定的事件，自然无效。
    - 比如：
      ```js
      <App @click="call" />
      ```
      - 点击App，click并不会被触发（无效果）
  - 要想使绑定的事件发生作用，需要加上修饰符`native`
    - 比如：
      ```js
      <App @click.native="call" />
      ```
      - 这样，这个click，就会绑定在组件的根元素dom上（往下自动移了一级）

- **组件内，获取组件dom上绑定的事件**
  - 通过`this.$listeners`可以获取事件对象
    - 事件名作为属性值，事件绑定的方法作为属性值
    - 比如
      ```js
      const App = {
          methods: {
              clickCall() {
                  // 打印：{click: ƒ}
                  console.log(this.$listeners);
              }
          },
          template: `<div>
              <button @click="clickCall">按钮</button>
          </div>`
      }
      new Vue({
          el: '#app',
          template: `<App @click="console.log(123)" />`,
          components: {
              App
          }
      });
      ```
  - **注意: 如果事件使用了native修饰符，则通过$listeners获取不到**



- **手动触发组件dom上绑定的事件**
  - 标准方法: `this.$emit("事件名", 传参)`
  - 直接取出事件函数进行调用: `this.$listeners.函数名(传参)`
  - 比如
    ```js
    const App = {
        methods: {
            clickCall() {
                // 触发组件dom上绑定的click事件
                this.$emit('click', 'a');  // 标准方式
                this.$listeners.click('a');  // 取巧方式
            }
        },
        template: `<div>
            <button @click="clickCall">按钮</button>
        </div>`
    }
    new Vue({
        el: '#app',
        methods: {
            clickCall(d) {
                // 打印参数（两次打印的都是 a）
                console.log(d);
            }
        },
        template: `<App @click="clickCall" />`,
        components: {
            App
        }
    });
    ```




- **组件内移用组件上的所有事件**
  - 把组件dom上的所有的事件原封不动的，在给其它标签和组件进行绑定
  - 借助的是`v-on`和`$listeners`。方法为`v-on="$listeners"`
    - 只要组件中的某个标签或者子组件的行间写上，上面的方法
    - 则该标签或者子组件，就会绑定当前组件上所有的事件
  - 该方式，可以实现组件间的事件函数的传递（父组件控制子组件中某个dom上绑定的事件）
    - 前提是组件上的事件没有使用修饰符`native`，要不然`$listeners`获取不到


- **扩展**
  - 事件的处理函数赋值，可以赋值成一个表达式
    - 如果写成一个表达式，则会自定在外侧包裹一个函数，作为事件函数
    - 当事件函数执行的时候，就会执行赋值的表达式了
  - 这也是事件函数的复制可以写成方法调用的原因
    - 但是并不是，调用函数，把返回值作为事件处理函数
    - 原因，就是外届包了一个事件函数，这样这个函数执行语句就不会执行了
      - 只有当事件处理函数执行的时候（外界自动包裹的函数），才会进行执行
  - 比如
    ```js
    <template>
      <!-- 写一个表达式，底层会自动变成 () => { console.log('a') }，把它转换成一个函数 -->
      <button @click="console.log('a')">按钮1</button>
      <!-- 这也是这个地方可以写方法调用的原因 -->
      <button @click="clickCall_b()">按钮2</button>
    </template>
    ```






#### 条件渲染
