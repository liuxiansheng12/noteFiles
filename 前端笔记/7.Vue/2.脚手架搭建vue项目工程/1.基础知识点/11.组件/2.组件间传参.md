

## 子组件获取父组件定义的数据



2. 子组件直接获取父组件的vue环境，然后获取父组件中的数据
   1) 通过`this.$parent`，获取父组件的vue环境对象
   2) 相当于父组件的this，这样就可以通过`this.$parent.?`获取到父组件中的某个数据
   3) 计算属性可以进行监管
      1) 比如: `computed: { aa() { return this.$parent.a } }`


3. 执行期上下文传递数据
   1) 没有层级限制，只要位于执行期上下文的环境中，就可以使用内部的数据
   2) 在组件中，通过`provide属性`创建执行期上下文。
      1) 比如: `provide: { a: 123 }`
   3) 某个组件创建了执行期上下文，则该组件的所有子组件都位于该上下文的环境中
      1) 子组件，要想使用上下文中的数据，通过`inject属性`进行获取
         1) 和props的使用方式一样
         2) 比如: `inject: ["a"]`
      2) 创建执行期上下文中的组件，是不位于该上下文中的
         1) 也就是不能通过inject获取上下文中的数据
   4) 创建执行期上下文的组件，是无法使用上下文中的数据的
      1) 要想使用，可以直接通过`this._provided.?`，是可以访问到上下文空间对象的
      2) 通过`this._provided.?`是无法造成，使用上下文数据的子组件的重新渲染的
         1) 直接通过inject取数据，然后{{}}中使用，是无法造成重新渲染的
            1) 相当于，取出数据，然后赋值给了某个属性，数据变化是不会重新赋值的
            2) props可以引发重新渲染，是父组件行间传参，建立的对应关系。
               1) 数据变化，根据对应关系，找到对应的组件，直接重新渲染
               2) inject是无法建立关系的，没有关系自然无法重新渲染
         1) 计算属性也无法进行重新渲染
   5) 子组件先从距离最近的父组件创建的上下文中取数据，如果没有，在继续向上查询         



## 父组件获取子组件中的数据

1. 获取子组件的环境
   1) 当前的组件环境有一个`$children`属性，通过该属性可以获取到下一级子组件的vue环境
      1) 由于下一级子组件可能有多个，所以该属性是一个数组
      2) 数组的每一项对应一个子组件的vue环境对象
      3) 比如: `this.$children[0]`，获取第一个子组件的vue环境对象
   2) 无法进行跨级获取，如果想要进行跨级获取，需要进行`$children`的连用
      1) 比如: `this.$children[0].$children[0]`


2. 通过数据引用的方式，获取到子组件的数据
   1) 其实获取的也是下一级子组件的vue环境，类似$children
   2) 在vue的行间中，有这么一个属性`ref`
      1) 行间，通过`ref="ref名称，自定义"`，启用ref
      2) 比如: `ref="a"`
   3) 普通的dom，使用ref
      1) 通过`this.$refs.对应的ref名`。获取到的是该dom节点
   4) 组件，使用ref
      1) 通过`this.$refs.对应的ref名`。获取到的就是该组件对应的vue环境
   5) 注意同一个组件下，ref不要重复，否则发生替换
   6) v-for循环对应的ref比较特殊
      1) 由于，v-for循环产生对应的html结构，ref势必会相同
      2) 虽然相同，但是不会进行替换，而是把它们放在一个数组中
      3) 通过`this.$refs.对应的ref名`，获取到的就是一个数组
      4) 数组的每一项，对应循环产生的dom节点或者组件的vue环境对象



3. 通过函数传参的方式，获取子组件的数据
   1) 父组件中声明一个函数，然后把函数传入子组件中
   2) 子组件调用函数，把对应的数据传入，这样父组件就可以获取到子组件中的数据



4. 子组件通过手动触发组件上绑定的事件，向父组件传参
   1) 原理借助的还是函数传参
   2) 组件上绑定的事件可以是自定义的，也可以是原生的
      1) 绑定方式，比如: `<App @a="func" />`
   3) 子组件中，就可以通过`$emit()`方法，手动触发组件上绑定的事件
      1) 使用方式: `this.$emit(事件名, 传递的参数1，传递的参数2，··· ···)`
      2) 比如: `this.$emit("a", this.b)`
         1) 触发func函数，然后把b传入
   4) 子组件中，通过`this.$options._parentListeners`，可以获取到组件上绑定的事件函数
      1) 得到的是一个对象，对象的属性名为事件名，属性值为事件函数
      2) 这样就可以手动直接调用事件函数，进行传参，不用通过`$emit`进行触发
      3) 比如: `this.$options._parentListeners.a( this.b )`，但是有些麻烦
   5) 子组件中，通过`this._events`，可以获取到组件上绑定的事件函数
      1) 得到的是一个对象，对象的属性名为事件名，属性值为一个数组
         1) 数组中的数据为对应的事件函数
      2) 可以直接调用事件函数，进行传参，，不用通过`$emit`进行触发
      3) 比如: `this._events.a[0]( this.b )`，但是有些麻烦



## 兄弟组件间的传参

1. 借助共同的父级
   1) 先把数据传入共同的父级中，然后共同的父级在把数据传入另一个组件中
   2) 过程过于麻烦


2. 利用事件总线的方式，实现兄弟组件间的传参
   1) 原理，在事件总线上绑定函数，然后其它的组件手动触发事件总线上绑定的函数，进行数据传递
      1) 类似事件传参
      2) 往事件总线上绑定函数，是在组件中完成的，利用组件上的一个方法。
      3) 创建一条事件总线，`Vue.prototype.自定义事件总线名 = new Vue()`
         1) 该条事件总线，就会贯穿整个组件
      4) 组件中，往事件总线上绑定方法
         1) 通过`this.总线名.$on("自定义事件名", 事件处理函数)`
         2) 如果事件处理函数中，需要使用this，获取到当前组件的vue环境对象
            1) 必须写成箭头函数的形式
            2) 如果使用function关键字定义的事件处理函数，则this指向有问题
               1) 指向的是创建事件总线时new Vue()，返回的vue环境对象
         3) 由于，事件处理只需要注册一次，所以通常周期函数`mounted`中注册
         4) 并且事件名可以重复，不会发生覆盖现象
            1) 会按照注册的顺序，全部触发
            2) 甚至多个组件中，都可以注册同一个事件名
            3) 触发的时候，多个组件中注册的事件函数，都会触发
            4) 只要是该事件名，全面触发
      5) 组件中，触发事件总线上绑定的事件，进行传参
         1) 通过`this.总线名.$emit("将要触发的事件名称", 传参, 传参, ··· ···)`
         2) 父子级间的传参，也可以使用事件总线的方式，进行传参
   





