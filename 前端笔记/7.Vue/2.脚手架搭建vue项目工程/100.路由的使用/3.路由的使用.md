

#### 把配置的路由，导入项目中
1. Vue的传参对象中，存在一个`router属性`，该属性的赋值对象就是路由对象
    1. 导入路由对象: `import router from './router.js'`
    2. 使用路由对象: `router: router`
    3. `router属性`向vue环境对象中添加了两个属性
        1. `$router属性`，通过该属性，可以访问到赋予的`router对象`
        2. `$route属性`，通过该属性，可以访问到赋予的`router对象`中的`currentRoute对象`
        1. 即`$route = $router.currentRoute`
        2. 由于该对象使用频繁，所以单独的封装了一个索引
        3. 这两个属性，在vue中，可以通过`this`的方式调用
    4. 由于`router属性`赋值后，在初始化时，需要使用赋值对象中的一些方法
        1. 所以，只能赋值路由对象，赋值其它对象报错





#### 普通路由对象的分析与使用

1. 分析创建路由对象的传参(Router的传参对象)
   1) `routes属性`对应的数组中的每一个对象，就是一个路由信息对象
   2) 路由信息对象中的常用属性
      1) 其中，`path属性`，设置的是路径匹配规则，格式是正则
         1) 匹配成功，就会创建对应的组件节点，进而渲染组件
         2) 匹配失败，对应的组件不显示
         3) 类似于组件的显示与隐藏，控制条件为路径是否匹配成功
         4) **如果`path`属性，设置为`"*"`，则所有的路径都可以匹配成功**
            1) **path为"*"的路由信息对象，必须放在最后，否则影响巨大**
      2) `name属性`，该属性不是必须设置的一个属性，作用为给当前路由对象起一个名字
      3) `component属性`，设置的是匹配成功，加载的组件，两种赋值方式
         1) 先引入对应的组件对象，然后直接赋值
            1) 引入组件: `import A from "./A.vue"`
            2) 直接赋值: `component: A`
         2) 当第一次匹配成功后，对应的组件才进行加载，被称为按需加载
            1) 按需加载: `component: () => import("./A.vue")`
            2) 经过打包后，其实对应的文件代码已经打包进来了，只不过没有运行
               1) 如果一开始加载所有的组件，浏览器一打开页面，所有的组件代码就会运行一遍
               2) 而按需加载，是当需要时，才运行对应组件中的代码，节约一部分性能
               3) 运行完，就会进行缓存，即组件代码只运行一次
      4) `children属性`，定义子路由的信息
         1) 属性值为一个数组，数组的每一项，为一个子路由信息对象
         2) 子路由信息对象，与父路由对应的组件密切相关
      5) `redirect属性`，进行重定向的设置


2. **路由匹配成功，加载对应组件的规则**
   1) 路由对应的组件，加载的位置与`<router-view />`标签密切相关
   2) Vue在解析模板，构建对应的虚拟节点时
      1) 如果遇到了`<router-view />`标签，就会与当前的路径进行匹配
      2) 匹配规则: 
         1) **此时解析的模板，并不是路由组件，而是基础组件**
         2) 所以，`<router-view />`使用的匹配`path`，是所有一级路由中的
         3) 那个`path`匹配成功，就会在该位置显示对应的组件
         4) 比如: 匹配成功路由对应的组件为`A`，此时`A`组件就会加载
         5) 相当于把`<router-view />`替换成`<A />`，在该位置显示该组件
         6) 解析时，不受层级的限制
         7) 即使是子组件中的`<router-view />`也使用一级路由中的`path`进行匹配
      3) 每一个`<router-view />`，都会进行匹配，匹配成功就会在该位置加载对应路由组件
      4) **路由匹配成功，开始解析路由组件模板**
         1) 如果解析到了`<router-view />`标签，也会进行匹配
         2) 匹配规则: 按照`该组件对应的路由信息对象中的子路由信息`中的`path`进行匹配
         3) 匹配成功，把`<router-view />`替换成，匹配成功的子路由对应的组件，进行加载
         4) 组件加载完成继续分析子路由对应的模板，处理`<router-view />`标签
         5) 每一个`<router-view />`，都会进行匹配，匹配成功就会在该位置加载对应路由组件
         6) 解析时，不受层级的限制
         7) 即使是子组件中的`<router-view />`也使用子路由对象中的`path`进行匹配
      5) **所以: 子路由组件的显示位置，由父路由组件中的`<router-view />`标签控制**
      6) 某一个`<router-view />`匹配成功，就会加载对应的路由组件，然后进行分析
         1) 如果路由组件中，还存在`<router-view />`匹配成功，继续加载路由组件，继续分析
         2) 直到，匹配不成功，或者没有`<router-view />`，就没有对应的路由组件加载
         3) 然后，才会继续向下分析，如果又遇到了`<router-view />`，继续匹配加载分析
   3) 通常`<router-view />`写在根组件中，并且只写一个，便于管理分析
      1) 如果隐藏在子组件中，工程一庞大起来，后期调换`<router-view />`
      2) 不容易找到其所在的组件位置


3. `path`匹配的注意点
   1) vue中path的匹配都是完全匹配
   2) 如果当前路径被子路由匹配成功，则子路由的父路由组件也会进行加载
      1) 此时，父组件不遵循完全匹配
      2) 如果，父组件遵循完全匹配，子路由对应的路径，父路由一定匹配不上
      3) 如果，父路由匹配不上，则对应的父路由组件不会进行加载
      4) 父路由组件不进行加载，无法提供子路由组件显示位置的`<router-view />`
   3) 父路由组件的显示位置，由该路由的父级路由组件中的`<router-view />`控制
      1) 如果没有找到`<router-view />`，路由组件就不会进行加载，造成子路由组件也无法加载
      2) 如果是一级路由，没有父级路由，则由基础组件中的`<router-view />`控制显示位置
   4) 如果有一个路由的`path`，就不在进行向下匹配
      1) 所以`path: "*"`号的使用，只能最后，当前面的所有路由都匹配失败，该路由匹配成功
      2) 如果，放在前面，则无论是什么路径，它都能匹配成功，然后立刻停止匹配
      3) 则下方所有的路由对象都失效，对应的路由组件也不会被加载


4. 多级路由的path设置的注意点
   1) 必须要写全: 比如: `path: /a/b/c`
   2) 即必须以`/`开头，如果没有`/`开头会进行路径的拼接
   3) 拼接方式: 前面拼接上父路由设置的`path`，然后加上`/`，然后拼接上当前路由设置的`path`
      1) 比如: 父路由设置的`path`为`/a`，子路由设置的`path`为`b`
      2) 最终: 子路由的`path`会变成`/a/b`，进行拼接

