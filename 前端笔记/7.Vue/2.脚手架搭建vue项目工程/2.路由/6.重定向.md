
#### 重定向
 
1. 在Router构造函数的传参对象中的路由参数对象中，借助`redirect`属性进行配置

2. 具体的配置方式
   1) `redirect`属性有两种赋值方式
      1) 字符串
         1) 比如: `redirect: "/a"`
      2) 函数
         1) 比如: `redirect: (to) => { }`
   2) 当对应的路由匹配成功，重定向到`redirect属性`设置的路径
      1) 如果是函数赋值，则匹配成功，执行函数，并且传入当前的路径对象
      2) 然后函数运行的返回值，作为重定向的地址
      3) 传参对象中，存在一个`path`属性，通过该属性，可以获取到当前的路径
         1) 这样就可以根据当前的路径，进行动态的重定向，不用一次写死
   3) **函数赋值，通常用于`path: "*"`路由参数对象中**
      1) 这种path，所有的路径都可以匹配成功，即每个路径都会运行一次重定向函数
         1) 这样才能动态的判断`传参对象中的path属性`，实现动态重定向
      3) 如果写在path为固定值的路由参数对象中
         1) 每次匹配成功，运行重定向函数，得到的`传参对象中的path属性`都是一个值
         2) 其它值匹配不成功，重定向函数不会运行
         3) 这样的话，每次运行得到的返回值都相同，直接采用字符串赋值即可
         4) 除非有一些其它的处理，必须使用函数式赋值

3. 使用`path: "*"`进行重定向匹配的注意点
   1) 路由参数对象必须放在最后
   2) 重定向后的路径，在该路由参数对象的上面必须存在可以匹配成功的路由
   3) 如果上方不存在匹配成功的路由，会陷入重定向的死循环
      1) 上方匹配失败，被`path: "*"`匹配成功，重定向到另一个路径
      2) 底层借助的是`history.push`方法完成的路径跳转
      3) 跳转后，就会重新进行匹配，如果上方没有定义可以匹配的路由
      4) 又会被`path: "*"`匹配成功，继续跳转，继续匹配，陷入死循环
   4) 如果匹配成功，匹配终止，`path: "*"`不进行匹配，也就不会陷入重定向死循环了


4. 通常使用`path: "*"`进行重定向匹配，加载404页面
   1) 上方的所有路由，都匹配失败，表示没有该路由
   2) 然后`path: "*"`匹配成功，重定向到一个路径中
   3) 重定向的路径，在上方有定义，匹配成功，加载404组件
   4) 重定向到404的示范路由参数对象
   ```js
   {
       path: "*",
       redirect: (to) => {
           console.log(to);
           // 处理根路径的重定向和404的重定向
           if(to.path === "/"){
               // 该路径对应的路由参数对象，加载初始路由组件
               return "/home"    
           }else {
               // 该路径对应的路由参数对象，加载404路由组件
               return "/404"  
           }
       }
   }
   ```



5. 进行重定向的路由数据对象，不用写component，引入对应的组件
   1) 永远也不会进行显示
   2) 匹配成功，就进行重定向，然后重新匹配，加载其它的组件






