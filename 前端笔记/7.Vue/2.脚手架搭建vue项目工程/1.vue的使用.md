<script src='/笔记/see/index.js'></script>
[toc]

#### 搭建项目(启用规则检查)
- **下载vue插件**
  - 在命令行中输入: `npm install @vue/cli -D`


- **创建项目的步骤**
  - 在命令行中输入`npx vue create 文件名`，敲击回车键
  - 选择`Manually select features`，表示重新创建一个项目，
    - 在该选项上面还有一些选项，都是之前创建项目时，保存的该项目的创建流程(预设)
    - 点击这些流程模板(预设)，会按照保存的流程快速创建出一个项目
    - 如果重新创建，创建流程需要重新，一步一步的进行配置
  - 进入一个选择项，选择一些依赖，选择和取消状态的切换，通过空格键来完成
    - `Babel`: 把Es6语言降级成为Es5语言，适用于不支持Es6语言的浏览器
      - 如果想对语言进行降级，可以选中该依赖，在创建的过程中，会下载对应的第三方插件
    - `TypeScript`: 如果工程中设计到了`TypeScript`语言
      - 浏览器不识别`TypeScript`
      - 如果涉及到了该语言，需要选中该依赖，进行语言转换
    - `Progressive Web`: 
    - `Router`: 是否启用路由
    - `Vuex`:
    - `CSS Pre-processo`: 选中css预处理语言
    - `Linter / Formatt`: 检查代码，如果不规范，进行提示
      - 一个大项目，可能有多个开发人员共同开发，但是由于属于同一个项目，所以要求风格相同
      - 此时，就可以使用该工具，约定风格格式，如果不符合进行提示
      - 这样开发出来的代码，便于管理
    - `Unit Testing`: 进行单元检测的
    - `E2E Testing`: 
  - 如果第三步选择依赖时，选择了`router`，会进入一个选择页面
    - `Use history mode for router?`: 表示是否使用路由器的历史模式
  - 如果第三步选择依赖时，选择了`CSS Pre-processo`，会进入一个选择页面
    - 选择一些css的预处理语言，比如`scss`、`less`
  - 如果第三步选择依赖时，选择了`Linter / Formatt`，会进入一个选择页面
    - 选择一种语言规范，通常选择`ESLint + Airbnb config`语言标准
    - 选择完语言标准，会进入一个选择页面，选择什么时候进行语言规范检测
      - `Lint on save`: 代码一保存，就进行检测，通常选择该选项
      - `Lint and fix on commit`: 向git仓库提交的时候进行检测
  - 进入一个选择页面，选择一个测试的框架
    - 自动生成一些代码(页面)，用于框架的测试
    - 通常选择`Jest`
    - 选哪个都可以，只是自动生成一些测试框架是否可以正常使用的一些代码，最终也是要删除的
  - 进入一个选择页面，选择把配置文件放在那里
    - `In dedicated config files`: 单独形成文件，常用
    - `In package.json`: 把配置放在package.json，如果配置过长会导致`package.json`文件过大
  - 进入一个选择页面，问是否保存本次创建流程
    - `Save this as a preset for future projects?`
      - 意思为: 将本次流程，保存为将来项目的预设
    - 如果保存了，则下次在使用`npx vue create 文件名`创建文件时
      - 第一项就会多一个选项，为本次的创建流程(上面选择的一些东西)
      - 会按照本次流程，快速的创建出文件
  - 选择完，点击回车，就会自动创建出一个项目




- 自动修复不规范的代码
  - 启用了代码规范检测，如果代码不规范，在打包时会报出不规范的地方
    - 如果一个一个的修改，比较麻烦
  - 可以另外打开一个终端(当前终端正在监听)
    - 在新打开的终端，输入`npm run lint --fix`
      - 会自动修改不规范的地方，直接修改源文件(读出来修改，在写进去)
      - 修改完，监听的终端就会重新打包
    - 该指令是生成文件的时候，根据所选的代码规范检测的方法，自动生成的
      - 该指令不会开启监听，运行完直接结束
      - 下次代码不规范，需要重新开启该命令
    - 如果使用该指令修改完，还报不规范的地方，就需要手动修改了



- 开启服务，运行工程
  - 进入创建的文件: `cd 项目文件`
  - 开启服务: `npm run serve`



#### vue的工作流程（初始渲染）
- 首先，创建出一个实例（一个对象）
  - new Vue();
- 然后，把属性、方法，注入到实例中（注入）
- 在然后，创建出虚拟dom树（虚拟dom，是一个描述真实dom的对象）
  - 虚拟dom树的创建：利用的是 render 这个函数，每一个虚拟dom，都是利用render函数创建出来的
  - **render这个函数，可以自定义，但是通常都是根据模版自动产生**
    - 因为通过自定义render，构建虚拟dom树结构，过于麻烦
    - 每个节点都要写一个render函数，不如`<div></div>` 这样写来的方便
  - 通常情况下，都是利用模版，自动产生对应的render函数，然后创建出对应的虚拟dom
    - 比如：解析到`<div></div>`，就会创建出一个 render 的调用，然后创建出一个div虚拟dom
- 最后，根据虚拟dom树，创建出对应的真实dom，然后渲染出来
  -这一步是非常消耗性能的，所以vue在重新渲染的时候，做了优化


#### vue的工作流程（重新渲染）
- 首先，发生变化的地方，会重新构建一个虚拟dom树
- 然后，与旧的虚拟dom树进行比较
- 最后，只针对发生变化的dom，进行真实dom的操作（即：不是所有的dom都重新构建一遍，这很浪费效率）


#### Vue实例的创建与挂载
- 创建，通过 new Vue()
- 挂载，有两种
  - 一种是通过属性 el
  - 一种是通过 $mount() 这个方法
    - 两个共存，以$mount()为准
  - 比如
    ```js
    const App = new Vue({
      el: '#App'
    })

    App.$mount('#App');
    ```
- 以上是原生的Vue使用方式： `cdn` 引入
- 如果使用的是vue脚手架，则创建和挂载如下
  ```js
  import {createApp} from 'vue'
  // 引入组件对象
  import App from './App.vue'

  createApp(App).mount('#App');
  ```

#### render函数
- 作用，创建虚拟dom，形成虚拟dom树
- 在src中引入和脚手架中使用略有不同
- 在src中引入
  - render函数，接受的参数是一个函数（构建虚拟节点的函数）
  - 返回值必须是构建的虚拟节点（通过接收的参数构建），返回其他的不好使（比如返回JSX结构，就无效）
  - render和template共存，template会失效，以render为准
  - 比如
    ```js
    new Vue({
        el: '#app',
        template: `<div>123456</div>`,
        // render和template共存，template会失效，以render为准
        render(h) {
            return h('div', {class: 'd'}, [
                h('span', {}, '子节点')
            ])
        }
    });
    ```
  - 虚拟dom创建函数，还可以传递一个组件对象
  - 比如
    ```js
    const App = {
      template: `<div>123</div>`
    }
    new Vue({
        el: '#app',
        render(h) {
          // 可以直接传入一个组件对象
          return h(App)
        }
    });
    ```
- 脚手架使用render
  - 不能和模版共存（不是template属性，脚手架不能使用template），否则会被替换掉
    - 脚手架在打包的时候，会把模版解析成一个render函数，然后自定义的render就会被替换掉（可以打印一下引入的组件，发现就是一个普通的对象，对象中有一个render方法）
    - 比如
      ```js
      // Vue组件的模版，如果模版存在，则自定义的render就会被替换掉
      <template>
        <div>123</div>
      </template>

      <script>
        export default {
          name: 'App',
          data: function() {
            return {
              ds: 'any'
            };
          },
          // 发现无效果
          render(h) {
            console.log(h);
            return <div>456</div>
          }
        }
      </script>
      ```
- 接收的参数不在是虚拟dom的构造函数，而是当前组件的实例对象（内部有状态data，可以获取状态）
- 返回值是JSX结构（内部可以使用data定义的状态）
  - 由于没有虚拟dom的构造方法，所以无法返回虚拟dom
  - 比如
    ```js
    <script>
      export default {
        name: 'App',
        data: function() {
          return {
            ds: 'any'
          };
        },
        // 定义一些方法
        methods: {
          call: () => {
            console.log('自定义方法');
          }
        },
        render(h) {
          // 由于接收的参数是当前组件的实例对象，所以可以使用定义的方法和状态
          console.log(h);
          h.call();
          return <div>{h.ds}</div>
        }
      }
    </script>
    ```
  


#### 组件
- 作用：降低项目的复杂度
- 本质：就是一个普通的对象
- 比如：
  ```js
  const obj = {
    // 定义组件状态，需要注意的是组件状态是一个函数，返回一个对象
    //    而不是直接赋值一个对象
    data: () => {
        return {
            ds: 'dssdd'
        }
    },
    template: `<div>123</div>`
  }
  ```

- 组件分为全局组件和局部组件
  - 全局组件
    - 利用Vue上的component方法
    - 作用，一次定义，全局使用
    - 比如
      ```js
      const App = {
        template: `<div>123456</div>`
      }
      // 创建一个全局组件
      Vue.component("App", App);
      new Vue({
          el: '#app',
          template: `<App />`,
      });
      ```
  - 局部组件
    - 利用属性components
    - 作用，只能在引入组件的组件中使用，其他地方是无法使用的
    - 比如
      ```js
      const Vue = window.Vue;
      const App = {
        template: `<div>123456</div>`
      }
      new Vue({
          el: '#app',
          // 局部组件只能内部使用
          template: `<App />`,
          // 引入一个局部组件
          components: {
              App
          }
      });
      ```

- 需要注意的是，脚手架中没有模版解析器，所以template不能使用，可以使用render（使用方法render中有介绍）
  - 组件是一个普通的对象，如果直接写，略有复杂，所以脚手架就搞出了一个vue的类型文件，用来编写组件代码
  - 在打包的时候，就会打包成一个对象
  - 既然，打包的时候，是把vue文件打包成一个对象，则这个对象我们可以完全手写出来（简单的原理）
  - 比如
  ```js
  import { createApp } from 'vue';
  // 引入的组件
  import App from './App.vue';
  console.log(App);  // 发现就是一个普通的对象，可以手动写一个对象也是可以用的
  // 手写的组件对象，可以可以用的
  const Apps = {
      name: 'App',
      data: () => {
          return {
              ds: 'dssdd'
          }
      },
      render(d) {
          console.log(d);
          return <div>
              <span>{d.ds}</span>
          </div>
      }
  }
  // 正常使用
  createApp(Apps).mount('#app')
  ```


#### 状态
- **状态的定义**
  ```js
  <template>
    <span>{{a}}</span>
  </template>

  <script>
  export default {
    data: () => {
      return {
        a: 1
      }
    }
  }
  </script>
  ```

- **状态的修改**
  - 修改一个模版中使用的状态，才会引发重新渲染（底层做了效率优化）
  - 直接修改一个数组，是无法引发重新渲染的（Vue3是可以引发重新渲染的），比如：`a[0] = 3;`
    - 如果利用数组上的一些方法，对数组进行操作，是可以引发重新渲染的
      - 因为，这些方法，Vue已经进行了重写
    - 或者使用 $set 修改状态，也能引发重新渲染
      - `a[0] = 3;` Vue监听不到，使用数组方法，Vue就能知道状态进行了修改，然后Vue触发重新渲染
      - 调用 $set 方法，Vue也能知道状态进行了修改，然后Vue触发重新渲染
  - 修改对象中的属性，也可以引发重新渲染（深度监管）
  - 比如
    ```js
    <template>
      <span>{{a}}</span>
      <button @Click="clickCall">按钮</button>
    </template>

    <script>
    export default {
      data: () => {
        return {
          a: 1
        }
      },
      methods: {
        clickCall() {
          // 修改状态，引发重新渲染
          this.a = 3;
        }
      }
    }
    </script>
    ```

- **状态的使用**
  - 模版中使用
    - 内容使用，用 {{}} 进行包裹
    - 行间属性使用：需要借助一个属性`v-bind:(可以简写成:)`，并且不用加{{}}，直接""
      - "" 这个中间写的是表达式
    - 比如
      ```html
      <span>{{a}}</span>
      <!-- 表现为2 -->
      <span>{{1 + 1}}</span>
      <img v-bind:src="imgSrc">
      <img v-bind:class="class">
      <img :src="imgSrc">
      <img :style="style">
      ```


#### $set方法(修改状态，Vue3已废弃改方法)
  - 使用$set方法，也可以修改状态，并且引发重新渲染
  - 比如
    ```js
    <template>
      <span>{{a}}</span>
      <span>{{b.b1.b2}}</span>
      <button @Click="clickCall">按钮</button>
    </template>

    <script>
    export default {
      data: () => {
        return {
          a: 1,
          arr: [3, 4],
          b: {
            b1: {
              b2: 4
            }
          }
        }
      },
      methods: {
        clickCall() {
          this.a = 3;
          // 使用$set修改状态，第一个参数传入属性所在的位置对象，第二个为修改的属性，第三个为新的值
          this.$set(this, 'a', 4);
          this.$set(this.b.b1, 'b2', 8);
          // 数组，是一个特殊的对象，所以索引就是属性，所以，第一个参数传入的就是数组，第二个传入的就是索引
          this.$set(this.arr, 1, 8);
        }
      }
    }
    </script>
    ```




#### 设置class（从Vue中取值）
1. **取一个值**
   1) 直接取值: `v-bind:class="a"`
   2) 运行表达式: `:class=" da ? 'a' : 'b' "`
   3) 赋值固定值: `:class=" 'a' "`
   4) 原理: 把表达式的结果运算完，作为class名

2. **取一个值或者取多个值**
   1) 直接取值: `v-bind:class="[a, b, c]"`
   2) 运行表达式: `:class="[a, da && 'c', da ? 'a' : 'b']"`
   3) 赋值固定值: `:class="['a', b, da && 'c']"`
   4) 原理: 把数组中的每一项表达式的结果运算完，作为class名



3. **取一个值或者取多个值**
   1) class名，提前定义好，然后根据条件判断进行添加，无法从data数据中获取
   2) `v-bind:class="{a: a, b: b, c}"`
      1) 当属性值为true时，属性名作为class名
      2) 没有属性值的属性名则直接作为class名，不进行判断添加


4. **`:class`可以与`class`共存，两者定义的class名最终会进行合并**




#### style从vue中取值的方式

1. css样式比较特殊，必须有一个属性名和一个属性值。


2. 获取方式
   1) 把所有样式写成一个字符串，然后进行获取
      1) 比如: 定义的数据为`sty: "color: #f0f; "`
      2) 取值方式: `v-bind:style="sty"`
      3) 运行表达式: `:style="a && sty"`
         1) 把表达式的运算结果，赋值给style
   2) 把样式定义成对象格式(常用)，可以定义多个对象
      1) 比如: 定义的数据为`sty: {color: '#f0f', fontSize: '14px' }`
      2) 取值方式: `v-bind:style="[ sty, a ]"`
         1) 可以取一个或多个样式对象
      3) 运行表达式: `v-bind:style="[ a && sty, b ]"`
   3) 样式只定义键值对中的键值，键名(样式名)在模板中设置
      1) 比如: 定义的数据为`color: "#f0f", fontSize: '16px'`
      2) 取值方式: `v-bind:style='{color: color, fontSize: fontSize}'`
      3) 运行表达式: `:style='{color: a && color, fontSize: fontSize}'`
      

3. `:style`可以与`style`共存，不会发生覆盖现象。但是`:style`会替换`style`中相同的样式




4. 每一个vue文件中定义的style样式，是会对全局起作用的，而不是只针对当前的vue文件
   1) 最终打包形成行间标签`style`中的样式，作用于全局



#### 组件上的slot插槽

1. 作用
   1) slot插槽的作用，给组件中动态的添加一些html结构
   2) slot插槽分为普通插槽和具名插槽两种


2. 普通插槽的使用
   1) 普通插槽，无需做任何操作
   2) 在使用组件时，直接书写html内容
   3) 组件中，使用插槽，直接通过`<slot></slot>`标签进行使用
      1) 会把使用该组件时，书写的html内容放到该位置
         1) **插入的是，行间没有使用slot属性的节点**
         2) 行间使用`slot`属性的节点，替换的是具名插槽
         3) 相当于提取出所有的没有`slot`属性的节点，然后在进行替换
      2) 比如: `<el-a><a>123</a></el-a>`中的`<a>123</a>`替换组件中的`<slot></slot>`标签
   4) `<slot></slot>`标签不会发生覆盖现象，也不会只替换最后一个
      1) 组件中有几个`<slot></slot>`标签，就替换几个
   5) 如果使用组件时，没有写html，则`<slot></slot>`标签替换为空
      1) 相当于直接删除，啥也不干



3. 具名插槽的使用
   1) 通过`<slot></slot>`标签，行间属性`name`，给`<slot></slot>`标签定义一个名称
      1) 随便定义
      2) 这样，`<slot></slot>`标签就变成了具名插槽，有名字了
   2) 具名插槽的name，与使用该组件时书写的html中，节点的slot属性，形成对应关系
   3) 把所有具有相同的`slot`属性的节点，替换与对应的`name`属性相同的`slot`标签
      1) 相当于把所有相同的具有相同的`slot`属性的节点，提取出来
      2) 然后替换，对应的`name`属性相同的`slot`标签
      3) 有几个替换几个
   4) 如果没有找到对应的`name`属性相同的`slot`标签，则不会进行替换
      1) 不会替换普通的插槽，直接舍弃掉了


4. 在js中使用传进来的插槽节点，即组件的html结构
   1) 通过`this.$slots`可以获取所有的插槽节点
      1) 包括具名插槽，普通插槽
   2) `this.$slots`获取的是一个对象，对象中的属性名就是插槽的名称
      1) 普通插槽的名称是: `default`
      2) 所以，普通插槽也是具名插槽，有默认的名称
   3) 每个插槽的属性值都是一个数组
      1) 不确定有几个符合的节点，所以把所有符合的节点提取出来，放入数组中
         1) 具名插槽根据`slot`属性提取，普通插槽提取没有`slot`属性的节点


5. 与`render`的联合使用
   1) 数组的每一项，是一个虚拟节点对象
      1) **可以直接作为，render函数的第三个参数中的节点，直接传入**
      2) 使用render函数接收的函数，也是创建的虚拟节点
      3) 所以可以直接使用，插槽节点
   2) `render`函数的第三个参数，可以传递数组，表示该节点有不止一个子节点
      1) 而插槽属性，对应的属性值，就是提取出的、对应的虚拟节点组成的数组
      2) 所以可以直接作为第三个参数，传入整个插槽节点数组
      



#### 解决组件间类样式冲突问题(style)
- 比如当前组件设置样式，选择的是 .demo。但是其他组件中也可能有.demo，这样就有可能对其他组件的demo造成css样式冲突
- 解决办法
  ```js
  <template>
    <div class="demo">123</div>
  </template>

  <script>
  export default {
  }
  </script>


  <style scoped>
    /* 加一个scoped，就行了 */

    .demo {
      color: red;
    }
  </style>
  ```
- 加上了 scoped，在打包的时候，该组件的每个元素都会加上一个组件唯一的属性
  - 组件中一样，组件间不同
- 选择器也会自定的加上对应的选择器（可以在浏览器上查看源代码）
  - 比如
    ```js
    <style>
      // ['data-v-3234q23'] 就是自动生成的组件唯一标示
      //    这样.demo就只能选中当前组件的demo了，与其他组件就无关了
      //    完美的解决了类样式冲突问题
      .demo['data-v-3234q23'] {
        color: red;
      }
    </style>
    ```


#### 组件之间的传参（行间属性传递）
- 父组件可以通过行间属性，向子组件传递一些数据
  - 子组件通过props属性，获取行间传入的数据
    - props有两种使用方式，一种是数组，一种是对象（可以用来数据验证）
  - 比如
    ```js
    const App = {
      // 获取父组件传递的行间属性（获取什么，就指定什么）
      props: ['a', 'b'],
      template: `<div>{{a}} {{b}}</div>`
    }
    new Vue({
      el: '#app',
      // 父组件向子组件传递参数
      template: `<App a="1" b="2" />`,
      components: {
          App
      }
    });
    ```
- 传递非字符串类型的数据或者状态、属性
  - 需要借助 v-bind: 指令，简写 :
  - 比如
    ```js
    const App = {
      props: ['a', 'b'],
      template: `<div>{{a}}</div>`
    }
    new Vue({
      el: '#app',
      data() {
          return {
              ds: 3
          }
      },
      // 只要加了: 则该属性后面的 "" 中写的就是表达式了，如果没有:，则写的就是一个字符串
      //    所以 :b="1"，传入的就是数字 1，而不是字符串 1
      template: `<App :a="ds" :b="1" />`,
      components: {
          App
      }
    });
    ```

- 扩展
  - 如果行间使用了某个属性进行传参，但是该属性没有在props中引入，则该属性就会在行间渲染出来
    - 比如父组件共传递了a、b、c三个属性参数，但是子组件就用了a、b两个属性
    - 则 c 就会在元素的行间渲染出来
    - 这样查看元素的时候就会感觉很奇怪，虽然没有什么影响
    - 比如：
      ```js
      const App = {
        // 传递了三个，但是获取了两个，则另一个就会在行间显示出来
        props: ['a', 'b'],
        // div是根组件，所以c就会在div上显示出来，具体样子为 <div c='3'>1 2</div>
        template: `<div>{{a}} {{b}}</div>`
      }
      new Vue({
        el: '#app',
        template: `<App a="1" b="2" c='3' />`,
        components: {
            App
        }
      });
      ```
    - 解决办法
      - 设置属性`inheritAttrs: false`
      - 比如：
        ```js
        const App = {
          props: ['a', 'b'],
          // 设置不展示多余的属性
          inheritAttrs: false,
          // 这样c就会消失不见，展示样子为 <div>1 2</div>
          template: `<div>{{a}} {{b}}</div>`
        }
        new Vue({
          el: '#app',
          template: `<App a="1" b="2" c='3' />`,
          components: {
              App
          }
        });
        ```

- $attrs的使用
  - 行间传参，但是没有被props引入的数据，会放在`$attrs`对象中
    - 这样，子组件就可以通过`this.$attrs`获取到剩余的，没有被props引入的行间传参
    - 比如
      ```js
      const App = {
        props: ['a', 'b'],
        // $attrs中，有两个属性c、d（a、b被props引入了）
        template: `<div>{{$attrs.c}}</div>`
      }
      new Vue({
        el: '#app',
        template: `<App a="1" b="2" c='3' d='4' />`,
        components: {
            App
        }
      });
      ```
  - 可以实现行间属性跨级传输
    - 比如：
      - A有子组件B，B有子组件C
      - A向B和C同时传递参数，但是B没有使用C的参数
      - 这样，正常情况下，就是B也通过props接受C使用的参数，然后在通过行间传递给C
    - 这样的后果就是**B中多了几个多余的props属性，并且B往C传递的行间参数要写很多（一个一个的写出来，过于麻烦）**
    - 这样的话，B组组件就可以使用`v-bind="$attrs"`，把$attrs对象中的数据继续向下传递（多余的属性，C用到的属性，传递下去）
      - 当然，如果某个属性B也使用了，C也使用了，就只能老老实实的单个传输了
    - 比如
      ```js
      const Demo = {
        props: ['b', 'c', 'd'],
        template: `<div>{{b}} {{c}}</div>`
      }
      const App = {
        props: ['a', 'b'],
        // 通过v-bind=$attrs，把多余的属性传到Demo中（Demo单独的属性）
        // :b="b"，把b也传到Demo中（两个组件共用的行间属性，只能单独传递，因为$attrs中没有）
        template: `<Demo :b="b" v-bind=$attrs />`,
        components: {
            Demo
        }
      }
      new Vue({
        el: '#app',
        template: `<App a="1" b="2" c='3' d='4' />`,
        components: {
            App
        }
      });
      ```
         
#### 行间属性传参的类型约定(数据验证)（只作用于开发阶段）
- **验证props传入的的数据参数，是否正确，以防胡乱传递**
- 作用：限制父组件，通过props向子组件所传参数的格式
- 如果不符合设置的格式，则控制台打印出错误，但是赋值正常
  - 只是给开发者起一个提示的作用


- 具体使用
  ```js
  Vue.component('my-component', {
    props: {
      // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
      propA: Number,
      // 多个可能的类型
      propB: [String, Number],
      // 必填的字符串
      propC: {
        type: String,
        required: true
      },
      // 带有默认值的数字（行间不传递，就使用默认值）
      propD: {
        type: Number,
        default: 100
      },
      // 带有默认值的对象（行间不传递，就使用默认值）
      propE: {
        type: Object,
        // 对象或数组默认值必须从一个工厂函数获取，不能直接赋值一个对象
        default: function () {
          return { message: 'hello' }
        }
      },
      // 自定义验证函数（只要返回true，就表示验证通过，返回false，验证失败）
      propF: {
        validator: function (value) {
          // 这个值必须匹配下列字符串中的一个
          return ['success', 'warning', 'danger'].indexOf(value) !== -1
        }
      }
    }
  })
  ```










#### 计算属性
- 作用：可以对某些值进行运算，然后得到一个新的渲染结果
  - 对原数据不会产生任何影响，和过滤器的作用差不多
- 组件的配置对象中，存在一个`computed`属性，该属性是一个对象
  - 该对象中的每一个属性，就是一个自定义的计算属性
- **计算属性的定义方式有两种**
  - 直接给计算属性赋值成一个函数，相当于对象赋值中的get方法
    ```js
    const App = {
        // 定义计算属性
        computed: {
            // 函数赋值
            comA: () => {
                console.log('计算属性A');
                return '123'
            },
        },
        template: `<div>
            {{comA}}
        </div>`
    }
    new Vue({
        el: '#app',
        template: `<App />`,
        components: {
            App
        }
    });
    ```
  - 给计算属性赋值成一个对象，对象中有两个属性可以使用，一个是get函数，一个是set函数（get是取计算属性时运行的函数，set是修改计算属性运行的函数）
    ```js
    const App = {
        methods: {
            setA() {
                // 只要一执行这个赋值语句，就会执行该计算属性的set方法
                //   相当于`Object.defineProperty`中的set
                this.comA = 3;
            }
        },
        // 定义计算属性
        computed: {
            comA: {
                get() {
                    return '计算属性'
                },
                set(d) {
                    console.log('计算属性发生了修改', d);
                }
            }
        },
        template: `<div>
            {{comA}}
            <button @click="setA">按钮</button>
        </div>`
    }
    new Vue({
        el: '#app',
        template: `<App />`,
        components: {
            App
        }
    });
    ```
    - 如果直接给计算属性赋值成一个函数，则修改是没有效果的
    - 如果赋值成一个对象，对象中有set方法，则修改计算属性，则会运行set方法，然后把赋的值作为参数传入
      - 当然，计算属性的值不一定发生变化，因为计算属性的值和set没有关系，和get有关
      - 除非set中修改了状态，然后触发了计算属性重新计算，才会发生变化
    - set和get配合使用，这样就可以通过计算属性，完全控制data中的数据
    - 相当于`Object.defineProperty`中的get和set


- **计算属性的使用**
  - 如果是vue执行程序中使用
      1) 和data中的数据使用方式相同，直接通过`this.计算属性名`使用
      2) 计算属性虽然运行的是一个函数，但是不能写成函数调用的形式
      3) 比如: `mounted() { console.log( this.a ) }`
  - 如果是vue模板中使用
      1) 和使用data中的数据相同，直接`计算属性名`
      2) 比如: `{{ a }}`


- **计算属性的特点**
  - 只有执行到需要计算属性的地方，才会执行计算属性对应的方法（或者get方法）
    - 比如解析模版 {{comA}}
    - **也就是说，计算属性对应的函数，并不是定义了就会执行**
  - 并且计算属性对应的函数，只会执行一遍，就会产生缓存
    - 如果计算属性的依赖（状态和props）没有发生变化，则下一次使用该计算属性的时候，就会从缓存中获取，而不是重新在执行一遍计算属性对应的函数（优化效率）
    - 比如
      ```js
      const App = {
          data: () => {
              return {
                  a: 'a'
              }
          },
          methods: {
              setA() {
                  // 引发重新渲染
                  this.a = 'a点击了'
              }
          },
          // 定义计算属性
          computed: {
              comA: () => {
                  // 由于没有依赖（依赖没有发生变化），则该打印在重新渲染的时候，就不会在执行了
                  console.log('计算属性A');
                  return '123'
              },
          },
          template: `<div>
              {{comA}}
              {{a}}
              <button @click="setA">按钮</button>
          </div>`
      }
      new Vue({
          el: '#app',
          template: `<App />`,
          components: {
              App
          }
      });
      ```
  - 虽然，计算属性定义的时候，是一个函数，但是使用的时候，不能写成函数调用，而是作为一个普通的属性使用
  - 计算属性重新执行的情况（依赖发生了变化）
    - 并不是依赖一发生变化，计算属性就会重新执行
    - 而是，依赖发生变化，会引发重新渲染，重新渲染的时候，解析到计算属性（获取计算属性值），在获取的时候，才会进行依赖的判断，如果发生变化，重新执行函数，如果没有发生变化则从缓存中获取
    - 即：如果计算属性没有被使用，即使依赖发生变化，也不会重新执行

- **注意点**
  - 由于计算属性存在缓存，所以尽量不要使用日期，随机数，异步函数。会造成数据不准确性

#### 预编译(打包)
- 作用：优化了效率
- Vue的渲染，利用的是虚拟dom。而虚拟dom的创建依赖的是render函数
- 如果没有render，就会利用模版解析器，解析template。然后产生对应的render函数，创建出对应的虚拟dom
  - 这个解析模版的过程是发生在执行过程中

- 但是脚手架就不一样了，由于存在一个打包过程，它就会直接把模版打包成对应的render（这个过程就是预编译）
  - 这样，在执行的时候，就不需要在解析模版了，缩短了时间
- 由于，打包后，项目中不存在模版了，所以脚手架在打包的过程中，就会舍弃掉模版解析器代码
  - 这也是脚手架中不能使用template属性的原因（打包的时候不解析该模版，打包后又没有模版解析器，所以templage无效）



#### 组件事件
- **事件的绑定**
  - 原始方式，借助ref，获取到dom，然后进行事件的绑定（不推荐使用）
  - Vue提供的事件绑定方式
    - 借助指令 v-on:。简写成@
    - 比如
      ```js
      <template>
        <!-- 完整写法 -->
        <button v-on:click="clickCall">按钮1</button>
        <!-- 简写 -->
        <button @click="clickCall">按钮2</button>
      </template>

      <script>
      export default {
        // 定义事件处理方法
        methods: {
          clickCall() {
            console.log('按钮点击了');
          }
        }
      }
      </script>

      <style scoped>
      </style>
      ```



- **事件函数的传参**
  - 事件函数默认接收一个参数event。
  - 但是，除了默认参数，还可以传递其它的数据
  - 要想传入其他数据，则事件函数，就需要写成函数调用的方式
    - 比如: `@click="func('aaa')"`
      - 会替换传入的默认参数，接收的第一个参数是默认值`"aaa"`
      ```js
      <template>
        <!-- 传入默认值a，和状态d -->
        <button @click="clickCall('a', d)">按钮2</button>
      </template>

      <script>
      export default {
        data: () => {
          return {
            d: 'd'
          }
        },
        // 定义事件处理方法
        methods: {
          clickCall(a1, a2) {
            console.log('按钮点击了', a1, a2);
          }
        }
      }
      </script>
      ```
    - 要想即传入自定义属性，又传入event对象，需要借助vue提供的`$event`。
      - 比如: `@click="func($event, 'aaa')"`  
        - 第一个参数接收event对象，第二个参数接收默认值`"aaa"`
        ```js
        <template>
          <!-- 传入默认值a，和事件属性集合 -->
          <button @click="clickCall('a', $event)">按钮2</button>
        </template>

        <script>
        export default {
          data: () => {
            return {
              d: 'd'
            }
          },
          // 定义事件处理方法
          methods: {
            clickCall(a1, a2) {
              console.log('按钮点击了', a1, a2);
            }
          }
        }
        </script>
        ```

- **事件函数内部的this指向**
  - 如果事件函数，定义的是一个箭头函数，则this指向undefined
  - 如果事件函数，定义的是一个普通函数，则this指向当前组件的实例对象
  - 比如
    ```js
    <template>
      <button @click="clickCall_a">按钮1</button>
      <button @click="clickCall_b">按钮2</button>
    </template>

    <script>
    export default {
      data: () => {
        return {
          d: 'd'
        }
      },
      // 定义事件处理方法
      methods: {
        // 箭头函数，指向undefined
        clickCall_a: () => {
          console.log('按钮点击了', this);
        },
        // 普通函数，指向当前组件的实例对象
        clickCall_b() {
          console.log('按钮点击了', this);
        }
      }
    }
    </script>
    ```
  - 要想获取到触发事件的dom，可以借助event对象上的target属性







- **组件上绑定事件的无效问题**
  - 组件元素，是Vue特有的东西，并不会真正的渲染到页面中
    - 比如：`<App />`，而App并不会真正的渲染，只是标记这个地方要插入一个组件
  - 由于组件元素不会渲染，所以上面绑定的事件，自然无效。
    - 比如：
      ```js
      <App @click="call" />
      ```
      - 点击App，click并不会被触发（无效果）
  - 要想使绑定的事件发生作用，需要加上修饰符`native`
    - 比如：
      ```js
      <App @click.native="call" />
      ```
      - 这样，这个click，就会绑定在组件的根元素dom上（往下自动移了一级）

- **组件内，获取组件dom上绑定的事件**
  - 通过`this.$listeners`可以获取事件对象
    - 事件名作为属性值，事件绑定的方法作为属性值
    - 比如
      ```js
      const App = {
          methods: {
              clickCall() {
                  // 打印：{click: ƒ}
                  console.log(this.$listeners);
              }
          },
          template: `<div>
              <button @click="clickCall">按钮</button>
          </div>`
      }
      new Vue({
          el: '#app',
          template: `<App @click="console.log(123)" />`,
          components: {
              App
          }
      });
      ```
  - **注意: 如果事件使用了native修饰符，则通过$listeners获取不到**



- **手动触发组件dom上绑定的事件**
  - 标准方法: `this.$emit("事件名", 传参)`
  - 直接取出事件函数进行调用: `this.$listeners.函数名(传参)`
  - 比如
    ```js
    const App = {
        methods: {
            clickCall() {
                // 触发组件dom上绑定的click事件
                this.$emit('click', 'a');  // 标准方式
                this.$listeners.click('a');  // 取巧方式
            }
        },
        template: `<div>
            <button @click="clickCall">按钮</button>
        </div>`
    }
    new Vue({
        el: '#app',
        methods: {
            clickCall(d) {
                // 打印参数（两次打印的都是 a）
                console.log(d);
            }
        },
        template: `<App @click="clickCall" />`,
        components: {
            App
        }
    });
    ```




- **组件内移用组件上的所有事件**
  - 把组件dom上的所有的事件原封不动的，在给其它标签和组件进行绑定
  - 借助的是`v-on`和`$listeners`。方法为`v-on="$listeners"`
    - 只要组件中的某个标签或者子组件的行间写上，上面的方法
    - 则该标签或者子组件，就会绑定当前组件上所有的事件
  - 该方式，可以实现组件间的事件函数的传递（父组件控制子组件中某个dom上绑定的事件）
    - 前提是组件上的事件没有使用修饰符`native`，要不然`$listeners`获取不到


- **扩展**
  - 事件的处理函数赋值，可以赋值成一个表达式
    - 如果写成一个表达式，则会自定在外侧包裹一个函数，作为事件函数
    - 当事件函数执行的时候，就会执行赋值的表达式了
  - 这也是事件函数的复制可以写成方法调用的原因
    - 但是并不是，调用函数，把返回值作为事件处理函数
    - 原因，就是外届包了一个事件函数，这样这个函数执行语句就不会执行了
      - 只有当事件处理函数执行的时候（外界自动包裹的函数），才会进行执行
  - 比如
    ```js
    <template>
      <!-- 写一个表达式，底层会自动变成 () => { console.log('a') }，把它转换成一个函数 -->
      <button @click="console.log('a')">按钮1</button>
      <!-- 这也是这个地方可以写方法调用的原因 -->
      <button @click="clickCall_b()">按钮2</button>
    </template>
    ```






#### 条件渲染

1. v-if和v-else和v-else-if控制显示与隐藏
   1) `v-if`和`v-else-if`必须写上条件判断，`v-else`不需要写条件判断
   2) 联合使用，`v-if`必须写在前面，其次后面跟`v-else-if`，最后写上`v-else`
      1) `v-if`和`v-else`只能使用一次，`v-else-if`可以使用多次，或者不使用
      2) `v-else`也可以不使用，如果使用，前面必须存在`v-if`或者存在`v-if`和`v-else-if`
      3) 中间不能插入其它的组件
   3) 就相当于js中的`if -> else if -> else`，使用规则相同，功能不同


2. v-show控制显示与隐藏
   1) 后面跟上判断条件就可以控制组件的显示与隐藏了


3. v-if和v-show控制显示与隐藏的区别
   1) v-if会彻底的销毁组件或者dom，即组件会启用销毁周期
      1) 下次满足条件后，会重新创建组件，是一个全新的组件，重新走生命周期
      2) 与key值存在密切的关系
      3) 在解析时，如果条件不满足，组件是不会被解析的，不会被激活
   2) v-show只是控制css样式的`display`为`block`还是为`none`，来控制组件的显示与隐藏
      1) 在解析时，所有的组件都会激活声明周期函数，即使组件隐藏，也会激活
      2) 然后把隐藏的组件的`display`设置为`none`
      3) 无法与key建立关系，因为组件并不会被销毁
      4) v-show无法使用到vue提供的辅助标签`<template>`上
   3) 如果是频繁的显示与隐藏，建议使用`v-show`，效率较高








#### 双向数据绑定

1. 作用
   1) 数据与用户操作进行绑定，可以获取用户操作的数据

2. 使用
   1) vue中提供了一个`v-model`指令
   2) 可以使用`v-model`指令的标签有
      1) `<input type="text">`
      2) `<textarea name="abc" cols="30" rows="10"></textarea>`  
         1) 多行文本输入框
      3) `<input type="checkbox" value="ss" v-model="arr">`      
         1) 复选框
         2) input上要定义好value
         3) 用于v-model绑定的数据，必须为一个数组，因为复选框可以选中多项
         4) 选中对应的input，把定义的value存放到数组中，取消选中，从数组中移除对应的数据
      4) `<input type="radio" value="hh" v-model="arr">`         
         1) 单选框
         2) 虽然单选框只能选中一项，但是v-model绑定的数据，也必须是一个数组
         3) 选中对应的input，把定义的value存放到数组中，取消选中，从数组中移除对应的数据
      5) `<select v-model="checkbox"> <option value="A">A</option> </select>`  
         1) 下拉菜单组件
         2) 下拉菜单的`v-model`绑定在父标签select上
         3) 子标签option上也提前定义好value。
         4) 当option被选中时，对应的value就会赋值给v-model绑定的vue数据
         5) 赋值方式不为数组

3. 原理
   1) 底层借助的是`v-bind:value="***"`和`input`事件相互配合实现双向数据绑定
   2) 并且v-model和@input事件没有冲突
      1) 事件是可以多次绑定的




#### 获取当前组件的配置对象
- 通过`this.$options`，可以获取当前组件的配置对象
  - 所以，通过`this.$options.?`，可以获取到配置对象中，自定义属性的属性值


示范代码
```vue
<script>
    export default {
        name: 'App',
        abc: "测试",
        beforeMount() {
            // 获取当前组件的配置对象
            console.log(this.$options);
            console.log(this.$options.abc);
        },
        data() {
            return {
                name: "张三",
                cla: "name",
                boo: true
            }
        }
    }
</script>
```





#### 侦听器
1. 作用
   1) 用来监听vue中data数据的变化
   2) 当数据发生变化时，即不影响原先的功能，然后添加附加功能


2. 创建侦听器
   1) 组件对象中，存在一个`watch`属性，属性值为一个对象
   2) 对象中的每一个属性，就是一个侦听器，属性值有两种格式
      1) 对象格式，常用属性
         1) `handler`: 属性值为一个函数，侦听器执行函数
         2) `immediate`: 属性值为布尔值
            1) 当`true`时，初始时，侦听器函数就执行一次
            2) 当为`false`时，初始时，侦听器函数不进行执行，相当于直接赋值函数
               1) 只有当侦听的数据发生变化，侦听器函数才会执行
         3) 比如: `watch: { name: {  handler(res) { }, immediate: true } }`
      2) 函数格式
         1) 函数接收一个参数，就是数据的变化值(新赋值的值)
         2) **在初始时，侦听器函数不会进行执行，只有侦听属性发生变化时才进行执行**
   3) 利用`$watch函数`创建侦听器
      1) 不像watch属性创建侦听器一样，利用函数可以动态创建侦听器
      2) 通过`this.$watch()`创建侦听器
      3) `$watch`函数的传参
         1) 第一个参数: 侦听器的名称，必须与侦听属性相同
         2) 第二个参数: 侦听器执行函数
         3) 第三个参数: 侦听器的配置对象
            1) 比如: `immediate`，就在该对象中进行设置
            2) 如果第三个参数没有传递，`immediate`默认为false
               1) 开始时不进行执行，只有侦听属性发生变化才进行执行
               2) 如果想要开始时执行一次，需要把对应的属性值设置为true
      4) 比如: `this.$watch("a", function (res) {}, { immediate: true })`
   4) 侦听器名称，需要与被侦听的数据相同。
      1) 比如侦听data中的a数据，侦听器的名称必须为a
   5) 侦听器函数，只有一个参数
      1) 初始时执行，传入侦听属性的初始值
      2) 侦听属性值变化时，传入新赋值的值
   6) 侦听器函数中，如果想要通过this读取到当前组件的vue环境对象，不能使用箭头函数


3. 注意事项
   1) 只有侦听的数据发生了变化，侦听器函数才会执行
   2) 哪怕使用`this.$set()`，强制重新渲染，只要数据没有变化，侦听器函数是不会触发的
      1) 与上次的值一比较，发现一样，侦听器函数就不会执行








#### 子组件获取父组件定义的数据

2. 子组件直接获取父组件的vue环境，然后获取父组件中的数据
   1) 通过`this.$parent`，获取父组件的vue环境对象
   2) 相当于父组件的this，这样就可以通过`this.$parent.?`获取到父组件中的某个数据
   3) 计算属性可以进行监管
      1) 比如: `computed: { aa() { return this.$parent.a } }`


3. 执行期上下文传递数据
   1) 没有层级限制，只要位于执行期上下文的环境中，就可以使用内部的数据
   2) 在组件中，通过`provide属性`创建执行期上下文。
      1) 比如: `provide: { a: 123 }`
   3) 某个组件创建了执行期上下文，则该组件的所有子组件都位于该上下文的环境中
      1) 子组件，要想使用上下文中的数据，通过`inject属性`进行获取
         1) 和props的使用方式一样
         2) 比如: `inject: ["a"]`
      2) 创建执行期上下文中的组件，是不位于该上下文中的
         1) 也就是不能通过inject获取上下文中的数据
   4) 创建执行期上下文的组件，是无法使用上下文中的数据的
      1) 要想使用，可以直接通过`this._provided.?`，是可以访问到上下文空间对象的
      2) 通过`this._provided.?`是无法造成，使用上下文数据的子组件的重新渲染的
         1) 直接通过inject取数据，然后{{}}中使用，是无法造成重新渲染的
            1) 相当于，取出数据，然后赋值给了某个属性，数据变化是不会重新赋值的
            2) props可以引发重新渲染，是父组件行间传参，建立的对应关系。
               1) 数据变化，根据对应关系，找到对应的组件，直接重新渲染
               2) inject是无法建立关系的，没有关系自然无法重新渲染
         1) 计算属性也无法进行重新渲染
   5) 子组件先从距离最近的父组件创建的上下文中取数据，如果没有，在继续向上查询         



#### 父组件获取子组件中的数据

1. 获取子组件的环境
   1) 当前的组件环境有一个`$children`属性，通过该属性可以获取到下一级子组件的vue环境
      1) 由于下一级子组件可能有多个，所以该属性是一个数组
      2) 数组的每一项对应一个子组件的vue环境对象
      3) 比如: `this.$children[0]`，获取第一个子组件的vue环境对象
   2) 无法进行跨级获取，如果想要进行跨级获取，需要进行`$children`的连用
      1) 比如: `this.$children[0].$children[0]`


2. 通过数据引用的方式，获取到子组件的数据
   1) 其实获取的也是下一级子组件的vue环境，类似$children
   2) 在vue的行间中，有这么一个属性`ref`
      1) 行间，通过`ref="ref名称，自定义"`，启用ref
      2) 比如: `ref="a"`
   3) 普通的dom，使用ref
      1) 通过`this.$refs.对应的ref名`。获取到的是该dom节点
   4) 组件，使用ref
      1) 通过`this.$refs.对应的ref名`。获取到的就是该组件对应的vue环境
   5) 注意同一个组件下，ref不要重复，否则发生替换
   6) v-for循环对应的ref比较特殊
      1) 由于，v-for循环产生对应的html结构，ref势必会相同
      2) 虽然相同，但是不会进行替换，而是把它们放在一个数组中
      3) 通过`this.$refs.对应的ref名`，获取到的就是一个数组
      4) 数组的每一项，对应循环产生的dom节点或者组件的vue环境对象



3. 通过函数传参的方式，获取子组件的数据
   1) 父组件中声明一个函数，然后把函数传入子组件中
   2) 子组件调用函数，把对应的数据传入，这样父组件就可以获取到子组件中的数据



4. 子组件通过手动触发组件上绑定的事件，向父组件传参
   1) 原理借助的还是函数传参
   2) 组件上绑定的事件可以是自定义的，也可以是原生的
      1) 绑定方式，比如: `<App @a="func" />`
   3) 子组件中，就可以通过`$emit()`方法，手动触发组件上绑定的事件
      1) 使用方式: `this.$emit(事件名, 传递的参数1，传递的参数2，··· ···)`
      2) 比如: `this.$emit("a", this.b)`
         1) 触发func函数，然后把b传入
   4) 子组件中，通过`this.$options._parentListeners`，可以获取到组件上绑定的事件函数
      1) 得到的是一个对象，对象的属性名为事件名，属性值为事件函数
      2) 这样就可以手动直接调用事件函数，进行传参，不用通过`$emit`进行触发
      3) 比如: `this.$options._parentListeners.a( this.b )`，但是有些麻烦
   5) 子组件中，通过`this._events`，可以获取到组件上绑定的事件函数
      1) 得到的是一个对象，对象的属性名为事件名，属性值为一个数组
         1) 数组中的数据为对应的事件函数
      2) 可以直接调用事件函数，进行传参，，不用通过`$emit`进行触发
      3) 比如: `this._events.a[0]( this.b )`，但是有些麻烦



#### 兄弟组件间的传参

1. 借助共同的父级
   1) 先把数据传入共同的父级中，然后共同的父级在把数据传入另一个组件中
   2) 过程过于麻烦


2. 利用事件总线的方式，实现兄弟组件间的传参
   1) 原理，在事件总线上绑定函数，然后其它的组件手动触发事件总线上绑定的函数，进行数据传递
      1) 类似事件传参
      2) 往事件总线上绑定函数，是在组件中完成的，利用组件上的一个方法。
      3) 创建一条事件总线，`Vue.prototype.自定义事件总线名 = new Vue()`
         1) 该条事件总线，就会贯穿整个组件
      4) 组件中，往事件总线上绑定方法
         1) 通过`this.总线名.$on("自定义事件名", 事件处理函数)`
         2) 如果事件处理函数中，需要使用this，获取到当前组件的vue环境对象
            1) 必须写成箭头函数的形式
            2) 如果使用function关键字定义的事件处理函数，则this指向有问题
               1) 指向的是创建事件总线时new Vue()，返回的vue环境对象
         3) 由于，事件处理只需要注册一次，所以通常周期函数`mounted`中注册
         4) 并且事件名可以重复，不会发生覆盖现象
            1) 会按照注册的顺序，全部触发
            2) 甚至多个组件中，都可以注册同一个事件名
            3) 触发的时候，多个组件中注册的事件函数，都会触发
            4) 只要是该事件名，全面触发
      5) 组件中，触发事件总线上绑定的事件，进行传参
         1) 通过`this.总线名.$emit("将要触发的事件名称", 传参, 传参, ··· ···)`
         2) 父子级间的传参，也可以使用事件总线的方式，进行传参
   



#### 父子级组件间的双向通信
1. 作用
   1) 父子级组件共用一个数据


2. 原理
   1) 父组件定义数据，然后通过行间传参的方式传入子组件中
   2) 同时在传入一个函数，子组件通过传入的函数，可以实现对父组件中的数据进行修改


3. vue中专门提供了一种方式
   1) 把传入函数与传入数据绑定在一起
   2) 即: `:b.sync="?"`
   3) `?`表示用来进行双向数据绑定的数据
   

4. `:b.sync`的原理
   1) 和v-model实现双向数据绑定的原理一样
   2) 使用的是绑定事件的方式
   3) 绑定的事件为: `update:b`
   4) 子组件要想修改`:b.sync`中绑定的数据，需要手动触发`update:b`事件
      1) 具体代码: ``this.$emit("update:b", 123)``



5. 借助`v-model`来实现父子级组件的双向数据通信
   1) 该方法给组件绑定的事件为`input`事件
   2) 子组件需要手动触发`input`事件，来修改绑定的数据
      1) 具体代码: `this.$emit("input", 123)`



#### 过滤器
1. 作用
   1) 改变将要展示的数据，对数据进行加工
      1) 比如`老马 -> 姓名: 老马`
      2) 实际对应的数据(data)，还是`老马`，数据不会发生变化

2. 原理
   1) 当渲染时，分析vue模板
   2) 当分析到具有过滤器符号的模板，就会触发定义的过滤器
   3) 把vue中的数据，传入过滤器中，**实际上，用于替换模板的数据，是过滤器的返回数据**
   4) 即: 本来是`老马`替换，现在变成了`姓名: 老马`替换。展示的自然为`姓名: 老马`
   5) 影响的是模板的替换过程
   

3. 触发环境
   1) **只有渲染时(初始渲染、重新渲染)，分析到过滤器模板，过滤器才会触发**


4. 过滤器的定义
   1) 局部过滤器
      1) Vue的传参对象中的`filters`属性，用于定义局部过滤器，属性值为一个对象
      2) 对象中的每一个属性，就是一个具体的过滤器，属性值为过滤器函数
      3) 比如: `filters: { abc() {} }`，abc就是一个局部过滤器
   2) 全局过滤器
      1) Vue有一个`filter`静态属性，用于定义全局过滤器，属性值为一个函数
      2) 调用一次函数，创建一个全局过滤器
         1) 第一个属性，传入过滤器器的名称
         2) 第二个属性，传入过滤器处理函数
      3) 比如: `Vue.filter("abc", () => {} )`，abc就是一个全局过滤器
   3) **如果全局过滤器与局部过滤器重名，优先使用局部过滤器**

5. 过滤器的使用
   1) `<div>{{name | a | b}}<div>`
      1) a、b为定义好的过滤器
      2) **过滤器函数默认接收一个参数**
         1) 第一个过滤器接收的是: 前面对应的vue数据(即name对应的数据)
         2) 后面使用的过滤器函数，接收的参数，是前面过滤器的返回值
            1) 相当于进一步加工
      3) 最终替换模板所使用的数据，是最后一个过滤器的返回值
         1) **渲染的是最后一个过滤器的返回值**
   2) `<div>{{name | a(1, 2) | b(3, 4)}}<div>` 
      1) **给过滤器传递其它的数据**
      2) 过滤器函数，默认接收一个参数，作为第一个参数
      3) 过滤器函数，接收的数据，从第二个位置开始，对应模板中传入的数据


6. 过滤器运行在重新渲染时，所以需要了解重新渲染机制
   1) 修改数据，不造成重新渲染，过滤器是不会运行的
   2) 使用$set，强制重新渲染，哪怕数据没有发生变化，都要重新渲染
      1) 只要重新渲染，就会分析模板，分析到过滤器，过滤器就会运行
      2) $set使用一次(处理使用过滤器的数据)，过滤器运行一次

















#### 指令—常用指令
1.  `v-pre`   禁止解析数据(正常情况下会对{{}}进行解析，但是给标签设置了v-pre就进行解析，直接展示{{}}这种形态)

2. `v-cloak`  vue加载时存在，解析完消失(配合css使用`[v-cloak] {   display: none;  }`, 可以避免加载过慢，产生从{{}}到正确数据的变换过程(效果不好))

3. `v-once`   对数据进行缓存，即使修改数据，页面刷新，也是从缓存中取数据(页面不会再发生变化)

4. `v-html`   通过`v-html="data"`，可以把data数据解析成html格式(正常情况下为字符串)。并且以data替换掉整个之前的innerHTML。

5. `v-text`   该指令就是插入文本元素，可以不使用{{}}，直接`v-text="属性名"`，就可以把数据插入到标签中，并且把之前的innerHTML替换掉。




#### 指令—自定义指令


1. 作用
   1) 使用简单的指令，实现复杂的功能，类似黑科技

2. 自定义指令的定义
   1) 全局
      1) 借助Vue的静态方法`directive`进行创建，传入两个参数
      2) 第一个参数传递`自定义指令的名称`，第二个参数传入`指令的处理方式`
      3) 第二个参数有两种赋值方式
         1) `传入一个对象`，对象中有三个属性，属性值都是函数，对应三个阶段的处理函数
            1) `bind`: 使用该指令的dom创建后，但是还没有插入页面时，触发该函数
               1) 只执行一次
               2) 由于对应dom还没有插入，所以实现不了input初始时自动聚焦
                  1) 聚焦的方式: `dom.focus()`
            2) `inserted`: 使用该指令的dom，插入页面后，触发该函数
               1) 只执行一次
               2) 由于对应的dom已经插入页面中，所以可以实现input的自动聚焦
            2) `update`:  当使用该指令的dom的innerHTML进行重新渲染时，触发该函数
               1) 只要重新渲染，该函数就会执行
               2）如果标签进行了重新构建，比如v-if或者key值不同，与之前的就没有关系了
                  1) 从新执行`bind和inserted`
         2) `传入一个函数`，相当于传入对象中的bind和update的合成体
            1) 创建没插入时执行一次
            2) innerHTML重新渲染时执行一次

   2) 局部
      1) 利用Vue使用时的传参对象中的`directives属性`，属性值为一个对象
      2) 对象中的每一个属性，就是一个自定义指令，`属性名为指令名，属性值为指令的处理方式`
         1) 指令属性值，也有两种赋值方式，与全局一样。一种为函数，一种为对象格式。


3. 自定义指令函数接收的参数分析
   1) 指令处理函数，一共接收三个参数。
      1) 哪怕是对象格式中的三个参数，在执行时也接收三个参数。
   2) `el`(第一个参数): 传入使用该指令的dom
   3) `bindings`(第二个参数): 传入该指令的一些基础信息，格式为对象，内部常用的有四个属性
      1) `arg`: 存放的是指令，`:后面，=前面`的一段字符串标记
      2) `value`: 存放的是指令，`=后面`在vue中的实际数据(数据赋值)
      3) `expression`: 存放的是指令，`=后面`的字符串(数据名称)
      4) `modifiers`: 存放的是修饰符的相关信息，格式为对象
         1) 修饰符的名称作为属性名，属性值为true
         2) 表示该修饰符已经启用，具体的功能在指令函数中进行判断创建
         3) 比如: {inn: true}，判断inn为true，执行相应的代码
   4) `vnode`(第三个参数): 使用该指令的虚拟节点信息，内部常用的属性只有一个。
      1) `context`: 指向的就是当前的vue环境


4. 示范代码
```js
Vue.directive("abc", {
    bind(el, bindings, vnode) {
        // 无法进行聚焦，没有效果
        el.focus();  
    },
    update(el, bindings, vnode) {
    },
    inserted(el, bindings, vnode) {
        // 可以进行聚焦
        el.focus();  
    }
})
```

5. 使用时，通过`v-自定义指令名`进行使用。


6. 注意
   1) 如果指令中，涉及到了数据变化，从而引发重新渲染，或者绑定一些事件
      1) 要使用对象的赋值方式，然后在bind中进行实现
      2) 如果使用函数的赋值方式，或者在对象模式中的update中进行实现
         1) 会操作死循环，或者事件重复定义





#### 修饰符
常用的修饰符有两种，一种是事件修饰符，一种是v-model使用的修饰符。

事件的修饰符(给事件的触发在加上限制条件)
比如:  `<input @keyup="func">`   只要键盘按下就会触发func事件
加上修饰符，比如: `<input @keyup.enter="func">`  当回车键按下时才触发func函数(多了一条限制条件)
`enter`也可以用对应的键值来替换`<input @keyup.13="func">`。   键值就是`keyCode`

**给键盘修饰符起个别名**
```html
<input @keyup.a-b="func">
<script>
    Vue.config.keyCodes = {
        // 不支持小驼峰式的写法，也就是不能写成aB。要写成a-b
        "a-b": 13   //给键值为13的按键起一个别名(回车键)
    }
</script>
```


v-model修饰符
1. `v-model.lazy`    当输入框失去焦点时，才改变vue中的数据
2. `v-model.number`  当输入框输入的是纯数字时，vue获取的是number类型的数据(正确情况下获取的都是string类型的数据)
3. `v-model.trim`    当输入框中输入的内容两侧存在空格时，vue获取的数据去除两侧的空格(不影响展示样式，input中的空格依旧存在)
    


#### 列表渲染
1. 作用
    1) 遍历vue中的一个数组，生成对应的html模板结构，渲染vue数组中的数据
    2) 可以快速书写出大量相同结构的HTML结构

2. 遍历方法
   1) 借助vue中的`v-for`指令实现遍历，需要`key`的配合
   2) 比如: `v-for="(item, index) in arr" :key="index"`
      1) item对应arr数组的每一项的数据
      2) index为对应的数组索引
      3) v-for内部的模板就可以使用item和index，渲染对应的数据
   3) 如果只使用数据，不使用索引，可以把`()`省略不写
      1) 比如: `v-for="item in arr" :key="item.id"`

3. 与v-for循环配合使用的还有一个`template`标签
   1) 该标签在实际渲染的时会消失，起一个辅助的作用
   2) 通常用于，父级节点使用v-for进行遍历，但是真实的dom结构中，该父级节点并不存在
   3) 需要注意，`key`必须要加在实际展示的标签上
      1) `template`标签不能使用key值，但是v-for必须借助key的辅助
      2) 所以只能加在`template`标签下的第一级子标签上，每个标签都需要进行添加
      1) 所以，为了保持每一个子节点的key都不相同，通常拼接一个后缀
         1) 比如: `<div :key=" 'key.id + a' "> {{ key.name }}</div>`



#### key


1. 作用
   1) 为了优化重新渲染时的渲染效率
   2) 复用节点


2. 具体表现
   1) 当数据发生变化，又有可能引发重新渲染。
   2) 此时就可能涉及到了组件或者dom的创建与销毁
      1) 比如使用v-if，涉及到了组件或者dom的销毁与创建
   3) 如果销毁的组件或者dom，与将要创建的组件或者dom
      1) **定义的key相同，并且dom名或者组件名相同，并且位于同级**
      2) 三个条件都满足，就会产生dom或者组件的复用，即不在创建新的
   4) 组件节点使用key的表现形式
      1) 如果进行复用(满足上方的三个条件)，复用的是组件环境，即数据还是之前的数据
      2) 此时，如果组件进行过重新渲染(更改数据引发的)
      3) 由于环境被复用，所以，展示的还是重新渲染后的样式，并没有复原
      4) 如果涉及了`slot`的使用，并且新组件与复用的不同。相当于innerHTML不同
         1) 节点复用，并不涉及`innerHTML`，即`innerHTML`依旧进行判断，如果相同，继续复用
         2) 如果不同进行替换
         3) `slot`的使用会进行更新，不会继承复用环境中的`slot`，如果相同继续复用(优化效率)
      5) 如果没有进行复用，之前的组件就会进行卸载，然后创建新的组件
         1) 会还原成初始的状态，组件是新创建的，是一个新的环境，所有的数据都是初始数据
   5) 普通节点使用key的表现形式
      1) 如果进行复用(满足上方的三个条件)，复用的是dom节点
      2) innerHTML是不会进行复用的，需要继续判断
         1) 如果dom名相同，继续复用，如果标签名不同，创建新的
            1) 然后继续判断dom中的innerHTML
         2) 如果文本内容相同，继续复用，如果文本内容不同，创建新的
         3) 如果旧的多余，进行卸载，如果旧的没有，进行创建
      3) 不会整个结构都进行复用
         1) 只复用当前节点，html结构由节点树构成，复用的是枝杈的头
         2) 枝杈会继续判断
            1) 如果相同，才继续复用
            2) 如果不同，创新新的，替换旧的
         3) 这样，即保证了效率，又保证了与实际相符
   6) 所以，key用于复用节点，而不是复用整个结构


3. `v-for`指令必须配合`key`的使用
   1) `v-for`，涉及到了大量的节点的创建与销毁
      1) 数据发生变化，循环就会重新执行
      2) 此时如果没有key的辅助，所有的节点都会重新生成，大量浪费效率
   2) `key`的值最好不用使用index
      1) 如果使用index作为key值，每次循环都会进行复用
      2) 如果循环过程中，某个节点需要重新创建，index是无法进行操作的
      3) 如果使用其他数据作为key值，是可以进行动态控制的


4. `key`必须加在实际的标签上，`template`标签不能使用key值，它不参与渲染







#### 生命周期
1. 初始化以及初始渲染阶段
   1) 初始化vue
   2) 初始化完成后，执行周期函数`beforeCreate`
   3) 初始化自定义的数据(data)
   4) 初始化完成后，执行周期函数`created`
      1) `this`指向正常，可以操作`data`的数据，可以进行`ajax`请求
   5) 查看是否有el，$mount。
   6) 获取模板
      1) 获取自定义的模板: 即`template`
      2) 获取默认模板，即`el.outerHTML`
   7) 创建虚拟节点
      1) 使用render创建
      2) 根据模板创建
   8) 虚拟节点创建完成后，执行周期函数`beforeMount`
   9) 根据虚拟节点创建真实的节点
   10) 真实节点创建完成后，执行周期函数`mounted`    (通常发送ajax请求)
   11) 把真实的节点进行插入


2. 重新渲染阶段
   1) 当重新渲染前的时候，执行周期函数`beforeUpdate`
      1) 可以修改`data`中的数据
      2) 由于重新渲染时异步的，此时还没有重新渲染完成
      3) 修改数据，不会再次引发重新的渲染的过程
   2) 当重新渲染完成时，执行周期函数`updated`  
      1) 不能修改`data`中的数据
      2) 由于此时重新渲染完成
      3) 再次进行修改的话，会再次触发重新渲染流程，陷入死循环


3. 销毁阶段
   1) 当前组件不在重新渲染，触发销毁生命周期，比如`v-if`，`v-show`无法触发销毁周期
   2) Vue销毁前，执行周期函数`beforeDestroy`
      1) 通常用来消除vue中使用到的定时器
   3) Vue销毁完成，执行周期函数`destroyed`  




#### 使用webpack工具进行vue的开发

1. vue工作的入口是: `new Vue()`，就会进行模板的解析与替换

2. 需要借助的插件
   1) `vue`: 提供vue构造函数
   2) `vue-loader、vue-template-compiler`: 用于解析`.vue`为后缀的文件
      1) 如果不涉及vue为后缀的文件引入，这两个插件不需要下载。
         1) 配置文件中也不需要配置对应的代码
      2) **原理(vue模块化开发的原理)**
         1) 浏览器是不认识以vue为后缀的文件的，所以需要时webpack工具进行打包
            1) 借助loader，把以vue为后缀的文件进行代码替换
         2) 把以vue为后缀的文件，解析成对应的一个模块对象
         3) 就是Vue传参对象中components属性，定义的模块对象
         4) 当使用`import或者request`引入以vue为后缀的文件时，得到的就是模块对象
            1) loader对以vue为后缀的文件中的代码进行了重写
            2) 把原先的代码解析成对应的模块对象，然后把模块对象进行抛出
            3) 比如: `const obj = {};  export default obj;`
            4) 初次引入以vue为后缀的文件，运行的就是替换代码，然后得到模块对象
            5) 之后，就是从缓存中取模块对象


3. 配置文件代码
```js
const VueLoaderPlugin = require("vue-loader/lib/plugin");
module.exports = {
    entry: "./src/index.js",
    mode: "development",
    output: {
        path: __dirname + "/dist",
        filename: "index.js"
    },
    module: {
        rules: [
            {
                test: /\.vue$/,
                use: ["vue-loader"]
            },
        ]
    },
    plugins: [
        new VueLoaderPlugin()
    ],
    resolve: {
        alias:  {
            vue: "vue/dist/vue.js"
        }
    }
}
```



