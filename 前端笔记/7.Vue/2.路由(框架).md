<script src='/笔记/see/index.js'></script>
[toc]


#### 路由的下载
1. **脚手架下载方式**
   1. `vue add router`
2. 自定义webpack中使用路由的下载方式
   1. `npm i vue-router -D`
   2. 路由的使用需要借助服务器，所以在开发阶段，需要配置服务器
      1. 下载服务器: `npm i webpack-dev-server -D`
      2. 配置服务器: `devServer: { contentBase: "dist" }`



#### 路由配置
1. 需要通过 `Router` 构造出路由对象（**通常在一个单独的文件中构建，然后抛出路由对象**）
2. `Router`构造函数，在使用的时候，需要传入一个对象，该对象，就是路由的配置对象
3. 具体的配置示范代码如下
```js
import Vue from "vue";
import Router from "vue-router";

// 激活Router组件
// Router.install(Vue);
Vue.use(Router);

// 导出路由对象(根据传参创建的对象)
export default new Router({
    // 开启浏览器历史模式
    mode: "history",
    // 路由信息
    routes: [
        {   
            // 父路由信息
            path: "/a",
            component: ?,
            // 子路由信息
            children: [
                {
                    path: "/a/c",
                    component: ?,
                }
            ]
        }
    ]
})
```



4. `Vue.use(Router)`的作用
   1) 激活Router
   2) 创建两个组件
      1) 底层运行`Router.install(Vue)`;
      2) 传入Vue，使用传入的Vue创建全局组件
      3) 模板中可以直接使用`router-link`和`router-view`组件
      4) 并没有在对应的组件中使用`components属性`定义这两个组件








#### 把配置的路由，导入项目中
1. Vue的传参对象中，存在一个`router属性`，该属性的赋值对象就是路由对象
    1. 导入路由对象: `import router from './router.js'`
    2. 使用路由对象: `router: router`
    3. `router属性`向vue环境对象中添加了两个属性
        1. `$router属性`，通过该属性，可以访问到赋予的`router对象`
        2. `$route属性`，通过该属性，可以访问到赋予的`router对象`中的`currentRoute对象`
        1. 即`$route = $router.currentRoute`
        2. 由于该对象使用频繁，所以单独的封装了一个索引
        3. 这两个属性，在vue中，可以通过`this`的方式调用
    4. 由于`router属性`赋值后，在初始化时，需要使用赋值对象中的一些方法
        1. 所以，只能赋值路由对象，赋值其它对象报错





#### 普通路由对象的分析与使用

1. 分析创建路由对象的传参(Router的传参对象)
   1) `routes属性`对应的数组中的每一个对象，就是一个路由信息对象
   2) 路由信息对象中的常用属性
      1) 其中，`path属性`，设置的是路径匹配规则，格式是正则
         1) 匹配成功，就会创建对应的组件节点，进而渲染组件
         2) 匹配失败，对应的组件不显示
         3) 类似于组件的显示与隐藏，控制条件为路径是否匹配成功
         4) **如果`path`属性，设置为`"*"`，则所有的路径都可以匹配成功**
            1) **path为"*"的路由信息对象，必须放在最后，否则影响巨大**
      2) `name属性`，该属性不是必须设置的一个属性，作用为给当前路由对象起一个名字
      3) `component属性`，设置的是匹配成功，加载的组件，两种赋值方式
         1) 先引入对应的组件对象，然后直接赋值
            1) 引入组件: `import A from "./A.vue"`
            2) 直接赋值: `component: A`
         2) 当第一次匹配成功后，对应的组件才进行加载，被称为按需加载
            1) 按需加载: `component: () => import("./A.vue")`
            2) 经过打包后，其实对应的文件代码已经打包进来了，只不过没有运行
               1) 如果一开始加载所有的组件，浏览器一打开页面，所有的组件代码就会运行一遍
               2) 而按需加载，是当需要时，才运行对应组件中的代码，节约一部分性能
               3) 运行完，就会进行缓存，即组件代码只运行一次
      4) `children属性`，定义子路由的信息
         1) 属性值为一个数组，数组的每一项，为一个子路由信息对象
         2) 子路由信息对象，与父路由对应的组件密切相关
      5) `redirect属性`，进行重定向的设置


2. **路由匹配成功，加载对应组件的规则**
   1) 路由对应的组件，加载的位置与`<router-view />`标签密切相关
   2) Vue在解析模板，构建对应的虚拟节点时
      1) 如果遇到了`<router-view />`标签，就会与当前的路径进行匹配
      2) 匹配规则: 
         1) **此时解析的模板，并不是路由组件，而是基础组件**
         2) 所以，`<router-view />`使用的匹配`path`，是所有一级路由中的
         3) 那个`path`匹配成功，就会在该位置显示对应的组件
         4) 比如: 匹配成功路由对应的组件为`A`，此时`A`组件就会加载
         5) 相当于把`<router-view />`替换成`<A />`，在该位置显示该组件
         6) 解析时，不受层级的限制
         7) 即使是子组件中的`<router-view />`也使用一级路由中的`path`进行匹配
      3) 每一个`<router-view />`，都会进行匹配，匹配成功就会在该位置加载对应路由组件
      4) **路由匹配成功，开始解析路由组件模板**
         1) 如果解析到了`<router-view />`标签，也会进行匹配
         2) 匹配规则: 按照`该组件对应的路由信息对象中的子路由信息`中的`path`进行匹配
         3) 匹配成功，把`<router-view />`替换成，匹配成功的子路由对应的组件，进行加载
         4) 组件加载完成继续分析子路由对应的模板，处理`<router-view />`标签
         5) 每一个`<router-view />`，都会进行匹配，匹配成功就会在该位置加载对应路由组件
         6) 解析时，不受层级的限制
         7) 即使是子组件中的`<router-view />`也使用子路由对象中的`path`进行匹配
      5) **所以: 子路由组件的显示位置，由父路由组件中的`<router-view />`标签控制**
      6) 某一个`<router-view />`匹配成功，就会加载对应的路由组件，然后进行分析
         1) 如果路由组件中，还存在`<router-view />`匹配成功，继续加载路由组件，继续分析
         2) 直到，匹配不成功，或者没有`<router-view />`，就没有对应的路由组件加载
         3) 然后，才会继续向下分析，如果又遇到了`<router-view />`，继续匹配加载分析
   3) 通常`<router-view />`写在根组件中，并且只写一个，便于管理分析
      1) 如果隐藏在子组件中，工程一庞大起来，后期调换`<router-view />`
      2) 不容易找到其所在的组件位置


3. `path`匹配的注意点
   1) vue中path的匹配都是完全匹配
   2) 如果当前路径被子路由匹配成功，则子路由的父路由组件也会进行加载
      1) 此时，父组件不遵循完全匹配
      2) 如果，父组件遵循完全匹配，子路由对应的路径，父路由一定匹配不上
      3) 如果，父路由匹配不上，则对应的父路由组件不会进行加载
      4) 父路由组件不进行加载，无法提供子路由组件显示位置的`<router-view />`
   3) 父路由组件的显示位置，由该路由的父级路由组件中的`<router-view />`控制
      1) 如果没有找到`<router-view />`，路由组件就不会进行加载，造成子路由组件也无法加载
      2) 如果是一级路由，没有父级路由，则由基础组件中的`<router-view />`控制显示位置
   4) 如果有一个路由的`path`，就不在进行向下匹配
      1) 所以`path: "*"`号的使用，只能最后，当前面的所有路由都匹配失败，该路由匹配成功
      2) 如果，放在前面，则无论是什么路径，它都能匹配成功，然后立刻停止匹配
      3) 则下方所有的路由对象都失效，对应的路由组件也不会被加载


4. 多级路由的path设置的注意点
   1) 必须要写全: 比如: `path: /a/b/c`
   2) 即必须以`/`开头，如果没有`/`开头会进行路径的拼接
   3) 拼接方式: 前面拼接上父路由设置的`path`，然后加上`/`，然后拼接上当前路由设置的`path`
      1) 比如: 父路由设置的`path`为`/a`，子路由设置的`path`为`b`
      2) 最终: 子路由的`path`会变成`/a/b`，进行拼接



#### 路径的跳转
   
1. 作用
   1) 只是单纯的实现跳转路径
   2) 但是路径只要发生变化，就会自动触发路由的重新匹配，相当于对路径进行了监听

2. 跳转路径的方式(无刷新跳转)
   1) 通过js跳转
      1) 创建的路由对象中，它的原型上，有一个`push`方法
         1) 通过该方法就可以实现路径的无刷新跳转
         2) `push方法`的实现原理
            1) 该方法是重写后的方法，并不是浏览器元素的`push方法`
            2) 底层也没有进行过多的处理，只是进行判断，当不符合条件时，抛出一个错误
            3) 当没有问题的时候，调用`this.$router.history.push方法`进行路径的实际操作
            4) `this.$router.history.push方法`也是进行重写的方法
               1) 底层借助浏览器的`push`方法实现路径无刷新跳转
               2) 在原有的无刷新跳转页面的基础上，重启路由的匹配
      2) 由于路由对象，赋值给了`router`属性
         1) 所以在js中就可以通过`this.$router`访问到该对象
         2) 从而使用`push`方法，进行路径的无刷新跳转
         3) 比如: `this.$router.push("/a")`
         4) 也可以借助: `this.$router.history.push方法`进行跳转
         5) `this.$router.push`的底层借助的就是该方法
   2) 通过点击组件跳转
      1) 组件的使用: `<router-link to="?">a</router-link>`
      2) 当点击该标签后，路径跳转到`to属性`设置的值
      3) **该标签默认解析成`a标签`，可以通过`tag属性`指定创建什么标签**
         1) 比如: `<router-link to="?" tag="li">a</router-link>`
      4) 原理
         1) 绑定一个`click事件`，阻止a标签的点击默认刷新页面的默认功能
         2) **事件处理函数中，还是借助`this.$router.push()`实现**
         3) `push`方法的传参，就是to的属性值，原封不动的传入进去
      5) to的赋值方式
         1) to有两种赋值方式，一种为字符串格式，一种为对象格式
            1) 字符串格式: `<router-link to="/a">a</router-link>`
            2) 对象格式: `<router-link :to="{{name: 'a'}}">a</router-link>`
               1) 跳转路由，关键的是`path`，`name`没有用处
               2) 但是会根据name对应的值，找到路由数据中对应的`path`值，然后进行跳转
               3) 直接使用path: `<router-link :to="{{path: '/a'}}">a</router-link>`
         2) to的属性值会作为`push`的参数传入
         3) `push`的传参方式有两种，所以`to`的赋值方式也有两种
         4) **如果to赋值为对象格式，to必须写成`v-bind:to`或者`:to`**
      
      


#### 动态路由的配置方法

1. 动态路由的path设置方式
   1) 借助`:`，完成动态路由的匹配
   2) 比如: `path: "/dong/:id/:c"`
   3) 只要是`/dong/?/?`的路径，都可以匹配成功，加载对应组件，`?`表示任意字符串

2. 把路径跳转到动态路由的方式
   1) 使用组件`<router-link to="?"></router-link>`进行跳转
      1) 比如: `<router-link to="/dong/a/d">`
      2) 动态路由中的to，如果采用对象格式的赋值方式
         1) **如果使用path，则path要写全，此时的params不起作用**
            1) 已经有path属性了，不会在重新构建
            2) 比如: `<router-link :to="{ path: "/dong/a/d" }">`
         2) 如果使用name，会进行比较特殊
            1) 取出对应的path，然后进行替换
            2) 比如: `<router-link :to="{ name: "a" params:{id: 'a', c: 'd'} }">`
            3) 根据name取出对应的path值，发现为`"/dong/:id/:c"`
            4) 此时，就会使用params中的数据，进行对应的替换
            5) 替换完的path变成: `"/dong/a/d"`
            6) 然后使用替换完的path，进行跳转



3. 动态路由加载的组件中获取动态路径的方法
   1) 获取设置的path，对应的带`:`的字符串，表示这是动态的路径
   2) 通过`this.$route.params.?`，可以进行获取
      1) 比如: `this.$route.params.id`
      2) 比如: `this.$route.params.c`
      3) `this.$route`对象，是`this.$router`对象中的一个属性指向的对象
         1) 为了便于使用，单独提取出来的
   3) 根据不同的路径，显示不同的组件内容


4. 获取动态路由的注意点(重点)
   1) 由于动态路由加载的都是同一个组件，如果路径切换完，动态路由还是可以匹配成功
   2) 此时虽然路径，发生了变化，但是路由组件不会重新加载，触发的也不是重新渲染
   3) 如果在mounted中获取动态路由，进而加载不同的组件内容，就会出现问题
      1) 一开始，组件激活，可以正常获取到动态路由，可以正常的进行判断处理
      2) 但是路径切换，此时的动态路由已经不符合条件，应该加载另一个符合条件的组件内容
      3) 但是发现，组件内容不会发生变化，原因就在于，组件没有重新加载
   4) **所以动态路由的获取，不光在`mounted`中获取，也需要在`beforeRouteUpdate`获取**
      1) 当前组件的环境依旧存在，但是路径发生了变化，`beforeRouteUpdate`函数就会执行
         1) 初次进入，`beforeRouteUpdate`函数不会执行，此时环境刚激活
         2) 激活后，路径并没有发生变化，所以`beforeRouteUpdate`是不会执行的
         3) 路径发生变化，但是匹配失败，组件进入卸载周期
            1) 环境都即将卸载，`beforeRouteUpdate`也是不会执行的
         4) 下次匹配成功，重新激活组件，是一个全新的环境
            1) 环境是一个新环境，初次进入，`beforeRouteUpdate`也是不会执行的
   5) `beforeRouteUpdate`使用的注意点
      1) 该方法共接收三个参数，前两个参数都是对象
      2) 只有第三个参数是一个函数，只有调用该函数，路径才允许发生变化
      3) 比如: `beforeRouteUpdate(to, from, next) {  next();  }`




#### 重定向
 
1. 在Router构造函数的传参对象中的路由参数对象中，借助`redirect`属性进行配置

2. 具体的配置方式
   1) `redirect`属性有两种赋值方式
      1) 字符串
         1) 比如: `redirect: "/a"`
      2) 函数
         1) 比如: `redirect: (to) => { }`
   2) 当对应的路由匹配成功，重定向到`redirect属性`设置的路径
      1) 如果是函数赋值，则匹配成功，执行函数，并且传入当前的路径对象
      2) 然后函数运行的返回值，作为重定向的地址
      3) 传参对象中，存在一个`path`属性，通过该属性，可以获取到当前的路径
         1) 这样就可以根据当前的路径，进行动态的重定向，不用一次写死
   3) **函数赋值，通常用于`path: "*"`路由参数对象中**
      1) 这种path，所有的路径都可以匹配成功，即每个路径都会运行一次重定向函数
         1) 这样才能动态的判断`传参对象中的path属性`，实现动态重定向
      3) 如果写在path为固定值的路由参数对象中
         1) 每次匹配成功，运行重定向函数，得到的`传参对象中的path属性`都是一个值
         2) 其它值匹配不成功，重定向函数不会运行
         3) 这样的话，每次运行得到的返回值都相同，直接采用字符串赋值即可
         4) 除非有一些其它的处理，必须使用函数式赋值

3. 使用`path: "*"`进行重定向匹配的注意点
   1) 路由参数对象必须放在最后
   2) 重定向后的路径，在该路由参数对象的上面必须存在可以匹配成功的路由
   3) 如果上方不存在匹配成功的路由，会陷入重定向的死循环
      1) 上方匹配失败，被`path: "*"`匹配成功，重定向到另一个路径
      2) 底层借助的是`history.push`方法完成的路径跳转
      3) 跳转后，就会重新进行匹配，如果上方没有定义可以匹配的路由
      4) 又会被`path: "*"`匹配成功，继续跳转，继续匹配，陷入死循环
   4) 如果匹配成功，匹配终止，`path: "*"`不进行匹配，也就不会陷入重定向死循环了


4. 通常使用`path: "*"`进行重定向匹配，加载404页面
   1) 上方的所有路由，都匹配失败，表示没有该路由
   2) 然后`path: "*"`匹配成功，重定向到一个路径中
   3) 重定向的路径，在上方有定义，匹配成功，加载404组件
   4) 重定向到404的示范路由参数对象
   ```js
   {
       path: "*",
       redirect: (to) => {
           console.log(to);
           // 处理根路径的重定向和404的重定向
           if(to.path === "/"){
               // 该路径对应的路由参数对象，加载初始路由组件
               return "/home"    
           }else {
               // 该路径对应的路由参数对象，加载404路由组件
               return "/404"  
           }
       }
   }
   ```



5. 进行重定向的路由数据对象，不用写component，引入对应的组件
   1) 永远也不会进行显示
   2) 匹配成功，就进行重定向，然后重新匹配，加载其它的组件







