

1. 如果一个文件非常大，一次性读取出来，内存是抗不住的，此时就需要流来进行解决
2. 数据流，就是数据从一个地方，流向另一个地方， 比如从文件流向内存。
3. 借助流，我们就可以一次只获取一部分




#### 创建一个可读流
1. `const f = fs.createReadStream(路径，配置对象)`
   1. 配置对象中，常用的属性有
      1. `encoding`: 设置编码格式，如果不设置，读取的是Buffer，也就是字节数据
      2. `highWaterMark`: 设置每一次读取的数量，默认一次读取`64kb`的数量，也就是 `64 * 1024` 个字节或者字符
         1. **这个值设置的不是一次读取多少 `kb`，而是设置的，一次读取多少个字节或者字符**
         2. 如果 `encoding` 设置的是 `utf-8`，则 `highWaterMark` 设置的是一次读多少个字符
         3. 如果 `encoding` 为 `null`(默认值)，则 `highWaterMark` 设置的是一次读多少个字节
      3. `autoClose`: 设置，读取完成后，是否自动关闭，默认为 `true`
         1. 通常不进行设置，如果设置为false，读取完成后，不进行关闭，该文件是无法删除的，**产生文件删除不了的问题**
   2. 该函数的返回值
      1. 内部有很多事件，可以通过返回值，注册对应的事件处理函数
      2. 通过 `on` 注册事件，即 `f.on(事件名，事件处理函数)`   
      3. `open`事件，文件被打开的时候，触发对应的函数
      4. `error`事件，读取数据的时候出现错误，触发对应的函数
         1. 流是一部分一部分的读，只要某次读取出现问题，该事件就会触发
      5. `close`事件，文件关闭的时候，触发对应的函数
         1. 可能手动关闭，可能自动关闭。手动关闭通过 `f.close()` 实现。
         2. 自动关闭，文件全部读取完成，就会自动关闭（受配置对象中一个属性控制）
         3. 只要关闭，该事件就会触发
      6. **`data`事件，该事件，每一次读取成功后，就会触发。并且事件函数可以接受到本次读取的数据**
         1. 该事件，不进行注册，流是不会进行读操作的，文件只是单纯的被打开
         2. **只有注册了该事件，才会开始读文件，直到读取完成**，也就是这个事件会一直触发，直到读取完成
      7. `end`事件，数据全部读取完成后，该事件触发。并且先触发 `end` 在触发 `close`
      8. `pause`事件，暂停读取的时候，触发该事件
      9. `resume`事件，恢复读取的时候，触发该事件
   3. `f.pause()`，暂停读取
   4. `f.resume()`，恢复读取
   5. **`f.pipe(x)`，把读出的数据，写到另一地方**
      1. x为创建的输出流，该方法解决了写入的时候，产生的背压问题
      2. `pipe` 方法的底层原理
         1. 使用 `x.write` 写入的时候，如果返回`false`，说明已经满了
         2. 执行 `f.pause()` 停一会，当 `w` 的 `drain` 事件触发后，说明已经写完了
         3. 执行 `f.resume()`，恢复读取。然后进行判断是否产生背压