<script src='/笔记/see/index.js'></script>
[toc]


#### 概述

1. **ECMAscript、Javascript、nodejs之间的关系**
   1) ECMAscript简称ES，它是一种语言标准
   2) Javascript可以理解为ES + WebAPI构成的
   3) nodejs可以理解为ES + nodeAPI构成的
   4) ES就是一种语言标准，只要提供环境，就可以运行。


2. **几个著名的ES版本**
   1) ES3。1999年提出的
   2) ES5。2009年提出的
   3) ES2015(即ES6)。2015年提出的，后来ES版本都是以年号命名
   4) ES4由于种种原因，没有发布。


3. **ES发展史**
   1) 从ES3到ES5大概经过了十年的间隔时间，在这段时间内由于种种原因，ES(JS)无法得到发展的机会
      1) 硬件、技术(模块化)的限制
   2) 由于ES的创建时间比较短，所以存在很多漏洞。
   3) 经过十年时间的沉淀，暴露出了非常多的问题
   4) 2008年，v8引擎的出现，以及nodejs的诞生，使ES迎来了发展机遇
   5) 经过大量的修整，推出了ES5版本。但是由于时间过短，所以ES5并没有真正的解决ES中的很多问题
   6) 直到经过了6年的沉淀，推出了震撼的ES6版本，内涵模块化思想。
   7) ES6的推出，使ES具备了编写大型应用程序的基础








#### let、const

1. **作用**
   1) 用来声明变量
   2) 声明的变量不会进行提升（下面声明的变量，上面不能先使用，否则报错，要先声明在使用）
   3) 不可以声明相同名称的变量(不会发生替换现象，报错)
   4) 在块级作用域中可以形成封闭作用域的效果
   5) 可以完善循环的闭包问题(变量提升问题)


2. **let**
   1) 特点: 声明可变的变量
   2) **解决for循环闭包问题的原理**:
      1) for循环在父作用域中声明一个变量，然后进行递增、递减的循环
      2) 即使使用let定义数据，也是定义在父作用域中
      3) 实现闭包问题的原理
         1) 循环的{}会自动创建一个块级作用域，循环一次创建一次
         2) let在使用时，一看是循环，会自动向块级作用域中绑定一个数据
         3) 即`let i = i`;  let在块级作用域中自动形成闭包
         4) 循环执行完，父级作用域声明的let i，自动销毁。


3. **const**
   1) 特点: 声明不可变的变量
   2) 原理: 不能修改存储空间
   3) **for循环不能使用该变量定义数据，for-of循环可以**
   4) 命名规范: 原理上不可能发生变化的数据，比如圆周率、地月距离。
      1) 命名时使用全部字母大写的方式，并且单词间用下滑线隔开
   5) 并且在命名时就需要进行赋值


4. **其实let和const也进行提升，只不过是把提升的变量放在了暂时性死区。这个时候变量是无法使用的**
   1. 只有运行到变量声明的地方，声明的变量才从暂时性死区中移出来，此时数据就可以正常使用。
   2. 借用Es6降级bable，降级成Es5，是看不出来暂时性死区（暂时性死区是Es6的特点），会直接把let、count替换成var
      - 所以：就不要想着，把Es6降级成Es5，然后查看为什么不能提前使用的原因，打包不出来的






#### 参数默认值

1. 作用
   1) 如果函数调用时，没有传递对应的参数，附一个默认值。


2. 使用
   1) 不传递值，使用默认值
   2) 传undefined，使用默认值，传递null不使用默认值，认为传值。


3. 代码示范
```js
function a(a = b(), c = 2, d) {
    console.log("a");
}
function b() {
    console.log('b执行了');
    return 123
}
a(undefined, undefined, 2);
a(undefined, undefined, 3);
// b函数共运行2次，附一次默认值，表达式就会运行一次（并不是代码执行到声明函数的地方，b就执行，然后默认值就固定下来了）
```


4. 注意点
   1) 只要使用了默认值，形参相当于使用let声明的数据，存在暂时性死区
      1) 比如(a = b, b)，a的默认值赋b
      2) 但是执行到该位置时，b还没有声明，报错(暂时性死区)
      3) (a, b = a)是可以的，b赋值默认值，a已经声明，从暂时性死区中移除
   2) 只要使用了默认值，函数自动开启严格模式
      1) 形参与arguments不在对应
      2) 修改形参不会影响argument






#### 点点点运算符

1. 作用
   1) 收集功能(收集函数剩余参数的功能，只有在函数形参位置有效)
   2) 展开功能


.
- **收集函数剩余参数**

1. 作用
   1) 可以灵活的使用函数接收到的参数

2. 使用环境
   1) 任何函数都可以使用，只不过通常使用在**不确定传参个数的函数中**


3. 表现样式
   1) ...运算符前面的形参，正常接收。如果没有接收完成，存在剩余参数。
   2) ...运算符，就把收集的函数放在一个数组中，以便使用。


4. 注意点
   1) 一个函数形参中不能出现多个...运算符
   2) ...运算符必须使用在函数形参的最后
   3) 没有按照规定定义，就会报错(在预编译环节报错，不符合语法规定)


5. 示范代码
```js
function fun(a, b, ...c) {
    console.log(a, b, c);
    // 打印出1  2  [3, 4, 5]
}
fun(1, 2, 3, 4, 5);
```

.
- **展开功能**
   
1. Es6的展开功能
   1) 只能展开数组
   2) **可以在函数调用时当做参数传入、在数组中展开另一个数组、可以在对象中展开一个数组**
   3) 比如: [1, 2, 3] -> 1, 2, 3


2. Es7的展开功能
   1) 可以展开对象
   2) **只能在对象中展开一个对象，在其它地方报错**
   3) 比如: {name: 123, age: 456} -> {name: 123, age: 456}
   4) 相当于{name: a.name, age: a.age}
   5) 可以简单的实现对象的浅层克隆功能


3. 限制
...只能展开可以进行迭代的数据(具有迭代属性)。






#### 箭头函数

1. 作用
   1) 解决this指向的问题

2. 箭头函数的this指向
   1) 不管函数是怎样触发运行的，函数内部的this，一定指向创建该箭头函数时，所处环境的this指向，`call、apply、bind`也无法改变this的指向，事件函数也不会指向标签dom。

3. 箭头函数的arguments指向
   1) 指向创建该函数时，所处环境的arguments指向
   2) 如果在全局中声明箭头函数，则内部无法使用arguments，否则报错。
      1) this可以使用，指向window
      2) arguments指向声明函数时所处的环境，全局环境，但是全局环境没有arguments所以报错。

4. 箭头函数没有原型，并且不能通过new的方式调用，否则报错

5. 声明箭头函数的方式
   1) `const a = (c, d) => { return c + d}`
      1) 相当于`const a = function() {}`，功能上还是稍有区别
      2) 箭头函数是一个函数表达式，并且是匿名函数
   2) 箭头函数可以简化书写
      1) 如果只有一个参数，可以省略()
         1) 比如: `a => {}`
         2) 没有参数不可以省略()
      2) 如果函数体只有一个返回值，可以省略{}以及return
         1) 比如: `() => 1` 相当于 `() => { return 1 }`
         2) 如果返回对象，在对象外侧需要加上()
         3) 比如: `() => ({ a: 1 })`


6. 箭头函数的使用场景
   1) 函数内部绑定外界环境的this
   2) 函数内部没有使用this，为了代码简洁，通常使用箭头函数创建函数





#### 块级作用域

1. **作用**
   1) 封闭作用域，和函数作用域的功能相同
   2) 此时存在三个作用域，一个是全局作用域、一个是块级作用域、一个是函数作用域


2. **使用**
   1) 使用{}包裹的代码，就是位于一个块级作用域
      1) 可以直接书写{}，常见的是判断、循环形成的块级作用域
   2) 块级作用域运行完，作用域自动销毁
   3) **块级作用域只有let和const和class定义的数据，才能私有化**
      1) 其它方式声明的数据，并不能进行私有化(提升到全局或者函数作用域中)
      2) 比如: function、var声明的数据，块级作用域外依旧可以访问到


3. **示范代码**
```js
{
    // 一个块级作用域
}
if() {
    // 一个块级作用域
}
for() {
    // 一个块级作用域
}
```







#### 判断函数是否通过new调用的

1. 旧方法
   1) 通过`this instanceof 构造函数名`，来判断是否是通过new 调用的函数
   2) 缺点: 如果通过call或者apply改变this的指向，指向`new 构造函数()`，判断也能通过

2. Es6新提出的一种方法
   1) 在函数内部使用`new.target`进行判断
   2) 如果是使用new调用的函数，返回构造函数本身
   3) 如果是直接调用(没有通过new)，返回undefined

3. 作用 
   1) 判断构造函数是否是通过new调用的
   2) 如果不是通过new的方式调用，内部的this指向就会出现问题








#### class类

1. 类的作用
   1) 简化构造函数的书写，以及原型的书写
   2) 是一个构造函数看起来向一个整体
      1) 和其它大型语言相似


2. 类的特点:
   1) 类声明不会进行提升，与let和const一样，并且也存在暂时性死区
      1) 必须先声明在使用
   2) 类中的所有代码均在严格模式下执行
   3) 类中的所有方法都是不可枚举的(原型上的方法)
      1) 遍历对象，无法遍历出原型上的方法
   4) 类中的所有方法，都不能作为构造函数，通过new的方式调用，如果调用报错
   5) 类构造器必须通过new的方式调用


3. 类的使用
   1) 通过`class A {}`创建一个类，A是类的名称
   2) 类通过函数`constructor`函数，创建类的构造器(相当于构造函数)
   3) 原型上的方法，直接在类中写函数
      1) 比如: `class A{ constructor(){} pro() {} }`，pro为定义在原型上的方法
      2) new A的传参，constructor接收到传入的具体的参数
      3) 即类的形参在constructor上定义
   4) 定义类的静态属性，通过`static`进行标记
      1) 比如: `class A{ static b() {} }`，方法b作为A的静态属性函数
      2) 调用该函数，需要通过A.b()进行调用
      3) 定义普通的静态属性: `class A{ static b = 123 }`
   5) 如果在类中以赋值的方式定义属性，会作为私有属性进行定义(被称为字段初始化器)
      1) `class A{ b = 5 }`，b会作为使用该类构造出的对象的私有属性
      2) 相当于`class A{ constructor(){ this.b = 5 } }`
      3) 该功能是Es7中提出的
      4) 间接说明，类的原型上只能定义方法，无法定义出普通属性
         1) 除非间接使用`__proto__`进行定义
      5) 可以通过该方法定义私有属性的固定值(不是从外界传入的)
      6) 在constructor中可以使用字段初始化定义的数据
         1) 即使字段初始化器定义在constructor的后面
         2) 说明字段初始化执行的时间早于constructor的执行
      7) **通常使用该方法绑定this(利用箭头函数)**
         1) 为了防止`const fun = obj.b;  fun()`，以这种方式调用
         2) 但是b函数中使用了this，此时就会报错
         3) 严格模式下，直接调用，this指向undefined，而不是window
         4) 可以使用字段初始化器，绑定this，示范代码如下:
         ```js
         class A {
             b = () => {
                 console.log(this);
             }
             // 由于使用的是箭头函数，内部的this指向外界环境的this
             /**
              * 字段初始化器相当于
              constructor() {
                  this.b = () => {}
                  * 此时的constructor的this，指向的就是创建的对象
                  * 是否是通过obj对象调用，this指向相同，指向创建的obj对象
              }
             */
         }
         const obj = new A();
         const fun = obj.b;
         b();
         ```
   6) 使用计算属性名
      1) 在类中，每个属性名(私有属性、或者原型属性、或者静态属性)都可以直接使用`[]`，内部直接添加计算属性表达式
      2) 并且在调用时，也可以直接通过[]，内部添加对应的计算属性表达式进行调用
      3) 示范代码
      ```js
      const name = "abc"
      class A {
          constructor() {
              this[name] = 1
          }
          [name + 1]() {
              console.log(this[name]);
          }
      }
      const a = new A();
      a[name + 1]();
      ```
   7) 添加存取器属性(相当于Object.defineProperty方法中的set和get)
      1) 对某个属性值赋值，运行某个函数
      2) 取值的时候，也运行某个函数，然后把返回值作为取到的值返回
      3) Es5需要借助Object.defineProperty函数的辅助才能完成
      4) 但是在类构造器中，简化了操作。可以直接通过set和get关键字直接设置
      5) 示范代码
      ```js
      class A{
          constructor() {
              // 甚至在constructor中触发下方对应的监听属性函数
              // 说明age的形成时间很早，在函数开始就赋值，然后此处相当于重新赋值
              this.age = 123;
          }
          set age(a) {
              this._a = a;
          }
          get age() {
              return this._a;
          }
          // 相当于在constructor中(私有属性)添加了一个age属性
          // 当给该属性赋值时，运行对应的set标记的函数
          // 当获取age的值时，运行对应的get标记的函数
          // 这两个方法并不是定义在原型上的
      }
      ```
   8) 类表达式(匿名类)
      1) `const A = class {}`，这种表达式被称为类表达式，使用方式不变
   9) 通过类构造出的对象，可以通过`__proto__`影响到构造函数的原型
   10) 可以通过`类名.prototype`访问到原型空间


4. 类的继承(构造函数原型的继承和私有属性的继承)
   1) 有两个关键字
      1) `extends`: 继承原型属性
      2) `super`: 继承私有属性，可以传递参数，并且监听属性set和get定义的属性也可以继承4
      3) 这两个关键字是必填的
      4) 子类中没有写constructor，则不用写super。
         1) 实际上启用了底层默认的constructor，自动调用super
         2) 并且底层的constructor定义形参和继承类的constructor的形参个数相同
         3) 然后使用super传入到继承类的constructor中
   2) 静态属性无法继承
   3) this指向，无特殊情况，一直指向创建出的对象，继承属性中的this也指向创建的对象
   4) 一般父类，都是抽离一些有相同特征子类的相同属性，照理说不能直接通过new调用
      1) 只能通过子类的继承属性super调用
      2) 可以在父类中使用`new.target`进行判断
    






#### Es6中的错误监管机制
通过try catch可以对错误进行一个监管，如果在执行时出现了错误，就会执行catch中设置的代码，这样就避免了出错阻塞页面的情况，只能监管同步执行的代码。具体的示范代码如下:
```js
    // 错误监管
    try {
        console.log(a); // 没有a，就会报错
    } catch (e) {       // 避免报错，报错执行内部的函数
        console.log("===");  
    }

    // 不能监管异步中的错误
    try {
        setTimeout( () => {
            // 会直接报错，阻塞页面运行，不会执行catch中的函数
            console.log(a); 
        }, 0)
    } catch (e) {       
        console.log("===");  
    }
    // 如果想要监管异步中的错误，就需要在异步执行的函数中加上try catch
```




#### 迭代器
1. 迭代的表现形式
   1) 迭代与遍历，在本质上有本质的区别
   2) 遍历是直接操作数据，迭代操作的是第三方工具，第三方工具操作数据
   3) 迭代是迭代一次，取一次的数据。并不关心数据是否取完
   4) 迭代关系的是取多少数据，而不是取多少次取完，迭代是不知道数据是否取完的


2. 迭代器
   1) 迭代器是一个对象，对象中必须存在一个`next方法`。
   2) next方法必须返回一个对象，对象中有两个属性，一个是`value`，一个是`done`
      1) value对应的属性值为本次迭代取出的数据
      2) done对应的属性值表示是否迭代到了最后一个数据
      3) 如果迭代到最后一个数据
         1) 下次再进行迭代时value为undefined，表示没有数据了，done变为true
      4) 如果没有迭代完，done为false。

3. 迭代器的示范代码
```js
const a = {
    next() {
        // 进行其他操作
        const a = {
            value: ?,
            done: ?
        }
        // 进行其他操作
        return a;
    }
}
```


#### 迭代器生成函数

1. 作用
   1) 就是一个普通的函数，但是该函数返回一个迭代器对象

2. 示范代码
```js
function a() {
    return {
        next() {
            // 进行其他操作
            const a = {
                value: ?,
                done: ?
            }
            // 进行其他操作
            return a;
        }
    }
}
const a = 
```









#### 可迭代协议与for-of之间的关系

1. 可迭代协议
   1) 一个数据集合(对象)上存在一个特殊的属性，为Symbol的知名符号`Symbol.iterator`
   2) 该属性的属性值为一个迭代器创建函数，即通过该函数可以创建出一个迭代器
   3) 创建出的迭代器，可以迭代该集合。

2. 作用
   1) 只要一个集合具有可迭代协议(特殊属性)，无论是在本身上还是原型上
   2) 就可以使用该属性创建迭代器，迭代该集合
   3) 普通的对象是没有可迭代协议的，数组具有可迭代协议
      1) 数组的可迭代协议存在于`Array.prototype`上


3. 可迭代协议的使用示范代码
```js
const a = [1, 2];

// 使用可迭代协议创建一个迭代器
const iterator = a[Symbol.iterator]();

// 迭代一次，打印{value: 1, done: false}
console.log(iterator.next());
// 迭代一次，打印{value: 2, done: false}
console.log(iterator.next());
// 迭代一次，打印{value: undefined, done: true}，迭代完成
console.log(iterator.next());
```


4. 仿写数组的可迭代协议(迭代器生成函数)
   1) 数组的可迭代协议存在于`Array.prototype`
   2) 可以直接对其进行重写，实现的功能一样
```js
// 重写数组的可迭代协议
Object.defineProperty(Array.prototype, Symbol.iterator, {
    value: function (){
        let i = 0;
        const _this = this;
        return {
            next() {
                const d = {
                    value: _this[i],
                    done: i >= _this.length
                }
                i ++;
                return d
            }
        }
    } 
})
```


5. for-of的作用
   1) 一直迭代某个集合，直到不能迭代为止，并且可以获取到每次迭代的数据


6. 可迭代协议与for-of之间的关系
   1) for-of是一个语法糖
   2) for-of的底层原理
      1) for-of可以迭代一个具有迭代协议的集合
      2) 所以底层一定是调用了`Symbol.iterator`属性对应的函数，创建迭代器
      3) 然后进行循环迭代，并且判断done的属性值是否为true
      4) 当done的值为false的时候，表示还可以继续迭代，循环迭代
      5) 当done的值为true的时候，表示不可以继续迭代，停止循环迭代完成
   3) 底层代码如下
   ```js
   // 使用可迭代协议创建一个迭代器
   const iterator = a[Symbol.iterator]();
   // 先取一次数据
   let iter = iterator.next();
   // 进行循环
   while(!iter.done) {
       // 如果iter.done为false，表示本次迭代还有数据，可以继续迭代
       // 如果iter.done为ture，表示本次迭代没有数据，循环进不去，迭代结束
       const prop = iter.value;
       
       /********for-of循环中的代码体*********/
       // 
       // prop也是for-of声明的数据，由于底层是定义在while中
       // 每次都重新声明数据，不存在替换的现象，所以可以使用const定义数据
       // for循环不是语法糖，变量只声明一次，然后进行替换，所以只能使用let定义数据
       console.log(prop);
       /*************             **********/

       // 进行下一次迭代，重新赋值，进行判断
       iter = iterator.next();
   }
   ```


7. 点点点运算符与可迭代协议之间的关系
   1) Es6中: 点点点运算符底层的实现原理，与for-of循环相同
      1) 利用`Symbol.iterator`属性对应的函数，创建迭代器
      2) 然后进行循环迭代，并且判断done的属性值是否为true
      3) 当done的值为false的时候，表示还可以继续迭代，循环迭代
      4) 当done的值为true的时候，表示不可以继续迭代，停止循环迭代完成
      5) 并且把每次迭代出来的数据，展示出来
   2) Es7中: 对点点点运算符进行了功能增强
      1) 使其可以迭代对象，但是底层使用的不是迭代原理，对象是无法被迭代的




#### 生成器

1. 作用
   1) 生成器最初创建的目的，简化迭代器的书写
   2) **为迭代提供数据**

2. 生成器解决的现象
   1) 迭代的原理
      1) 一次取一个数据
      2) 可以理解为调用一次next，经过一系列复杂的函数处理，返回一个对象
   2) 生成器解决的现象
      1) 迭代一次取一个数据，取出的数据可能在next内部进行了复杂的处理
      2) 并且是根据将要迭代的集合数据进行了复杂的处理
      3) 如果集合每次迭代一个数据，处理方式不同
      4) 这样迭代器的next构建起来就非常麻烦(既复杂，每次迭代处理方式还不同)
      5) 生成器就可以快速的构建出这个复杂的生成器
         1) 每次迭代，对数据的处理不同(可以相同)，然后返回迭代的数据

3. 生成器的创建方法
   1) 生成器不能直接创建(底层API不开放)
   2) 可以通过生成器创建函数，创建一个生成器
   3) **只要在函数名的前面加*，该函数就变成了生成器函数**
      1) 匿名函数，在()的前面加上*
      2) 普通函数转换成生成器函数，就会失去原先的功能
   4) 调用生成器创建函数，默认返回一个生成器函数
      1) 内部的代码体，会放在一个特殊的地方(调用函数不会进行执行)
      2) 内部代码变成迭代执行的代码，使用next才进行执行


4. 生成器的使用
   1) 生成器是为了给迭代提供数据，所以就需要有指令提供数据
      1) 迭代一次，运行一部分生成器中的代码，然后返回迭代到的数据
   2) `yield指令`
      1) 调用一次next方法，生成器函数中的代码执行一次，执行完yield后面的表达式，停止执行
      2) 然后把yield后面表达式的值，赋给迭代返回的对象中的value属性，作为本次迭代得到的值
      3) **done属性一定为false**，代码停止还没有运行完，哪怕yield在函数的最后
         1) 函数最后为return，虽然没写，但是会自动添加，返回undefined
         2) 所以，虽然yield写在最后，实际后面还有代码，表示当前生成器还可以进行迭代
         3) done的属性值自然为false
      4) **下次迭代，从上次迭代的位置(yield)开始执行，执行完下一个yield后方的表达式**
   3) `return指令(表示迭代完成)`
      1) 如果生成器函数中没有yield关键字，进行迭代(运行next)，会一直运行到结束
      2) 如果生成器函数中存在yield关键字，以yield为分界线，迭代一次运行一段代码
      3) return的作用
         1) 标记，生成器的最后一次迭代
            1) 如果某次迭代，运行了生成器的return，表示生成器中定义的代码已经运行完成
            2) 本次迭代是最后一次迭代
         2) 把return值，作为本次迭代的数据返回，如果没有返回值，为undefined
         3) 与正常迭代不同之处
            1) 如果生成器存在return，则迭代出的对象，value属性有值
            2) 但是done属性的值为true，表示迭代完成
            3) 正常迭代器，done为true，value为undefined


5. yield指令的使用
   1) 分割生成器中的代码，迭代一次运行一段代码
   2) yield指令，与赋值符号一起运用的原理
      1) 比如: const a = yield ?
      2) 并不是yield后面的表达式运行结果赋值给a，作为本次迭代的返回数据
      3) **迭代一次运行完yield后面的表达式，返回表达式值，就会立刻停止执行**
      4) 即，虽然赋值符号与yield写在一起，但是并没有被解析
      5) 解析时间: 进行下一次迭代，代码重新执行，此时才会解析赋值符号进行赋值
         1) **此时迭代，就已经与上一次迭代无关了**
         2) 所以赋值符号使用的也不是上一次迭代的结果
         3) 迭代，就是运行next方法，next方法运行值可以传递参数
         4) 赋值符号使用的就是本次迭代，next的传参，把传参赋值给a


6. 生成器的原理
   1) 生成器就是一个特殊的对象
   2) 该对象即使一个迭代器，存在next属性(迭代调用的方法)
   3) 该对象也是一个具有可迭代协议的对象，存在知名符号`Symbol.iterator`
   4) 生成器创建函数中的代码，按照yield拆分完，放在一个集合中
      1) 迭代一次，运行一段代码

7. 生成器的示范代码
```js
function * a() {
    const a = yield 1;
    // 打印b
    console.log(a);
    const b = yield 2;
    // 打印c
    console.log(b);
    return 3;
}

// 创建生成器
const sheng = a();
// 迭代一次，打印{value: 1, done: false}
console.log(sheng.next("a"));
// 迭代一次，打印{value: 2, done: false}
console.log(sheng.next("b"));
// 迭代一次(结束)，打印{value: 3, done: true}
console.log(sheng.next("c"));
```


8. 生成器与promise的配合使用
   1) 使用原理
      1) yield后面跟的表达式，返回一个promise对象
      2) 使用生成器创建函数，创建生成器
      3) 生成器调用next，进行迭代，得到的迭代数据对象的value属性就是一个promise对象
      4) 给promise对象绑定状态，当promise对象的状态改变，触发成功回调函数
      5) 成功回调函数中，在调用生成器的next方法，继续迭代
      6) 并且传入成功回调函数接收的参数(上次迭代得到的promise对象的状态改变时的传参)
      7) 可以使用递归的方式，进行生成器的迭代
   2) 示范代码
   ```js
   function * a() {
       const a = yield fetch("http://127.0.0.1:10086/a");
       const ajie = yield a.text();
       console.log(ajie);
       const b = yield fetch("http://127.0.0.1:10086/b");
       const bjie = yield b.text();
       console.log(bjie);
       const c = yield fetch("http://127.0.0.1:10086/c");
       const cjie = yield c.text();
       console.log(cjie);
       return cjie;
   }


   // 创建一个生成器
   const f = a();
   function d(res) {
       // 进行一次迭代(返回一个对象，对象中的value属性是一个promise对象)
       const pro = f.next(res);
       // 判断是否迭代完成，迭代完成，该属性为true
       if(pro.done) {
           console.log(pro, "结束");
           return pro.value;
       }
       // 如果没有迭代完成，给promise对象绑定回调函数
       pro.value.then( (res) => {
           // 如果promise对象变为成功状态，表示promise对象的功能处理完成
           // 可以进行下一次的迭代处理，进行递归
           d(res);
       } )
   }
   d();
   ```


9. 使用点点点运算符和for-of循环迭代生成器
   1) 只要具有可迭代协议，就可以使用点点点运算符和for-of循环进行迭代
   2) 生成器的原型上就具有可迭代协议，所以是可以使用点点点运算符和for-of循环迭代生成器
   3) 由于for-of和点点点，只有迭代返回对象的done属性的属性值为false，才展示迭代出的数据
   4) 但是，生成器构建函数的return返回值，使用for-of或点点点运算符是得不到的
      1) 最后一次迭代的done的结果为false，对应的value不会显示出来






#### 反射

1. 作用
   1) 抛出一些底层的代码，减少魔法的使用(抛出魔法底层实现功能的方法)
   2) 使开发更加接近底层开发

2. Es6提供了一个`Reflect对象`
   1) 该对象中有一些属性，这些属性的属性值，就是一些底层的方法
   2) 比如对象属性的赋值(Es6认为=号也是一种魔法，无法定义出与=号相同的功能)
      1) 对象属性的赋值，底层借助的就是`Reflect.set方法`
      2) 示范代码: `Reflect.set(对象，属性，新的属性值)`






#### 代理的使用

- 作用
  - 定义出一个操作对象的中介对象，这样再次操作对象的时候，就可以通过操作中介对象，实现操作对象的作用。
  - 不在直接与对象接触，而是与中介对象接触，然后中介对象在操作对象
  - 可以实现**观察者模式，当对象中的属性发生变化，可以被代码感知到，从而进行一些处理**

- **对象的修改需要手动定义代码，不会自动进行修改的**

- 示范代码
```js
const obj = {
    name: "adfa"
}        

const proxy = new Proxy(obj, {
    set(_obj, key, value) {
        // 可以进行一些其他的处理，比如数据的验证
        console.log(_obj, key, value);
        // 对 对象中的元素进行修改
        //   （手动定义修改代码，不会自动进行修改的）
        Reflect.set(_obj, key, value);
      
        // 甚至可以这样做
        //    修改是手动实现的，只要能实现修改对象中的属性，通过什么方法都可以
        // _obj[key] = value;
    }
    get(_obj, key) {
        console.log(_obj, key);
        return Reflect.get(_obj, key);
    }
});
// 修改对象中的name，就会触发上面的set
proxy.name = 456;
// 读取对象中的name，就会触发上面的get
console.log( proxy.name );

// 直接通过对象读取，不会触发get（没有走代理对象）
console.log( obj.name );
```

.
- 代理需要借助 `Reflect（反射）`
  - 对 对象完成实际的操作，是通过 Reflect 实现的，Reflect可以直接用
  - 比如
  ```js
  const obj = {
      name: "adfa"
  }        
  // 修改对象中的name
  Reflect.set(obj, 'name', '3456');

  // 读取，发现已经实现了修改
  console.log( obj.name );
  ```


.
- 旧版本的实现（以及两者的差距）
  - Es5之前，只能借助`Object.defineProperty`中的set和get来实现
    - 需要另外创建一个集合，用于保存数据，避免死循环
    - 新增属性无法进行观察，需要重新使用`Object.defineProperty`进行设置

  - Es6中的代理，由于创建了一个观察对象，只要一点，就会调用get或者set。然后内部手动改变对象
    - 所以，哪怕新增属性，也会调用set，从而被观察到




#### 符号-普通符号


1. 作用
   1) 为了解决对象的属性私有化，而诞生的一种数据类型，被称为符号


2. 使用
   1) 通过调用函数`Symbol`，得到符号
      1) 虽然是一个构造函数，但是不能通过new的方式调用，而是直接使用
   2) 函数中可以传递参数，传递的参数没有什么用处，只是起一个说明作用，被称为符号说明
   3) 比如: `const sym = Symbol("描述");`，得到的是`Symbol(描述)`;



3. 特点
   1) 符号没有字面量的书写方式，只能通过调用函数Symbol进行创建;
   2) 使用typeof得到的符号类型，为`symbol`;
   3) **Symbol得到的符号永远不相等，即使长得一样**
      1) 比如: `let a = Symbol("a"); let b = Symbol("a");`
      2) `a === b`，得到的是false
   3) **Symbol字符可以作为对象的属性名存在，利用该功能完成对象的属性私有化**
      1) 外界通过对象，无法使用该属性，只能对象内部才能使用
      2) 借助了闭包和符号永远不相等的概念，实现对象属性私有化的开发
      3) 对象属性私有化的示范代码
      ```js
      function createObj() {
          // 创建Symbol属性
          const sym = Symbol();
          return {
              // 添加一个私有属性
              [sym]: 123
          }
      }
      ```
      4) 通过函数创建出一个对象，由于闭包的作用，sym外界是无法获取的。
         1) 属性获取不到，则外界通过`对象.属性`也无法获取到属性对应的属性值
         2) 通过`对象.[ Symbol() ]`，虽然属性长相相同，但是不是同一个，所以也无法获取。
         3) 遍历对象，可以获取到对象的属性，通过遍历的属性就可以访问到对应的属性值
         4) Symbol为了防止该情况，所有的字符属性都是不可枚举的
            1) for-in无法获取到字符属性
            2) Object.keys()，获取对象的所有可以枚举的属性，但是无法获取符号属性
            3) Object.getOwnPropertyNames()，获取可枚举和不可枚举的属性，也无法获取符号属性
         5) 属性获取不到，自然无法获取到对应的属性值，这样该属性就变成了对象的私有属性
         6) 函数内部可以获取到定义sym，从而读取到对应的属性值
         7) 如果外界非要使用字符属性，Es6提供了一个方法`Object.getOwnPropertySymbols()`
            1) 该方法可以获取到一个对象中的所有字符属性，只能得到字符属性
            2) 不会顺着原型链查询，只获取传入对象的字符属性
  



#### 符号-共享符号

1. 作用
   1) 根据symbol的名称，获取相同的符号
   2) 方便对象外部访问对象的符号属性

2. 使用
   1) 通过`Symbol.for()`获取一个具名的符号
      1) 无法定义符号说明，for中传入的是符号的名称
      2) 当传入的名称，在之前创建过，则返回之前创建的符号(相等)
      3) 当传入的名称，没有创建过，则返回一个新的符号
      4) 类似创建符号，然后进行保存，当传入相同名称时，返回对应的符号(不在创建)
   2) 通过该方法获取到相同的字符，则就可以获取对象中对应字符属性的属性名






#### 符号-知名符号

1. Es6定义了一些符号，这些符号被称为知名符号
   1) 知名符号是一些具有特殊含义的共享符号，通过Symbol函数的静态属性得到
   2) Es6延续了Es5的思想，减少魔法，暴露内部实现
   3) Es6用知名符号暴露了某些场景的内部实现

2. Symbol.hasInstance
   1) 该符号用于定义构造函数的静态成员，它将影响`instanceof`的判断
   2) 通过`obj instanceof A`可以判断出，某个对象的原型链上，有没有构造函数A的原型
      1) 这就是一种魔法，不了解怎么实现的
      2) 该判断方法，底层使用了`Symbol.hasInstance`进行实现的
      3) 可以修改`Symbol.hasInstance`属性对应的方法，就可以控制instanceOf得到的值
   3) `Symbol.hasInstance`是不可修改的，要想进行修改，需要借助`Object.defineProperty()`
      1) 该属性是构造函数(对象)上的一个属性(静态属性)，不是Symbol函数上的一个静态属性
   4) 示范代码如下
   ```js
   function A() {};
   Object.defineProperty(A, Symbol.hasInstance, {
       value: function () {
           return false;
       }
   })
   // 实际运行Symbol.hasInstance函数，得到的是该函数的返回值
   console.log(new A() instanceof A);
   ```





#### 解构-参数解构

1. 作用
   1) 简化了函数中使用形参进行开发

2. 使用
   1) 如果函数接收的是对象，就使用对象解构的方式进行解构
   2) 如果函数接收的是数组，就使用数组结构的方式进行解构






#### 解构-对象解构

1. 作用
   1) 提取复杂对象的某些属性

2. 使用
   1) 分开写法
      1) 先定义数据: `let a, b, c;`
      2) 在进行解构赋值: `({a, b, c}) = obj`，obj为解构对象
      3) 这种方法相当于从新赋值，只能使用let声明数据，或者var
   2) 混合写法
      1) 声明加解构赋值写在一块: `const {a, b, c} = obj`
      2) 可以使用let、const、var声明数据
   3) 解构对象中某个对象中的属性
      1) 解构方式: `const {a, b: { c, d }} = obj`
      2) b不是出的属性，而是解构b对象中的c和d，即解构出的数据中没有b
      3) 并且使用b和c的时候，直接使用，不需要通过b.?进行使用
   4) 解构对象中某个数组中的数据
      1) 解构方式: `const {a, b: [a, , c]} = obj`
      2) b不是出的属性，而是解构b数组中的第0位和第三位数据，然后赋给a、c
      3) 并且使用b和c的时候，直接使用，不需要通过b进行使用
   5) 解构对象，解构属性(定义属性)必须与对象中的名称相同。
   6) 支持解构重命名
      1) 为了防止解构属性与其它属性产生冲突
      2) 重命名方式: `const { a: b } = obj`
      3) 把a重命名为b，在访问数据时，不能通过a，而是通过b使用
   7) 支持赋默认值的操作
      1) 如果对象中没有某个属性，在解构时赋默认值
      2) 比如: `const {a = 123, b:c = 123} = obj`
         1) 如果对象中没有a属性，则a使用默认值。
         2) b进行重命名为c，如果对象中没有b属性，则c使用默认值
         3) 如果有该属性，则使用对象中的数据，不使用默认值
      3) 没有对应属性或者属性值为undefined，才使用默认值。null认为有值




#### 解构-解构收集
1. 作用
   1) 解构出需要的数据，然后把其它数据放入一个变量中存储起来

2. 对象收集
   1) `const {a, b, ...c} = obj`;
   2) 收集的c是一个对象格式

3. 数组收集
   1) `const [a, b, ...c]= arr`;
   2) 收集的c是一个数组格式

4. 点点点必须写在最后才具有收集的功能，写在其它地方报错


5. 如果只对对象或者数组中的某个进行解构，可以直接取出来在进行解构
   1) 比如: `const {a, b, c} = obj.a`;






#### 解构-数组解构
1. 作用
   1) 提取复杂数组的某些属性

2. 使用
   1) 分开写法
      1) 先定义数据: `let a, b, c;`
      2) 在进行解构赋值: `([a, b, c]) = arr`，arr为解构数组
      3) 这种方法相当于从新赋值，只能使用let声明数据，或者var
   2) 混合写法
      1) 声明加解构赋值写在一块: `const [a, b, c] = arr`
      2) 可以使用let、const、var声明数据
   3) 解构数组中某个对象中的属性
      1) 解构方式: `const [a, { c, d }] = arr`
      2) 数组的第1位是一个对象，解构出该对象的c和d属性
      3) 在使用时，直接访问c和d即可
   4) 解构数组中某个数组中的数据
      1) 解构方式: `const [a, [c, d]] = arr`
      2) 数组的第1位是一个数组，解构出该数组的第0位和第1位对应的数据
      3) 在使用时，直接访问c和d即可
   5) 解构数组时，解构属性(定义属性)必须与数组的位数对应起来。
   6) 支持解构重命名
      1) 为了防止解构属性与其它属性产生冲突
      2) 重命名方式: `const [a: b]= arr`
      3) 把a重命名为b，在访问数据时，不能通过a，而是通过b使用
   7) 支持赋默认值的操作
      1) 如果数组中对应位数没有数据，在解构时赋默认值
      2) 比如: `const [a = 123, b:c = 123] = arr`
         1) 如果数组的第0位没有数据，则a使用默认值。
         2) b进行重命名为c，如果数组的第1位没有数据，则c使用默认值
         3) 如果数组的对应位数有值，则使用数组中的数据，不使用默认值
      3) 对应位数没有值或者为undefined，才使用默认值。null认为有值
   8) 如果跨位解构数组中的数据，格式必须写出来，即加上`,`号。使其与数组具体位数对应起来
      1) 比如: 解构数组的第2、4位数据
      2) 解构方式: `const [ , , a, , b] = arr`
      3) 使用`,`与对应的位数对应起来


3. 数组结构可以完成两个变量交换数据
   1) 比如有a、b两个数据，进行替换
   2) 示范代码
   ```js
   let a = 1;
   let b = 2;
   ([b, a]) = [a, b]
   // 先组装成一个数组，然后进行解构，把第0位数据(a)赋值给b，把第1位数据(b)赋值给a
   ```





#### fetch-发送请求
1. 通过调用`fetch()`函数，发送一个请求
    1. 该函数的第一个参数为请求的地址
    2. 该函数的第二个参数为一个配置对象，可以配置一些属性
        1. `method属性`: 配置请求方式。比如: method: "POST"，默认为GET
        2. `headers属性`: 属性值为一个对象，用来配置请求头
           1. 请求头是一个一个的键值对，即属性和属性值
        3. `body属性`: 配置请求体(POST请求时，发送的数据)，请求方式必须为POST才有效
            1. 发送数据的格式，在headers中配置(配置请求头)
            2. `"Content-Type": "application/json"`，发送的数据为json格式
        4. `credentials属性`: 用来设置是否发送cookie，**他对应的属性值以及作用如下**
            1. `omit`: 为默认值，不发送cookie
            2. `same-origin`: 请求同源地址时，携带cookie
            3. `include`: 请求任何地址都携带cookie



#### fetch-处理服务器返回的数据
1. **通过fetch发送一个请求，fetch函数返回的是一个promise对象**
   1. 当请求完成后，promise对象的状态就会变成已决状态
      1. 当服务器进行了响应，返回了数据，promise对象的状态变为resolved
         1. 响应数据，作为改变状态时的参数传入
      2. 当请求过程中发生了错误，导致请求没有到达服务器，则状态变为rejected
         1. 比如: 断网了
2. **可以通过then绑定成功回调函数，进行请求数据的处理**
3. **可以通过async和await的配合，处理数据**
      


#### fetch-分析fetch请求得到的数据
   1) 得到的是一个对象，对象中除了有服务器返回的数据，还有一些其他的数据
   2) **`ok属性`: 如果属性值为true，表示浏览器返回的状态码为200**
   3) `text属性`: 属性值为一个方法，该方法返回一个promise对象
      1) 可以绑定状态，或者使用async和await进行处理
      2) **该方法的作用: 把服务器返回的数据解析成字符串格式**
         1) 如果解析成功，则该方法返回的promise对象的状态变为resolved
         2) 并且解析成功的数据，作为改变状态的形参传入
         3) 如果解析出错，则该方法返回的promise对象的状态变为rejected
            1) 触发失败状态，如果使用await，没有失败处理函数，就会报错
            2) 可以使用try-catch进行拦截处理
            3) 如果注册了失败回调函数，则运行失败回调函数
   4) `json属性`: 属性值为一个方法，该方法返回一个promise对象
      1) 可以绑定状态，或者使用async和await进行处理
      2) **该方法的作用: 把服务器返回的数据(必须为json格式)解析成对象格式**
         1) 如果解析成功，则该方法返回的promise对象的状态变为resolved
         2) 并且解析成功的数据，作为改变状态的形参传入
         3) 如果解析出错，则该方法返回的promise对象的状态变为rejected
            1) 触发失败状态，如果使用await，没有失败处理函数，就会报错
            2) 可以使用try-catch进行拦截处理
            3) 如果注册了失败回调函数，则运行失败回调函数
   5) `blob属性`: 属性值为一个方法，该方法返回一个promise对象
      1) **该方法的作用: 处理二进制文件格式(比如图片或者电子表格)**
   6) `redirect属性`: 属性值为一个方法，该方法返回一个promise对象
      1) **该方法的作用: 解决重定向问题，服务器返回的状态码为302**
      2) 该方法会自动发送重定向请求，请求完成后，promise对象的状态变为resolved
      3) 根据请求数据创建的数据对象，作为改变状态时的形参传入
         1) 可以通过注册的成功回调函数进行接收处理
         2) 或者使用var ? = await ?.redirect进行接收


6. 示范代码
```js
async function a() {
    const a = await fetch("http://127.0.0.1:10086");
    const b = await a.text();
    return b;
}
a().then( (data) => { 
    console.log(data) 
} );
```




#### fetch-request对象

1. 使用
  1) fetch在发送请求时，可以传入两个参数，一个是路径，一个是配置对象。
  2) 底层会把这两个参数合并成一个request对象，实际上是利用该request对象进行请求
  3) **fetch可以直接传入一个request对象，进行请求**
  4) 可以利用`new Request(路径, 配置对象);`创建一个request对象
     1) fetch的底层也是利用该函数创建的request对象


2. 注意点
   1) 每次请求，都需要使用全新的request对象，不好进行保存复用
      1) GET请求可以进行复用
      2) POST请求，如果发生大数据(比如视频)，由于传输时间过长，request对象会保存传输进度
      3) 如果进行了复用，下次使用，传输进度还是百分之百。此时就会出现问题



#### fetch-response对象
  
1. 使用
   1) 当fetch请求成功后，会触发状态，然后状态传参为一个对象
   2) 传入的对象就是根据服务器返回的数据创建的response对象
   3) 可以使用`new Resposne(数据)`，手动创建一个response对象
      1) 传入的数据，为服务器返回的数据，此时可以模拟一个数据进行传入
         1) **服务器还没有开发完成，使用模拟数据开发页面**
      2) 创建的对象，和状态传参对象相同，底层就是使用该方法创建的response对象
      3) 使用对象提供的方法(返回promise对象)，处理一些数据
         1) 处理结果，作为改变状态时的传参



#### fetch-headers对象

1. 使用
   1) 使用fetch方法，发送请求的时候，可以传递配置对象
      1) 其中有一个headers属性，属性值为对象，该对象就是headers对象
   2) 底层是使用`commonHeaders`方法创建的headers对象 
      1) 可以直接使用该方法创建headers对象，然后传入创建好的headers对象
      2) 函数传参: 为一个对象，实际上就是headers的属性值，格式相同
      3) 函数返回值: 返回headers对象。
   3) **headers对象，本质上为头对象，包括请求头和响应头**。
      1) 请求头和响应头的headers对象，内部都有相同的方法，用来处理头数据
      2) 请求头(headers对象)，有两种获取方式(都离不开手动创建对象)
         1) 通过`new Request()`创建请求信息`request`对象
            1) request对象上有一个`headers属性`，通过该属性就可以获取到headers对象
         2) 通过`commonHeaders()`直接创建headers对象
      3) 响应头(headers对象)，有一种获取方式
         1) 请求成功，得到response对象
            1) response对象上有一个`headers属性`，通过该属性就可以获取到headers对象
   4) headers对象上的一些方法以及功能
      1) `has方法`: 验证headers对象中有没有某个键值(属性名)，返回Boolear值
         1) 使用方式: 传入键值
      2) `get方法`: 得到某个键值对应的键值数据(属性值)
         1) 使用方式: 传入键值
         2) 不存在的键值(属性名)返回null
      3) `set方法`: 修改对应的键值对(修改属性值)
         1) 使用方式: 传入键值、键值数据(属性名, 属性值)
      4) `append方法`: 添加一个键值对(新增属性、以及对应的属性值)
         1) 使用方式: 传入键值、键值数据(属性名, 属性值)
         2) 如果是已有的键值对: 则键值数据会变为`旧值, 新值`
      5) `keys方法`: 得到所有的键(属性名)
         1) 使用方式: 无参数传递，返回一个数据集合
         2) 返回的数据集合，只能使用for-of进行迭代遍历
      5) `values方法`: 得到所有的键值(属性值)
         1) 使用方式: 无参数传递，返回一个数据集合
         2) 返回的数据集合，只能使用for-of进行迭代遍历
      5) `entries方法`: 得到所有的键值对(属性名加属性值)
         1) 使用方式: 无参数传递，返回一个数据集合
         2) 返回的数据集合，只能使用for-of进行迭代遍历








#### Promise


1. 功能
   1) 解决回调地狱问题
   2) 解决不同异步之间的联系
   3) Promise不能消除回调，只不过给回调形成了一种模式
      1) 所有的回调都使用提供的模式进行回调，让回调看起来更加整洁



2. 异步状态
   1) 异步正在发生时，被称为未决状态，即`pending`
   2) 异步结束时，被称为已决状态(此时已经出结果)，共存在两种结果
      1) 成功，即`resolved`
      2) 失败，即`rejected`
   3) Promise完善异步，利用的就是这两种状态。
    

3. 使用
   1) 创建一个promise对象，通过`new Promise( () => {} )`进行创建
      1) 函数必须传递，负责报错
   2) 给promise对象，绑定已决状态的回调函数(成功和失败)
      1) promise对象上有一个方法(Promise.prototype上的方法)`then`
         1) 该函数接收两个参数，第一个参数为成功回调函数，第二个参数为失败回调函数
      2) promise对象上有一个方法(Promise.prototype上的方法)`catch`
         1) 该方法接收一个参数，为失败回调函数
      3) 可以给一个promise对象上绑定多个回调函数(通过then或者catch)
         1) 当达到对应的已决状态时
         2) 按照绑定的先后顺序，进行对应回调函数执行，先绑定的先执行


4. 执行原理
   1) 通过`then`或者`catch`，给promise对象注册上回调函数
   2) **当promise对象的状态从未决状态变成已决状态时，就会触发对应的回调函数**
      1) 按照注册的顺序执行
      2) 成功`resolved`，触发成功回调函数(放入微任务队列中)
      3) 成功`rejected`，触发失败回调函数(放入微任务队列中)
   3) **改变promise对象的状态(从未决变成已决)，依靠Promise函数执行时传入的函数**
      1) 传入函数接收两个形参，格式为函数
      2) 当第一个函数执行时，创建的promise对象的状态，变为resolved状态
      3) 当第二个函数执行时，创建的promise对象的状态，变为rejected状态
      4) 如果Promise的传入函数在执行时出现了错误(执行错误，不是语法错误)
         1) 创建的promise对象的状态，也会变为rejected状态
         2) 错误信息作为参数，传入失败的回调函数中
         3) 并且控制台不会抛出错误信息，不会造成阻塞，只要绑定了失败回调函数
            1) 不会阻塞代码，执行失败回调函数，执行完代码正常
            2) 如果没有绑定失败回调函数，则控制台抛出错误，表示没有对应的函数执行
               1) 由于Promise是异步执行，所以出现错误，不会影响其他异步函数的执行
            3) 不会造成阻塞的原因，执行栈中的执行的代码没有抛出错误
               1) 底层使用的是try-catch，进行了错误拦截
      5) **状态变为已决状态后，将不可被修改**
      6) **改变状态时，可以传递参数，会把传递的参数，传入执行的回调函数中**
   4) 只要给创建的promise对象绑定上回调函数(无论通过什么手段)
      1) 当Promise传入函数改变状态，绑定的回调函数就会执行


5. finally函数
   1) 该函数是Promise.prototype上的方法
   2) 通过该方法，也能像promise对象上绑定回调函数
   3) 绑定的回调函数，无法接受参数，没有形参
   4) 绑定的函数，无论promise对象的状态是成功还是失败，都会触发
      1) 改变状态传入的参数，通过finally绑定的函数是接收不到的
      2) 原因: 
         1) 失败和成功都能触发该方法绑定的函数
         2) 如果可以接收参数，不清楚参数是成功状态还是失败状态传入的。
   5) 该方法是Es7新增的一个方法


6. 链式调用
   1) `then、catch、finally`，这三个方法存在返回值，返回值为promise对象
      1) 返回的是一个全新的promise对象，并不是调用该方法的promise对象
   2) promise对象，可以使用`then、catch、finally`绑定回调函数
      1) 形成了链式调用
   3) `新promise对象`注册的回调函数，受`新promise对象`的状态控制
   4) `前一个promise对象`执行的回调函数，控制`新promise对象`的状态
      1) `前一个promise对象`执行的回调函数，在执行时报错(同步执行)
         1) `新promise对象`的状态变为rejected，触发失败函数
         2) 并且错误信息作为参数传入
      2) `前一个promise对象`执行的回调函数，执行完没有发生错误
         1) `新promise对象`的状态变为resolved，触发成功函数
         2) 并且把返回值作为参数传入
      3) `前一个promise对象`执行的回调函数，执行完没有发生错误，并且返回值为promise对象
         1) 则`新promise对象`的状态不变，改变与返回的promise对象绑定起来
         2) 返回的promise触发成功状态后，`新promise对象`的状态变为resolved
         3) 返回的promise触发失败状态后，`新promise对象`的状态变为rejected
         4) 触发状态传入值，作为`新promise对象`回调函数执行时的参数传入
         5) 返回的promise执行过程中报错，`新promise对象`的状态变为rejected
            1) 错误信息作为参数传入
   5) 链式调用，前一个promise对象的功能处理完成，下一个promise对象的状态才会改变
   6) 如果promise对象的状态改变，但是没有绑定对应的回调函数，就会报错
      1) 错误信息可以被下一个promise对象获取，然后状态变为reject，触发失败函数
      2) 如果没有失败回调函数，当前promise对象报错，再被下一个promise对象获取
      3) 以此类推，直到某个promise对象注有失败回调函数，并且正常执行
      4) 后面的promise对象的状态就会变为resolve。触发成功回调函数


7. Promise上的一些其它API(静态属性)
   1) `resolve`函数
      1) 返回一个已经是已决状态(resolve)的promise对象
      2) 传递的参数，作为回调函数的形参传入
      3) 如果传入的是一个promise对象，则返回传入的promise对象，不在创建
         1) 该函数的功能就是创建promise对象
         2) 既然传入一个，不在多此一举的创建，直接返回传入的
   2) `reject`函数
      1) 返回一个已经是已决状态(reject)的promise对象
      2) 传递的参数，作为回调函数的形参传入
      3) 如果传入的是一个promise对象，则返回传入的promise对象，不在创建
         1) 该函数的功能就是创建promise对象
         2) 既然传入一个，不在多此一举的创建，直接返回传入的
   3) `all`函数
      1) 该函数创建一个promise对象
      2) 创建的promise对象的状态，受多个promise对象状态的控制
         1) 该函数传入的参数是一个数组，数组的每一项为一个promise对象
         2) 成功状态的触发条件
            1) 传入的所有promise对象的状态都变为resolve
            2) 该方法创建的promise对象的状态才变成resolve
            3) **每一个触发成功状态的传参，会放入一个数组中，传入执行的回调函数中**
         2) 失败状态的触发条件
            1) 传入的所有promise对象的状态只要有一个变为reject
            2) 该方法创建的promise对象的状态就会变为reject
            3) **第一个触发失败状态的传参，传入执行的回调函数中**
            4) 其它的promise依旧正常执行，执行完不会影响该方法创建的promise对象
   4) `race`函数(竞赛模式)
      1) 该方法创建一个promise对象
      2) 该方法接收一个参数，格式为数组
      3) 传参数组的每一项为一个promise对象
      4) 创建的promise对象的状态改变为resolve的条件
         1) 传入的promise对象，只要有一个状态变为resolve
         2) 创建的promise对象的状态就变为resolve
         3) 传入的promise对象触发状态时的传参，作为回调函数的参数传入
      5) 创建的promise对象的状态改变为reject的条件
         1) 传入的promise对象，只要有一个状态变为reject
         2) 创建的promise对象的状态就变为reject
         3) 传入的promise对象触发状态时的传参，作为回调函数的参数传入
      6) 类似竞赛模式
         1) 传入的promise对象，那个先改变状态，创建的promise对象就立即改变状态
         2) 其它的promise对象正常执行，但是不会对创建的promise对象造成任何影响





#### 手写Promise底层代码

```js
class MyPromise {
    constructor( fun ) {
        // 下一个promise
        this.promise = null;
        this.type = "outstanding";
        this.data = null;

        this.reject = null;
        this.resolve = null;
        this.callBackRun = null;
        this.fallfun = null;
        

        // 立即执行函数
        fun && fun(this.resolves.bind(this), this.rejects.bind(this));
    }

    resolves (data) {
        this.gaiType(data, "resolve");
    }

    rejects(data) {
        this.gaiType(data, "reject");
    }
    gaiType(data, type) {
        if(this.type != "outstanding") return;
        this.type = type;
        this.data = data;
        this.zhuangHui();
    }
    // 执行对应状态绑定的函数
    zhuangHui() {
        let fun = null;
        // 放在微任务中，没有办法，只能放在宏任务中，产生异步的效果
        setTimeout( () => {
            if( this.type == "resolve") fun = this.resolve;
            else if(this.type == "reject") fun = this.reject;

            if(this.fallfun) fun = this.fallfun;
            try {
                const data = fun(this.data);
                if( !this.promise ) return;
                if(data instanceof MyPromise) {
                    // 把下一个绑定的函数，换一个绑定的位置
                    data.reject = this.promise.reject;
                    data.resolve = this.promise.resolve;
                    data.fallfun = this.promise.fallfun;
                    data.promise = this.promise.promise;
                }
                else {
                    this.callBackRun = data;
                    this.promise.resolve(this.callBackRun);
                }
            } catch(e) {
                // 发生错误，如果有下一个promise对象，触发失败的回掉函数
                if( !this.promise ) return;
                // 如果下一个没有的话，就会一直往下漏
                this.promise.reject(e);
            }
        } )
    }
    
    
    // 接受的函数可以控制下一个promise的状态
    then(resolve, reject) {
        this.resolve = resolve;
        this.reject = reject;

        this.promise = new MyPromise();
        return this.promise;
    }
    finally(fall) {
        this.fallfun = fall;
        this.promise = new MyPromise();
        return this.promise;
    }
}
```




#### 模板字符串

1. 功能
   1) 简化了字符串的拼接，以及换行
   2) Es5要想实现字符串的拼接，需要借助运算符+。
   3) 换行，需要借助换行符\n，如果直接敲回车键，需要在换行前，使用\进行转义。


2. 使用
   1) ``表示一个模板字符串。
   2) 直接敲击回车键，就会形成回车的效果
   3) \n也具有换行的效果
   4) 字符串拼接，可以使用+，模板字符串也是字符串。
   5) 字符串拼接，可以在模板字符串中使用${}进行拼接。{}中写拼接表达式。
      1) 比如: 
      ```js
      `a${1 + 2}c`
      ``` 
      相当于 'a' + (1 + 2) + 'c'
      2) 既然{}中写表达式，而``也是表达式，所以可以进行嵌套使用
      3) 比如: 
      ```js
      `a${ `d${s}` }c`
      ``` 
   6) 如果模板字符串中显示正常的${}字符，需要把$进行转义，后面的{}也会变成字符串格式
      1) 转义方式通过\，比如: \${}。






#### 模板字符串标记

1. 作用
   1) 可以更加灵活的控制模板字符串


2. 原理
   1) 通过调用函数
   2) 把模板字符串进行拆分，作为函数的参数进行传入
   3) 把函数返回值，作为字符串，赋值给其它变量
   4) 拆分规则
      1) 以${}进行拆分，即拼接字符串的位置，即表达式
      2) 把拆分形成的数组，作为函数的第一个参数传入
      3) 第一个${}中的表达式的运算结果作为第二个参数传入
      4) 第二个${}中的表达式的运算结果作为第三个参数传入  等等，后面依次类推
      5) 比如: `a${1 + 2}bc${2 + 3}dd`，分割完传参形式为
         1) `(["a", "bc", "dd"], 3, 5)`
   5) 启用函数的规则
      1) 在模板字符串前面加上函数名，作为标记，会自动启动函数，并且传入对应的分割值
      2) 比如: 
      ```js
      const a = abc`a${1 + 2}bc${2 + 3}dd`
      ```
      3) 自动启动abc函数，然后把abc函数的返回值，赋值给a。abc函数是自定义的函数
      4) 这样就可以利用函数返回值，以及函数接收到的参数，达到对字符串动态控制的效果
         1) 函数的功能非常强大


3. 代码示范
```js
const a = abc`a${1 + 2}bc${2 + 3}dd`;
function abc(arr, $1, $2) {
    console.log(arr, $1, $2);
    // 可以返回任意值
    return "123";
}
// a为"123"
console.log(a);
```









#### 属性描述符(Es5)

1. 作用
   1) 属性描述符，用于描述对象中某个属性信息
   2) 属性描述符是一个对象，一个属性有多个描述信息


2. 属性描述符对象中的属性(描述信息)
   1) value: ?
      1) 该属性的属性值，代表描述属性的属性值
   2) writable: false
      1) 该属性的属性值，代表描述属性是否可写(是否可以修改)
      2) true为可以修改，是默认值
      3) false为不可以修改
   3) enumerable: false
      1) 该属性的属性值，代表描述属性是否可枚举
      2) true为可以枚举，是默认值
      3) false为不可以枚举，无法通过for-in循环遍历到该属性，Object.keys也无法获取到该属性
   4) configurable: false   属性不可删除
      1) 该属性的属性值，代表描述属性是否可以删除
      2) true为可以删除，是默认值
      3) false为不可以删除


3. 获取单个属性的描述信息
   1) 方法: `Object.getOwnPropertyDescriptor(a, "name")`
   2) 传参: 第一个参数传入对象，第二个参数传入属性
   3) 返回值: 返回属性描述对象


4. 获取整个对象的属性的描述信息
   1) 方法: `Object.getOwnPropertyDescriptors(a)`
   2) 传参: 传入获取的对象，获取整个对象的所有属性的描述信息
   3) 返回值: 返回一个对象，对象的属性为描述属性，对象的属性值为该属性的描述信息


5. 设置单个属性的描述符信息
   1) 方法: `Object.defineProperty(a, name, {})`
   2) 传参: 第一个参数传入对象，第二个参数传入属性，第三个参数传入描述信息对象
   3) 现象: 传入的属性描述信息对象，与之前的进行合并，相同的替换
      1) 把合并完的对象，作为该属性的属性描述对象


6. 设置多个属性的描述符信息
   1) 方法: `Object.definePropertys(a, {})`
   2) 传参: 第一个参数传入属性位于的对象，第二个参数传入对象
      1) 第二个参数对象的属性名，为设置的描述信息的属性
      2) 第二个参数对象的属性值，为设置的描述信息
   3) 现象: 传入的属性描述信息对象，与之前的进行合并，相同的替换
      1) 把合并完的对象，作为该属性的属性描述对象


7. 设置存取器属性
   1) 如果设置的属性描述信息对象中存在下面两个属性
      1) `set`，属性值为函数，修改属性的属性值时，执行该函数，并不会对属性造成任何影响
      2) `get`，属性值为函数，获取属性的属性值时，执行该函数，得到函数运行的返回值
   2) 注意
      1) set和get不能与value和writable共存。
      2) get和set中不能操作监听的数据，否则会陷入死循环
         1) 比如: 读取触发get，如果get中在对数据读取，然后依旧触发get，陷入死循环





#### 文件上传

1. 流程
   1) 浏览器获取文件
      1) 之前，浏览器是无法获取本地文件的
      2) **HTML5给input标签新增加了一个type属性`file`**
         1) 给input标签的type设置上`file`属性值，该标签就变成了一个按钮
         2) 点击该按钮，就会弹出一个选择框，用来选择本地文件
         3) 双击本地文件，就可以选中文件
   2) js获取选中的文件数据
      1) 选中对应的input标签(获取dom)
      2) 当选中文件后，就可以通过dom上的files属性获取到选中的文件数据
      3) 获取的是一个数组格式的数据
         1) input标签支持选中多个文件，行间加上`multiple`属性，属性值设置为true
            1) 简写: 行间只写`multiple`，属性值默认为true
         2) 为了保存选中的多个文件的数据，默认格式为数组
   3) 发送请求(传输获取到的文件数据)
      1) 设置请求方式: 由于文件过大，所以上传方式选择`POST`方式
      2) 设置传输的数据格式
         1) 在请求头中设置，对应的键值对为`"Content-Type": "multipart/form-data"`
         2) **该操作可以不用写，请求体设置完成，会自动配置请求头**
      3) 设置请求体
         1) 由于请求是POST格式，所以传输的数据放在请求体中
         2) 请求体通常写成键值对的格式
            1) 键名: 该键名对应的数据，类似对象
            2) 更加灵活的处理数据
         3) 为了约定传输，服务器给定一个键名(防止恶意存储)
            1) 认为，该键名对应的键值才是浏览器传输过来的文件数据，才进行处理保存
            2) 通过其他键值对传输过来的文件数据不进行处理
            3) 安全起见，防止恶意向服务器传输文件，服务器进行保存
         4) form-data格式的数据，比较特殊，写起来麻烦，可以利用构造`函数FormData`进行创建
            1) `const a = new FormData();`  构建一个空的请求体
            2) 向请求体中添加键值对
               1) `a.append("键名", 键值)`
               2) 可以调用多次，添加多个键值对数据，组成请求体


2. 示范代码
```js
async function a() {
    const res = new FormData();
    // img为服务器约定的键名，传入input标签选中的文件数据
    res.append("img", document.getElementById("a").files[0]);
    
    // 发送请求
    await fetch("http://127.0.0.1:10086", {
        method: "POST",
        body: res
    });
}

// 点击按钮，发送文件
document.getElementById("d").onclick = () => {
    a()
};
```





#### 异步-async和await关键字

1. **作用**
   1) 简化创建promise对象的书写
      1. 不用在then、then的链式调用，看起来不是很方便
   2) 是一个语法糖


2. **使用**
   1) `await`的使用，必须在`async`的环境下
      1) `async`的使用可以没有`await`
      2) `await`的使用必须存在`async`


3. **async的使用以及原理**
   1) 作用
      1) 创建一个promise对象
   2) 使用
      1) 该关键字加在函数的前面，即function的前面
      2) 对应的函数就变成了promise对象的创建函数
      3) 如果对应的函数在执行时报错，则该函数创建的promise对象的状态变为`rejected`
      4) 默认触发成功状态，函数的返回值，作为触发成功状态时的传参
      5) **被标记的函数中的代码是同步执行的，并不是异步执行**
         1) 等价于Promise传参函数中的函数体，是立即执行的
   3) 示范代码
   ```js
   async function a() {
       console.log(123);
       return 1;
   }
   // 相当于
   function a() {
       return new Promise( (resolve, reject) => {
           console.log(123);
           resolve(1);
       } )
   }
   ```


4. **await的使用以及原理**
   1) 作用
      1) 进行异步管理
   2) 使用
      1) **await也是一个标记，并且存在于被async标记的函数中**
      2) **await后面的代码就是异步执行的**
      3) await标记一个表达式，表达式的运算结果返回
         1) 即 `const a = await ?;`
         2) a接收到的就是await后面表达式的返回值
      4) await后面跟一个普通的表达式，则下面的代码直接执行(异步执行)
      5) await后面跟一个promise对象，则下方的代码执行，受promise对象的状态控制
         1) 当状态变为resolved时，下方的代码才继续执行
   3) 原理
      1) **await下方的代码是放在then中的成功回调函数中，作为函数体存在**
      2) **函数的执行受await后面的promise对象的状态控制**
      3) 如果后面是一个普通的表达式，则自动创建一个promise对象
         1) 默认触发成功状态，表达式的值，作为触发成功状态的传参
         2) 报错，触发async绑定函数创建的promise对象的失败状态
         3) 可以使用try-catch捕获错误，进行处理
            1) 只有成功回调函数，如果报错，没有失败回调函数，await处就会报错
            2) try-catch就可以进行错误的捕获
            3) 如果没有进行捕获，则相当于async绑定函数报错，触发promise对象的失败状态
      4) await后面的promise对象的状态变为成功状态后，状态传入值，传入回调函数中
         1) 即声明的接收await返回数据的变量
   4) 注意点
      1) async绑定的函数，创建的promise对象的状态，受函数执行的返回值的控制
      2) 由于await会阻止代码的执行，所以return的执行也会被阻止，还没有解析
      3) 此时创建的promise对象的状态是改变不了的
      4) 只有，所有的await处理完成，才解析到return，改变创建的promise对象的状态
         1) 此时创建的promise对象上绑定的回调函数才进行执行
         2) 即创建的promise对象上绑定的回调函数最后执行 
      5) await虽然造成阻塞的现象，其实是把代码放在了then中进行注册
         1) 然后等待await后面的promise对象状态的改变
         2) **实际上执行栈中的代码执行是没有阻塞的**






#### 异步-异步任务队列

1. **分类**
    (1)  宏任务。 主要有setTimeout，setInterval，ajax
    (2)  微任务。 主要有Promise

2. **执行具体过程的分析**
当主线程执行完成后，会进入微任务队列，查看是否有函数需要执行。如果有把函数取出放到主线程中进行执行，只取一个。
当取出的函数执行完，主线程又空了，会继续查看微任务队列。
当微任务队列为空时(没有函数)，会进入宏任务队列中取一个函数放到主线程执行。
当取出的函数执行完，主线程又空了，还是去微任务队列查看，为空时，再去宏任务队列。

3. **总结**
每次从宏任务和微任务队列中取一个函数(先存先出)，进行执行。执行完成后，在去宏任务和微任务队列中取一个函数(先存先出)，进行执行。并且每次都是先查询微任务队列，哪怕微任务是后存的。

4. **示范代码**
```js
setTimeout( () => {
    console.log(1);
} , 0);

new Promise( (res, rej) => {
    res();
} ).then( () => {
    console.log(2);
} )

setTimeout( () => {
    new Promise((res, rej) => {
        res();
    } ).then( () => {
        console.log(4);
    } )
}, 0)

setTimeout( () => {
    console.log(3);
}, 0)

// 打印顺序为: 2 1 4 3
```







#### 异步-异步编程发布订阅
对某个功能函数，进行次数的订阅。当该函数的触发(执行)次数达到订阅的次数，该功能函数才会被执行，处理相关的业务。

```js
// 订阅函数
class Store {
    // 传入订阅的次数
    constructor(value) {
        this.index = value;
        // 存储订阅的方法
        this.fun = [];
    }

    // 订阅函数的方法(功能函数，当达到订阅次数，执行订阅的方法)，把要订阅的函数传入
    subscribe(...func) {
        // 保存传入的订阅函数，进行回调
        this.fun = [ ...this.fun, ...func];
    }

    // 执行函数(当执行次数达到的情况下回调注册的订阅功能函数)，可以传递一些参数
    fire(...data) {
        this.index --;
        if(this.index === 0) {
            this.fun.forEach( (fun) => {
                fun(...data);
            } )
        }
    }
}

// 设置订阅的次数
let myStore = new Store(4);
// 传入订阅函数
myStore.subscribe( (a) => {
    console.log(a, "订阅函数1");
}, (a) => {
    console.log(a, "订阅函数2");
});
// 传入订阅函数
myStore.subscribe( (a) => {
    console.log(a, "订阅函数3");
} )

// 执行4次触发订阅函数，在异步函数中执行
myStore.fire("a");
myStore.fire("b");
myStore.fire("c");
myStore.fire("d");
```





#### Map构造函数

1. 作用
   1) 专门创建一个存放键值对的集合

2. 以前存放键值对的方法
   1) 键值对类似对象属性，所以在Es6之前都是用对象存放键值对的
   2) 使用对象存放键值对的缺点
      1) 对象属性只能是字符串或者符号(symbol)
      2) 对象不容易获取存放数据的个数
      3) 容易产生与原型上某个属性重名的现象，这样原型上的属性就无法使用了

3. 特点
   1) 键名(属性名)可以是任意的数据
      1) 即使是函数、对象、数组，也能作为键名(属性名)。
      2) 增加键值对的对应关系。
      3) 比如以某标签的dom作为属性名，属性值为该标签的一些数据
      4) 标签与数据具有很强的对应关系，这在对象中是做不到这么完美的

4. 创建Map对象
   1) 方式: `let a = new Map();`

5. 存放数据
   1) 创建时存储，传参有要求
      1) Map传参，传入的也是一个可迭代的集合
      2) **传入集合的每一项必须为数组**
      3) 存放数据时: 先迭代外层的集合，得到子集合(数组)
      4) 然后数组的第一项数据作为键名，数组的第二项作为键值
         1) 如果数组的长度大于2，则后面的数据失效
      5) 然后继续迭代外层的集合，继续创建键值对
      6) 底层使用`Object.is方法`进行键名的判断，如果相同，则替换之前的键值对
   2) 创建完成后存储
      1) Map构造函数的原型上，有一个`set方法`，使用该方法可以向map对象上添加数据
         1) 传递的第一个参数，作为键名
         2) 传递的第二个参数，作为键值
         3) 底层使用`Object.is方法`进行键名的判断，如果相同，则替换之前的键值对
      2) 比如: `map.set({}, 123);`



6. 数据的获取
   1) 通过Map原型上的`forEach方法`(不是数组上的)遍历获取
      1) forEach传入的回调函数，共接收三个参数
         1) 第一个参数，接收本次遍历的键值
         2) 第二个参数，接收本次遍历的键名
         3) 第三个参数，接收遍历的map对象
   2) 通过Map原型上的`get方法`获取具体的键名对应的键值
      1) 传入对应的键名
      2) 如果没有对应的键值对，则获取undefined
      3) 如果属性名是引用类型的数据，必须保存到外界，这样才能根据索引获取到对应的属性值
         1) 否则键名是对应不上的
   3) 使用for-of进行迭代(map对象也具有可迭代协议)
      1) 遍历出的数据是数组格式，和创建Map存放数据的格式一样。
      2) 第一项为键名，第二项为键值
      3) **并不是键值**



7. 删除某个键值对和清空整个集合
   1) 删除: 借助原型上的`delete方法`
      1) 传入要删除的键名，删除成功返回true，删除失败返回false
      2) 如果删除一个没有的键值对，则返回false(删除失败)
   2) 清空: 借助原型上的`clear方法`，无参数传递



8. 查看map集合中共存放了多少条数据
   1) 借助私有属性`size`
   2) 由于该属性与map集合紧密相连，长度随时变化，所以该属性设置成了存取器属性
      1) 获取属性值，运行get方法，把get方法的返回值，返回。


9. 验证map集合中有没有某个键值对
   1) 使用原型上的`has方法`，传入键名
      1) 有返回true，没有返回false。


10. 扩展(map集合底层存放原理)
Map存储数据，依靠的是链表、hash(哈希算法)、桶。

Map的底层共有八个桶(空间)，对应的有八个哈希值(每个哈希值对应一个固定的桶)。
每个桶之间的数据也是一个一个的对象，这些对象依靠链表(穿成一条线)建立联系。

```js    
//  以new Map([[{}, "s"], ["ss", 5], ["ct", 8]])
   
//  按照属性名计算哈希值，假设对象的是2，字符串的是4。
//  此处有两个字符串，都放入4号桶内，并且依靠next建立链表(穿成一串)，最顶层的是ss，第二个是st

// 具体如下   
   {
    /* 1 */   {}，
    /* 2 */   {
                  next: {
                      key: {},
                      value: "s",
                  }
              }，
    /* 3 */   {}，
    /* 4 */   {
                  next: {
                      key: "ss",
                      value: 5,
                      next: {
                          key: "ct",
                          value: 8,
                      }
                  }
              }，
    /* 5 */   {}，
    /* 6 */   {}，
    /* 7 */   {}，
    /* 8 */   {}
   }
```
  





#### Set构造函数

1. 特点
   1) 构造出一个存放数据的空间，该空间的展示样式为{}，但是不是对象。
      1) 类似数组，只有一个一个的属性值，但是没有长度
   2) **会自动去除重复的数据**(无论是创建时，还是添加时，都会进行去重处理)。
   3) 兼容性较差


2. 使用Set创建存储空间
   1) 创建一个空集合: `new Set()`
   2) 向集合中添加数据
      1) 在创建时添加: `const a = new Set(添加的数据)`
         1) 添加的数据必须是可以具有可迭代协议的数据
         2) 底层会自动进行迭代，然后把迭代到的数据，进行去重保存
         3) **字符串也是可以进行迭代的(每次迭代出一个字符)**
      2) 创建完成添加: 
         1) Set创建的集合上有一个`add`方法，通过该方法可以向集合中添加一个数据
            1) 如果添加的数据，集合中已经存在，则添加无效(去重)

3. 取数据
   1) Set创建的集合，也具有可迭代协议，并且只能通过迭代的方式取出数据
   2) 通过调用可迭代协议，创建出迭代器，然后使用next()方法，进行取数据
   3) 可以使用for-of循环取数据
   4) 可以使用点点点运算符取数据，**该方法通常用于Set集合转换成数组**
   5) 可以使用forEach进行遍历
      1) 该方法Set原型上重写的一个方法，并不是数组原型上的方法，但是功能相同
      2) 用于Set集合没有索引，所以第二个参数传入的也是当前遍历的数据
         1) 数组的forEach方法，第二个参数传入的是当前遍历的索引



4. 删除数据和清空数据
   1) 删除数据: 使用`delete`方法，传入要删除的数据，一次只能删除一个
      1) 删除成功，返回true
      2) 删除失败，返回false，比如删除一个没有的数据，返回false
   2) 清空数据: 使用`clear`方法，无参数传递



5. Set集合和数组之间的相互转换
   1) 数组转Set: 创建Set时，把数组传入就可以实现。
   2) Set转数组: 两种方式
      1) `[...Set]`
      2)  `Array.from(Set)`


6.  Set主要用来数组和字符串的去重处理

7. Set去重的原理
   1) 底层借助的是`Object.is`判断，数据是否相同
   2) Set去重，认为+0和-0是相同的数据，与`Object.is`存在差异
      1) 先判断+0和-0，然后在使用`Object.is`进行判断
      2) 这也是前端面临的现象，规则不统一，不是一个人写的，也没有一个规范进行限制


8. 获取Set集合中存放的数据个数
   1) Set创建的集合中，存在一个私有属性`size`
      1) 通过该属性就可以获取到当前集合中存放的数据个数
   2) 由于该属性与set集合紧密相连，长度随时变化，所以该属性设置成了存取器属性
      1) 获取属性值，运行get方法，把get方法的返回值，返回。







#### 新增的一些字符串API

1. `includes`
   1) 作用: 判断某个字符串中有没有某个字符
   2) 使用: `字符串.includes(子字符);`，返回Boolear值
      1) 子字符可以是多位(比如: "abc")
   3) 可以传递第二个参数，格式为number类型，表示从字符串什么位置开始判断

2. `startsWith`
   1) 作用: 验证字符串是不是以什么开头
   2) 使用: `字符串.startsWith(子字符);`，返回Boolear值
      1) 子字符可以是多位(比如: "abc")
   3) 可以传递第二个参数，格式为number类型，表示字符串的某个位置是不是以某子串开头

3. `endsWith`
   1) 作用: 判断某个字符串是不是以什么位置结尾
   2) 使用: `字符串.endsWith(子字符);`，返回Boolear值
      1) 子字符可以是多位(比如: "abc")
   3) 可以传递第二个参数，格式为number类型，表示字符串的某个位置是不是以某子串结尾

4. `repeat`
   1) 作用: 让一个字符串重复几次，形成一个新的字符串
      1) 比如'abc'，重复3次。形成'abcabcabc'
   2) 使用: `字符串.repeat(次数);`，返回string值
   3) 只能传递一个参数






#### 新增对象字面量的语法

1. 属性速写
   1) 对象中的某个属性，对应的属性值是从外界引入的
   2) 并且属性名和外界属性名相同，就可以进行简写
   3) 比如: `const a = { name: name }` 就可以进行简写
   4) 简写格式: `const a = { name }`  

2. 方法速写
   1) 对象中定义方法可以进行简写，省略关键词function的书写
   2) 比如: `{ a: function () {} }` 可以简写为`{ a() {} }`

3. 表达式属性
   1) 对象中的属性使用表达式
   2) Es5只能先创建对象，然后`obj[表达式] = ?`
   3) Es6的对象中可以直接写`{ [表达式]: ? }`
   4) 比如: `const a = "name"; const obj = { [a] : 1 }` 相当于 { name: 1 }






#### 新增获取字符串Unicode编码

1. **作用**
   1) 可以间接的求出字符串的长度

2. **字符码点和码元的介绍**
   1) 刚开始时，由于硬件有限，只有16位的码元。也就是只有 2^16 个字符
   2) 后来随着技术的发展，这点字符已经不够用了，于是开发了32位的码元
   3) 之前的字符，还是前16位，后16位为0，表示占一个码元
   4) 之后添加的字符，前16有值，后16肯定也有值，表示占两个码元
   5) 字符所占的码点都是一个
   6) 但是字符串的长度，取得却是码元值。在一定程度上会造成误差
   7) 一些古汉字，是占有两个码元的，即length = 2
   8) 现代汉字，是占有一个码元的，即length = 1
   9) 造成了字符串长度的误差(比实际的长)
   10) **求字符串长度，根据码点求出的才是正确的，而length默认是根据码元求**

3. **Es6提出了一个方法`字符串.codepointAt()`**
   1) 通过该方法可以获取一个字符的Unicode编码
   2) Es5中也有一个方法可以获取Unicode编码(`charCodeAr`)
      1) 该方法获取的是码元的Unicode编码，如果是双码元字符，需要求和，才是真正的Unicode编码
      2) `const Unicode = 双码元字符.charCodeAt(0) + 双码元字符.charCodeAt(1)`
   3) `codepointAt方法`可以直接获取到Unicode编码，双码元的字符不用手动求和
      1) 其实底层自动完成的求和
      2) `双码元字符.codepointAt(0)`其实求得也是第一个码元的Unicode编码
         1) 只不过会自动查询后一位，如果后一位也有Unicode编码，表示是双码元字符
         2) 会自动求和然后返回。
         3) 如果使用 `双码元字符.codepointAt(1)`，一看后面没有Unicode编码，会认为是单码元字符，直接返回结果，即`双码元字符.codepointAt(1) = 双码元字符.charCodeAt(1)`
         4) 所以使用`codepointAt()`求双码元字符的Unicode编码，必须从第一个码元求才正确。
      3) 获取的是实际的32位值，只要与0xffff进行比较，如果大于，则表示实际长度应该减1
   4) 可以传递参数，表示求出字符串第几位的Unicode编码，默认是0


4. **示范代码**
```js
const a = "abc";
function _length(str) {
    // 保存实际的字符串长度
    let length = 0; 
    // 遍历字符长度，如果有双码元字符，长度肯定长
    for(let i = 0; i < str.length; i ++) {
        // 判断是否是双码元
        if( str.codePointAt(i) > 0xffff ) {
            // 表示是双码元，i要加上1，一定是从第0个码元开始，隔去第1个码元
            i ++;
        }
        // 实际的长度，双码元也只相加一次(少循环一次，相当于双码元只加一次)
        length ++;
    }
    return length;
}
console.log(_length(a));
```
      






#### 新增数组API

1. **静态方法**
   1) `Array.of(...args)`: 使用指定的数组项创建一个新数组
      1) 传递一个参数，创建的数组长度为1，数据为传入的值，而不是把传入的值作为长度
   2) `Array.from(args)`: 通过给定的类数组或者可迭代对象创建一个新数组


2. **实例方法**
   1) `find(callback)`: 用于查找满足条件的第一个元素
      1) 传入回调函数，然后开始自动遍历数组，并且执行回调函数
      2) 然后传入数组对应的数据以及索引
      3) 当回调函数执行时，返回false，循环继续
      4) 当回调函数执行时，返回true，循环停止，表示满足条件，返回对应的数组数据
   2) `Array.findIndex(callback)`: 用于查找满足条件的第一个元素的下标
      1) 传入回调函数，然后开始自动遍历数组，并且执行回调函数
      2) 然后传入数组对应的数据以及索引
      3) 当回调函数执行时，返回false，循环继续
      4) 当回调函数执行时，返回true，循环停止，表示满足条件，返回对应的数组数据的索引
   3) `Array.fill(data)`: 用传入的数据，填充完整个数组
      1) 直接通过`new Array()`，传入一个数据创建指定长度的对象，数组的每一项为空
      2) 这种对象，是无法使用forEach方法的
      3) 可以通过fill方法填充完数据，在使用forEach进行遍历
   4) `Array.copyWithin(target, start?, end?)`: 用数组中的数据，替换数组中的数据
      1) 第一个参数，设置从什么位置开始替换
      2) 第二个参数，设置从什么位置开始取数据，进行替换，默认为0，
      3) 第三个参数，设置什么取数据，什么位置结束，默认数组的最后
      4) 改变原数组，返回原数组。
      4) 示范代码
      ```js
      const a = [1, 2, 3, 4, 5]
      // 第三位，3后面开始替换，第二位，2后面开始，第四位，4后面结束，没到5
      // 数组变成 [1, 2, 3, 3, 4]
      const b = a.copyWithin(3, 2, 4);
      // 结果为true
      console.log(a === b);
      ```
   5) `Array.includes(data)`: 判断数组中有没有某个值，底层用`Object.is`进行判断







#### 新增正则-u
   1) 作用: 可以匹配双码元字符
   2) 比如: const a = "?"  是一个双码元字符
      1) const z = /./  z.test(a);  匹配失败，一个任意字符无法匹配两个码元的字符
      2) const z = /./u;   加上u，一个任意字符就可以匹配两个码元的字符



#### 新增正则-y
   1. 表示粘连标记，**这个标记只会匹配一次，也就是，从匹配的位置开始，就要符合定义的正则，如果不符合，则匹配失败，它是不会继续向后匹配的(也就是全局进行匹配，即使设置了g标记)**
      1. 匹配位置从0开始，相当于 `/^D/`
      2. 可以使用`z.lastIndex`，更改匹配位置
   2. 示范代码
   ```js
   const str = "abc def";
   const regExp = /bc/y;
   // 匹配位置默认，从0开始，显然是匹配失败的，所以得到的是false，不会向后继续匹配
   console.log( regExp.test(str) );
   // 更改匹配位置
   regExp.lastIndex = 1;
   // 由于更改了匹配位置，从1开始，显然是匹配成功的，得到true
   console.log( regExp.test(str) );
   ```
  




#### Object新增的API

1. `Object.is()`
   1) 作用: 用来判断两个数据是不是完全意义上的相等
   2) 和 === 的作用相同，只有两个特殊值比较不同
      1) NaN和NaN比较，结果相同。===判断结果不同，不符合常理
      2) +0和-0比较，结果不同，===判断结果相同
         1) 在数学上相同，但是在计算机中存储方式不同，所以判断结果应该不同，不符合计算机常理
      3) 为了解决 === 的这两个情况，提出了更加完善的`is方法`
   3) 使用: 把判断的两个数据，作为参数进行传入。函数返回判断的结果，为Boolear。


2. Object.assign()
  1) 作用: 该方法可以合并对象，也可以实现对象的浅层克隆
  2) 使用: 把要合并的对象一个一个的传入，不限个数
  3) 合并规则: 
     1) 后面传入的对象中的属性，全部合并到传入的第一个对象中
     2) 如果存在相同属性，则后面传递的对象中的属性值，替换掉前面传递对象中的属性值
  4) 然后把合并的对象返回
     1) 返回的对象就是传入的第一个对象(进行判断，是同一个对象)。
     2) 为了防止对其它对象产生影响，通常第一个参数传入一个空对象
     3) 比如: `Object.assign({}, obj1, obj2)`
     

3. Object.getOwnPropertyNames()
   1) 该方法Es5就已经存在，Es6对其进行了修改
   2) 作用: 该方法传入一个对象，然后返回一个数组，数组的每一项是对象中的属性名
      1) 之前对返回数组中的属性名，没有排序要求，浏览器厂商自行决定
      2) Es6对其进行了排序。先排数字(按照升序排序)，再排其它(按照书写顺序)
   3) 示范代码
   ```js
   const obj = {
       name: "s",
       age: 18,
       0: "a",
       3: "b",
       2: "d"
   }
   console.log( Object.getOwnPropertyNames(obj));
   // 打印[0, 2, 3, "name", "age"]  进行了排序
   ```


4. Object.setPrototypeOf()
   1) 作用: 修改一个对象的原型指向
   2) 使用: 该函数接收两个参数。底层原理: `第一个参数.__proto__ = 第二个参数`








