#### 执行流程
- 执行顺序：先微后宏，有微就执行微任务
- 大概的执行顺序
  - 先执行主线任务，主线任务执行完，去微任务队列查看
  - 如果微任务队列中有待执行的方法，就把代码拿到主线程中进行执行
  - 主线程执行完，又会去微任务队列查看，如果有，再拿到主线程中执行
  - 直到微任务队列执行空，然后去宏任务队列中查看，如果有就拿到主线程中进行执行
  - 执行完，会再去微任务队列中查看（虽然此时是从宏任务队列中获取的函数），微任务队列中没有，然后再去宏任务队列中查看
  - 直到两个队列执行空


#### 特殊现象（易出错的地方）
- 微任务都执行完了，宏任务执行的时候又往微任务中加入了一个待执行的代码。就会发现会先执行微任务中新添加的代码，然后在继续执行宏任务中剩余的代码

- 比如
```js
setTimeout(() => {
    console.log('宏任务1');
    Promise.resolve().then(() => {
        console.log('宏任务1添加的微任务2');
    })
}, 0)

setTimeout(() => {
    console.log('宏任务2');
}, 0)

Promise.resolve().then(() => {
    console.log('微任务1');
})
console.log('主线程');

// 打印顺序：
//   主线程
//   微任务1
//   宏任务1
//   宏任务1添加的微任务2
//   宏任务2
```

- 宏任务1 执行完，没有执行 宏任务2 的原因：就是因为 宏任务1 执行完，又往微任务队列中添加了待执行的代码。此时微任务队列就不是空的了