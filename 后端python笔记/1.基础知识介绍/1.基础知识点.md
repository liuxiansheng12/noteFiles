<script src='/笔记/see/index.js'></script>
[toc]



#### 准备-环境安装（Mac电脑）
- 搜索 python，进入官网，点击 downloads 进行下载
  - mac电脑，下载安装很简单
  - 点击 Download Python 3.10.0，下载安装包
  - 然后，一直下一步就行了

- mac安装成功后，启动台中就会出现个东西 `IDLE` 
  - 点击后，就会出现一个命令框
  - 在命令框中输入 python 代码，可以执行，表示安装成功
    - 比如 `print(123)`，如果控制台打印123，表示环境安装成功



#### 准备-安装编辑器
- 搜索 pycharm 
  - 进入官网: https://www.jetbrains.com/pycharm/
  - 点击: DOWNLOAD，进入下载页面
    - 有两个版本，一个开发版，收费
    - 一个社区版，免费，可以下载这个
  - mac下载安装很简单，直接点击对应版本的 download，进行下载就可以了
  - 下载完成后，就会自动安装

- 安装完成后，第一次打开软件，会出现一个选择框，直接点击 `ok`，就可以使用了




#### 数据-print的使用
- print是python的输出打印函数
  - 该函数的参数，除了传递需要打印的数据外，还可以传递一些配置
- `print` 除了打印字面量，还可以运行表达式
  - 比如
    ```py
    print(1 + 2)
    # 表现形式：3
    ```
- 考虑，两个print连用，为什么第二个打印在第一个的下面（换行）
  - 而不是，两个连一块显示出来
  - 原因：print中有一个 `end` 属性，默认是 `\n`（换行)
    - 作用，在最后拼接一个什么东西，由于默认是换行，所以下一次打印就打印在上一次的下面，因为上一次最后有一个换行
  - 比如：
    ```py
    print("word")
    print("word")
    ```
    - 底层打印的结果就是 `word\nword\n`，在换行符的作用下，第二个word就另起一行了
  - end属性，可以自定义（不使用默认的 \n），比如
    ```py
    print("word", end="")
    print("word")
    # 表现形式：wordword

    print("word", end="*#")
    print("word")
    # 表现形式：word*#word
    ```
- 两个打印结果（两个值），中间想要加点什么，除了利用 `end`，还有种方式可以实现
  - 利用 `sep`
  - 作用：一个 `print` ，多个参数中间用什么拼接，默认是 ` `（空格）
  - 比如
    ```py
    print("word", "word", "word", sep="*#")
    # 表现形式：word*#word*#word
    ```
  - `sep` 和 `end` 连用
    - sep是在中间拼接，end是在最后拼接
    - 比如
      ```py
      print("word", "word", "word", sep="*#", end="!!!")
      # 表现形式：word*#word*#word!!!
      ```
- 把打印内容，写到文件中
  ```py
  # a+，a表示没有文件就创建，+表示采用追加的方式，添加内容
  fy = open("./demo.txt", "a+");
  print("123", file=fy)
  fy.close()
  ```



#### 数据-转义字符
- 要想让一个字符，失去本来的意义，可以借助 `\`
  - 用 `\` 修饰的字符，就是转义字符
- 比如：`n`，加上 `\`，`n`就不是`n`了，而是换行
- 示范
  ```py
  print("a\nb")
  print("a\tb")
  print("abc\rddd") # 表现形式：ddd（替换前面的）
  print("abc\bddd") # 表现形式：abddd（往前回一位）
  print("http:\\\ds") # 表现形式：http:\\ds
  print('\'\'') # 表现形式：''
  print("abc\\") # 表现形式：abc\（最后一个字符不能是 \，如果想要展示，需要转义）
  ```




#### 数据-input的使用
- input是python的输入函数
  - 该函数，就是在控制台中，让开发者输入一些东西
  - 得到的是字符串类型
  ```python
    password = input("请输入数据：")
    print(password, type(password))  # 打印出  123 <class 'str'>，所以得到的是字符串类型
  ```



#### 数据-二进制
- 一个字节：0000 0000 -> 1111 1111 （八位）
- 英文一个字节，中文两个字节
  - 比如
    ```py
    print(chr(0b01000110)) # 表现：英文（一个字节）
    print(chr(0b0100011011000110)) # 表现：中文（两个字节）
    ```



#### 数据-数据类型
- 数据类型
    - 整型： int
    - 浮点型： float
    - 复数
    - 字符串类型：str
    - 布尔类型：True、False
    - 列表：[1, 2, 3, 4]
    - 字典：{"a": 1, "b": 2}
    - 元祖：(1, 2, 3)
    - 集合：{'a', 3, true, '张三'}

- 获取一个数的数据类型
  - 使用 type();
  ```python
  type(1)
  type(True)
  type('张三')
  type([1, 2, 3])
  ```

- 字符串不能和数字做运算
  - 不像其他语言，字符串加上一个变量，会变成字符串的拼接，在python中，会报错



#### 数据-获取存储数据的内存ID
- 数据，是存在内存中的一个一个的盒子中，每个盒子都有自己编号
- 获取内存id的方式（通过方法id进行获取）
  ```py
  a = 3
  b = 4
  c = [1, 2, 3]
  # 获取数据存储的内存地址
  print(id(a))
  print(id(b))
  print(id(c))
  ```
- 如果重新赋值，会重新开辟一个空间，进行新的数据存储（数据不一样）
  - 之前的数据空间，就变成了垃圾空间（没有变量指向该空间），最终由垃圾回收机制进行垃圾回收
  - 由于重新开辟了空间，所以变量指向的内存id就发生了变化
  - 比如
    ```py
    a = 3
    print(id(a))

    a = 8
    print(id(a))

    # 表现：两次id获取的不一样
    ```


#### 数据-数据类型转换
- 具体的方法
  - 转整型：int()
  - 转浮点型：float()
  - 转布尔：bool()
  - 转字符串：str()

- 示范
  ```py
  print( int('1') )
  print( str('1') )
  print( bool('1') )
  print( float('1') )
  ```

- 注意点
  - `int`（只能把整数字符串、浮点数(取整数部分)、布尔转换成int类型）
    - 其他字符串转换不了（会报错）
    - 比如
      ```py
      int("a")   # 不行
      int("10a") # 不会自动截取
      int("10.0") # 小数字符串也不行
      ```
  - `int`，第二个参数，可以传递进制
    - 把第一个参数，作为几进制，然后进行转换（默认10进制）
    - 比如
      ```py
      # 如果不传递16，默认作为十进制进行转换，而a超过了十进制范围，所以会报错
      int('aa', 16)  

      int('gg', 16) # 即使作为16进制转换，也会报错
      ```
      - 总结：字符不能超过进制的表示范围，否则转换不了
  - `str`，可以把任何数据转换成对应的字符串
  - `bool`
    - 只有 None、0.0、0、''（空字符串）、[]（空列表）、list()（空列表）、()（空元组）、tuple()（空元组）、{}（空字典）、dict()（空字典）、set()（空集合） 会转换成 False
    - 其他的全是 True
  - `float`（只能把整数字符串、小数字符串、整数(加.0)、布尔转换成float类型）
    - 其他字符串转换不了（会报错）



#### 数据-进制表示
```py
print("十进制", 11);
print("二进制", 0b11);
print("八进制", 0o11);
print("十六进制", 0x11);
# 最终打印，都会打印成对应的十进制
```


#### 数据-进制转换
- 转二进制：bin()
- 转八进制：oct()
- 转十六进制：hex()

- 注意点
  - 每个方法，传入的都是一个整型（可以是进制表示的，进制表示也是整数），传入字符串会报错
    - 比如：bin(0o56)



#### 数据-补码和原码
- 数据存在内存中，存的都是补码格式

- `原码`转`补码`：
  - 正整数的补码是它本⾝
    - 即+1的原码：0000 0001，补码还是 0000 0001
  - 负整数的补码是符号位不变，其余位按位取反，再加1，
    - 例如：-1的原码：1000 0001，补码：1111 1111
  

- `补码`转`原码`
  - 正整数的补码即是原码。
    - 比如：1的补码：0000 0001，原码还是 0000 0001
  - 负整数已知补码求原码
    - 只需要再对补码求⼀次补码即可，即负整数的补码的补码即是原码。
    - 例：-1的补码：1111 1111，再取⼀次补码（符号位不变，其余位按位取反，再加1）即是原码：1000 0001
    


#### 运算符-算数运算符
- 算数运算符分类：`+（加）、-（减）、*（乘）、/（除）、//（整除）、%（取余）、**（幂运算）`
  - 其中：`//`会向下取整（即：`-3.4 -> -4`、`3.4 -> 3`）
    - 比如
      ```py
      print(10 // 4) # 表现形式：2.5 向下取整，所以结果为 2
      print(-10 // -4) # 表现形式：2.5 向下取整，所以结果为 2
      print(-10 // 4) # 表现形式：-2.5 向下取整，所以结果为 -3
      ```
  - 其中：`%`运算结果的正负号：商是正数余数就是正数，商是负数余数就是负数
    - 如果是浮点型，结果也是浮点型
    - 比如
      ```py
      print(-10 % 4) # 表现形式：-2，因为商是负数
      print(-10 % -4) # 表现形式：2，因为商是正数
      print(10 % 4) # 表现形式：2，因为商是正数
      print(10 % -4) # 表现形式：-2，因为商是负数
      print(10.0 % -4) # 表现形式：-2.0，因为商是负数，并且是一个浮点型
      print(10.2 % -4) # 表现形式：并不是 -2.2
      ```
  - 其中：`/`，得到的是一个浮点型
    - 比如： 6 / 2 = 3.0

.
- 算数运算符的使用范围
  - 参与运算的数据类型：`int`、`float`、`布尔（会作为0和1参与运算）`
  - `+`：还可以用于两个字符串的拼接
    - 不能实现，字符串和其他数据类型的拼接，报错
  - `*`：可以实现字符串的重复拼接
    - 比如:  'abc' * 2  --->  'abcabc'



#### 运算符-赋值运算符
- 赋值运算符可以实现：
  - 链式赋值
  - 参数赋值
  - 解包赋值
- 比如
  ```py
  # 链式赋值
  a=b=c=1

  # 参数赋值
  a += 3 # 相当于：a = a + 3
  a /= 3 # 相当于：a = a / 3
  a //= 3 # 相当于：a = a // 3
  a *= 3 # 相当于：a = a // 3
  # 算数运算符都可以和 = 联合使用，变成参数赋值

  # 解包负值（左右个数要一致，比如：a,b=1,2,3，个数不一致就报错）
  a,b,c=1,2,3
  print(a,b,c)
  ```

- 解包赋值还可以快速的实现两个数据的交换
  - 比如
    ```py
    a,b = 1,2
    a,b = b,a
    # 这样就快速实现了两个数据的交换
    ```




#### 运算符-比较运算符
- 字符串的比较
  - 字符串和字符串比较，比较的是 码值（即字符对应的十进制数字，后面有获取的方式介绍）
    - 挨个字符进行比较
  - 字符串 与 其他类型，使用 == 比较，永远为 False
  - 字符串 与 其他类型，使用 != 比较，永远为 True

- `==`：比较的是value
  - 只要print打印出来的结果长得一样，就为True
    - 因为print打印的就是value
  - 比如
    ```py
    print(1 == 1)
    print("ab" == "ab")
    print((1, 2) == (1,2))
    print([1,2,3] == [1,2,3])
    print({'a', 3, True, '张三'} == {'a', 3, True, "张三"})
    # 上面全是 True
    ```
- `is`：比较的是内存id是否相同（相同为true，不同为false）
  - 注意：不能写成 1 is 1，因为 is 比较的内存id，所以只能比较变量
  - 比如
    ```py
    a = 1
    b = 1
    print(a is b) # 表现形式：True，说明：两个基本类型的数据如果相同，就进行地址复用

    a = (1, 2)
    b = (1, 2)
    print(a is b) # 表现形式：True，说明：元组如果value长得一样，就会进行地址复用

    a = {"a": 1}
    b = {"a": 1}
    print(a is b) # 表现形式：False，说明：两个变量使用的内存空间不同（即使长得一样）

    a = [1,2,3]
    b = [1,2,3]
    print(a is b) # 表现形式：False，说明：两个变量使用的内存空间不同（即使长得一样）

    a = {'a', 3, True, "张三"}
    b = {'a', 3, True, "张三"}
    print(a is b) # 表现形式：False，说明：两个变量使用的内存空间不同（即使长得一样）
    ```
- `is not`：比较的是内存id是否不相同（不相同为true，相同为false）
  - 注意：不能写成 1 is 1，因为 is not 比较的内存id，所以只能比较变量
  - 比如
    ```py
    a = 1
    b = 1
    print(a is not b) # 表现形式：False，说明：地址相同（和 is 刚好相反）
    ```



#### 运算符-逻辑运算符
- 逻辑与 `and`、逻辑或 `or`、逻辑非 `not`
  - 比较的时候，如果值不是布尔类型，则使用类型转换，先转换成布尔类型，然后在进行比较（转换规则看类型转换）
- `and`：全True为True
- `or`：有一个Ture为Ture
- `not`：Ture为False，False为True
  - 比如
    ```py
    print(not True) # 表现形式为 False
    print(not False) # 表现形式为 True
    ```
- `not`操作一个数据（在前面），`and`和`or`操作两个数据（在中间）


#### 运算符-某个数据是否在某个数据的内部
- `in`：在为True，不在为False
  - 比如
    ```py
    print(1 in (1, 2)) # 表现形式为 True，元组中有 1
    print(3 in (1, 2)) # 表现形式为 False，元组中没有 3
    print(2 in [1, 2, 3]) # 表现形式为 True，列表中有 2
    print(2 in {1, 2, "a"}) # 表现形式为 True，集合中有 2
    print("ab" in "abc") # 表现形式为 True，字符串 abc 中有 ab
    ```
- `not in`：不在为True，在为False
  - 比如
    ```py
    print(1 not in (1, 2)) # 表现形式为 False，元组中有 1
    print(3 not in (1, 2)) # 表现形式为 True，元组中没有 3
    print("ab" not in "abc") # 表现形式为 False，字符串 abc 中有 ab
    ```



#### 运算符-位运算
- 按位与 &（全一为一）
  ```py
  print(0b11 & 0b10) # 表现形式：0b10，对应十进制为 2
  ```
- 按位或 |（有一为一）
  ```py
  print(0b10 | 0b01) # 表现形式：0b11，对应十进制为 3
  ```
- 按位异或 ^（相同为0，不同为一）
  ```py
  print(0b110 ^ 0b100) # 表现形式：0b010，对应十进制为 2
  ```
- 左移 <<
  ```py
  print(0b11110100 << 2) # 表现形式：0b1111010000，对应十进制为 976
  # 直接在后面补0，经测试32位不是最大（前面不会丢失，会继续补0）
  ```
- 右移 >>
  ```py
  print(0b11010 >> 2) # 表现形式：0b00110，对应十进制为 6
  # 往右挪两位，前面的补0，后面的删除
  ```
- 取反 ~
  ```py
  print(~0b01) # 表现形式：-2
  # 涉及到补码（底层存的是补码，然后按位取反，
  #   取反后得到的还是补码，然后在转换成对应的源码，就是取反后的数据）
  # 补码求原码的方式，上面有介绍
  ```



#### 运算符-优先级
- `**` --> `*、/、//、%` --> `+、-` --> `>>、<<` --> `&` --> `|` --> `比较运算符` --> `and` --> `or` --> `=`
  - 有括号，先算括号中的
- 总结来说：算数 < 位运算 < 比较 < 逻辑 < 赋值



#### 内置函数-range（创建一个序列）
- 什么是序列：一组有序的数（比如：1、3、5、7、9，在比如：1、2、3，在比如：2、4、6、8）
- 如果创建一个序列：`range()`，这个玩意有三个参数
  - 一个参数，是序列的终点
    - 默认起点是0
  - 两个参数，第一个是序列的起点，第二个是序列的终点
  - 三个参数，第一个是序列的起点，第二个是序列的终点，第三个是序列的步长
    - 默认步长是1
- 查看序列：要想查看完整的序列，需要借助list

- 示范代码
  ```py
  r = range(12); # 一个参数，是序列的终点
  print(r);  # 表现形式：range(0, 12)，看不出完整的整数序列
  print(list(r)) # 表现形式：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

  r = range(3, 8);  # 两个参数，第一个是序列的起点，第二个是序列的终点
  print(list(r)) # 表现形式：[3, 4, 5, 6, 7]


  r = range(3, 10, 3);  # 三个参数，第一个是序列的起点，第二个是序列的终点，第三个是序列的步长
  print(list(r)) # 表现形式：[3, 6, 9]
  ```
  - 使用range创建序列的好处：和直接写[1, 2, 3, 4, 5]相比，优点在哪里
    - 使用range创建的序列，所占的内存是一样的（无论序列有多大）
    - 因为：存储的信息就三个（起点，终点，步长）
      - 即使序列在长，存的也是这三个信息
      - 只有在使用到range的时候，会根据存储的三个值进行计算，然后得到结果
    - 所以，可以节省内存空间
    - 要是直接写[1, 2, 3, 4, 5]，就会直接开辟内存空间进行信息的存储
      - 如果过大，内存就会爆掉

.
- `range`可以与`in`和`not in`配合使用
  - `in`和`not in`的作用，就是判断某个数据是否在某个数据（集合）中
  - 而range创建的序列，也可以看成某个集合，所以就可以使用 `in`和`not in` 判断某个数据是不是在序列中
  - 示范代码
    ```py
    r = range(3, 10, 3);
    print(list(r)) # 表现形式：[3, 6, 9]
    print(3 in r) # 表现形式：True，3在序列中
    print(3 not in r) # 表现形式：False，3在序列中
    print(4 not in r) # 表现形式：True，4不在序列中
    ```


#### 循环判断-if的使用
- 在python中，可以使用联合判断
  ```py
  if 1 > 2 > 3:
      print('这是成立的，其他语言不能这样写')
  elif 4 > 5:
      print('else if')
  else:
      print('else')
  ```



#### 循环判断-三目运算
- 比如
  ```py
  print("条件成立，执行的代码") if (1 > 2) else print("条件不成立，执行的代码")
  ```
  


#### 循环判断-pass的使用
- pass的作用：站位
  - 比如某段业务不清，就可以使用pass先进行占位，后面在补上

- 比如
  ```py
  if 1 > 2 > 3:
      pass
  elif 4 > 5:
      pass
  else:
      pass
  ```


#### 循环判断-while的使用
- 示范代码
  ```py
  a = 0
  while a < 10:
      print(a)
      a += 1
  ```

- while和else联合使用
  - while正常结束循环（不是通过break结束的循环），else中的代码就会执行
  - 比如
    ```py
    a = 0
    while a < 2:
        a += 1
    else:
        print("没有经过break退出循环，是条件不满足自动退出的，所以else中的代码会进行执行")


    while a < 8:
        if a == 6:
            break
        a += 1
    else:
        print("会经过break退出循环，所以else中的代码不会进行执行")
    ```



#### 循环判断-for-in的使用
- for-in的作用：遍历（只能遍历可迭代的对象）
  - 可迭代对象：字符串、列表、元祖、字典、集合、range
    - 注意：字典只能遍历出key
  - 使用示范代码
    ```py
    for a in "abc":
        print(a) # 表现形式：a b c

    for b in range(2, 10, 3):
        print(b) # 表现形式：2 5 8（队列是：[2, 5, 8]）

    for c in [1, 6, 9, 3]:
        print(c) # 表现形式：1 6 9 3

    for d in {"a": 3, "b": 4}:
      print(d) # 表现形式：a b
    ```

- for-in和else联合使用
  - for-in正常结束循环（不是通过break结束的循环），else中的代码就会执行
  - 示范代码
    ```py
    for a in "abc":
        print(a)
    else:
        print("会执行，因为上面没有经过break，而是正常结束的")

    for b in range(2, 10, 3):
        if b == 5:
            break
        print(b)
    else:
        print("不会执行，因为上面是经过break退出的循环，而不是条件不满足退出的")
    ```





#### 字符串-字符串的定义
- 注意：字符串最后不能是 `\`
  - 因为这玩意是一个转义，后面必须有东西
  - 如果最后非要展示 `\`，则需要给它进行转义操作
  - 比如
    ```py
    str = "abc\\"
    ```
- 三引号写的字符串，允许换行，单双引号只能一行书写字符串
  - 比如
    ```py
    # 三引号有两种
    str = """a
    b
    c
    """

    str = '''a
    b
    c
    '''
    # 这是可以的

    str = 'abc'
    str = "abc"
    # 单双引号只能一行书写字符串，换行就报错（除非进行一些处理，会在后面加上一个 \，但是打印的时候也是在一行，
    #   不像三引号，换行，打印的时候也表现为换行）
    str = 'abc' \
          'ddss'
    ```


#### 字符串-获取某个字符对应的ASCII码
- 获取字符串的ASCII码
  ```py
  str = 'a'
  print(ord(str)) # 表现形式：97
  ```

- 把ASCII码转换成对应的字符
  ```py
  asc = 97
  print(chr(asc))  # 表现形式：a
  ```


- 字符串的比较，其实就是比较的每一位字符的ASCII码
  ```py
  print("1" < "2") # 表现：True

  # 其实比较的是下面的东西
  print(ord("1")) # 表现：49
  print(ord("2")) # 表现：50
  print(ord("1") < ord("2")) # 表现：True
  ```



#### 字符串-字符串的驻留机制
- 如果创建的字符串，之前创建过，则不会创建新的，直接使用之前创建的
  - 节省效率——字符串的创建销毁需要一定的性能，如果重复的创建，效率低下
  - 节省内存

- 如果驻留池中有这个字符串，就会进行复用
- 如果是通过计算产生的字符串，即使之前存在（驻留池中存在），也不会进行复用

- 比如
  ```py
  a = "abc"
  b = "abc"
  print( a is b ) # 表现形式：True（说明两个字符串的内存空间用的是同一个，也就是说底层只创建了一个 abc）

  a = "abc"
  b = "ab" + "c"  # 编译的时候，就会自动变成 "abc"。所以也会产生字符串的复用
                  # 并不是电脑通过计算得到的 "abc"。如果是通过计算得到的 "abc"，则不会进行复用
  print( a is b ) # 表现形式：True（说明两个字符串的内存空间用的是同一个，也就是说底层只创建了一个 abc）

  a = "abc"
  b = 'a'.join(['bc'])
  print( a is b ) # 表现形式：False（因为b的abc是计算产生的，所以不会复用）
  ```


#### 字符串-获取子串的位置
- `index`：获取子串第一次出现的位置（没有就抛异常）
  ```py
  a = "abcab"
  print(a.index('a')) # 表现形式：0
  print(a.index('d')) # 表现形式：抛异常（没有d）
  ```

- `rindex`：获取子串最后一次出现的位置（没有就抛异常）
  ```py
  a = "abcab"
  print(a.rindex('a')) # 表现形式：3
  print(a.rindex('d')) # 表现形式：抛异常（没有d）
  ```

- `find`：获取子串第一次出现的位置（没有就返回-1）
  ```py
  a = "abcab"
  print(a.find('a')) # 表现形式：0
  print(a.find('d')) # 表现形式：-1（没有d）
  ```

- `rfind`：获取子串最后一次出现的位置（没有就返回-1）
  ```py
  a = "abcab"
  print(a.rfind('a')) # 表现形式：3
  print(a.rfind('d')) # 表现形式：-1（没有d）
  ```

- 扩展：可以根据 `find` 和 `rfind` 判断某个字符串是否包含某个子串（利用值是否是-1）



#### 字符串-大小写转换
- `upper`：把所有的字符都转换成大写
  ```py
  a = "aBcD"
  print(a.upper()) # 表现形式：ABCD
  ```

- `lower`：把所有的字符都转换成小写
  ```py
  a = "aBcD"
  print(a.lower()) # 表现形式：abcd
  ```

- `swapcase`：把字符串中所有的大写都转换成小写，小写转换成大写
  ```py
  a = "aBcD"
  print(a.swapcase()) # 表现形式：AbCd（大转小、小转大）
  ```

- `capitalize`：把第一个字符转换成大写，其他的转换为小写
  ```py
  a = "aBcD Efg"
  print(a.capitalize()) # 表现形式：Abcd efg
  ```

- `title`：把每个单词的第一个字符转换成大写，单词其他的字符都转换为小写
  ```py
  a = "aBcD efg"
  print(a.title()) # 表现形式：Abcd Efg
  ```

- 因为字符串是不可变序列，所以上例中的所有转换，都会产生一个新的字符串对象，而不是修改字符串
  - 即使转换前和转换后一样，得到的也是一个新的字符串（虽然相同，但是是运行时产生的，即使有字符串驻留机制，也不起作用）




#### 字符串-字符串的对齐方式（长度不够，自动填充）
- `center`（居中对齐）：两侧填充，两个参数
  - 第一个参数是长度，第二个参数是填充字符，可以不传递，默认是空格
  - 如果长度小于字符串，则直接返回字符串本身
  - 比如
    ```py
    a = "abc d"
    print(a.center(16, "*")) # 表现形式：*****abc d******
    ```
    - 填充字符，只能是一个字符，如果是多个字符，就会报错
    - 先填充一个右侧，然后在填充一个左侧，然后在填充一个右侧，然后在填充一个左侧，直到长度达到指定值
      - 所以说，右侧有可能比左侧多一个字符

.
- `ljust`（左对齐）：右侧填充，两个参数
  - 第一个参数是长度，第二个参数是填充字符，可以不传递，默认是空格
  - 如果长度小于字符串，则直接返回字符串本身
  - 比如
    ```py
    a = "abc d"
    print(a.ljust(16, "*")) # 表现形式：abc d***********
    ```
    - 填充字符，只能是一个字符，如果是多个字符，就会报错

.
- `rjust`（右对齐）：左侧填充，两个参数
  - 第一个参数是长度，第二个参数是填充字符，可以不传递，默认是空格
  - 如果长度小于字符串，则直接返回字符串本身
  - 比如
    ```py
    a = "abc d"
    print(a.rjust(16, "*")) # 表现形式：***********abc d
    ```
    - 填充字符，只能是一个字符，如果是多个字符，就会报错
  

.
- `zfill`（右对齐）：左侧填充，一个参数（长度）
  - 左侧填充内容为0，不可修改
  - 如果长度小于字符串，则直接返回字符串本身
  - 比如
    ```py
    a = "abc d"
    print(a.zfill(16)) # 表现形式：00000000000abc d

    # 如果第一个字符是 - ，则0补到-后面
     a = "-abc"
    print(a.zfill(16)) # 表现形式：-000000000000abc（连上-，共计16位，而不是忽略-，进行补0）
    ```
  


#### 字符串-字符串的分割（拆分）
- `split`：从左往右分
  - 如果没有传递参数，默认按照空格进行分割
    ```py
    a = "ab cd e"
    print(a.split()) # 表现形式：['ab', 'cd', 'e']
    ```
  - 可以指定参数，按照参数进行分割
    ```py
    a = "ab cd e"
    print(a.split(" c")) # 表现形式：['ab', 'd e']
    ```
  - 还可以指定最大的分割次数，如果超过了分割次数，则后续的就不再分割了
    ```py
    a = "dabacadaf"
    print(a.split("a", maxsplit=2)) # 表现形式：['d', 'b', 'cadaf']（只能分割两次，也就是三段）
    ```

- `rsplit`：从右往左分
  - 和 `split` 的用法一样，并且如果不指定分割次数（也就是全部分割，两个方法得到的值没有区别，因为从左分，还是从右分，只要全部分割就没有区别了）
  - 如果指定了最大分割次数，并且最大分割次数小于可以分割的次数，那区别就来了（可以证实split是从左分的，rsplit是从右分的）
    ```py
    a = "dabacadaf"
    print(a.split("a", maxsplit=2)) # 表现形式：['d', 'b', 'cadaf']（只能分割两次，也就是三段）(从左开始分)
    print(a.rsplit("a", maxsplit=2)) # 表现形式：['dabac', 'd', 'f']（只能分割两次，也就是三段）(从右开始分)
    ```



#### 字符串-字符串的常用判断方法
- `isidentifier`：判断指定的字符串是不是合法的标识符（合法的字符串，只能由字母数字下划线（中文）组成）
  ```py
  a = "abc"
  print(a.isidentifier()) # 表现形式：True

  a = '张三a_123'
  print(a.isidentifier()) # 表现形式：True

  a = "abc%"
  print(a.isidentifier()) # 表现形式：False
  ```

- `isspace`：判断指定的字符串是不是全部由空白字符组成（空格、换行、水平制表符）
  ```py
  a = "    "
  print(a.isspace()) # 表现形式：True

  a = ' \n  \t'
  print(a.isspace()) # 表现形式：True

  a = "abc%"
  print(a.isspace()) # 表现形式：False
  ```

- `isalpha`：判断指定的字符串是否全部由字母（中文）组成
  ```py
  a = "abc"
  print(a.isalpha()) # 表现形式：True

  a = '张三abc'
  print(a.isalpha()) # 表现形式：True

  a = "abc132"
  print(a.isalpha()) # 表现形式：False
  ```


- `isdecimal`：判断指定的字符串是否全部由十进制的数字组成
  ```py
  a = '1234'
  print(a.isdecimal()) # 表现形式：True

  a = '壹'
  print(a.isdecimal()) # 表现形式：False
  ```

- `isnumeric`：判断指定的字符串是否全部由数字组成
  ```py
  a = '1234'
  print(a.isnumeric()) # 表现形式：True（十进制数字）

  a = '叁'
  print(a.isnumeric()) # 表现形式：True（阿拉伯数字）

  a = '亿'
  print(a.isnumeric()) # 表现形式：True（阿拉伯数字）

  a = '一'
  print(a.isnumeric()) # 表现形式：True（大写数字）

  a = '一二'
  print(a.isnumeric()) # 表现形式：True（大写数字）

  a = 'Ⅱ'
  print(a.isnumeric()) # 表现形式：True（罗马数字）

  a = 'Ⅱ三0叁'
  print(a.isnumeric()) # 表现形式：True（混合）

  a = '-1'
  print(a.isnumeric()) # 表现形式：False
  ```


- `isalnum`：判断指定的字符串是否全部由数字和字母组成
  ```py
  a = '1234'
  print(a.isalnum()) # 表现形式：True

  a = '壹'
  print(a.isalnum()) # 表现形式：True

  a = '壹1ad'
  print(a.isalnum()) # 表现形式：True

  a = '壹1ad_'
  print(a.isalnum()) # 表现形式：False
  ```




#### 字符串-字符串的替换与合并
- 替换：利用函数`replace`进行替换
  - 默认全部替换，但是可以指定替换的个数
  - 比如
    ```py
    a = 'a py py py'
    print(a.replace('py', 'java')) # 表现形式：a java java java

    print(a.replace('py', 'java', 2)) # 表现形式：a java java py
    ```


- 合并：利用函数 `join` 进行合并
  - 字符串调用（表示多个字符串合并后，中间的连接符号是什么）
  - join的参数：可以是列表、集合、元组、字符串(字符串会每一项拆分后在进行拼接)
  - 比如
    ```py
    a = ["a", 'b', 'c']
    print("".join(a)) # 表现形式：abc

    a = ["a", 'b', 'c']
    print("-+".join(a)) # 表现形式：a-+b-+c

    a = ("a", 'b', 'c')
    print("-+".join(a)) # 表现形式：a-+b-+c

    a = {"a", 'b', 'c'}
    print("-+".join(a)) # 表现形式：a-+b-+c

    a = "abc"
    print("-+".join(a)) # 表现形式：a-+b-+c
    ```


#### 字符串-判断某个字符串是否是该字符串的子串
- 可以使用 `in` 和 `not in` 进行判断
- 也可以使用 `find` 和 `rfind` 进行判断（利用返回值是否是-1）

- 比如
  ```py
  a = "abcd"
  print( 'ab' in a ) # 表现形式：True （ab是子串）

  print( 'ab' not in a ) # 表现形式：False （ab是子串）

  print( a.find("ab") )  # 表现形式：0   （0 > -1 ab是子串）

  print( a.find("abd") )  # 表现形式：-1   （-1，说明abd不是子串）
  ```


#### 字符串-字符串的比较
- 运算符：`>、>=、<=、<、==`比较的是每一位的 ASCII码值
- `is` 比较的是内存的id
- 比如
  ```py
  a = "abcd"
  b = "abcd"
  c = ''.join("abcd")

  print( a == b == c) # 表现形式：True（比较的ASCII值，三个字符串一样，所以为True）

  print(a is b)  # 表现形式：True（根据字符串驻留机制，b进行了复用，所以地址一样，结果为True）
  print(a is c)  # 表现形式：False（由于c是运行时产生的，所以即使一样也不会复用，而是存到一个新的内存空间中，所以地址不同，结果为False）
  ```
    

#### 字符串-字符获取和字符串的长度获取
- 根据索引，获取字符
  ```py
  a = "abcdefg"
  print(a[4])  # 表现形式：e
  ```

- 使用 `for in` 循环遍历
  ```py
  a = "abcdefg"

  for v in a:
      print(v)
  ```


- 获取字符串的长度
  ```py
  a = "abcdefg"

  print(len(a))  # 表现形式：7
  ```



#### 字符串-字符串切片
- 和列表切片用法完全一致
- 有三个参数
  - 第一个参数，表示开始位置（默认从0开始）
  - 第二个参数，表示结束位置（默认到最后结束）
  - 第三个参数，表示步长（默认步长为1）
- 这三个切可正可负
  - 第一个和第二个参数，正数从左侧开始查，负数从右侧开始查
  - 第三个参数，正数从左往右截，负数从右往左截
    - 步长如果是负数的话，第一个和第二个参数的默认值也会发生变化（起点从最后开始，终点为0，因为负数是往左截）
- 如果起点和终点超过字符串范围，就会报错

- 比如
  ```py
  a = "abcdefg"
  print(a[:4])  # 表现形式：abcd （从 0截到4，步长为1）
  print(a[2:4])  # 表现形式：cd （从 2截到4，步长为1）
  print(a[:4:2])  # 表现形式：ac （从 0截到4，步长为2）
  print(a[2::2])  # 表现形式：ceg （从 2截到最后，步长为2）

  print(a[2:-2:1])  # 表现形式：cde （从 2截到5，步长为1）
  print(a[-2:-4:1])  # 表现形式： （从 5截到3，步长为1，往右截，但是终点在起点的左侧，所以截不到内容）
  print(a[-2:-4:-1])  # 表现形式：fe（从 5截到3，步长为-1，往左截，而终点在起点的左侧，所以可以截到内容）
  ```

- 利用步长为负数，可以实现字符串的反转
  ```py
  str = 'abcdefg';
  # 因为是往左截的，所以第一个获取的是g，第二个获取的是f，以此类推，最终获取a，然后最终得到的结果就是一个反转的字符串了
  print(str[::-1]);  
  ```


#### 字符串-格式化字符串（模版字符串）
- 格式化字符串有三种方式：一种使用 `%` 作为占位符，一种是使用 `{}` 作为占位符，一种是 `f-string`（这种方式只有python3以上的版本才能用）

- `%` 作为占位符
  ```py
  template = '我叫 %s，今年 %s 岁'  # %s 表示这个地方填充的是字符串
  str = template % ("张三", 20)
  print(str)  # 表现形式：我叫 张三，今年 20 岁
  ```
  - 替换的数据，不能多也不能少，否则报异常

- `{}` 作为占位符
  ```py
  template = '我叫 {}，今年 {} 岁'
  str = template.format("张三", 20)
  print(str)  # 表现形式：我叫 张三，今年 20 岁
  ```
  - 替换的数据，可以多，但是不能少，否则报异常



- `f-string`
  ```py
  name = "张三"
  age = 20
  str = f'我叫 {name}，今年 {age} 岁'
  ```
  - 注意：前面的那个 `f` 不要省略




#### 字符串-格式化字符串（宽度和精度的限制）
- 限制宽度（最小值）
  - 超出了不管（不会进行截取），小了自动在左侧补空格
  ```py
  str = "%4d" % 12  # %d 表示整数，而 %4d 表示长度最小为4
  print(str)
  print("1234")
  '''
  表现形式：会发现str前面补了两个空格（因为长度不够）
    12
  1234
  '''
  ```

- 限制精度（小数）
  ```py
  str = "%f" % 12.34567891234  # %f 表示小数，
  print(str)  # 表现形式：12.345679（默认精度为6）

  str = "%.3f" % 12.34567891234  # %f 表示小数，而 %.3f 表示小数精度设置为3
  print(str)  # 表现形式：12.346

  str = "%.7f" % 12.34567891234  # %f 表示小数，而 %.7f 表示小数精度设置为7
  print(str)  # 表现形式：12.3456789
  ```

- 限制宽度和精度
  ```py
  str = "%7.3f" % 12.34567891234  # %f 表示小数，而 %7.3f 表示小数精度设置为3，字符串总长度最小为7
  print(str)
  print(1234567)

  '''
  表现形式：会发现str前面补了一个空格（因为长度不够，包含小数点）
  12.346
  1234567
  '''

  str = "%4.3f" % 12.34567891234  # %f 表示小数，而 %4.3f 表示小数精度设置为3，字符串总长度最小为4
  print(str)
  print(1234)

  '''
  表现形式：不会补空格（因为长度够了）
  12.346
  1234
  '''
  ```


- `{}`占位符如何限制宽度和精度，方式如下
  ```py
  # 限制精度
  str = "{:.3f}".format(12.34567891234)
  print(str) # 表现形式：12.346

  # 限制宽度和精度
  str = "{:7.3f}".format(12.34567891234)
  print(str) # 表现形式：" 12.346" （补了一个空格）

  # 限制有效数字的个数（要注意，限制精度要加上f，否则就是限制有效数字的个数了）
  str = "{:.3}".format(12.34567891234)
  print(str) # 表现形式：12.3 （三个有效数字）
  ```




#### 字符串-编码和解码
- 字符串编码
  ```py
  str = "张三"
  print(str.encode(encoding="GBK")) # 表现形式：b'\xd5\xc5\xc8\xfd'
  print(str.encode(encoding="UTF-8")) # 表现形式：b'\xe5\xbc\xa0\xe4\xb8\x89'
  ```

- 字符串解码
  ```py
  gbk = b'\xd5\xc5\xc8\xfd'
  print(gbk.decode(encoding="GBK")) # 表现形式：张三

  utf8 = b'\xe5\xbc\xa0\xe4\xb8\x89'
  print(utf8.decode(encoding="UTF-8")) # 表现形式：张三
  ```
  - 编码格式和解码格式（也就是encoding要一样），否则会抛出异常



#### 列表-创建列表的方式
- 一种：使用[]，进行创建
- 一种：借助内置函数list，进行创建

- 比如：
  ```py
  lis = ["a", True, 3, 5.4]
  print(lis, id(lis))

  lis = list(["a", True, 3, 5.4])
  print(lis, id(lis))
  ```
- 列表的特点：有序的，可重复的


#### 列表-利用索引获取对应的数据
- 索引可正可负（正的从0开始，负的从-1开始。正的正着查，负的倒着查）
  - 索引0：表示第一位数据、索引1：表示正数第二位数据（等等）
  - 索引-1：表示最后一位数据、索引-2：表示倒数第二位数据（等等）
- 比如
  ```py
  lis = ["a", True, 3, 5.4]
  print(lis[0], lis[1]) # 表现形式："a", True

  lis = list(["a", True, 3, 5.4])
  print(lis[-1], lis[-2]) # 表现形式：5.4  3
  ```
- 注意点：如果索引超出列表范围，则抛出异常


#### 列表-获取某个数据的索引
- 利用函数 `index`
  - 注意点：如果某个数据不在列表中，则报错
  - 可以先使用 `in` 判断数据是否在列表中，如果在，然后在获取索引
- 获取第一个符合条件的数据的索引
  - 可以指定开始匹配的位置，和结束匹配的位置
  - 默认是从0开始，一直到最后

- 比如
  ```py
  lis = ["a", True, 3, 5.4]
  print( lis.index(3) ) # 表现形式：2（采用默认匹配范围：0 - 最后）
  print( lis.index("a", 1) ) # 表现形式：报错（指定开始位置，结束位置采用默认：1 - 最后，而这一段中没有 a，所以找不到就报错）
  print( lis.index("a", 1, 3) ) # 表现形式：报错（指定开始位置和结束位置：1 - 3(不包括3)，而这一段中没有 a，所以找不到就报错）
  

  # 判断列表中有没有某数据，有就获取没有就不获取（避免抛出异常）
  if 8 in lis:
      print(lis.index(8))
  else:
      print("列表中没有", 8)
  ```




#### 列表-切片
- 可以指定切片的起点、终点、步长
  - 起点默认为0，终点默认为最后，步长默认为1
  - 比如
    ```py
    lis = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    _lis = lis[2:8:2] # 表现形式：从2开始截取，一直到8（包括2和8），步长为2
    print(_lis) # 表现形式：[3, 5, 7]

    _lis = lis[2:8:] # 表现形式：使用默认步长，从2开始，到8结束
    print(_lis) # 表现形式：[3, 4, 5, 6, 7, 8]

    _lis = lis[2:8] # 表现形式：使用默认步长，从2开始，到8结束
    print(_lis) # 表现形式：[3, 4, 5, 6, 7, 8]

    _lis = lis[2:] # 表现形式：使用默认终点和步长，起点为2（最少有一个:，如果一个都没有，就是取索引为2的值了）
    print(_lis) # 表现形式：[3, 4, 5, 6, 7, 8, 9]

    _lis = lis[2::] # 表现形式：使用默认终点和步长，起点为2
    print(_lis) # 表现形式：[3, 4, 5, 6, 7, 8, 9]

    _lis = lis[2::2] # 表现形式：使用默认终点，起点为2，步长为2
    print(_lis) # 表现形式：[3, 5, 7, 9]

    _lis = lis[::2] # 表现形式：使用默认起点和终点，步长为2
    print(_lis) # 表现形式：[1, 3, 5, 7, 9]

    _lis = lis[:6:2] # 表现形式：使用默认起点，终点为6，步长为2
    print(_lis) # 表现形式：[1, 3, 5]
    ```

- 起点，终点，步长可以为负数
  - 负数就是倒着来
  - 注意
    - 起点和终点正负只影响查询的方向，默认值不会影响
    - 步长为负，会影响默认值的取值（起点会变成列表最后，终点会变成0，这样才能往左查）
      - 并且，起点要大于终点，这样才能往左查
  - 比如（起点和终点为负数）
    ```py
    lis = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    _lis = lis[2:-2:2] # 起点为2，终点为-2（倒着查，其实就是正着查：7），步长2
    print(_lis) # 表现形式：从 2 到 7 进行切片，步长为2  [3, 5, 7]

    _lis = lis[-6:-2:2] # 起点为-6（倒着查，其实就是正着查：3），终点为-2（倒着查，其实就是正着查：7），步长2
    print(_lis) # 表现形式：从 3 到 7 进行切片，步长为2  [4, 6]

    _lis = lis[-6:7:2] # 起点为-6（倒着查，其实就是正着查：3），终点为7，步长2
    print(_lis) # 表现形式：从 3 到 7 进行切片，步长为2  [4, 6]
    ```
  - 比如（步长为负数）
    ```py
    lis = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    _lis = lis[2:-2:-2] # 起点为2，终点为-2（倒着查，其实就是正着查：7），步长-2
    print(_lis) # 表现形式：从 2 到 7 进行切片，步长为-2
                # 也就是说从 2 开始往左查（步长为2），但是终点为7，所以 2 的左边查不到，于是结果就是 []

    _lis = lis[-2:-6:2] # 起点为-2（倒着查，其实就是正着查：7），终点为-6（倒着查，其实就是正着查：3），步长2
    print(_lis) # 表现形式：从 7 到 3 进行切片，步长为2
                # 也就是说从 7 开始往右查（步长为2），但是终点为 3，所以 7 的右边查不到，于是结果就是 []

    _lis = lis[-2:-6:-2] # 起点为-2（倒着查，其实就是正着查：7），终点为-6（倒着查，其实就是正着查：3），步长-2
    print(_lis) # 表现形式：从 7 到 3 进行切片，步长为-2
                # 也就是说从 7 开始往左查（步长为2），一直到终点 3，于是结果就是 [8, 6]

    _lis = lis[7:3:-2] # 起点为7，终点为3，步长-2
    print(_lis) # 表现形式：从 7 到 3 进行切片，步长为-2
                # 也就是说从 7 开始往左查（步长为2），一直到终点 3，于是结果就是 [8, 6]
    ```

- 总结：
  - 终点超过列表边界，则以实际边界为准，超过的忽略
  - 没有符合的数据，得到是一个空列表 []

- 步长为负数，可以实现列表的逆转
  - 比如
    ```py
    lis = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    _lis = lis[::-1] # 起点和终点使用默认值，由于步长为负数，
                     # 所以起点为列表最后，终点为0，然后往左查询，每次查一个（步长 1），这样就倒着取了一遍数据（实现了逆置）

    print(_lis) # 表现形式 [9, 8, 7, 6, 5, 4, 3, 2, 1]
    ```




#### 列表-判断和遍历
- 可以使用 `in` 和 `not in` 判断某个元素是否在列表中
  - 比如
    ```py
    lis = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    print(3 in lis) # 表现形式 True
    print(12 in lis) # 表现形式 False
    print(12 not in lis) # 表现形式 True
    ```


- 可以使用 for-in 循环进行遍历
  - 比如
    ```py
    lis = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    for a in lis:
        print(a)
    ```


#### 列表-新增数据
- 在列表的最后添加一个元素：借助 `append` 方法
  - 比如
    ```py
    lis = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    lis.append(100)
    print(lis) # 表现形式 [1, 2, 3, 4, 5, 6, 7, 8, 9, 100]
    ```
- 在列表的最后添加一组元素：借助 `extend` 方法
  - 比如
    ```py
    lis = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    lis.extend([100, 200, 300]) # 必须传递一个集合
    print(lis) # 表现形式 [1, 2, 3, 4, 5, 6, 7, 8, 9, 100, 200, 300]
    ```
- 在中间添加一个元素：借助 `insert` 方法
  - 比如
    ```py
    lis = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    lis.insert(3, 100) # 在第三位插入一个 100 
    print(lis) # 表现形式 [1, 2, 3, 100, 4, 5, 6, 7, 8, 9]
    ```
- 在中间添加一组元素：借助 `切片` 实现
  - 比如
    ```py
    lis = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    lis[2:2] = [100, 200] # 把 2 到 2（不包括2） 的位置切掉，然后把 [100, 200] 插入到切掉的位置
    print(lis) # 表现形式 [1, 2, 100, 200, 3, 4, 5, 6, 7, 8, 9]

    lis = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    lis[2:4] = [100, 200] # 把 2 到 4（不包括4） 的位置切掉，然后把 [100, 200] 插入到切掉的位置
    print(lis) # 表现形式 [1, 2, 100, 200, 5, 6, 7, 8, 9]（ 3、4被切掉了，然后把 100、200 放到 3、4 的位置）
    ```



#### 列表-删除数据
- 移除某个具体的数据：借助 `remove` 方法
  - 如果有相同的移除第一个，如果没有对应的数据，则报错
  - 可以先使用in进行判断，如果有就移除，如果没有就不进行操作，防止抛出异常
  - 比如
    ```py
    lis = [1, 2, 3, 6, 6]
    lis.remove(6) # 移除6，如果有相同的移除第一个
    print(lis) # 表现形式 [1, 2, 3, 6]
    ```
- 根据索引删除其对应的数据：借助 `pop` 方法
  - 如果索引超出范围，则报错
  - 如果不指定参数，则默认删除列表的最后一个元素
  - 比如
    ```py
    lis = [1, 2, 3, 6, 6]
    lis.pop(2) # 移除索引为3位置的数据
    print(lis) # 表现形式 [1, 2, 6, 6]

    lis = [1, 2, 3, 6, 6]
    lis.pop() # 没有传递索引，默认删除最后一个元素
    print(lis) # 表现形式 [1, 2, 3, 6]
    ```

- 一次删除一堆元素：利用 `切片` 实现
  - 修改数据中介绍，切片赋值，可以把某段内容切掉，然后替换成赋值的列表
    - 如果这个时候，替换的是一个空列表，则就实现的数据的删除功能
  - 比如
    ```py
    lis = [1, 2, 3, 6, 6]
    lis[1:3] = [] # 删除从 1 到 3（不包括3）的元素
    print(lis) # 表现形式 [1, 6, 6]
    ```

- 清空整个列表：借助 `clear` 方法
  - 比如
    ```py
    lis = [1, 2, 3, 6, 6]
    lis.clear()
    print(lis) # 表现形式 []
    ```
  
- 删除列表对象（前面介绍的都是删除内容，这个是删除本体）：借助 `del` 实现
  - 比如
    ```py
    lis = [1, 2, 3, 6, 6]
    del lis
    print(lis) # 这里就报错了，因为列表已经被干掉了，找不到它了，所以报错
    ```



#### 列表-列表修改数据
- 利用索引重新赋值
  - 比如
    ```py
    lis = [1, 2, 3, 6, 6]
    lis[3] = 100
    print(lis) # 表现形式 [1, 2, 3, 100, 6]
    ```

- 利用切片，替换数据（可以替换多个数据）（本质是：删除插入）
  - 比如
    ```py
    lis = [1, 2, 3, 6, 6]
    lis[2: 4] = [100, 200] # 把 2 到 4（不包括4）删掉，然后在把[100, 200]放到这个位置
    print(lis) # 表现形式 [1, 2, 100, 200, 6]


    lis = [1, 2, 3, 6, 6]
    lis[2: 3] = [100] # 把 2 到 3（不包括3）删掉，然后在把[100]放到这个位置
    print(lis) # 表现形式 [1, 2, 100, 6, 6]
    ```
  


#### 列表-排序
- 使用自带的`sort`方法进行排序，会改变原列表
  - 比如
    ```py
    lis = [1, 2, 9, 6, 8, 6]
    lis.sort()  # 默认升序排列
    print(lis)  # 表现形式：[1, 2, 6, 6, 8, 9]

    lis = [1, 2, 9, 6, 8, 6]
    lis.sort(reverse=False)  # 指定升序排列（通过使用上面的默认方式）
    print(lis)  # 表现形式：[1, 2, 6, 6, 8, 9]

    lis = [1, 2, 9, 6, 8, 6]
    lis.sort(reverse=True)  # 指定降序排列
    print(lis)  # 表现形式：[9, 8, 6, 6, 2, 1]
    ```

- 使用内置函数 `sorted` 实现排序，它不会改变原列表，而是产生一个新的列表
  - 比如
    ```py
    lis = [1, 2, 9, 6, 8, 6]
    _lis = sorted(lis)  #  默认升序排列
    print(_lis)  # 表现形式：[1, 2, 6, 6, 8, 9]
    print(lis)   # 表现形式：[1, 2, 9, 6, 8, 6]（原列表没有发生变化）

    lis = [1, 2, 9, 6, 8, 6]
    _lis = sorted(lis, reverse=True)  # 指定降序排列
    print(_lis)   # 表现形式：[9, 8, 6, 6, 2, 1]
    ```



#### 列表-列表生成式
- 利用 `for-in` 实现，但是不通过 `list[i] = xxx` 进行赋值
- 比如
  ```py
  lis = [i for i in range(0, 8)]  # 把遍历得到的i，经过for前面的表达式运算后，存入列表中
  print(lis) # 表现形式：[0, 1, 2, 3, 4, 5, 6, 7]

  lis = [i * 2 for i in range(0, 8)]  # 把遍历得到的i，经过for前面的表达式运算后，存入列表中
  print(lis) # 表现形式：[0, 2, 4, 6, 8, 10, 12, 14]

  lis = [i * 2 + 4 for i in range(0, 8)]  # 把遍历得到的i，经过for前面的表达式运算后，存入列表中
  print(lis) # 表现形式：[4, 6, 8, 10, 12, 14, 16, 18]
  ```


#### 列表-多个列表进行合并
- 把一个列表拼接在另一个列表的后面，会改变原列表
  ```py
  list_a = [1, 2, 3];
  list_b = [4, 5, 6];
  list_a.extend(list_b);
  print(list_a)  # 打印 [1, 2, 3, 4, 5, 6]，list_a发生了变化
  print(list_b)  # 打印 [4, 5, 6]，list_b不变
  ```

- 使用 +号 拼接，得到新的列表
  ```py
  list_a = [1, 2, 3];
  list_b = [4, 5, 6];
  list_c = list_a + list_b;
  print(list_c)  # 打印 [1, 2, 3, 4, 5, 6]，得到一个新的列表
  print(list_a)  # 打印 [1, 2, 3]，list_a不变
  print(list_b)  # 打印 [4, 5, 6]，list_b不变
  ```



#### 字典-存取数据的原理
- 底层是一个列表存放的数据
  - 存数据的时候，利用 `hash(key)` 计算出一个值，这个值就是索引，然后把key和value存进去
  - 取数据的时候，也是利用 `hash(key)` 计算出一个值，这个值就是索引。然后根据这个索引，就能找到列表中对应的空间，然后在根据key，把value取出来
- 如果有重复的key，则计算出来的hash就会一样，这样在列表中存的位置就会一样，于是新的数据就把旧的数据覆盖掉了

- 字典的特点：key不能重复，value可以重复
  - key如果重复，就会出现覆盖的现象


#### 字典-创建方式
- 借助`{}`创建
  - key必须是字符串格式
  - 重复的key，后面的会替换掉前面的数据
  ```py
  o = {"a": 2, "a": 3, 'b': "dds"}
  print(o)  # 表现形式：{'a': 3, 'b': 'dds'}
  ```

- 使用内置函数`dict`进行创建
  - 不能写重复的key，否则报错
  ```py
  o = dict(a=3, b="dds")
  print(o)  # 表现形式：{'a': 3, 'b': 'dds'}
  ```



#### 字典-获取字典中的元素
- 直接只用`key`获取
 
  ```py
  o = {"a": "dds", "b": 3}
  value = o["b"]
  # o.a 这样写报错
  print(value)
  ```

- 借助`get`函数获取
  ```py
  o = {"a": "dds", "b": 3}
  value = o.get("b")
  print(value)
  ```


- 上面两种的区别
  - 第一种，如果获取一个没有的key，会报错
  - 第二种，如果获取一个没有的key，得到的是 `None`


- get还可以设置默认值
  - 如果获取的key没有的话，默认返回 `None`。但是如果设置了默认值值，则获取的就是默认值了
  ```py
  o = {"a": "dds", "b": 3}
  value1 = o.get("c")
  value2 = o.get("c", 33)
  print(value1)  # 表现形式：None
  print(value2)  # 表现形式：33
  ```




#### 字典-判断某个key是否存在
- 利用 `in` 或者 `not in` 进行判断
- 示范
  ```py
  o = {"a": "dds", "b": 3}

  a = "a" in o
  print(a)  # 表现形式：True

  a = "c" in o
  print(a)  # 表现形式：False

  a = "c" not in o
  print(a)  # 表现形式：True
  ```
  - 判断的是key不是value


#### 字典-字典元素的删除
- 删除指定的元素
  ```py
  o = {"a": "dds", "b": 3}

  del o["a"]
  print(o)  # 表现形式：{'b': 3}
  ```

- 清空字典
  ```py
  o = {"a": "dds", "b": 3}

  o.clear()
  print(o)  # 表现形式：{}
  ```



#### 字典-元素的新增和修改
- 新增
  ```py
  o = {"a": "dds", "b": 3}

  o["name"] = "张三"
  print(o)  # 表现形式：{'a': 'dds', 'b': 3, 'name': '张三'}
  ```

- 修改
  ```py
  o = {"a": "dds", "b": 3}

  o["a"] = "张三"
  print(o)  # 表现形式：{'a': '张三', 'b': 3}
  ```



#### 字典-获取所有的key和value
- 获取所有的key
  - 借助的是一个 `keys` 方法，该方法得到的不是一个列表
    - 如果想要得到列表类型的数据，需要在转化一下
  ```py
  o = {"a": "dds", "b": 3}

  ks = o.keys()
  print(type(ks))  # 表现形式：<class 'dict_keys'>
  print(ks)  # 表现形式：dict_keys(['a', 'b'])

  # 转换成列表
  ks = list(ks)
  print(type(ks))  # 表现形式：<class 'list'>
  print(ks)  # 表现形式：['a', 'b']
  ```

- 获取所有的value
  - 借助的是一个 `values` 方法，该方法得到的不是一个列表
    - 如果想要得到列表类型的数据，需要在转化一下
  ```py
  o = {"a": "dds", "b": 3}

  vs = o.values()
  print(type(vs))  # 表现形式：<class 'dict_values'>
  print(vs)  # 表现形式：dict_values(['dds', 3])

  # 转换成列表
  vs = list(vs)
  print(type(vs))  # 表现形式：<class 'list'>
  print(vs)  # 表现形式：['dds', 3]
  ```


- 获取所有的key-value对
  - 得到的是元组类型（每一个健值对为一组元素）（第一个是key，第二个是value）
  - 借助的是一个 `items` 方法，该方法得到的不是一个列表
    - 如果想要得到列表类型的数据，需要在转化一下
  ```py
  o = {"a": "dds", "b": 3}

  its = o.items()
  print(type(its))  # 表现形式：<class 'dict_items'>
  print(its)  # 表现形式：dict_items([('a', 'dds'), ('b', 3)])

  # 转换成列表
  its = list(its)
  print(type(its))  # 表现形式：<class 'list'>
  print(its)  # 表现形式：[('a', 'dds'), ('b', 3)]
  ```



#### 字典-遍历
- 借助 `for-in` 实现
- 只能遍历出所有的key，要想获取value，需要利用遍历出的key，然后在获取对应的value

- 比如
  ```py
  o = {"a": "dds", "b": 3}

  for item in o:
      print(item)
      # 根据key，获取到value
      print(o[item])
  ```



#### 字典-字典生成式
- 利用内置函数 `zip` 和 `for-in` 生成一个字典
- 比如
  ```py
  a1 = ["a", "b", "c"]
  a2 = [2, 4, 5]
  # a1中的内容作为key，a2中的元素作为value
  o = { item: value for item, value in zip(a1, a2) }
  print(o) # 表现形式：{'a': 2, 'b': 4, 'c': 5}
  ```

- 注意：如果`key列表`和`value列表`的长度不一致，则以短的那个为基础
  ```py
  a1 = ["a", "b", "c"]
  a2 = [2, 4, 5, 7, 8]
  o = { item: value for item, value in zip(a1, a2) }
  print(o) # 表现形式：{'a': 2, 'b': 4, 'c': 5} （a1短，所以以a1为基础）


  a1 = ["a", "b", "c"]
  a2 = [2, 4]
  o = { item: value for item, value in zip(a1, a2) }
  print(o) # 表现形式：{'a': 2, 'b': 4} （a2短，所以以a2为基础）
  ```
  




#### 字典-多个字典合并成一个字典
- 字典是不能使用 +号 进行合并的，会报错
  - 列表和元祖是可以使用 +号 进行合并的

- 使用 `update` 合并字典，但是会改变原字典
- 比如：
  ```py
  dict_a = {
      'a': 1,
      'b': 2
  }
  dict_b = {
      'c': 3,
      'd': 4
  }

  dict_a.update(dict_b)
  print(dict_a)  # 表现形式： {'a': 1, 'b': 2, 'c': 3, 'd': 4} dict_a 发生了变化
  print(dict_b)  # 表现形式： {'c': 3, 'd': 4} dict_b 没有变化
  ```
  - 把 `dict_b` 合并到了 `dict_a` 中




#### 元组-介绍
- 元组：是Python内置的数据结构之一，是一个不可变序列
- 什么是不可变序列和可变序列
  - 不可变序列：一旦创建后，数据结构就不能发生改变了（即不能进行增删改操作）
    - 比如：字符串、元组
    ```py
    a = "a"
    a += "3"
    print(a) # 表现形式：虽然a变成了a3，但是那是重新申请了一块空间，存入新值，之前的不能进行修改
            # 可以使用id看一下地址，发现发生了变化
    ```
  - 可变序列：创建后，数据结构可以发生改变（即可以进行增删改操作）
    - 比如：列表、字典
    - 比如
      ```py
      a = [1]

      print(id(a))  # 表现形式：4341007872

      a.append(2)
      print(a)      # 表现形式：[1, 2]

      print(id(a))  # 表现形式：4341007872
      ```
      - 修改后，id没发生变化，说明直接操作的原空间。也就是说数据创建后，数据结构可以发生变化



- 为什么要设置不可变序列
  - 一定程度上保证可数据的安全性
  - 比如：某段代码产生了一个数据（不提供修改数据的方法），任务A需要使用到这个数据数据，任务B也需要使用到这个数据数据（多线程）
    - 如果某个任务不小心修改了数据，则对另一个任务也造成了伤害
    - 如果是不可变序列（又没有提供重新覆盖数据的方法，无法修改），这样两个任务，就只能获取和使用数据
      - 如果某个任务想要修改数据，只能新创建一个（只能对任务自身造成影响，无法对另一个任务造成影响）


- 可变序列和不可变序列配合使用
  ```py
  (1, [1, 2], 3)
  ```
  - 元组的第1、2、3块不能修改
    - 比如不能变成：`(1, 2, 3)`
    ```py
    a = (1, [1, 2], 3)
    a[1] = 2  # 运行有异常
    print(a)
    ```
  - 但是，第2块是一个列表，而列表的内容是可变的
    - 比如可以变成：`(1, [1, 2, 3], 3)`
    ```py
    a = (1, [1, 2], 3)
    a[1].append(3)
    a[1].append(4)
    print(a)  # 表现形式：(1, [1, 2, 3, 4], 3)
    ```





#### 元组-创建方式
- 使用 `()` 进行创建
  ```py
  a = (1, 2, 3)
  print(a)  # 表现形式：(1, 2, 3)
  ```
  - 这种方式，可以省略 `()`
    ```py
    a = 1, 2, 3
    print(a)  # 表现形式：(1, 2, 3)
    ```
    - 当然了，只有元组有多个元素的时候，可以省略 `()`
  - 这种方式，如果只有一个元素，需要加上一个 `,`，如果不加，会认为这就是一个普通的变量，即使加上 `()` 也会认为是一个普通的元素
    ```py
    a = (1)
    print(a)  # 表现形式：a = 1  （普通变量）

    a = (1, )
    print(a)  # 表现形式：a = (1, )

    a = 1,
    print(a)  # 表现形式：a = (1, )
    ```


- 使用内置函数 `tuple` 进行创建
  ```py
  a = tuple( (1, 2, 3) )
  print(a)  # 表现形式：(1, 2, 3)
  ```


- 空元组
  ```py
  a = ()
  print(a)  # 表现形式：()

  a = tuple(())
  print(a)  # 表现形式：()
  ```




#### 元组-元组中元素的获取
- 可以使用索引进行获取
  ```py
  a = (2, 4, 6)
  print(a[2]) # 表现形式：6

  # 无法 a[2] = 4 进行修改（报错），因为元组不可变
  ```


- 可以通过 `for-in` 遍历获取（元组是一个可迭代对象，所以可以使用 `for-in` 进行遍历）
  ```py
  a = (2, 4, 6)

  for v in a:
      print(v) 
  ```







#### 元组-多个元组拼接成一个元组
- 元祖不可变性，所以原来的元祖不可能发生改变，只能得到新的元祖

- 使用 +号，可以拼接多个元组
  ```py
  tuple_a = (4, 8, 9);
  tuple_b = (1, 2, 3);
  print(tuple_a + tuple_b)  # 打印 (4, 8, 9, 1, 2, 3) 得到一个新的元祖
  print(tuple_a)  # 打印 (4, 8, 9)  tuple_a没有发生变化
  print(tuple_b)  # 打印 (1, 2, 3)  tuple_b没有发生变化
  ```



#### 集合-集合的创建方式
- 使用 `{}` 进行创建
  ```py
  a = {1, 1, 3, 4, 5, 6, 2}
  print(a) # 表现形式：{1, 2, 3, 4, 5, 6}
  ```
  - 可以看到集合中不能有重复值（会进行去重处理）



- 使用内置函数 `set` 方法进行创建
  - set可以把很多种类型的数据变成集合
  - 比如
  ```py
  a = set({1, 2, 3, 3, 5})
  print(a) # 表现形式：{1, 2, 3, 5}

  a = set(range(1, 4))
  print(a) # 表现形式：{1, 2, 3}

  a = set([3, 2, 4, 5 ,4])
  print(a) # 表现形式：{2, 3, 4, 5}

  a = set((3, 2, 4, 5 ,4))
  print(a) # 表现形式：{2, 3, 4, 5}

  a = set("ABC")
  print(a) # 表现形式：{'A', 'C', 'B'}
  ```



- 空集合
  ```py
  a = set()
  print(a) # 表现形式：set()
  ```
  - 不能使用 `{}` 定义空集合（因为python会认为这是空字典）
    ```py
    a = {}
    print(type(a)) # 表现形式：<class 'dict'>  （dict是字典类型）
    ```



#### 集合-验证某个元素是否在集合中存在
- 可以使用 `in` 和 `not in` 进行判断
- 比如
  ```py
  a = {3, "a", '6'}

  print(3 in a) # 表现形式：True
  print("d" in a) # 表现形式：False
  print("d" not in a) # 表现形式：True
  ```



#### 集合-元素的新增
- 使用 `add` 一次增加一个元素
  ```py
  a = {3, "a", '6'}

  a.add("dd")
  print(a) # 表现形式：{'6', 3, 'dd', 'a'}
  ```

- 使用 `update` 一次增加至少一个元素
  - `update`可以传入的数据类型有很多种（列表、集合、元组、range、字符串）
  - 比如
    ```py
    a = {3, "a", '6'}

    a.update(("张三", 3))
    print(a) # 表现形式：{'张三', 'a', 3, '6'}

    a.update(["张三", 3])
    print(a) # 表现形式：{'张三', 'a', 3, '6'}

    a.update({"张三", 3})
    print(a) # 表现形式：{'张三', 'a', 3, '6'}

    a.update("ABC")
    print(a) # 表现形式：{3, 'C', '张三', '6', 'a', 'A', 'B'}
    ```


#### 集合-元素的删除
- `remove` 删除指定元素（如果没有就报错）
  ```py
  a = {3, "a", '6'}
  a.remove("a")
  print(a) # 表现形式：{3, '6'}

  a.remove(8) # 抛异常
  ```

- `discard` 删除指定元素（如果没有不会报错）
  ```py
  a = {3, "a", '6'}
  a.discard("a")
  print(a) # 表现形式：{3, '6'}

  a.discard(8) # 没有反应
  ```

- `pop` 一次删除一个随机元素（无法控制） 
  ```py
  a = {3, "a", '6', 4, 6}
  print(a) # 表现形式：{3, 4, 6, '6', 'a'}

  a = {3, "a", '6', 4, 6}
  a.pop()
  print(a) # 表现形式：{4, 6, '6', 'a'}
  ```
  - 其实删除的是第一个元素，但是第一个元素是随机的，所以删除的是随机元素



- 清空整个集合
  ```py
  a = {3, "a", '6'}
  a.clear()
  print(a) # 表现形式：set()
  ```




#### 集合-获取两个集合之间的关系
- 判断两个集合是否相同（判断的是两个集合的内容是否相同）
  ```py
  a = {3, "a", '6', 4, 6}
  b = {4, 3, 6, "a", '6', 4}
  print(a) # 表现形式：{3, '6', 4, 'a', 6}
  print(b) # 表现形式：{3, '6', 4, 'a', 6}  或者 {'6', 3, 4, 6, 'a'}  （排列随机）

  print(a == b)  # 表现形式：True
  print(a != b)  # 表现形式：False

  print(id(a))   # 表现形式：4470422656
  print(id(b))   # 表现形式：4471058208
  ```
  - 如果集合 A 和 B 的内容存的完全一样，则无论长什么样都相同（随便写，只要最终的值相同就就可以）
    - 即使排列不同，也相等


- 判断一个集合是不是另一个集合的子集合
  ```py
  a = {1, 2, 3, 4}
  b = {3, 2, 1}

  print(b.issubset(a))  # 表现形式：True
  print(a.issubset(b))  # 表现形式：False
  ```
  - 集合B的元素在集合A中都可以找到，所以集合B是集合A的子集合



- 判断一个集合是不是另一个集合的超集
  ```py
  a = {1, 2, 3, 4}
  b = {3, 2, 1}

  print(b.issuperset(a))  # 表现形式：False
  print(a.issuperset(b))  # 表现形式：True 
  ```
  - b是a的子集合，那么a就是b的超集



- 判断一个集合和另一个集合是否有交集（有交集为False）
  ```py
  a = {1, 2, 3, 4}
  b = {3, 2, 1}
  c = {3, 2, 1, 8}
  print(b.isdisjoint(a))  # 表现形式：False（有交集）
  print(a.isdisjoint(c))  # 表现形式：False（有交集）


  a = {1, 2, 3, 4}
  b = {8, 9}
  print(b.isdisjoint(a))  # 表现形式：True（没有交集）
  ```





#### 集合-两个集合间的数学操作
- 取出两个集合间的交集（有两种方式）
  ```py
  a = {1, 2, 3, 4}
  b = {3, 2, 1}
  c = {3, 2, 4, 8}
  print(b.intersection(a))  # 表现形式：{1, 2, 3}
  print(a.intersection(c))  # 表现形式：{2, 3, 4}

  print(b & a)  # 表现形式：{1, 2, 3}
  print(a & c)  # 表现形式：{2, 3, 4}
  ```

- 取出两个集合间的并集（有两种方式）
  ```py
  a = {1, 2, 3, 4}
  b = {3, 2, 1}
  c = {3, 2, 4, 8}
  print(b.union(a))  # 表现形式：{1, 2, 3, 4}
  print(a.union(c))  # 表现形式：{1, 2, 3, 4, 8}

  print(b | a)  # 表现形式：{1, 2, 3, 4}
  print(a | c)  # 表现形式：{1, 2, 3, 4, 8}
  ```

- 取出两个集合间的差集（有两种方式）
  ```py
  a = {1, 2, 3, 4, 10}
  b = {3, 2, 1}
  c = {3, 2, 4, 8}
  print(b.difference(a))  # 表现形式：set()    （b集合中有的，a集合都有）
  print(a.difference(c))  # 表现形式：{1, 10}  （a集合中有1、10，c集合没有）
  print(a.difference(b))  # 表现形式：{10, 4}  （a集合中有4、10，b集合没有）
  print(c.difference(a))  # 表现形式：{8}      （c集合中有8，b集合没有）


  print(b - a)  # 表现形式：set()    （b集合中有的，a集合都有）
  print(a - c)  # 表现形式：{1, 10}  （a集合中有1、10，c集合没有）
  print(a - b)  # 表现形式：{10, 4}  （a集合中有4、10，b集合没有）
  print(c - a)  # 表现形式：{8}      （c集合中有8，b集合没有）
  ```


- 取出两个集合间的对称差集（有两种方式）
  ```py
  a = {1, 2, 3, 4, 10}
  b = {3, 2, 1}
  c = {3, 2, 4, 8}
  print(b.symmetric_difference(a))  # 表现形式：{4, 10}    （a集合中有4、10，b集合没有）
  print(a.symmetric_difference(c))  # 表现形式：{1, 8, 10} （a集合中有1、10，c集合没有。c集合有8，a集合没有）


  print(b ^ a)  # 表现形式：{4, 10}    （a集合中有4、10，b集合没有）
  print(a ^ c)  # 表现形式：{1, 8, 10} （a集合中有1、10，c集合没有。c集合有8，a集合没有）
  ```
  


#### 集合-集合生成式
- 和列表生成式一样，只需要把 `[]` 换成 `{}` 就是集合生成式了
- 比如
  ```py
  a = [v * 2 for v in range(4)]
  print(a)  # 表现形式：[0, 2, 4, 6]

  a = {v * 2 for v in range(4)}
  print(a)  # 表现形式：{0, 2, 4, 6}
  ```




#### 函数-函数的定义与调用
- 比如
  ```py
  def demo (d1, d2):
    print("函数运行了")
    print(d1, d2) # 表现形式：8，9
    return 3, 4

  a, b = demo(8, 9)
  print(a, b) # 表现形式：3，4
  ```




#### 函数-参数传递
- 方式一：位置传递
  ```py
  def demo (d1, d2):
      print(d1, d2) # 表现形式：8，9

  demo(8, 9)
  ```
- 方式二：参数名传递
  ```py
  def demo (d1, d2):
      print(d1, d2) # 表现形式：8，9

  demo(d2=9, d1=8)
  ```

- 混合使用
  ```py
  def demo (d1, d2, d3):
      print(d1, d2, d3) # 表现形式：2 8 9

  demo(2, d3=9, d2=8)
  ```
  - 按位传递，必须写在前面，写在后面抛异常 
    - 因为：前面如果按名称匹配，则第三个就有可能已经被匹配到了，而第一个却没有值传入，这样就会抛异常




#### 装饰器-定义
- 简单使用
  ```py
  # 定义一个装饰器，其实就是一个高阶函数
  def parent(fun):
      def f():
          fun()
      return f

  @parent
  def demo():
      print('a');
  # 被装饰器装饰过的函数，相当于解析到该位置的使用，自动执行了下面的代码，对装饰方法，进行包装
  # demo = parent(demo);

  print(demo) # 此时得到的 demo 已经不是原来的demo了，而是装饰后的方法
  ```


- 装饰器就是一个高阶函数，可以用来扩展一个函数的功能
  - 比如: 定义了一个功能函数，但是后期需求发生了变化，如果是功能的扩展，就可以考虑使用装饰器进行修改，这样原函数就不用删除重新定义